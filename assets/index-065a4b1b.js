(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const style = "";
var dist = {};
var bufferPolyfill = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
  lookup[i$1] = code[i$1];
  revLookup[code.charCodeAt(i$1)] = i$1;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i6;
  for (i6 = 0; i6 < len; i6 += 4) {
    tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i6 = start; i6 < end; i6 += 3) {
    tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i6 = 0, len2 = len - extraBytes; i6 < len2; i6 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len2 ? len2 : i6 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i6 = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i6];
  i6 += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i6], i6 += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i6], i6 += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i6 = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i6] = m & 255, i6 += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i6] = e & 255, i6 += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i6 - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }
    const b6 = fromObject(value);
    if (b6)
      return b6;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i6 = 0; i6 < length; i6 += 1) {
      buf[i6] = array[i6] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer.alloc(+length);
  }
  Buffer.isBuffer = function isBuffer(b6) {
    return b6 != null && b6._isBuffer === true && b6 !== Buffer.prototype;
  };
  Buffer.compare = function compare(a, b6) {
    if (isInstance(a, Uint8Array))
      a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b6, Uint8Array))
      b6 = Buffer.from(b6, b6.offset, b6.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b6)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b6)
      return 0;
    let x6 = a.length;
    let y6 = b6.length;
    for (let i6 = 0, len = Math.min(x6, y6); i6 < len; ++i6) {
      if (a[i6] !== b6[i6]) {
        x6 = a[i6];
        y6 = b6[i6];
        break;
      }
    }
    if (x6 < y6)
      return -1;
    if (y6 < x6)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer.alloc(0);
    }
    let i6;
    if (length === void 0) {
      length = 0;
      for (i6 = 0; i6 < list.length; ++i6) {
        length += list[i6].length;
      }
    }
    const buffer2 = Buffer.allocUnsafe(length);
    let pos = 0;
    for (i6 = 0; i6 < list.length; ++i6) {
      let buf = list[i6];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer.isBuffer(buf))
            buf = Buffer.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype._isBuffer = true;
  function swap(b6, n, m) {
    const i6 = b6[n];
    b6[n] = b6[m];
    b6[m] = i6;
  }
  Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i6 = 0; i6 < len; i6 += 2) {
      swap(this, i6, i6 + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i6 = 0; i6 < len; i6 += 4) {
      swap(this, i6, i6 + 3);
      swap(this, i6 + 1, i6 + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i6 = 0; i6 < len; i6 += 8) {
      swap(this, i6, i6 + 7);
      swap(this, i6 + 1, i6 + 6);
      swap(this, i6 + 2, i6 + 5);
      swap(this, i6 + 3, i6 + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals(b6) {
    if (!Buffer.isBuffer(b6))
      throw new TypeError("Argument must be a Buffer");
    if (this === b6)
      return true;
    return Buffer.compare(this, b6) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x6 = thisEnd - thisStart;
    let y6 = end - start;
    const len = Math.min(x6, y6);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i6 = 0; i6 < len; ++i6) {
      if (thisCopy[i6] !== targetCopy[i6]) {
        x6 = thisCopy[i6];
        y6 = targetCopy[i6];
        break;
      }
    }
    if (x6 < y6)
      return -1;
    if (y6 < x6)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer.from(val, encoding);
    }
    if (Buffer.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i7) {
      if (indexSize === 1) {
        return buf[i7];
      } else {
        return buf.readUInt16BE(i7 * indexSize);
      }
    }
    let i6;
    if (dir) {
      let foundIndex = -1;
      for (i6 = byteOffset; i6 < arrLength; i6++) {
        if (read(arr, i6) === read(val, foundIndex === -1 ? 0 : i6 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i6;
          if (i6 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i6 -= i6 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i6 = byteOffset; i6 >= 0; i6--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i6 + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i6;
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i6;
    for (i6 = 0; i6 < length; ++i6) {
      const parsed = parseInt(string.substr(i6 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i6;
      buf[offset + i6] = parsed;
    }
    return i6;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i6 = start;
    while (i6 < end) {
      const firstByte = buf[i6];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i6 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i6 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i6 + 1];
            thirdByte = buf[i6 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i6 + 1];
            thirdByte = buf[i6 + 2];
            fourthByte = buf[i6 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i6 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i6 = 0;
    while (i6 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i6, i6 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i6 = start; i6 < end; ++i6) {
      ret += String.fromCharCode(buf[i6] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i6 = start; i6 < end; ++i6) {
      ret += String.fromCharCode(buf[i6]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i6 = start; i6 < end; ++i6) {
      out += hexSliceLookupTable[buf[i6]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i6 = 0; i6 < bytes.length - 1; i6 += 2) {
      res += String.fromCharCode(bytes[i6] + bytes[i6 + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i6 = 0;
    while (++i6 < byteLength3 && (mul *= 256)) {
      val += this[offset + i6] * mul;
    }
    return val;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
  });
  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
  });
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i6 = 0;
    while (++i6 < byteLength3 && (mul *= 256)) {
      val += this[offset + i6] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i6 = byteLength3;
    let mul = 1;
    let val = this[offset + --i6];
    while (i6 > 0 && (mul *= 256)) {
      val += this[offset + --i6] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last2 = this[offset + 7];
    if (first === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i6 = 0;
    this[offset] = value & 255;
    while (++i6 < byteLength3 && (mul *= 256)) {
      this[offset + i6] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i6 = byteLength3 - 1;
    let mul = 1;
    this[offset + i6] = value & 255;
    while (--i6 >= 0 && (mul *= 256)) {
      this[offset + i6] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf[offset++] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 6] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 5] = lo2;
    lo2 = lo2 >> 8;
    buf[offset + 4] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf[offset] = hi2;
    return offset + 8;
  }
  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i6 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i6 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i6 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i6] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i6 = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i6] = value & 255;
    while (--i6 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i6 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i6] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i6;
    if (typeof val === "number") {
      for (i6 = start; i6 < end; ++i6) {
        this[i6] = val;
      }
    } else {
      const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i6 = 0; i6 < end - start; ++i6) {
        this[i6 + start] = bytes[i6 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E6(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E6(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E6(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E6(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i6 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i6 >= start + 4; i6 -= 3) {
      res = `_${val.slice(i6 - 3, i6)}${res}`;
    }
    return `${val.slice(0, i6)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i6 = 0; i6 < length; ++i6) {
      codePoint = string.charCodeAt(i6);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i6 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i6 = 0; i6 < str.length; ++i6) {
      byteArray.push(str.charCodeAt(i6) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi2, lo2;
    const byteArray = [];
    for (let i6 = 0; i6 < str.length; ++i6) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i6);
      hi2 = c >> 8;
      lo2 = c % 256;
      byteArray.push(lo2);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i6;
    for (i6 = 0; i6 < length; ++i6) {
      if (i6 + offset >= dst.length || i6 >= src.length)
        break;
      dst[i6 + offset] = src[i6];
    }
    return i6;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i6 = 0; i6 < 16; ++i6) {
      const i16 = i6 * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i6] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(bufferPolyfill);
var browser = { exports: {} };
var process = browser.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e6) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e6) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue$1 = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue$1 = currentQueue.concat(queue$1);
  } else {
    queueIndex = -1;
  }
  if (queue$1.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue$1.length;
  while (len) {
    currentQueue = queue$1;
    queue$1 = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue$1.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      args[i6 - 1] = arguments[i6];
    }
  }
  queue$1.push(new Item(fun, args));
  if (queue$1.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser.exports;
(function(exports) {
  Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
  const t = bufferPolyfill, r = browserExports, o = (e) => e && e.__esModule ? e : { default: e }, l = o(r), u = globalThis || void 0 || self;
  Object.defineProperty(exports, "Buffer", { enumerable: true, get: () => t.Buffer });
  Object.defineProperty(exports, "process", { enumerable: true, get: () => l.default });
  exports.global = u;
})(dist);
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i6 = 0; i6 < list.length; i6++) {
    map[list[i6]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO$1 = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el2) => {
  const i6 = arr.indexOf(el2);
  if (i6 > -1) {
    arr.splice(i6, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_6, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i6 = 0; i6 < fns.length; i6++) {
    fns[i6](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof dist.global !== "undefined" ? dist.global : {});
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i6 = 0; i6 < value.length; i6++) {
      const item = value[i6];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i6 = 0; i6 < value.length; i6++) {
      const normalized = normalizeClass(value[i6]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style: style2 } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style2) {
    props.style = normalizeStyle(style2);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b6) {
  if (a.length !== b6.length)
    return false;
  let equal = true;
  for (let i6 = 0; equal && i6 < a.length; i6++) {
    equal = looseEqual(a[i6], b6[i6]);
  }
  return equal;
}
function looseEqual(a, b6) {
  if (a === b6)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b6);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b6.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b6);
  if (aValidType || bValidType) {
    return a === b6;
  }
  aValidType = isArray(a);
  bValidType = isArray(b6);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b6) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b6);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b6).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b6.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b6[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b6);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn2) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i6, l;
      for (i6 = 0, l = this.effects.length; i6 < l; i6++) {
        this.effects[i6].stop();
      }
      for (i6 = 0, l = this.cleanups.length; i6 < l; i6++) {
        this.cleanups[i6]();
      }
      if (this.scopes) {
        for (i6 = 0, l = this.scopes.length; i6 < l; i6++) {
          this.scopes[i6].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i6 = 0; i6 < deps.length; i6++) {
      deps[i6].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i6 = 0; i6 < deps.length; i6++) {
      const dep = deps[i6];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn2, scheduler = null, scope) {
    this.fn = fn2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i6 = 0; i6 < deps.length; i6++) {
      deps[i6].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn2, options) {
  if (fn2.effect instanceof ReactiveEffect) {
    fn2 = fn2.effect.fn;
  }
  const _effect = new ReactiveEffect(fn2);
  if (options) {
    extend(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a2;
  return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i6 = 0, l = this.length; i6 < l; i6++) {
        track(arr, "get", i6 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _shallow = false) {
    this._isReadonly = _isReadonly;
    this._shallow = _shallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, shallow = this._shallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(false, shallow);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!this._shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(true, shallow);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v6) => Reflect.getPrototypeOf(v6);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function assertNumber(val, type) {
  return;
}
function callWithErrorHandling(fn2, instance, type, args) {
  let res;
  try {
    res = args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn2, instance, type, args) {
  if (isFunction(fn2)) {
    const res = callWithErrorHandling(fn2, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i6 = 0; i6 < fn2.length; i6++) {
    values.push(callWithAsyncErrorHandling(fn2[i6], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i6 = 0; i6 < errorCapturedHooks.length; i6++) {
          if (errorCapturedHooks[i6](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn2) {
  const p6 = currentFlushPromise || resolvedPromise;
  return fn2 ? p6.then(this ? fn2.bind(this) : fn2) : p6;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i6 = queue.indexOf(job);
  if (i6 > flushIndex) {
    queue.splice(i6, 1);
  }
}
function queuePostFlushCb(cb2) {
  if (!isArray(cb2)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb2,
      cb2.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb2);
    }
  } else {
    pendingPostFlushCbs.push(...cb2);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i6 = isFlushing ? flushIndex + 1 : 0) {
  for (; i6 < queue.length; i6++) {
    const cb2 = queue[i6];
    if (cb2 && cb2.pre) {
      queue.splice(i6, 1);
      i6--;
      cb2();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b6) => getId(a) - getId(b6));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b6) => {
  const diff = getId(a) - getId(b6);
  if (diff === 0) {
    if (a.pre && !b6.pre)
      return -1;
    if (b6.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let devtools;
let buffer = [];
function setDevtoolsHook(hook, target) {
  var _a2, _b2;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b2 = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b2.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn2(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i6 = 0; i6 < children.length; i6++) {
    const child = children[i6];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i6 = 0; i6 < dynamicProps.length; i6++) {
        const key = dynamicProps[i6];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i6 = 0; i6 < nextKeys.length; i6++) {
    const key = nextKeys[i6];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el2;
    parent = parent.parent;
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n12 == null) {
      mountSuspense(
        n22,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      patchSuspense(
        n12,
        n22,
        container,
        anchor,
        parentComponent,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    isSVG,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      isSVG,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n12, n22, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n22.suspense = n12.suspense;
  suspense.vnode = n22;
  n22.el = n12.el;
  const newBranch = n22.ssContent;
  const newFallback = n22.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(
          activeBranch,
          newFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          isSVG,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            isSVG,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n22, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
              queuePostFlushCb(effects);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          isSVG2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          isSVG,
          optimized
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    document.createElement("div"),
    null,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
    /* hydrating */
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el2 = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el2;
    updateHOCHostEl(parentComponent, el2);
  }
}
function isVNodeSuspensible(vnode) {
  var _a2;
  return ((_a2 = vnode.props) == null ? void 0 : _a2.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "sync" }
  );
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb2, options) {
  return doWatch(source, cb2, options);
}
function doWatch(source, cb2, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a2;
  const instance = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb2) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb2 && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn2) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn2, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb2) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb2, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb2) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v6, i6) => hasChanged(v6, oldValue[i6])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb2, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb2;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb2) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  const unwatch = () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb2;
  if (isFunction(value)) {
    cb2 = value;
  } else {
    cb2 = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb2.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i6 = 0; i6 < segments.length && cur; i6++) {
      cur = cur[segments[i6]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray(value)) {
    for (let i6 = 0; i6 < value.length; i6++) {
      traverse(value[i6], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v6) => {
      traverse(v6, seen2);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i6 = 0; i6 < directives.length; i6++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i6];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i6 = 0; i6 < bindings.length; i6++) {
    const binding = bindings[i6];
    if (oldBindings) {
      binding.oldValue = oldBindings[i6].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el2[leaveCbKey] = () => {
              earlyRemove();
              el2[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el2) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el2[leaveCbKey]) {
        el2[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el2]);
    },
    enter(el2) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el2[enterCbKey$1] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el2]);
        } else {
          callHook2(afterHook, [el2]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el2[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el2, done]);
      } else {
        done();
      }
    },
    leave(el2, remove2) {
      const key2 = String(vnode.key);
      if (el2[enterCbKey$1]) {
        el2[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el2]);
      let called = false;
      const done = el2[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el2]);
        } else {
          callHook2(onAfterLeave, [el2]);
        }
        el2[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el2, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i6 = 0; i6 < children.length; i6++) {
    let child = children[i6];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i6);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i6 = 0; i6 < ret.length; i6++) {
      ret[i6].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i6) => !!i6.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
          /* do not throw in dev if user provided error component */
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce: ce2 } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce2;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        isSVG,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da2 = vnode.component.da;
          da2 && queuePostRenderEffect(da2, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray(pattern)) {
    return pattern.some((p6) => matches(p6, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i6 = 0, l = source.length; i6 < l; i6++) {
      ret[i6] = renderItem(source[i6], i6, void 0, cached && cached[i6]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i6 = 0; i6 < source; i6++) {
      ret[i6] = renderItem(i6 + 1, i6, void 0, cached && cached[i6]);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i6) => renderItem(item, i6, void 0, cached && cached[i6])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i6 = 0, l = keys.length; i6 < l; i6++) {
        const key = keys[i6];
        ret[i6] = renderItem(source[key], key, i6, cached && cached[i6]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i6 = 0; i6 < dynamicSlots.length; i6++) {
    const slot = dynamicSlots[i6];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i6) => {
  if (!i6)
    return null;
  if (isStatefulComponent(i6))
    return getExposeProxy(i6) || i6.proxy;
  return getPublicInstance(i6.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i6) => i6,
    $el: (i6) => i6.vnode.el,
    $data: (i6) => i6.data,
    $props: (i6) => i6.props,
    $attrs: (i6) => i6.attrs,
    $slots: (i6) => i6.slots,
    $refs: (i6) => i6.refs,
    $parent: (i6) => getPublicInstance(i6.parent),
    $root: (i6) => getPublicInstance(i6.root),
    $emit: (i6) => i6.emit,
    $options: (i6) => resolveMergedOptions(i6),
    $forceUpdate: (i6) => i6.f || (i6.f = () => queueJob(i6.update)),
    $nextTick: (i6) => i6.n || (i6.n = nextTick.bind(i6.proxy)),
    $watch: (i6) => instanceWatch.bind(i6)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend(
  {},
  PublicInstanceProxyHandlers,
  {
    get(target, key) {
      if (key === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_6, key) {
      const has2 = key[0] !== "_" && !isGloballyAllowed(key);
      return has2;
    }
  }
);
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function useModel(props, name, options) {
  const i6 = getCurrentInstance();
  if (options && options.local) {
    const proxy = ref(props[name]);
    watch(
      () => props[name],
      (v6) => proxy.value = v6
    );
    watch(proxy, (value) => {
      if (value !== props[name]) {
        i6.emit(`update:${name}`, value);
      }
    });
    return proxy;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return props[name];
      },
      set value(value) {
        i6.emit(`update:${name}`, value);
      }
    };
  }
}
function getContext() {
  const i6 = getCurrentInstance();
  return i6.setupContext || (i6.setupContext = createSetupContext(i6));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p6) => (normalized[p6] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip"))
      continue;
    let opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else
      ;
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b6) {
  if (!a || !b6)
    return a || b6;
  if (isArray(a) && isArray(b6))
    return a.concat(b6);
  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b6));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v6) => c.value = v6
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v6) => injected.value = v6
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h6) => h6.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to2, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to2, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from[key]) : from[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from) {
  if (!from) {
    return to2;
  }
  if (!to2) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to2) ? to2.call(this, this) : to2,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to2, from) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i6 = 0; i6 < raw.length; i6++) {
      res[raw[i6]] = raw[i6];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to2, from) {
  return to2 ? [...new Set([].concat(to2, from))] : from;
}
function mergeObjectOptions(to2, from) {
  return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
}
function mergeEmitsOrPropsOptions(to2, from) {
  if (to2) {
    if (isArray(to2) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to2, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to2),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to2, from) {
  if (!to2)
    return from;
  if (!from)
    return to2;
  const merged = extend(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to2[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO$1,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v6) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn2) {
        currentApp = app;
        try {
          return fn2();
        } finally {
          currentApp = null;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i6 = 0; i6 < propsToUpdate.length; i6++) {
        let key = propsToUpdate[i6];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i6 = 0; i6 < needCastKeys.length; i6++) {
      const key = needCastKeys[i6];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i6 = 0; i6 < raw.length; i6++) {
      const normalizedKey = camelize(raw[i6]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b6) {
  return getType(a) === getType(b6);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i6) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i6] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove2,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode2(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i6 = 0; i6 < vnode.staticCount; i6++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i6 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode2(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVGContainer(container),
            optimized
          );
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            isSVGContainer(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
              patchProp2(
                el2,
                key,
                null,
                props[key],
                false,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props.onClick) {
          patchProp2(
            el2,
            "onClick",
            null,
            props.onClick,
            false,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode2(el2)) {
        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el2.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el2, parentComponent);
        vnode.el = el2 = content;
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el2);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el2.firstChild,
          vnode,
          el2,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          hasMismatch = true;
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el2.textContent !== vnode.children) {
          hasMismatch = true;
          el2.textContent = vnode.children;
        }
      }
    }
    return el2.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i6 = 0; i6 < l; i6++) {
      const vnode = optimized ? children[i6] : children[i6] = normalizeVNode(children[i6]);
      if (node) {
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVGContainer(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      isSVGContainer(container),
      slotScopeIds
    );
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open)
          match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode2 = (node) => {
    return node.nodeType === 1 && node.tagName.toLowerCase() === "template";
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n12, n22, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n22.dynamicChildren) => {
    if (n12 === n22) {
      return;
    }
    if (n12 && !isSameVNodeType(n12, n22)) {
      anchor = getNextHostNode(n12);
      unmount(n12, parentComponent, parentSuspense, true);
      n12 = null;
    }
    if (n22.patchFlag === -2) {
      optimized = false;
      n22.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n22;
    switch (type) {
      case Text:
        processText(n12, n22, container, anchor);
        break;
      case Comment:
        processCommentNode(n12, n22, container, anchor);
        break;
      case Static:
        if (n12 == null) {
          mountStaticNode(n22, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n12,
          n22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n12,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n12,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n12,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n12,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n12 && n12.ref, parentSuspense, n22 || n12, !n22);
    }
  };
  const processText = (n12, n22, container, anchor) => {
    if (n12 == null) {
      hostInsert(
        n22.el = hostCreateText(n22.children),
        container,
        anchor
      );
    } else {
      const el2 = n22.el = n12.el;
      if (n22.children !== n12.children) {
        hostSetText(el2, n22.children);
      }
    }
  };
  const processCommentNode = (n12, n22, container, anchor) => {
    if (n12 == null) {
      hostInsert(
        n22.el = hostCreateComment(n22.children || ""),
        container,
        anchor
      );
    } else {
      n22.el = n12.el;
    }
  };
  const mountStaticNode = (n22, container, anchor, isSVG) => {
    [n22.el, n22.anchor] = hostInsertStaticContent(
      n22.children,
      container,
      anchor,
      isSVG,
      n22.el,
      n22.anchor
    );
  };
  const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling);
      el2 = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el: el2, anchor }) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n22.type === "svg";
    if (n12 == null) {
      mountElement(
        n22,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n12,
        n22,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el2 = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el2, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el2,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el2,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el2, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i6 = 0; i6 < slotScopeIds.length; i6++) {
        hostSetScopeId(el2, slotScopeIds[i6]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el2,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i6 = start; i6 < children.length; i6++) {
      const child = children[i6] = optimized ? cloneIfMounted(children[i6]) : normalizeVNode(children[i6]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n12, n22, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el2 = n22.el = n12.el;
    let { patchFlag, dynamicChildren, dirs } = n22;
    patchFlag |= n12.patchFlag & 16;
    const oldProps = n12.props || EMPTY_OBJ;
    const newProps = n22.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n22, n12);
    }
    if (dirs) {
      invokeDirectiveHook(n22, n12, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n22.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n12.dynamicChildren,
        dynamicChildren,
        el2,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n12,
        n22,
        el2,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el2,
          n22,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n22.dynamicProps;
          for (let i6 = 0; i6 < propsToUpdate.length; i6++) {
            const key = propsToUpdate[i6];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el2,
                key,
                prev,
                next,
                isSVG,
                n12.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n12.children !== n22.children) {
          hostSetElementText(el2, n22.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el2,
        n22,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n22, n12);
        dirs && invokeDirectiveHook(n22, n12, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i6 = 0; i6 < newChildren.length; i6++) {
      const oldVNode = oldChildren[i6];
      const newVNode = newChildren[i6];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el2,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el2,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n22.el = n12 ? n12.el : hostCreateText("");
    const fragmentEndAnchor = n22.anchor = n12 ? n12.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n22;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n12 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n22.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n12.dynamicChildren) {
        patchBlockChildren(
          n12.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n22.key != null || parentComponent && n22 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n12,
            n22,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n12,
          n22,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n22.slotScopeIds = slotScopeIds;
    if (n12 == null) {
      if (n22.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n22,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n12, n22, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n12, n22, optimized) => {
    const instance = n22.component = n12.component;
    if (shouldUpdateComponent(n12, n22, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n22, optimized);
        return;
      } else {
        instance.next = n22;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n22.el = n12.el;
      instance.vnode = n22;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el: el2, props } = initialVNode;
        const { bm: bm2, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm2) {
          invokeArrayFns(bm2);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el2,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect2.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c12 = n12 && n12.children;
    const prevShapeFlag = n12 ? n12.shapeFlag : 0;
    const c22 = n22.children;
    const { patchFlag, shapeFlag } = n22;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c12,
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c12,
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c12, parentComponent, parentSuspense);
      }
      if (c22 !== c12) {
        hostSetElementText(container, c22);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c12,
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c12, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c12, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c12 = c12 || EMPTY_ARR;
    c22 = c22 || EMPTY_ARR;
    const oldLength = c12.length;
    const newLength = c22.length;
    const commonLength = Math.min(oldLength, newLength);
    let i6;
    for (i6 = 0; i6 < commonLength; i6++) {
      const nextChild = c22[i6] = optimized ? cloneIfMounted(c22[i6]) : normalizeVNode(c22[i6]);
      patch(
        c12[i6],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c12,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c22,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c12, c22, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i6 = 0;
    const l22 = c22.length;
    let e12 = c12.length - 1;
    let e22 = l22 - 1;
    while (i6 <= e12 && i6 <= e22) {
      const n12 = c12[i6];
      const n22 = c22[i6] = optimized ? cloneIfMounted(c22[i6]) : normalizeVNode(c22[i6]);
      if (isSameVNodeType(n12, n22)) {
        patch(
          n12,
          n22,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i6++;
    }
    while (i6 <= e12 && i6 <= e22) {
      const n12 = c12[e12];
      const n22 = c22[e22] = optimized ? cloneIfMounted(c22[e22]) : normalizeVNode(c22[e22]);
      if (isSameVNodeType(n12, n22)) {
        patch(
          n12,
          n22,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e12--;
      e22--;
    }
    if (i6 > e12) {
      if (i6 <= e22) {
        const nextPos = e22 + 1;
        const anchor = nextPos < l22 ? c22[nextPos].el : parentAnchor;
        while (i6 <= e22) {
          patch(
            null,
            c22[i6] = optimized ? cloneIfMounted(c22[i6]) : normalizeVNode(c22[i6]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i6++;
        }
      }
    } else if (i6 > e22) {
      while (i6 <= e12) {
        unmount(c12[i6], parentComponent, parentSuspense, true);
        i6++;
      }
    } else {
      const s12 = i6;
      const s22 = i6;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i6 = s22; i6 <= e22; i6++) {
        const nextChild = c22[i6] = optimized ? cloneIfMounted(c22[i6]) : normalizeVNode(c22[i6]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i6);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e22 - s22 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i6 = 0; i6 < toBePatched; i6++)
        newIndexToOldIndexMap[i6] = 0;
      for (i6 = s12; i6 <= e12; i6++) {
        const prevChild = c12[i6];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s22; j <= e22; j++) {
            if (newIndexToOldIndexMap[j - s22] === 0 && isSameVNodeType(prevChild, c22[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s22] = i6 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c22[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i6 = toBePatched - 1; i6 >= 0; i6--) {
        const nextIndex = s22 + i6;
        const nextChild = c22[nextIndex];
        const anchor = nextIndex + 1 < l22 ? c22[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i6] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i6 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el: el2, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el2, container, anchor);
      for (let i6 = 0; i6 < children.length; i6++) {
        move(children[i6], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el2, container, anchor);
        const performLeave = () => {
          leave(el2, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el: el2, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el2, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um: um2 } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um2) {
      queuePostRenderEffect(um2, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i6 = start; i6 < children.length; i6++) {
      unmount(children[i6], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n12, n22, shallow = false) {
  const ch1 = n12.children;
  const ch2 = n22.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i6 = 0; i6 < ch1.length; i6++) {
      const c12 = ch1[i6];
      let c22 = ch2[i6];
      if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
        if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
          c22 = ch2[i6] = cloneIfMounted(ch2[i6]);
          c22.el = c12.el;
        }
        if (!shallow)
          traverseStaticChildren(c12, c22);
      }
      if (c22.type === Text) {
        c22.el = c12.el;
      }
    }
  }
}
function getSequence(arr) {
  const p6 = arr.slice();
  const result = [0];
  let i6, j, u, v6, c;
  const len = arr.length;
  for (i6 = 0; i6 < len; i6++) {
    const arrI = arr[i6];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p6[i6] = j;
        result.push(i6);
        continue;
      }
      u = 0;
      v6 = result.length - 1;
      while (u < v6) {
        c = u + v6 >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v6 = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p6[i6] = result[u - 1];
        }
        result[u] = i6;
      }
    }
  }
  u = result.length;
  v6 = result[u - 1];
  while (u-- > 0) {
    result[u] = v6;
    v6 = p6[v6];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n22.props);
    let { shapeFlag, children, dynamicChildren } = n22;
    if (n12 == null) {
      const placeholder = n22.el = createText("");
      const mainAnchor = n22.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n22.target = resolveTarget(n22.props, querySelector);
      const targetAnchor = n22.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n22.el = n12.el;
      const mainAnchor = n22.anchor = n12.anchor;
      const target = n22.target = n12.target;
      const targetAnchor = n22.targetAnchor = n12.targetAnchor;
      const wasDisabled = isTeleportDisabled(n12.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(
          n12.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        traverseStaticChildren(n12, n22, true);
      } else if (!optimized) {
        patchChildren(
          n12,
          n22,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n22,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n22.props && n12.props && n22.props.to !== n12.props.to) {
            n22.props.to = n12.props.to;
          }
        }
      } else {
        if ((n22.props && n22.props.to) !== (n12.props && n12.props.to)) {
          const nextTarget = n22.target = resolveTarget(
            n22.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n22,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n22,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n22);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i6 = 0; i6 < children.length; i6++) {
        const child = children[i6];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el: el2, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el2, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i6 = 0; i6 < children.length; i6++) {
        move(
          children[i6],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n12, n22) {
  return n12.type === n22.type && n12.key === n22.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style2)) {
      if (isProxy(style2) && !isArray(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i6 = 0; i6 < args.length; i6++) {
    const toMerge = args[i6];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i6) => currentInstance = i6);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i6) => {
    if (i6.render._rc) {
      i6.withProxy = new Proxy(i6.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      unsetCurrentInstance();
    }
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h$1(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i6 = 0; i6 < prev.length; i6++) {
    if (hasChanged(prev[i6], memo[i6])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.3.8";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is2, props) => {
    const el2 = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el2.setAttribute("multiple", props.multiple);
    }
    return el2;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el2, text) => {
    el2.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el2, id2) {
    el2.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h22) => h22(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h22) => h22.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el2, isAppear, done) => {
    removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el2, done) => {
    el2._isLeaving = false;
    removeTransitionClass(el2, leaveFromClass);
    removeTransitionClass(el2, leaveToClass);
    removeTransitionClass(el2, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el2, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el2, isAppear, done);
      callHook(hook, [el2, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el2, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el2) {
      callHook(onBeforeEnter, [el2]);
      addTransitionClass(el2, enterFromClass);
      addTransitionClass(el2, enterActiveClass);
    },
    onBeforeAppear(el2) {
      callHook(onBeforeAppear, [el2]);
      addTransitionClass(el2, appearFromClass);
      addTransitionClass(el2, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el2, done) {
      el2._isLeaving = true;
      const resolve2 = () => finishLeave(el2, done);
      addTransitionClass(el2, leaveFromClass);
      forceReflow();
      addTransitionClass(el2, leaveActiveClass);
      nextFrame(() => {
        if (!el2._isLeaving) {
          return;
        }
        removeTransitionClass(el2, leaveFromClass);
        addTransitionClass(el2, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el2, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el2, resolve2]);
    },
    onEnterCancelled(el2) {
      finishEnter(el2, false);
      callHook(onEnterCancelled, [el2]);
    },
    onAppearCancelled(el2) {
      finishEnter(el2, true);
      callHook(onAppearCancelled, [el2]);
    },
    onLeaveCancelled(el2) {
      finishLeave(el2);
      callHook(onLeaveCancelled, [el2]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c) => c && el2.classList.add(c));
  (el2[vtcKey] || (el2[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c) => c && el2.classList.remove(c));
  const _vtc = el2[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el2[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb2) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb2);
  });
}
let endId = 0;
function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
  const id2 = el2._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el2._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el2.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el2 && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el2.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el2, expectedType) {
  const styles = window.getComputedStyle(el2);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type ? type === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION$1 && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION$1}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i6) => toMs(d) + toMs(delays[i6])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
const vShowOldKey = Symbol("_vod");
const vShow = {
  beforeMount(el2, { value }, { transition }) {
    el2[vShowOldKey] = el2.style.display === "none" ? "" : el2.style.display;
    if (transition && value) {
      transition.beforeEnter(el2);
    } else {
      setDisplay(el2, value);
    }
  },
  mounted(el2, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el2);
    }
  },
  updated(el2, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el2);
        setDisplay(el2, true);
        transition.enter(el2);
      } else {
        transition.leave(el2, () => {
          setDisplay(el2, false);
        });
      }
    } else {
      setDisplay(el2, value);
    }
  },
  beforeUnmount(el2, { value }) {
    setDisplay(el2, value);
  }
};
function setDisplay(el2, value) {
  el2.style.display = value ? el2[vShowOldKey] : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
function patchStyle(el2, prev, next) {
  const style2 = el2.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
    if (vShowOldKey in el2) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray(val)) {
    val.forEach((v6) => setStyle(style2, name, v6));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i6 = 0; i6 < prefixes.length; i6++) {
    const prefixed = prefixes[i6] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el2[key] = value == null ? "" : value;
    return;
  }
  const tag = el2.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el2._value = value;
    const oldValue = tag === "OPTION" ? el2.getAttribute("value") : el2.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el2[key] = value;
  } catch (e) {
  }
  needRemove && el2.removeAttribute(key);
}
function addEventListener(el2, event, handler, options) {
  el2.addEventListener(event, handler, options);
}
function removeEventListener(el2, event, handler, options) {
  el2.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2[veiKey] || (el2[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el2, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el2, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn2) => (e22) => !e22._stopped && fn2 && fn2(e22));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el2, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(
      el2,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el2;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, hydrate2) {
  const Comp = /* @__PURE__ */ defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options) => {
  return /* @__PURE__ */ defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._ob = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    if (this._ob) {
      this._ob.disconnect();
      this._ob = null;
    }
    nextTick(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i6 = 0; i6 < this.attributes.length; i6++) {
      this._setAttr(this.attributes[i6].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve2 = (def2, isAsync = false) => {
      const { props, styles } = def2;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve2(def2, true));
    } else {
      resolve2(this._def);
    }
  }
  _resolveProps(def2) {
    const { props } = def2;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    const camelKey = camelize(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(event, {
              detail: args
            })
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob2 = new MutationObserver(setVars);
    ob2.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob2.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el: el2, anchor } = vnode;
    while (el2) {
      setVarsOnNode(el2, vars);
      if (el2 === anchor)
        break;
      el2 = el2.nextSibling;
    }
  }
}
function setVarsOnNode(el2, vars) {
  if (el2.nodeType === 1) {
    const style2 = el2.style;
    for (const key in vars) {
      style2.setProperty(`--${key}`, vars[key]);
    }
  }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el2 = c.el;
        const style2 = el2.style;
        addTransitionClass(el2, moveClass);
        style2.transform = style2.webkitTransform = style2.transitionDuration = "";
        const cb2 = el2[moveCbKey] = (e) => {
          if (e && e.target !== el2) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el2.removeEventListener("transitionend", cb2);
            el2[moveCbKey] = null;
            removeTransitionClass(el2, moveClass);
          }
        };
        el2.addEventListener("transitionend", cb2);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i6 = 0; i6 < children.length; i6++) {
        const child = children[i6];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      if (prevChildren) {
        for (let i6 = 0; i6 < prevChildren.length; i6++) {
          const child = prevChildren[i6];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el2 = c.el;
  if (el2[moveCbKey]) {
    el2[moveCbKey]();
  }
  if (el2[enterCbKey]) {
    el2[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx2 = oldPos.left - newPos.left;
  const dy2 = oldPos.top - newPos.top;
  if (dx2 || dy2) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx2}px,${dy2}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el2, root, moveClass) {
  const clone = el2.cloneNode();
  const _vtc = el2[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn2 = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el2, { modifiers: { lazy, trim, number } }, vnode) {
    el2[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el2, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el2.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el2[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el2, "change", () => {
        el2.value = el2.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el2, "compositionstart", onCompositionStart);
      addEventListener(el2, "compositionend", onCompositionEnd);
      addEventListener(el2, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el2, { value }) {
    el2.value = value == null ? "" : value;
  },
  beforeUpdate(el2, { value, modifiers: { lazy, trim, number } }, vnode) {
    el2[assignKey] = getModelAssigner(vnode);
    if (el2.composing)
      return;
    if (document.activeElement === el2 && el2.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el2.value.trim() === value) {
        return;
      }
      if ((number || el2.type === "number") && looseToNumber(el2.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue) {
      el2.value = newValue;
    }
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el2, _6, vnode) {
    el2[assignKey] = getModelAssigner(vnode);
    addEventListener(el2, "change", () => {
      const modelValue = el2._modelValue;
      const elementValue = getValue(el2);
      const checked = el2.checked;
      const assign = el2[assignKey];
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el2, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el2, binding, vnode) {
    el2[assignKey] = getModelAssigner(vnode);
    setChecked(el2, binding, vnode);
  }
};
function setChecked(el2, { value, oldValue }, vnode) {
  el2._modelValue = value;
  if (isArray(value)) {
    el2.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el2.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el2.checked = looseEqual(value, getCheckboxValue(el2, true));
  }
}
const vModelRadio = {
  created(el2, { value }, vnode) {
    el2.checked = looseEqual(value, vnode.props.value);
    el2[assignKey] = getModelAssigner(vnode);
    addEventListener(el2, "change", () => {
      el2[assignKey](getValue(el2));
    });
  },
  beforeUpdate(el2, { value, oldValue }, vnode) {
    el2[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el2.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el2, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el2, "change", () => {
      const selectedVal = Array.prototype.filter.call(el2.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el2[assignKey](
        el2.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
    });
    el2[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el2, { value }) {
    setSelected(el2, value);
  },
  beforeUpdate(el2, _binding, vnode) {
    el2[assignKey] = getModelAssigner(vnode);
  },
  updated(el2, { value }) {
    setSelected(el2, value);
  }
};
function setSelected(el2, value) {
  const isMultiple = el2.multiple;
  if (isMultiple && !isArray(value) && !isSet(value)) {
    return;
  }
  for (let i6 = 0, l = el2.options.length; i6 < l; i6++) {
    const option = el2.options[i6];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el2.selectedIndex !== i6)
          el2.selectedIndex = i6;
        return;
      }
    }
  }
  if (!isMultiple && el2.selectedIndex !== -1) {
    el2.selectedIndex = -1;
  }
}
function getValue(el2) {
  return "_value" in el2 ? el2._value : el2.value;
}
function getCheckboxValue(el2, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el2 ? el2[key] : checked;
}
const vModelDynamic = {
  created(el2, binding, vnode) {
    callModelHook(el2, binding, vnode, null, "created");
  },
  mounted(el2, binding, vnode) {
    callModelHook(el2, binding, vnode, null, "mounted");
  },
  beforeUpdate(el2, binding, vnode, prevVNode) {
    callModelHook(el2, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el2, binding, vnode, prevVNode) {
    callModelHook(el2, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el2, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el2.tagName,
    vnode.props && vnode.props.type
  );
  const fn2 = modelToUse[hook];
  fn2 && fn2(el2, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn2, modifiers) => {
  return (event, ...args) => {
    for (let i6 = 0; i6 < modifiers.length; i6++) {
      const guard = modifierGuards[modifiers[i6]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn2(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn2, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k7) => k7 === eventKey || keyNames[k7] === eventKey)) {
      return fn2(event);
    }
  };
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const runtimeDom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  EffectScope,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  get devtools() {
    return devtools;
  },
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getTransitionRawChildren,
  guardReactiveProps,
  h: h$1,
  handleError,
  hasInjectionContext,
  hydrate,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  toValue,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useModel,
  useSSRContext,
  useSlots,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
}
function createCompilerError(code2, loc, messages, additionalMessage) {
  const msg = code2;
  const error = new SyntaxError(String(msg));
  error.code = code2;
  error.loc = loc;
  return error;
}
const FRAGMENT = Symbol(``);
const TELEPORT = Symbol(``);
const SUSPENSE = Symbol(``);
const KEEP_ALIVE = Symbol(``);
const BASE_TRANSITION = Symbol(``);
const OPEN_BLOCK = Symbol(``);
const CREATE_BLOCK = Symbol(``);
const CREATE_ELEMENT_BLOCK = Symbol(``);
const CREATE_VNODE = Symbol(``);
const CREATE_ELEMENT_VNODE = Symbol(``);
const CREATE_COMMENT = Symbol(``);
const CREATE_TEXT = Symbol(``);
const CREATE_STATIC = Symbol(``);
const RESOLVE_COMPONENT = Symbol(``);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(
  ``
);
const RESOLVE_DIRECTIVE = Symbol(``);
const RESOLVE_FILTER = Symbol(``);
const WITH_DIRECTIVES = Symbol(``);
const RENDER_LIST = Symbol(``);
const RENDER_SLOT = Symbol(``);
const CREATE_SLOTS = Symbol(``);
const TO_DISPLAY_STRING = Symbol(``);
const MERGE_PROPS = Symbol(``);
const NORMALIZE_CLASS = Symbol(``);
const NORMALIZE_STYLE = Symbol(``);
const NORMALIZE_PROPS = Symbol(``);
const GUARD_REACTIVE_PROPS = Symbol(``);
const TO_HANDLERS = Symbol(``);
const CAMELIZE = Symbol(``);
const CAPITALIZE = Symbol(``);
const TO_HANDLER_KEY = Symbol(``);
const SET_BLOCK_TRACKING = Symbol(``);
const PUSH_SCOPE_ID = Symbol(``);
const POP_SCOPE_ID = Symbol(``);
const WITH_CTX = Symbol(``);
const UNREF = Symbol(``);
const IS_REF = Symbol(``);
const WITH_MEMO = Symbol(``);
const IS_MEMO_SAME = Symbol(``);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
const locStub = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode2 = false) {
  return {
    type: 20,
    index,
    value,
    isVNode: isVNode2,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
const isStaticExp = (p6) => p6.type === 4 && p6.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const isMemberExpressionBrowser = (path) => {
  path = path.trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i6 = 0; i6 < path.length; i6++) {
    const char = path.charAt(i6);
    switch (state) {
      case 0:
        if (char === "[") {
          stateStack.push(state);
          state = 1;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2;
          currentOpenParensCount++;
        } else if (!(i6 === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i6 === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpression = isMemberExpressionBrowser;
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(
      loc.start,
      loc.source,
      offset + length
    );
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    extend({}, pos),
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i6 = 0; i6 < numberOfCharacters; i6++) {
    if (source.charCodeAt(i6) === 10) {
      linesCount++;
      lastNewLinePos = i6;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function findDir(node, name, allowEmpty = false) {
  for (let i6 = 0; i6 < node.props.length; i6++) {
    const p6 = node.props[i6];
    if (p6.type === 7 && (allowEmpty || p6.exp) && (isString(name) ? p6.name === name : name.test(p6.name))) {
      return p6;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i6 = 0; i6 < node.props.length; i6++) {
    const p6 = node.props[i6];
    if (p6.type === 6) {
      if (dynamicOnly)
        continue;
      if (p6.name === name && (p6.value || allowEmpty)) {
        return p6;
      }
    } else if (p6.name === "bind" && (p6.exp || allowEmpty) && isStaticArgOf(p6.arg, name)) {
      return p6;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p6) => p6.type === 7 && p6.name === "bind" && (!p6.arg || // v-bind="obj"
    p6.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p6.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p6) {
  return p6.type === 7 && p6.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p6) => p6.key.type === 4 && p6.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function getCompatValue(key, context) {
  const config = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config && config[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  return enabled;
}
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
};
const defaultParserOptions = {
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: NO$1,
  isPreTag: NO$1,
  isCustomElement: NO$1,
  decodeEntities: (rawText) => rawText.replace(decodeRE, (_6, p12) => decodeMap[p12]),
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: false
};
function baseParse(content, options = {}) {
  const context = createParserContext(content, options);
  const start = getCursor(context);
  return createRoot(
    parseChildren(context, 0, []),
    getSelection(context, start)
  );
}
function createParserContext(content, rawOptions) {
  const options = extend({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns2 = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns2 !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23);
            parseTag(context, 1, parent);
            continue;
          } else {
            emitError(
              context,
              12,
              2
            );
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (isCompatEnabled(
            "COMPILER_NATIVE_TEMPLATE",
            context
          ) && node && node.tag === "template" && !node.props.some(
            (p6) => p6.type === 7 && isSpecialTemplateDirective(p6.name)
          )) {
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(
            context,
            21,
            1
          );
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray(node)) {
      for (let i6 = 0; i6 < node.length; i6++) {
        pushNode(nodes, node[i6]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i6 = 0; i6 < nodes.length; i6++) {
      const node = nodes[i6];
      if (node.type === 2) {
        if (!context.inPre) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i6 - 1];
            const next = nodes[i6 + 1];
            if (!prev || !next || shouldCondense && (prev.type === 3 && next.type === 3 || prev.type === 3 && next.type === 1 || prev.type === 1 && next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
              removedWhitespace = true;
              nodes[i6] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        } else {
          node.content = node.content.replace(/\r\n/g, "\n");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i6] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match.index <= 3) {
      emitError(context, 0);
    }
    if (match[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match.index);
    const s = context.source.slice(0, match.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, 0, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find(
      (p6) => p6.type === 6 && p6.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      context,
      inlineTemplateProp.loc
    )) {
      const loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
const isSpecialTemplateDirective = /* @__PURE__ */ makeMap(
  `if,else,else-if,for,slot`
);
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns2 = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (type === 0 && !context.inVPre && props.some((p6) => p6.type === 7 && p6.name === "pre")) {
    context.inVPre = true;
    extend(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter((p6) => p6.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props.some(
        (p6) => p6.type === 7 && isSpecialTemplateDirective(p6.name)
      )) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns: ns2,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: void 0
    // to be created during transform phase
  };
}
function isComponent(tag, props, context) {
  const options = context.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  }
  for (let i6 = 0; i6 < props.length; i6++) {
    const p6 = props[i6];
    if (p6.type === 6) {
      if (p6.name === "is" && p6.value) {
        if (p6.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context,
          p6.loc
        )) {
          return true;
        }
      }
    } else {
      if (p6.name === "is") {
        return true;
      } else if (
        // :is on plain element - only treat as component in compat mode
        p6.name === "bind" && isStaticArgOf(p6.arg, "is") && true && checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context,
          p6.loc
        )
      ) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames = /* @__PURE__ */ new Set();
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  var _a2;
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match[0];
  if (nameSet.has(name)) {
    emitError(context, 2);
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern = /["'<]/g;
    let m;
    while (m = pattern.exec(name)) {
      emitError(
        context,
        17,
        m.index
      );
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
      name
    );
    let isPropShorthand = startsWith(name, ".");
    let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(
        match2[2],
        name.length - (((_a2 = match2[3]) == null ? void 0 : _a2.length) || 0)
      );
      const loc2 = getSelection(
        context,
        getNewPosition(context, start, startOffset),
        getNewPosition(
          context,
          start,
          startOffset + match2[2].length + (isSlot && match2[3] || "").length
        )
      );
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(
            context,
            27
          );
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers.includes("sync") && checkCompatEnabled(
        "COMPILER_V_BIND_SYNC",
        context,
        loc,
        arg.loc.source
      )) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(
        context,
        context.source.length,
        4
      );
    } else {
      content = parseTextData(context, endIndex, 4);
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while (m = unexpectedChars.exec(match[0])) {
      emitError(
        context,
        18,
        m.index
      );
    }
    content = parseTextData(context, match[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return void 0;
  }
  const start = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i6 = 0; i6 < endTokens.length; i6++) {
    const index = context.source.indexOf(endTokens[i6], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start)
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(
      rawText,
      mode === 4
    );
  }
}
function getCursor(context) {
  const { column, line, offset } = context;
  return { column, line, offset };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}
function last(xs2) {
  return xs2[xs2.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(
    start,
    context.originalSource.slice(start.offset, numberOfCharacters),
    numberOfCharacters
  );
}
function emitError(context, code2, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(
    createCompilerError(code2, {
      start: loc,
      end: loc,
      source: ""
    })
  );
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i6 = ancestors.length - 1; i6 >= 0; --i6) {
          if (startsWithEndTagOpen(s, ancestors[i6].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last(ancestors);
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root, context) {
  walk(
    root,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i6 = 0; i6 < children.length; i6++) {
    const child = children[i6];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = `-1`;
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i22 = 0; i22 < child.branches.length; i22++) {
        walk(
          child.branches[i22],
          context,
          child.branches[i22].children.length === 1
        );
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    const hoisted = context.hoist(
      createArrayExpression(node.codegenNode.children)
    );
    if (context.hmr) {
      hoisted.content = `[...${hoisted.content}]`;
    }
    node.codegenNode.children = hoisted;
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i6 = 0; i6 < node.children.length; i6++) {
          const childType = getConstantType(node.children[i6], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i6 = 0; i6 < node.props.length; i6++) {
            const p6 = node.props[i6];
            if (p6.type === 7 && p6.name === "bind" && p6.exp) {
              const expType = getConstantType(p6.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i6 = 0; i6 < node.props.length; i6++) {
            const p6 = node.props[i6];
            if (p6.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i6 = 0; i6 < node.children.length; i6++) {
        const child = node.children[i6];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i6 = 0; i6 < properties.length; i6++) {
      const { key, value } = properties[i6];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic: hoistStatic2 = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode2 = false) {
      return createCacheExpression(context.cached++, exp, isVNode2);
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag + ``,
      void 0,
      void 0,
      true,
      void 0,
      false
      /* isComponent */
    );
  } else
    ;
}
function traverseChildren(parent, context) {
  let i6 = 0;
  const nodeRemoved = () => {
    i6--;
  };
  for (; i6 < parent.children.length; i6++) {
    const child = parent.children[i6];
    if (isString(child))
      continue;
    context.parent = parent;
    context.childIndex = i6;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i22 = 0; i22 < nodeTransforms.length; i22++) {
    const onExit = nodeTransforms[i22](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i22 = 0; i22 < node.branches.length; i22++) {
        traverseNode(node.branches[i22], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i6 = exitFns.length;
  while (i6--) {
    exitFns[i6]();
  }
}
function createStructuralDirectiveTransform(name, fn2) {
  const matches2 = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i6 = 0; i6 < props.length; i6++) {
        const prop = props[i6];
        if (prop.type === 7 && matches2(prop.name)) {
          props.splice(i6, 1);
          i6--;
          const onExit = fn2(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
const PURE_ANNOTATION = `/*#__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code2, node) {
      context.code += code2;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const isSetupInlined = false;
  const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${helpers.map(aliasHelper).join(", ")} } = _Vue`);
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i6 = 0; i6 < ast.temps; i6++) {
      push(`${i6 > 0 ? `, ` : ``}_temp${i6}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: isSetupInlined ? preambleContext.code : ``,
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i6 = 0; i6 < assets.length; i6++) {
    let id2 = assets[i6];
    const maybeSelfReference = id2.endsWith("__self");
    if (maybeSelfReference) {
      id2 = id2.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id2, type)} = ${resolver}(${JSON.stringify(id2)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i6 < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i6 = 0; i6 < hoists.length; i6++) {
    const exp = hoists[i6];
    if (exp) {
      push(
        `const _hoisted_${i6 + 1} = ${``}`
      );
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || false;
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i6 = 0; i6 < nodes.length; i6++) {
    const node = nodes[i6];
    if (isString(node)) {
      push(node);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i6 < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(node);
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i6 = 0; i6 < node.children.length; i6++) {
    const child = node.children[i6];
    if (isString(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i6 = args.length;
  while (i6--) {
    if (args[i6] != null)
      break;
  }
  return args.slice(0, i6 + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || false;
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i6 = 0; i6 < properties.length; i6++) {
    const { key, value } = properties[i6];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i6 < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);
const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i6 = siblings.indexOf(ifNode);
      let key = 0;
      while (i6-- >= 0) {
        const sibling = siblings[i6];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          );
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          );
        }
      };
    });
  }
);
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    let i6 = siblings.indexOf(node);
    while (i6-- >= -1) {
      const sibling = siblings[i6];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag + ``,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
const transformFor = createStructuralDirectiveTransform(
  "for",
  (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const isTemplate = isTemplateNode(node);
      const memo = findDir(node, "memo");
      const keyProp = findProp(node, `key`);
      const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        renderExp,
        fragmentFlag + ``,
        void 0,
        void 0,
        true,
        !isStableFragment,
        false,
        node.loc
      );
      return () => {
        let childBlock;
        const { children } = forNode;
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : void 0,
            node.children,
            `64`,
            void 0,
            void 0,
            true,
            void 0,
            false
            /* isComponent */
          );
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              );
            } else {
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              );
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          );
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached++))
          );
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
              /* force newline */
            )
          );
        }
      };
    });
  }
);
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp
  );
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(
      loc,
      RHS.trim(),
      exp.indexOf(RHS, LHS.length)
    ),
    value: void 0,
    key: void 0,
    index: void 0
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          loc,
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          )
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
  }
  return result;
}
function createAliasExpression(range, content, offset) {
  return createSimpleExpression(
    content,
    false,
    getInnerRange(range, offset, content.length)
  );
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i6 = args.length;
  while (i6--) {
    if (args[i6])
      break;
  }
  return args.slice(0, i6 + 1).map((arg, i22) => arg || createSimpleExpression(`_`.repeat(i22 + 1), false));
}
const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
  props,
  children,
  false,
  true,
  children.length ? children[0].loc : loc
);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i6 = 0; i6 < children.length; i6++) {
    const slotElement = children[i6];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(
      slotProps,
      vFor == null ? void 0 : vFor.exp,
      slotChildren,
      slotLoc
    );
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i6;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i6, 1);
        i6--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp);
      if (parseResult) {
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
              /* force newline */
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(32, vFor.loc)
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn2 = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn2.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn2);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + ``,
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn2, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn2)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i6 = 0; i6 < children.length; i6++) {
    const child = children[i6];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent2 = node.tagType === 1;
    let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let vnodePatchFlag;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = (
      // dynamic component may resolve to plain elements
      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
      // updates inside get proper isSVG flag at runtime. (#639, #643)
      // This is technically web-specific, but splitting the logic out of core
      // leads to too much unnecessary complexity.
      (tag === "svg" || tag === "foreignObject")
    );
    if (props.length > 0) {
      const propsBuildResult = buildProps(
        node,
        context,
        void 0,
        isComponent2,
        isDynamicComponent
      );
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(
        directives.map((dir) => buildDirectiveArgs(dir, context))
      ) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
      }
      const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (patchFlag !== 0) {
      {
        vnodePatchFlag = String(patchFlag);
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      vnodePatchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false,
      isComponent2,
      node.loc
    );
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg)
      mergeArgs.push(arg);
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i6 = 0; i6 < props.length; i6++) {
    const prop = props[i6];
    if (prop.type === 6) {
      const { loc, name, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(
            createObjectProperty(
              createSimpleExpression("ref_for", true),
              createSimpleExpression("true")
            )
          );
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(
            name,
            true,
            getInnerRange(loc, 0, name.length)
          ),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression("ref_for", true),
            createSimpleExpression("true")
          )
        );
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushMergeArg();
            {
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i6 = 0; i6 < propsExpression.properties.length; i6++) {
          const key = propsExpression.properties[i6].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i6;
            } else if (key.content === "style") {
              styleKeyIndex = i6;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i6 = 0; i6 < properties.length; i6++) {
    const prop = properties[i6];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i6 = 0, l = props.length; i6 < l; i6++) {
    propsNamesString += JSON.stringify(props[i6]);
    if (i6 < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT),
      slotArgs,
      loc
    );
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i6 = 0; i6 < node.props.length; i6++) {
    const p6 = node.props[i6];
    if (p6.type === 6) {
      if (p6.value) {
        if (p6.name === "name") {
          slotName = JSON.stringify(p6.value.content);
        } else {
          p6.name = camelize(p6.name);
          nonNameProps.push(p6);
        }
      }
    } else {
      if (p6.name === "bind" && isStaticArgOf(p6.arg, "name")) {
        if (p6.exp)
          slotName = p6.exp;
      } else {
        if (p6.name === "bind" && p6.arg && isStaticExp(p6.arg)) {
          p6.arg.content = camelize(p6.arg.content);
        }
        nonNameProps.push(p6);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn$1 = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        toHandlerKey(camelize(rawName))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${rawName}`
      );
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp.content);
    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p6) => p6.key.isHandlerKey = true);
  return ret;
};
const transformBind = (dir, _node, context) => {
  const { exp, modifiers, loc } = dir;
  const arg = dir.arg;
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.includes("camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.includes("prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.includes("attr")) {
      injectPrefix(arg, "^");
    }
  }
  if (!exp || exp.type === 4 && !exp.content.trim()) {
    context.onError(createCompilerError(34, loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
    };
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};
const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i6 = 0; i6 < children.length; i6++) {
        const child = children[i6];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i6 + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i6] = createCompoundExpression(
                  [child],
                  child.loc
                );
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(
        (p6) => p6.type === 7 && !context.directiveTransforms[p6.name]
      ) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === "template"))) {
        return;
      }
      for (let i6 = 0; i6 < children.length; i6++) {
        const child = children[i6];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(
              `1`
            );
          }
          children[i6] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          };
        }
      }
    };
  }
};
const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true
          /* isVNode */
        );
      }
    };
  }
};
const transformModel$1 = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(
      createCompilerError(41, dir.loc)
    );
    return createTransformProps();
  }
  const rawExp = exp.loc.source;
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
    context.onError(
      createCompilerError(42, exp.loc)
    );
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          2
        )
      )
    );
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}
const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTER", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  }
  if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i6 = 0; i6 < node.children.length; i6++) {
      const child = node.children[i6];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i6, expression, filters = [];
  for (i6 = 0; i6 < exp.length; i6++) {
    prev = c;
    c = exp.charCodeAt(i6);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i6 + 1) !== 124 && exp.charCodeAt(i6 - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i6 + 1;
        expression = exp.slice(0, i6).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i6 - 1;
        let p6;
        for (; j >= 0; j--) {
          p6 = exp.charAt(j);
          if (p6 !== " ")
            break;
        }
        if (!p6 || !validDivisionCharRE.test(p6)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i6).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i6).trim());
    lastFilterIndex = i6 + 1;
  }
  if (filters.length) {
    for (i6 = 0; i6 < filters.length; i6++) {
      expression = wrapFilter(expression, filters[i6], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i6 = filter.indexOf("(");
  if (i6 < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i6);
    const args = filter.slice(i6 + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
const seen = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node)) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached++)
        ]);
      }
    };
  }
};
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...[],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const ast = isString(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers
    })
  );
}
const noopDirectiveTransform = () => ({ props: [] });
const V_MODEL_RADIO = Symbol(``);
const V_MODEL_CHECKBOX = Symbol(``);
const V_MODEL_TEXT = Symbol(``);
const V_MODEL_SELECT = Symbol(``);
const V_MODEL_DYNAMIC = Symbol(``);
const V_ON_WITH_MODIFIERS = Symbol(``);
const V_ON_WITH_KEYS = Symbol(``);
const V_SHOW = Symbol(``);
const TRANSITION = Symbol(``);
const TRANSITION_GROUP = Symbol(``);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
const isRawTextContainer = /* @__PURE__ */ makeMap(
  "style,iframe,script,noscript",
  true
);
const parserOptions = {
  isVoidTag,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
  isPreTag: (tag) => tag === "pre",
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: (tag) => {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION;
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent) {
    let ns2 = parent ? parent.ns : 0;
    if (parent && ns2 === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns2 = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns2 = 0;
      }
    } else if (parent && ns2 === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns2 = 0;
      }
    }
    if (ns2 === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns2;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag, ns: ns2 }) {
    if (ns2 === 0) {
      if (tag === "textarea" || tag === "title") {
        return 1;
      }
      if (isRawTextContainer(tag)) {
        return 2;
      }
    }
    return 0;
  }
};
const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p6, i6) => {
      if (p6.type === 6 && p6.name === "style" && p6.value) {
        node.props[i6] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p6.loc),
          exp: parseInlineCSS(p6.value.content, p6.loc),
          modifiers: [],
          loc: p6.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText);
  return createSimpleExpression(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};
function createDOMCompilerError(code2, loc) {
  return createCompilerError(
    code2,
    loc
  );
}
const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(53, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`innerHTML`, true, loc),
        exp || createSimpleExpression("", true)
      )
    ]
  };
};
const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(
        createSimpleExpression(`textContent`, true),
        exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
          context.helperString(TO_DISPLAY_STRING),
          [exp],
          loc
        ) : createSimpleExpression("", true)
      )
    ]
  };
};
const transformModel = (dir, node, context) => {
  const baseResult = transformModel$1(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        58,
        dir.arg.loc
      )
    );
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = findProp(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  59,
                  dir.loc
                )
              );
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else
        ;
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else
      ;
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        57,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p6) => !(p6.key.type === 4 && p6.key.content === "modelValue")
  );
  return baseResult;
};
const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ makeMap(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ makeMap(
  `onkeyup,onkeydown,onkeypress`,
  true
);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i6 = 0; i6 < modifiers.length; i6++) {
    const modifier = modifiers[i6];
    if (modifier === "native" && checkCompatEnabled(
      "COMPILER_V_ON_NATIVE",
      context
    )) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return transformOn$1(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length)
      return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!isStaticExp(key) || isKeyboardEvent(key.content))) {
      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
      key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key, handlerExp)]
    };
  });
};
const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(61, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};
const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context.removeNode();
  }
};
const DOMNodeTransforms = [
  transformStyle,
  ...[]
];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile(template, options = {}) {
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
const compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(template, options) {
  if (!isString(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
      return NOOP;
    }
  }
  const key = template;
  const cached = compileCache[key];
  if (cached) {
    return cached;
  }
  if (template[0] === "#") {
    const el2 = document.querySelector(template);
    template = el2 ? el2.innerHTML : ``;
  }
  const opts = extend(
    {
      hoistStatic: true,
      onError: void 0,
      onWarn: NOOP
    },
    options
  );
  if (!opts.isCustomElement && typeof customElements !== "undefined") {
    opts.isCustomElement = (tag) => !!customElements.get(tag);
  }
  const { code: code2 } = compile(template, opts);
  const render2 = new Function("Vue", code2)(runtimeDom);
  render2._rc = true;
  return compileCache[key] = render2;
}
registerRuntimeCompiler(compileToFunction);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "158";
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const ConstantColorFactor = 211;
const OneMinusConstantColorFactor = 212;
const ConstantAlphaFactor = 213;
const OneMinusConstantAlphaFactor = 214;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const AttachedBindMode = "attached";
const DetachedBindMode = "detached";
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RGB_BPTC_SIGNED_Format = 36494;
const RGB_BPTC_UNSIGNED_Format = 36495;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3e3;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const DisplayP3ColorSpace = "display-p3";
const LinearDisplayP3ColorSpace = "display-p3-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const Rec709Primaries = "rec709";
const P3Primaries = "p3";
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;
const StaticDrawUsage = 35044;
const GLSL3 = "300 es";
const _SRGBAFormat = 1035;
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i6 = 0, l = array.length; i6 < l; i6++) {
        array[i6].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d02 = Math.random() * 4294967295 | 0;
  const d12 = Math.random() * 4294967295 | 0;
  const d22 = Math.random() * 4294967295 | 0;
  const d32 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d02 & 255] + _lut[d02 >> 8 & 255] + _lut[d02 >> 16 & 255] + _lut[d02 >> 24 & 255] + "-" + _lut[d12 & 255] + _lut[d12 >> 8 & 255] + "-" + _lut[d12 >> 16 & 15 | 64] + _lut[d12 >> 24 & 255] + "-" + _lut[d22 & 63 | 128] + _lut[d22 >> 8 & 255] + "-" + _lut[d22 >> 16 & 255] + _lut[d22 >> 24 & 255] + _lut[d32 & 255] + _lut[d32 >> 8 & 255] + _lut[d32 >> 16 & 255] + _lut[d32 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x6, a12, a22, b12, b22) {
  return b12 + (x6 - a12) * (b22 - b12) / (a22 - a12);
}
function inverseLerp(x6, y6, value) {
  if (x6 !== y6) {
    return (value - x6) / (y6 - x6);
  } else {
    return 0;
  }
}
function lerp(x6, y6, t) {
  return (1 - t) * x6 + t * y6;
}
function damp(x6, y6, lambda, dt2) {
  return lerp(x6, y6, 1 - Math.exp(-lambda * dt2));
}
function pingpong(x6, length = 1) {
  return length - Math.abs(euclideanModulo(x6, length * 2) - length);
}
function smoothstep(x6, min, max) {
  if (x6 <= min)
    return 0;
  if (x6 >= max)
    return 1;
  x6 = (x6 - min) / (max - min);
  return x6 * x6 * (3 - 2 * x6);
}
function smootherstep(x6, min, max) {
  if (x6 <= min)
    return 0;
  if (x6 >= max)
    return 1;
  x6 = (x6 - min) / (max - min);
  return x6 * x6 * x6 * (x6 * (x6 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0)
    _seed = s;
  let t = _seed += 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b6, c, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b6 / 2);
  const s22 = sin(b6 / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c22 * s13, s22 * c1_3, s22 * s1_3, c22 * c13);
      break;
    case "YZY":
      q.set(s22 * s1_3, c22 * s13, s22 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q.set(s22 * c1_3, s22 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q.set(c22 * s13, s22 * s3_1, s22 * c3_1, c22 * c13);
      break;
    case "YXY":
      q.set(s22 * c3_1, c22 * s13, s22 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q.set(s22 * s3_1, s22 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize
};
class Vector2 {
  constructor(x6 = 0, y6 = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x6;
    this.y = y6;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x6, y6) {
    this.x = x6;
    this.y = y6;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x6) {
    this.x = x6;
    return this;
  }
  setY(y6) {
    this.y = y6;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v6) {
    this.x = v6.x;
    this.y = v6.y;
    return this;
  }
  add(v6) {
    this.x += v6.x;
    this.y += v6.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b6) {
    this.x = a.x + b6.x;
    this.y = a.y + b6.y;
    return this;
  }
  addScaledVector(v6, s) {
    this.x += v6.x * s;
    this.y += v6.y * s;
    return this;
  }
  sub(v6) {
    this.x -= v6.x;
    this.y -= v6.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b6) {
    this.x = a.x - b6.x;
    this.y = a.y - b6.y;
    return this;
  }
  multiply(v6) {
    this.x *= v6.x;
    this.y *= v6.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v6) {
    this.x /= v6.x;
    this.y /= v6.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x6 = this.x, y6 = this.y;
    const e = m.elements;
    this.x = e[0] * x6 + e[3] * y6 + e[6];
    this.y = e[1] * x6 + e[4] * y6 + e[7];
    return this;
  }
  min(v6) {
    this.x = Math.min(this.x, v6.x);
    this.y = Math.min(this.y, v6.y);
    return this;
  }
  max(v6) {
    this.x = Math.max(this.x, v6.x);
    this.y = Math.max(this.y, v6.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v6) {
    return this.x * v6.x + this.y * v6.y;
  }
  cross(v6) {
    return this.x * v6.y - this.y * v6.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v6) {
    const denominator = Math.sqrt(this.lengthSq() * v6.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v6) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v6) {
    return Math.sqrt(this.distanceToSquared(v6));
  }
  distanceToSquared(v6) {
    const dx2 = this.x - v6.x, dy2 = this.y - v6.y;
    return dx2 * dx2 + dy2 * dy2;
  }
  manhattanDistanceTo(v6) {
    return Math.abs(this.x - v6.x) + Math.abs(this.y - v6.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v6, alpha) {
    this.x += (v6.x - this.x) * alpha;
    this.y += (v6.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v12, v22, alpha) {
    this.x = v12.x + (v22.x - v12.x) * alpha;
    this.y = v12.y + (v22.y - v12.y) * alpha;
    return this;
  }
  equals(v6) {
    return v6.x === this.x && v6.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x6 = this.x - center.x;
    const y6 = this.y - center.y;
    this.x = x6 * c - y6 * s + center.x;
    this.y = x6 * s + y6 * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me2 = m.elements;
    te[0] = me2[0];
    te[1] = me2[1];
    te[2] = me2[2];
    te[3] = me2[3];
    te[4] = me2[4];
    te[5] = me2[5];
    te[6] = me2[6];
    te[7] = me2[7];
    te[8] = me2[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me2 = m.elements;
    this.set(
      me2[0],
      me2[4],
      me2[8],
      me2[1],
      me2[5],
      me2[9],
      me2[2],
      me2[6],
      me2[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b6) {
    const ae2 = a.elements;
    const be2 = b6.elements;
    const te = this.elements;
    const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
    const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
    const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
    const b11 = be2[0], b12 = be2[3], b13 = be2[6];
    const b21 = be2[1], b22 = be2[4], b23 = be2[7];
    const b31 = be2[2], b32 = be2[5], b33 = be2[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b6 = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g6 = te[6], h6 = te[7], i6 = te[8];
    return a * e * i6 - a * f * h6 - b6 * d * i6 + b6 * f * g6 + c * d * h6 - c * e * g6;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx2, ty3, sx2, sy3, rotation, cx2, cy3) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx2 * c,
      sx2 * s,
      -sx2 * (c * cx2 + s * cy3) + cx2 + tx2,
      -sy3 * s,
      sy3 * c,
      -sy3 * (-s * cx2 + c * cy3) + cy3 + ty3,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx2, sy3) {
    this.premultiply(_m3.makeScale(sx2, sy3));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx2, ty3) {
    this.premultiply(_m3.makeTranslation(tx2, ty3));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x6, y6) {
    if (x6.isVector2) {
      this.set(
        1,
        0,
        x6.x,
        0,
        1,
        x6.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x6,
        0,
        1,
        y6,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x6, y6) {
    this.set(
      x6,
      0,
      0,
      0,
      y6,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me2 = matrix.elements;
    for (let i6 = 0; i6 < 9; i6++) {
      if (te[i6] !== me2[i6])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i6 = 0; i6 < 9; i6++) {
      this.elements[i6] = array[i6 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix3();
function arrayNeedsUint32(array) {
  for (let i6 = array.length - 1; i6 >= 0; --i6) {
    if (array[i6] >= 65535)
      return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
const _cache = {};
function warnOnce(message) {
  if (message in _cache)
    return;
  _cache[message] = true;
  console.warn(message);
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /* @__PURE__ */ new Matrix3().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
);
const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /* @__PURE__ */ new Matrix3().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
);
const COLOR_SPACES = {
  [LinearSRGBColorSpace]: {
    transfer: LinearTransfer,
    primaries: Rec709Primaries,
    toReference: (color) => color,
    fromReference: (color) => color
  },
  [SRGBColorSpace]: {
    transfer: SRGBTransfer,
    primaries: Rec709Primaries,
    toReference: (color) => color.convertSRGBToLinear(),
    fromReference: (color) => color.convertLinearToSRGB()
  },
  [LinearDisplayP3ColorSpace]: {
    transfer: LinearTransfer,
    primaries: P3Primaries,
    toReference: (color) => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
  },
  [DisplayP3ColorSpace]: {
    transfer: SRGBTransfer,
    primaries: P3Primaries,
    toReference: (color) => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
  }
};
const SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
const ColorManagement = {
  enabled: true,
  _workingColorSpace: LinearSRGBColorSpace,
  get legacyMode() {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
    return !this.enabled;
  },
  set legacyMode(legacyMode) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
    this.enabled = !legacyMode;
  },
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(colorSpace) {
    if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
      throw new Error(`Unsupported working color space, "${colorSpace}".`);
    }
    this._workingColorSpace = colorSpace;
  },
  convert: function(color, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
    const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
    return targetFromReference(sourceToReference(color));
  },
  fromWorkingColorSpace: function(color, targetColorSpace) {
    return this.convert(color, this._workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this._workingColorSpace);
  },
  getPrimaries: function(colorSpace) {
    return COLOR_SPACES[colorSpace].primaries;
  },
  getTransfer: function(colorSpace) {
    if (colorSpace === NoColorSpace)
      return LinearTransfer;
    return COLOR_SPACES[colorSpace].transfer;
  }
};
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i6 = 0; i6 < data.length; i6++) {
        data[i6] = SRGBToLinear(data[i6] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i6 = 0; i6 < data.length; i6++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i6] = Math.floor(SRGBToLinear(data[i6] / 255) * 255);
        } else {
          data[i6] = SRGBToLinear(data[i6]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
}
let _sourceId = 0;
class Source {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i6 = 0, l = data.length; i6 < l; i6++) {
          if (data[i6].isDataTexture) {
            url.push(serializeImage(data[i6].image));
          } else {
            url.push(serializeImage(data[i6]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    if (typeof colorSpace === "string") {
      this.colorSpace = colorSpace;
    } else {
      warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
      this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0)
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv2) {
    if (this.mapping !== UVMapping)
      return uv2;
    uv2.applyMatrix3(this.matrix);
    if (uv2.x < 0 || uv2.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv2.x = uv2.x - Math.floor(uv2.x);
          break;
        case ClampToEdgeWrapping:
          uv2.x = uv2.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.x) % 2) === 1) {
            uv2.x = Math.ceil(uv2.x) - uv2.x;
          } else {
            uv2.x = uv2.x - Math.floor(uv2.x);
          }
          break;
      }
    }
    if (uv2.y < 0 || uv2.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv2.y = uv2.y - Math.floor(uv2.y);
          break;
        case ClampToEdgeWrapping:
          uv2.y = uv2.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv2.y) % 2) === 1) {
            uv2.y = Math.ceil(uv2.y) - uv2.y;
          } else {
            uv2.y = uv2.y - Math.floor(uv2.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv2.y = 1 - uv2.y;
    }
    return uv2;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  get encoding() {
    warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
    return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  set encoding(encoding) {
    warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
    this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(x6 = 0, y6 = 0, z = 0, w6 = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x6;
    this.y = y6;
    this.z = z;
    this.w = w6;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x6, y6, z, w6) {
    this.x = x6;
    this.y = y6;
    this.z = z;
    this.w = w6;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x6) {
    this.x = x6;
    return this;
  }
  setY(y6) {
    this.y = y6;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w6) {
    this.w = w6;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v6) {
    this.x = v6.x;
    this.y = v6.y;
    this.z = v6.z;
    this.w = v6.w !== void 0 ? v6.w : 1;
    return this;
  }
  add(v6) {
    this.x += v6.x;
    this.y += v6.y;
    this.z += v6.z;
    this.w += v6.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b6) {
    this.x = a.x + b6.x;
    this.y = a.y + b6.y;
    this.z = a.z + b6.z;
    this.w = a.w + b6.w;
    return this;
  }
  addScaledVector(v6, s) {
    this.x += v6.x * s;
    this.y += v6.y * s;
    this.z += v6.z * s;
    this.w += v6.w * s;
    return this;
  }
  sub(v6) {
    this.x -= v6.x;
    this.y -= v6.y;
    this.z -= v6.z;
    this.w -= v6.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b6) {
    this.x = a.x - b6.x;
    this.y = a.y - b6.y;
    this.z = a.z - b6.z;
    this.w = a.w - b6.w;
    return this;
  }
  multiply(v6) {
    this.x *= v6.x;
    this.y *= v6.y;
    this.z *= v6.z;
    this.w *= v6.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x6 = this.x, y6 = this.y, z = this.z, w6 = this.w;
    const e = m.elements;
    this.x = e[0] * x6 + e[4] * y6 + e[8] * z + e[12] * w6;
    this.y = e[1] * x6 + e[5] * y6 + e[9] * z + e[13] * w6;
    this.z = e[2] * x6 + e[6] * y6 + e[10] * z + e[14] * w6;
    this.w = e[3] * x6 + e[7] * y6 + e[11] * z + e[15] * w6;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x6, y6, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx2 = (m11 + 1) / 2;
      const yy3 = (m22 + 1) / 2;
      const zz2 = (m33 + 1) / 2;
      const xy3 = (m12 + m21) / 4;
      const xz2 = (m13 + m31) / 4;
      const yz2 = (m23 + m32) / 4;
      if (xx2 > yy3 && xx2 > zz2) {
        if (xx2 < epsilon) {
          x6 = 0;
          y6 = 0.707106781;
          z = 0.707106781;
        } else {
          x6 = Math.sqrt(xx2);
          y6 = xy3 / x6;
          z = xz2 / x6;
        }
      } else if (yy3 > zz2) {
        if (yy3 < epsilon) {
          x6 = 0.707106781;
          y6 = 0;
          z = 0.707106781;
        } else {
          y6 = Math.sqrt(yy3);
          x6 = xy3 / y6;
          z = yz2 / y6;
        }
      } else {
        if (zz2 < epsilon) {
          x6 = 0.707106781;
          y6 = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz2);
          x6 = xz2 / z;
          y6 = yz2 / z;
        }
      }
      this.set(x6, y6, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v6) {
    this.x = Math.min(this.x, v6.x);
    this.y = Math.min(this.y, v6.y);
    this.z = Math.min(this.z, v6.z);
    this.w = Math.min(this.w, v6.w);
    return this;
  }
  max(v6) {
    this.x = Math.max(this.x, v6.x);
    this.y = Math.max(this.y, v6.y);
    this.z = Math.max(this.z, v6.z);
    this.w = Math.max(this.w, v6.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v6) {
    return this.x * v6.x + this.y * v6.y + this.z * v6.z + this.w * v6.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v6, alpha) {
    this.x += (v6.x - this.x) * alpha;
    this.y += (v6.y - this.y) * alpha;
    this.z += (v6.z - this.z) * alpha;
    this.w += (v6.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v12, v22, alpha) {
    this.x = v12.x + (v22.x - v12.x) * alpha;
    this.y = v12.y + (v22.y - v12.y) * alpha;
    this.z = v12.z + (v22.z - v12.z) * alpha;
    this.w = v12.w + (v22.w - v12.w) * alpha;
    return this;
  }
  equals(v6) {
    return v6.x === this.x && v6.y === this.y && v6.z === this.z && v6.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(width = 1, height = 1, options = {}) {
    super();
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: 1 };
    if (options.encoding !== void 0) {
      warnOnce("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.");
      options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      depthTexture: null,
      samples: 0
    }, options);
    this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.flipY = false;
    this.texture.generateMipmaps = options.generateMipmaps;
    this.texture.internalFormat = options.internalFormat;
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.isRenderTargetTexture = true;
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
}
class DataArrayTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class Data3DTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class Quaternion {
  constructor(x6 = 0, y6 = 0, z = 0, w6 = 1) {
    this.isQuaternion = true;
    this._x = x6;
    this._y = y6;
    this._z = z;
    this._w = w6;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x02 = src0[srcOffset0 + 0], y02 = src0[srcOffset0 + 1], z02 = src0[srcOffset0 + 2], w02 = src0[srcOffset0 + 3];
    const x12 = src1[srcOffset1 + 0], y12 = src1[srcOffset1 + 1], z12 = src1[srcOffset1 + 2], w12 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x02;
      dst[dstOffset + 1] = y02;
      dst[dstOffset + 2] = z02;
      dst[dstOffset + 3] = w02;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x12;
      dst[dstOffset + 1] = y12;
      dst[dstOffset + 2] = z12;
      dst[dstOffset + 3] = w12;
      return;
    }
    if (w02 !== w12 || x02 !== x12 || y02 !== y12 || z02 !== z12) {
      let s = 1 - t;
      const cos = x02 * x12 + y02 * y12 + z02 * z12 + w02 * w12, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x02 = x02 * s + x12 * tDir;
      y02 = y02 * s + y12 * tDir;
      z02 = z02 * s + z12 * tDir;
      w02 = w02 * s + w12 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x02 * x02 + y02 * y02 + z02 * z02 + w02 * w02);
        x02 *= f;
        y02 *= f;
        z02 *= f;
        w02 *= f;
      }
    }
    dst[dstOffset] = x02;
    dst[dstOffset + 1] = y02;
    dst[dstOffset + 2] = z02;
    dst[dstOffset + 3] = w02;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x02 = src0[srcOffset0];
    const y02 = src0[srcOffset0 + 1];
    const z02 = src0[srcOffset0 + 2];
    const w02 = src0[srcOffset0 + 3];
    const x12 = src1[srcOffset1];
    const y12 = src1[srcOffset1 + 1];
    const z12 = src1[srcOffset1 + 2];
    const w12 = src1[srcOffset1 + 3];
    dst[dstOffset] = x02 * w12 + w02 * x12 + y02 * z12 - z02 * y12;
    dst[dstOffset + 1] = y02 * w12 + w02 * y12 + z02 * x12 - x02 * z12;
    dst[dstOffset + 2] = z02 * w12 + w02 * z12 + x02 * y12 - y02 * x12;
    dst[dstOffset + 3] = w02 * w12 - x02 * x12 - y02 * y12 - z02 * z12;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x6, y6, z, w6) {
    this._x = x6;
    this._y = y6;
    this._z = z;
    this._w = w6;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    const x6 = euler._x, y6 = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c12 = cos(x6 / 2);
    const c22 = cos(y6 / 2);
    const c32 = cos(z / 2);
    const s12 = sin(x6 / 2);
    const s22 = sin(y6 / 2);
    const s32 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s12 * c22 * c32 + c12 * s22 * s32;
        this._y = c12 * s22 * c32 - s12 * c22 * s32;
        this._z = c12 * c22 * s32 + s12 * s22 * c32;
        this._w = c12 * c22 * c32 - s12 * s22 * s32;
        break;
      case "YXZ":
        this._x = s12 * c22 * c32 + c12 * s22 * s32;
        this._y = c12 * s22 * c32 - s12 * c22 * s32;
        this._z = c12 * c22 * s32 - s12 * s22 * c32;
        this._w = c12 * c22 * c32 + s12 * s22 * s32;
        break;
      case "ZXY":
        this._x = s12 * c22 * c32 - c12 * s22 * s32;
        this._y = c12 * s22 * c32 + s12 * c22 * s32;
        this._z = c12 * c22 * s32 + s12 * s22 * c32;
        this._w = c12 * c22 * c32 - s12 * s22 * s32;
        break;
      case "ZYX":
        this._x = s12 * c22 * c32 - c12 * s22 * s32;
        this._y = c12 * s22 * c32 + s12 * c22 * s32;
        this._z = c12 * c22 * s32 - s12 * s22 * c32;
        this._w = c12 * c22 * c32 + s12 * s22 * s32;
        break;
      case "YZX":
        this._x = s12 * c22 * c32 + c12 * s22 * s32;
        this._y = c12 * s22 * c32 + s12 * c22 * s32;
        this._z = c12 * c22 * s32 - s12 * s22 * c32;
        this._w = c12 * c22 * c32 - s12 * s22 * s32;
        break;
      case "XZY":
        this._x = s12 * c22 * c32 - c12 * s22 * s32;
        this._y = c12 * s22 * c32 - s12 * c22 * s32;
        this._z = c12 * c22 * s32 + s12 * s22 * c32;
        this._w = c12 * c22 * c32 + s12 * s22 * s32;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v6) {
    return this._x * v6._x + this._y * v6._y + this._z * v6._z + this._w * v6._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b6) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b6._x, qby = b6._y, qbz = b6._z, qbw = b6._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb2, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb2);
    const x6 = this._x, y6 = this._y, z = this._z, w6 = this._w;
    let cosHalfTheta = w6 * qb2._w + x6 * qb2._x + y6 * qb2._y + z * qb2._z;
    if (cosHalfTheta < 0) {
      this._w = -qb2._w;
      this._x = -qb2._x;
      this._y = -qb2._y;
      this._z = -qb2._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb2);
    }
    if (cosHalfTheta >= 1) {
      this._w = w6;
      this._x = x6;
      this._y = y6;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w6 + t * this._w;
      this._x = s * x6 + t * this._x;
      this._y = s * y6 + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w6 * ratioA + this._w * ratioB;
    this._x = x6 * ratioA + this._x * ratioB;
    this._y = y6 * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa2, qb2, t) {
    return this.copy(qa2).slerp(qb2, t);
  }
  random() {
    const u12 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u12);
    const sqrtu1 = Math.sqrt(u12);
    const u22 = 2 * Math.PI * Math.random();
    const u32 = 2 * Math.PI * Math.random();
    return this.set(
      sqrt1u1 * Math.cos(u22),
      sqrtu1 * Math.sin(u32),
      sqrtu1 * Math.cos(u32),
      sqrt1u1 * Math.sin(u22)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}
class Vector3 {
  constructor(x6 = 0, y6 = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x6;
    this.y = y6;
    this.z = z;
  }
  set(x6, y6, z) {
    if (z === void 0)
      z = this.z;
    this.x = x6;
    this.y = y6;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x6) {
    this.x = x6;
    return this;
  }
  setY(y6) {
    this.y = y6;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v6) {
    this.x = v6.x;
    this.y = v6.y;
    this.z = v6.z;
    return this;
  }
  add(v6) {
    this.x += v6.x;
    this.y += v6.y;
    this.z += v6.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b6) {
    this.x = a.x + b6.x;
    this.y = a.y + b6.y;
    this.z = a.z + b6.z;
    return this;
  }
  addScaledVector(v6, s) {
    this.x += v6.x * s;
    this.y += v6.y * s;
    this.z += v6.z * s;
    return this;
  }
  sub(v6) {
    this.x -= v6.x;
    this.y -= v6.y;
    this.z -= v6.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b6) {
    this.x = a.x - b6.x;
    this.y = a.y - b6.y;
    this.z = a.z - b6.z;
    return this;
  }
  multiply(v6) {
    this.x *= v6.x;
    this.y *= v6.y;
    this.z *= v6.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b6) {
    this.x = a.x * b6.x;
    this.y = a.y * b6.y;
    this.z = a.z * b6.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x6 = this.x, y6 = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x6 + e[3] * y6 + e[6] * z;
    this.y = e[1] * x6 + e[4] * y6 + e[7] * z;
    this.z = e[2] * x6 + e[5] * y6 + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x6 = this.x, y6 = this.y, z = this.z;
    const e = m.elements;
    const w6 = 1 / (e[3] * x6 + e[7] * y6 + e[11] * z + e[15]);
    this.x = (e[0] * x6 + e[4] * y6 + e[8] * z + e[12]) * w6;
    this.y = (e[1] * x6 + e[5] * y6 + e[9] * z + e[13]) * w6;
    this.z = (e[2] * x6 + e[6] * y6 + e[10] * z + e[14]) * w6;
    return this;
  }
  applyQuaternion(q) {
    const vx2 = this.x, vy3 = this.y, vz2 = this.z;
    const qx2 = q.x, qy3 = q.y, qz2 = q.z, qw2 = q.w;
    const tx2 = 2 * (qy3 * vz2 - qz2 * vy3);
    const ty3 = 2 * (qz2 * vx2 - qx2 * vz2);
    const tz2 = 2 * (qx2 * vy3 - qy3 * vx2);
    this.x = vx2 + qw2 * tx2 + qy3 * tz2 - qz2 * ty3;
    this.y = vy3 + qw2 * ty3 + qz2 * tx2 - qx2 * tz2;
    this.z = vz2 + qw2 * tz2 + qx2 * ty3 - qy3 * tx2;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x6 = this.x, y6 = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x6 + e[4] * y6 + e[8] * z;
    this.y = e[1] * x6 + e[5] * y6 + e[9] * z;
    this.z = e[2] * x6 + e[6] * y6 + e[10] * z;
    return this.normalize();
  }
  divide(v6) {
    this.x /= v6.x;
    this.y /= v6.y;
    this.z /= v6.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v6) {
    this.x = Math.min(this.x, v6.x);
    this.y = Math.min(this.y, v6.y);
    this.z = Math.min(this.z, v6.z);
    return this;
  }
  max(v6) {
    this.x = Math.max(this.x, v6.x);
    this.y = Math.max(this.y, v6.y);
    this.z = Math.max(this.z, v6.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v6) {
    return this.x * v6.x + this.y * v6.y + this.z * v6.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v6, alpha) {
    this.x += (v6.x - this.x) * alpha;
    this.y += (v6.y - this.y) * alpha;
    this.z += (v6.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v12, v22, alpha) {
    this.x = v12.x + (v22.x - v12.x) * alpha;
    this.y = v12.y + (v22.y - v12.y) * alpha;
    this.z = v12.z + (v22.z - v12.z) * alpha;
    return this;
  }
  cross(v6) {
    return this.crossVectors(this, v6);
  }
  crossVectors(a, b6) {
    const ax2 = a.x, ay3 = a.y, az2 = a.z;
    const bx2 = b6.x, by3 = b6.y, bz2 = b6.z;
    this.x = ay3 * bz2 - az2 * by3;
    this.y = az2 * bx2 - ax2 * bz2;
    this.z = ax2 * by3 - ay3 * bx2;
    return this;
  }
  projectOnVector(v6) {
    const denominator = v6.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v6.dot(this) / denominator;
    return this.copy(v6).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$b.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$b);
  }
  reflect(normal) {
    return this.sub(_vector$b.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v6) {
    const denominator = Math.sqrt(this.lengthSq() * v6.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v6) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v6) {
    return Math.sqrt(this.distanceToSquared(v6));
  }
  distanceToSquared(v6) {
    const dx2 = this.x - v6.x, dy2 = this.y - v6.y, dz2 = this.z - v6.z;
    return dx2 * dx2 + dy2 * dy2 + dz2 * dz2;
  }
  manhattanDistanceTo(v6) {
    return Math.abs(this.x - v6.x) + Math.abs(this.y - v6.y) + Math.abs(this.z - v6.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y6) {
    this.x = radius * Math.sin(theta);
    this.y = y6;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx2 = this.setFromMatrixColumn(m, 0).length();
    const sy3 = this.setFromMatrixColumn(m, 1).length();
    const sz2 = this.setFromMatrixColumn(m, 2).length();
    this.x = sx2;
    this.y = sy3;
    this.z = sz2;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v6) {
    return v6.x === this.x && v6.y === this.y && v6.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
const _vector$b = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i6 = 0, il2 = array.length; i6 < il2; i6 += 3) {
      this.expandByPoint(_vector$a.fromArray(array, i6));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i6 = 0, il2 = attribute.count; i6 < il2; i6++) {
      this.expandByPoint(_vector$a.fromBufferAttribute(attribute, i6));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i6 = 0, il2 = points.length; i6 < il2; i6++) {
      this.expandByPoint(points[i6]);
    }
    return this;
  }
  setFromCenterAndSize(center, size2) {
    const halfSize = _vector$a.copy(size2).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i6 = 0, l = positionAttribute.count; i6 < l; i6++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i6, _vector$a);
          } else {
            _vector$a.fromBufferAttribute(positionAttribute, i6);
          }
          _vector$a.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$a);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$3.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$3.copy(geometry.boundingBox);
        }
        _box$3.applyMatrix4(object.matrixWorld);
        this.union(_box$3);
      }
    }
    const children = object.children;
    for (let i6 = 0, l = children.length; i6 < l; i6++) {
      this.expandByObject(children[i6], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$a);
    return _vector$a.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$a).distanceTo(point);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$a).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$a = /* @__PURE__ */ new Vector3();
const _box$3 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$4 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v02, v12, v22, extents) {
  for (let i6 = 0, j = axes.length - 3; i6 <= j; i6 += 3) {
    _testAxis.fromArray(axes, i6);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p02 = v02.dot(_testAxis);
    const p12 = v12.dot(_testAxis);
    const p22 = v22.dot(_testAxis);
    if (Math.max(-Math.max(p02, p12, p22), Math.min(p02, p12, p22)) > r) {
      return false;
    }
  }
  return true;
}
const _box$2 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i6 = 0, il2 = points.length; i6 < il2; i6++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i6]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$9 = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(v6) {
    this.direction.copy(v6).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$9));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$9.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$9.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$9.distanceToSquared(point);
  }
  distanceSqToSegment(v02, v12, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v02).add(v12).multiplyScalar(0.5);
    _segDir.copy(v12).sub(v02).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v02.distanceTo(v12) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b02 = _diff.dot(this.direction);
    const b12 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s02, s12, sqrDist, extDet;
    if (det > 0) {
      s02 = a01 * b12 - b02;
      s12 = a01 * b02 - b12;
      extDet = segExtent * det;
      if (s02 >= 0) {
        if (s12 >= -extDet) {
          if (s12 <= extDet) {
            const invDet = 1 / det;
            s02 *= invDet;
            s12 *= invDet;
            sqrDist = s02 * (s02 + a01 * s12 + 2 * b02) + s12 * (a01 * s02 + s12 + 2 * b12) + c;
          } else {
            s12 = segExtent;
            s02 = Math.max(0, -(a01 * s12 + b02));
            sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c;
          }
        } else {
          s12 = -segExtent;
          s02 = Math.max(0, -(a01 * s12 + b02));
          sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c;
        }
      } else {
        if (s12 <= -extDet) {
          s02 = Math.max(0, -(-a01 * segExtent + b02));
          s12 = s02 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c;
        } else if (s12 <= extDet) {
          s02 = 0;
          s12 = Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = s12 * (s12 + 2 * b12) + c;
        } else {
          s02 = Math.max(0, -(a01 * segExtent + b02));
          s12 = s02 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b12), segExtent);
          sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c;
        }
      }
    } else {
      s12 = a01 > 0 ? -segExtent : segExtent;
      s02 = Math.max(0, -(a01 * s12 + b02));
      sqrDist = -s02 * s02 + s12 * (s12 + 2 * b12) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s02);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s12);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$9.subVectors(sphere.center, this.origin);
    const tca = _vector$9.dot(this.direction);
    const d22 = _vector$9.dot(_vector$9) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d22 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d22);
    const t02 = tca - thc;
    const t12 = tca + thc;
    if (t12 < 0)
      return null;
    if (t02 < 0)
      return this.at(t12, target);
    return this.at(t02, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || isNaN(tmin))
      tmin = tymin;
    if (tymax < tmax || isNaN(tmax))
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$9) !== null;
  }
  intersectTriangle(a, b6, c, backfaceCulling, target) {
    _edge1.subVectors(b6, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me2 = m.elements;
    te[0] = me2[0];
    te[1] = me2[1];
    te[2] = me2[2];
    te[3] = me2[3];
    te[4] = me2[4];
    te[5] = me2[5];
    te[6] = me2[6];
    te[7] = me2[7];
    te[8] = me2[8];
    te[9] = me2[9];
    te[10] = me2[10];
    te[11] = me2[11];
    te[12] = me2[12];
    te[13] = me2[13];
    te[14] = me2[14];
    te[15] = me2[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me2 = m.elements;
    te[12] = me2[12];
    te[13] = me2[13];
    te[14] = me2[14];
    return this;
  }
  setFromMatrix3(m) {
    const me2 = m.elements;
    this.set(
      me2[0],
      me2[3],
      me2[6],
      0,
      me2[1],
      me2[4],
      me2[7],
      0,
      me2[2],
      me2[5],
      me2[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me2 = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me2[0] * scaleX;
    te[1] = me2[1] * scaleX;
    te[2] = me2[2] * scaleX;
    te[3] = 0;
    te[4] = me2[4] * scaleY;
    te[5] = me2[5] * scaleY;
    te[6] = me2[6] * scaleY;
    te[7] = 0;
    te[8] = me2[8] * scaleZ;
    te[9] = me2[9] * scaleZ;
    te[10] = me2[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x6 = euler.x, y6 = euler.y, z = euler.z;
    const a = Math.cos(x6), b6 = Math.sin(x6);
    const c = Math.cos(y6), d = Math.sin(y6);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae2 = a * e, af3 = a * f, be2 = b6 * e, bf2 = b6 * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af3 + be2 * d;
      te[5] = ae2 - bf2 * d;
      te[9] = -b6 * c;
      te[2] = bf2 - ae2 * d;
      te[6] = be2 + af3 * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce2 = c * e, cf3 = c * f, de2 = d * e, df3 = d * f;
      te[0] = ce2 + df3 * b6;
      te[4] = de2 * b6 - cf3;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b6;
      te[2] = cf3 * b6 - de2;
      te[6] = df3 + ce2 * b6;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce2 = c * e, cf3 = c * f, de2 = d * e, df3 = d * f;
      te[0] = ce2 - df3 * b6;
      te[4] = -a * f;
      te[8] = de2 + cf3 * b6;
      te[1] = cf3 + de2 * b6;
      te[5] = a * e;
      te[9] = df3 - ce2 * b6;
      te[2] = -a * d;
      te[6] = b6;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae2 = a * e, af3 = a * f, be2 = b6 * e, bf2 = b6 * f;
      te[0] = c * e;
      te[4] = be2 * d - af3;
      te[8] = ae2 * d + bf2;
      te[1] = c * f;
      te[5] = bf2 * d + ae2;
      te[9] = af3 * d - be2;
      te[2] = -d;
      te[6] = b6 * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac2 = a * c, ad2 = a * d, bc2 = b6 * c, bd2 = b6 * d;
      te[0] = c * e;
      te[4] = bd2 - ac2 * f;
      te[8] = bc2 * f + ad2;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b6 * e;
      te[2] = -d * e;
      te[6] = ad2 * f + bc2;
      te[10] = ac2 - bd2 * f;
    } else if (euler.order === "XZY") {
      const ac2 = a * c, ad2 = a * d, bc2 = b6 * c, bd2 = b6 * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac2 * f + bd2;
      te[5] = a * e;
      te[9] = ad2 * f - bc2;
      te[2] = bc2 * f - ad2;
      te[6] = b6 * e;
      te[10] = bd2 * f + ac2;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up2) {
    const te = this.elements;
    _z$1.subVectors(eye, target);
    if (_z$1.lengthSq() === 0) {
      _z$1.z = 1;
    }
    _z$1.normalize();
    _x$1.crossVectors(up2, _z$1);
    if (_x$1.lengthSq() === 0) {
      if (Math.abs(up2.z) === 1) {
        _z$1.x += 1e-4;
      } else {
        _z$1.z += 1e-4;
      }
      _z$1.normalize();
      _x$1.crossVectors(up2, _z$1);
    }
    _x$1.normalize();
    _y$2.crossVectors(_z$1, _x$1);
    te[0] = _x$1.x;
    te[4] = _y$2.x;
    te[8] = _z$1.x;
    te[1] = _x$1.y;
    te[5] = _y$2.y;
    te[9] = _z$1.y;
    te[2] = _x$1.z;
    te[6] = _y$2.z;
    te[10] = _z$1.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b6) {
    const ae2 = a.elements;
    const be2 = b6.elements;
    const te = this.elements;
    const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
    const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
    const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
    const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
    const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
    const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
    const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
    const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  setPosition(x6, y6, z) {
    const te = this.elements;
    if (x6.isVector3) {
      te[12] = x6.x;
      te[13] = x6.y;
      te[14] = x6.z;
    } else {
      te[12] = x6;
      te[13] = y6;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v6) {
    const te = this.elements;
    const x6 = v6.x, y6 = v6.y, z = v6.z;
    te[0] *= x6;
    te[4] *= y6;
    te[8] *= z;
    te[1] *= x6;
    te[5] *= y6;
    te[9] *= z;
    te[2] *= x6;
    te[6] *= y6;
    te[10] *= z;
    te[3] *= x6;
    te[7] *= y6;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x6, y6, z) {
    if (x6.isVector3) {
      this.set(
        1,
        0,
        0,
        x6.x,
        0,
        1,
        0,
        x6.y,
        0,
        0,
        1,
        x6.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x6,
        0,
        1,
        0,
        y6,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x6 = axis.x, y6 = axis.y, z = axis.z;
    const tx2 = t * x6, ty3 = t * y6;
    this.set(
      tx2 * x6 + c,
      tx2 * y6 - s * z,
      tx2 * z + s * y6,
      0,
      tx2 * y6 + s * z,
      ty3 * y6 + c,
      ty3 * z - s * x6,
      0,
      tx2 * z - s * y6,
      ty3 * z + s * x6,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x6, y6, z) {
    this.set(
      x6,
      0,
      0,
      0,
      0,
      y6,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy3, xz2, yx2, yz2, zx2, zy3) {
    this.set(
      1,
      yx2,
      zx2,
      0,
      xy3,
      1,
      zy3,
      0,
      xz2,
      yz2,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x6 = quaternion._x, y6 = quaternion._y, z = quaternion._z, w6 = quaternion._w;
    const x22 = x6 + x6, y22 = y6 + y6, z22 = z + z;
    const xx2 = x6 * x22, xy3 = x6 * y22, xz2 = x6 * z22;
    const yy3 = y6 * y22, yz2 = y6 * z22, zz2 = z * z22;
    const wx2 = w6 * x22, wy3 = w6 * y22, wz2 = w6 * z22;
    const sx2 = scale.x, sy3 = scale.y, sz2 = scale.z;
    te[0] = (1 - (yy3 + zz2)) * sx2;
    te[1] = (xy3 + wz2) * sx2;
    te[2] = (xz2 - wy3) * sx2;
    te[3] = 0;
    te[4] = (xy3 - wz2) * sy3;
    te[5] = (1 - (xx2 + zz2)) * sy3;
    te[6] = (yz2 + wx2) * sy3;
    te[7] = 0;
    te[8] = (xz2 + wy3) * sz2;
    te[9] = (yz2 - wx2) * sz2;
    te[10] = (1 - (xx2 + yy3)) * sz2;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx2 = _v1$5.set(te[0], te[1], te[2]).length();
    const sy3 = _v1$5.set(te[4], te[5], te[6]).length();
    const sz2 = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx2 = -sx2;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx2;
    const invSY = 1 / sy3;
    const invSZ = 1 / sz2;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx2;
    scale.y = sy3;
    scale.z = sz2;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const x6 = 2 * near / (right - left);
    const y6 = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b6 = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x6;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y6;
    te[9] = b6;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const w6 = 1 / (right - left);
    const h6 = 1 / (top - bottom);
    const p6 = 1 / (far - near);
    const x6 = (right + left) * w6;
    const y6 = (top + bottom) * h6;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p6;
      zInv = -2 * p6;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p6;
      zInv = -1 * p6;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w6;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x6;
    te[1] = 0;
    te[5] = 2 * h6;
    te[9] = 0;
    te[13] = -y6;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me2 = matrix.elements;
    for (let i6 = 0; i6 < 16; i6++) {
      if (te[i6] !== me2[i6])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i6 = 0; i6 < 16; i6++) {
      this.elements[i6] = array[i6 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x$1 = /* @__PURE__ */ new Vector3();
const _y$2 = /* @__PURE__ */ new Vector3();
const _z$1 = /* @__PURE__ */ new Vector3();
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x6 = 0, y6 = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x6;
    this._y = y6;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x6, y6, z, order = this._order) {
    this._x = x6;
    this._y = y6;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix$1.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$1, order, update);
  }
  setFromVector3(v6, order = this._order) {
    return this.set(v6.x, v6.y, v6.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$1 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x6, y6, z) {
    if (x6.isVector3) {
      _target.copy(x6);
    } else {
      _target.set(x6, y6, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i6 = 0; i6 < arguments.length; i6++) {
        this.add(arguments[i6]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i6 = 0; i6 < arguments.length; i6++) {
        this.remove(arguments[i6]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id2) {
    return this.getObjectByProperty("id", id2);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i6 = 0, l = this.children.length; i6 < l; i6++) {
      const child = this.children[i6];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value) {
    let result = [];
    if (this[name] === value)
      result.push(this);
    for (let i6 = 0, l = this.children.length; i6 < l; i6++) {
      const childResult = this.children[i6].getObjectsByProperty(name, value);
      if (childResult.length > 0) {
        result = result.concat(childResult);
      }
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i6 = 0, l = children.length; i6 < l; i6++) {
      children[i6].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i6 = 0, l = children.length; i6 < l; i6++) {
      children[i6].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i6 = 0, l = children.length; i6 < l; i6++) {
      const child = children[i6];
      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i6 = 0, l = children.length; i6 < l; i6++) {
        const child = children[i6];
        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0)
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i6 = 0, l = shapes.length; i6 < l; i6++) {
            const shape = shapes[i6];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i6 = 0, l = this.material.length; i6 < l; i6++) {
          uuids.push(serialize(meta.materials, this.material[i6]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i6 = 0; i6 < this.children.length; i6++) {
        object.children.push(this.children[i6].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i6 = 0; i6 < this.animations.length; i6++) {
        const animation = this.animations[i6];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
      if (nodes.length > 0)
        output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i6 = 0; i6 < source.children.length; i6++) {
        const child = source.children[i6];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$1 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
let warnedGetUV = false;
class Triangle {
  constructor(a = new Vector3(), b6 = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b6;
    this.c = c;
  }
  static getNormal(a, b6, c, target) {
    target.subVectors(c, b6);
    _v0$1.subVectors(a, b6);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a, b6, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b6, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v6 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v6, v6, u);
  }
  static containsPoint(point, a, b6, c) {
    this.getBarycoord(point, a, b6, c, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p12, p22, p32, uv1, uv2, uv3, target) {
    if (warnedGetUV === false) {
      console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
      warnedGetUV = true;
    }
    return this.getInterpolation(point, p12, p22, p32, uv1, uv2, uv3, target);
  }
  static getInterpolation(point, p12, p22, p32, v12, v22, v32, target) {
    this.getBarycoord(point, p12, p22, p32, _v3$1);
    target.setScalar(0);
    target.addScaledVector(v12, _v3$1.x);
    target.addScaledVector(v22, _v3$1.y);
    target.addScaledVector(v32, _v3$1.z);
    return target;
  }
  static isFrontFacing(a, b6, c, direction) {
    _v0$1.subVectors(c, b6);
    _v1$3.subVectors(a, b6);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b6, c) {
    this.a.copy(a);
    this.b.copy(b6);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i02, i12, i22) {
    this.a.copy(points[i02]);
    this.b.copy(points[i12]);
    this.c.copy(points[i22]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i02, i12, i22) {
    this.a.fromBufferAttribute(attribute, i02);
    this.b.fromBufferAttribute(attribute, i12);
    this.c.fromBufferAttribute(attribute, i22);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    if (warnedGetUV === false) {
      console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
      warnedGetUV = true;
    }
    return Triangle.getInterpolation(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  getInterpolation(point, v12, v22, v32, target) {
    return Triangle.getInterpolation(point, this.a, this.b, this.c, v12, v22, v32, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p6, target) {
    const a = this.a, b6 = this.b, c = this.c;
    let v6, w6;
    _vab.subVectors(b6, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p6, a);
    const d12 = _vab.dot(_vap);
    const d22 = _vac.dot(_vap);
    if (d12 <= 0 && d22 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p6, b6);
    const d32 = _vab.dot(_vbp);
    const d42 = _vac.dot(_vbp);
    if (d32 >= 0 && d42 <= d32) {
      return target.copy(b6);
    }
    const vc2 = d12 * d42 - d32 * d22;
    if (vc2 <= 0 && d12 >= 0 && d32 <= 0) {
      v6 = d12 / (d12 - d32);
      return target.copy(a).addScaledVector(_vab, v6);
    }
    _vcp.subVectors(p6, c);
    const d52 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d52 <= d6) {
      return target.copy(c);
    }
    const vb2 = d52 * d22 - d12 * d6;
    if (vb2 <= 0 && d22 >= 0 && d6 <= 0) {
      w6 = d22 / (d22 - d6);
      return target.copy(a).addScaledVector(_vac, w6);
    }
    const va2 = d32 * d6 - d52 * d42;
    if (va2 <= 0 && d42 - d32 >= 0 && d52 - d6 >= 0) {
      _vbc.subVectors(c, b6);
      w6 = (d42 - d32) / (d42 - d32 + (d52 - d6));
      return target.copy(b6).addScaledVector(_vbc, w6);
    }
    const denom = 1 / (va2 + vb2 + vc2);
    v6 = vb2 * denom;
    w6 = vc2 * denom;
    return target.copy(a).addScaledVector(_vab, v6).addScaledVector(_vac, w6);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p6, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p6 + (q - p6) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p6 + (q - p6) * 6 * (2 / 3 - t);
  return p6;
}
class Color {
  constructor(r, g6, b6) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g6, b6);
  }
  set(r, g6, b6) {
    if (g6 === void 0 && b6 === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g6, b6);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g6, b6, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g6;
    this.b = b6;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h6, s, l, colorSpace = ColorManagement.workingColorSpace) {
    h6 = euclideanModulo(h6, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p6 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p6;
      this.r = hue2rgb(q, p6, h6 + 1 / 3);
      this.g = hue2rgb(q, p6, h6);
      this.b = hue2rgb(q, p6, h6 - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style2, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style2 + " will be ignored.");
      }
    }
    let m;
    if (m = /^(\w+)\(([^\)]*)\)/.exec(style2)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(255, parseInt(color[1], 10)) / 255,
              Math.min(255, parseInt(color[2], 10)) / 255,
              Math.min(255, parseInt(color[3], 10)) / 255,
              colorSpace
            );
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(100, parseInt(color[1], 10)) / 100,
              Math.min(100, parseInt(color[2], 10)) / 100,
              Math.min(100, parseInt(color[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setHSL(
              parseFloat(color[1]) / 360,
              parseFloat(color[2]) / 100,
              parseFloat(color[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style2);
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style2)) {
      const hex = m[1];
      const size2 = hex.length;
      if (size2 === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size2 === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style2);
      }
    } else if (style2 && style2.length > 0) {
      return this.setColorName(style2, colorSpace);
    }
    return this;
  }
  setColorName(style2, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style2.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style2);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g6 = _color.g, b6 = _color.b;
    const max = Math.max(r, g6, b6);
    const min = Math.min(r, g6, b6);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g6 - b6) / delta + (g6 < b6 ? 6 : 0);
          break;
        case g6:
          hue = (b6 - r) / delta + 2;
          break;
        case b6:
          hue = (r - g6) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g6 = _color.g, b6 = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g6.toFixed(3)} ${b6.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g6 * 255)},${Math.round(b6 * 255)})`;
  }
  offsetHSL(h6, s, l) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h6, _hslA.s + s, _hslA.l + l);
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h6 = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h6, s, l);
    return this;
  }
  setFromVector3(v6) {
    this.r = v6.x;
    this.g = v6.y;
    this.b = v6.z;
    return this;
  }
  applyMatrix3(m) {
    const r = this.r, g6 = this.g, b6 = this.b;
    const e = m.elements;
    this.r = e[0] * r + e[3] * g6 + e[6] * b6;
    this.g = e[1] * r + e[4] * g6 + e[7] * b6;
    this.b = e[2] * r + e[5] * g6 + e[8] * b6;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
const _color = /* @__PURE__ */ new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.iridescence !== void 0)
      data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0)
      data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0)
      data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0)
      data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0)
      data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors === true)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor)
      data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor)
      data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation)
      data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null)
      data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null)
      data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null)
      data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor)
      data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0)
      data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth)
      data.depthFunc = this.depthFunc;
    if (this.depthTest === false)
      data.depthTest = this.depthTest;
    if (this.depthWrite === false)
      data.depthWrite = this.depthWrite;
    if (this.colorWrite === false)
      data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255)
      data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc)
      data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0)
      data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255)
      data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp)
      data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp)
      data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp)
      data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true)
      data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaHash === true)
      data.alphaHash = true;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = true;
    if (this.forceSinglePass === true)
      data.forceSinglePass = true;
    if (this.wireframe === true)
      data.wireframe = true;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = true;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (this.fog === false)
      data.fog = false;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i6 = 0; i6 !== n; ++i6) {
        dstPlanes[i6] = srcPlanes[i6].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vector$8 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.gpuType = FloatType;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i6 = 0, l = this.itemSize; i6 < l; i6++) {
      this.array[index1 + i6] = attribute.array[index2 + i6];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i6 = 0, l = this.count; i6 < l; i6++) {
        _vector2$1.fromBufferAttribute(this, i6);
        _vector2$1.applyMatrix3(m);
        this.setXY(i6, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i6 = 0, l = this.count; i6 < l; i6++) {
        _vector$8.fromBufferAttribute(this, i6);
        _vector$8.applyMatrix3(m);
        this.setXYZ(i6, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i6 = 0, l = this.count; i6 < l; i6++) {
      _vector$8.fromBufferAttribute(this, i6);
      _vector$8.applyMatrix4(m);
      this.setXYZ(i6, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i6 = 0, l = this.count; i6 < l; i6++) {
      _vector$8.fromBufferAttribute(this, i6);
      _vector$8.applyNormalMatrix(m);
      this.setXYZ(i6, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i6 = 0, l = this.count; i6 < l; i6++) {
      _vector$8.fromBufferAttribute(this, i6);
      _vector$8.transformDirection(m);
      this.setXYZ(i6, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized)
      value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized)
      value = normalize(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  getX(index) {
    let x6 = this.array[index * this.itemSize];
    if (this.normalized)
      x6 = denormalize(x6, this.array);
    return x6;
  }
  setX(index, x6) {
    if (this.normalized)
      x6 = normalize(x6, this.array);
    this.array[index * this.itemSize] = x6;
    return this;
  }
  getY(index) {
    let y6 = this.array[index * this.itemSize + 1];
    if (this.normalized)
      y6 = denormalize(y6, this.array);
    return y6;
  }
  setY(index, y6) {
    if (this.normalized)
      y6 = normalize(y6, this.array);
    this.array[index * this.itemSize + 1] = y6;
    return this;
  }
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized)
      z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized)
      z = normalize(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    let w6 = this.array[index * this.itemSize + 3];
    if (this.normalized)
      w6 = denormalize(w6, this.array);
    return w6;
  }
  setW(index, w6) {
    if (this.normalized)
      w6 = normalize(w6, this.array);
    this.array[index * this.itemSize + 3] = w6;
    return this;
  }
  setXY(index, x6, y6) {
    index *= this.itemSize;
    if (this.normalized) {
      x6 = normalize(x6, this.array);
      y6 = normalize(y6, this.array);
    }
    this.array[index + 0] = x6;
    this.array[index + 1] = y6;
    return this;
  }
  setXYZ(index, x6, y6, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x6 = normalize(x6, this.array);
      y6 = normalize(y6, this.array);
      z = normalize(z, this.array);
    }
    this.array[index + 0] = x6;
    this.array[index + 1] = y6;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x6, y6, z, w6) {
    index *= this.itemSize;
    if (this.normalized) {
      x6 = normalize(x6, this.array);
      y6 = normalize(y6, this.array);
      z = normalize(z, this.array);
      w6 = normalize(w6, this.array);
    }
    this.array[index + 0] = x6;
    this.array[index + 1] = y6;
    this.array[index + 2] = z;
    this.array[index + 3] = w6;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id$2 = 0;
const _m1 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$1 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$7 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x6, y6, z) {
    _m1.makeTranslation(x6, y6, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x6, y6, z) {
    _m1.makeScale(x6, y6, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i6 = 0, l = points.length; i6 < l; i6++) {
      const point = points[i6];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i6 = 0, il2 = morphAttributesPosition.length; i6 < il2; i6++) {
          const morphAttribute = morphAttributesPosition[i6];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$7.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$7);
            _vector$7.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$7);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i6 = 0, il2 = morphAttributesPosition.length; i6 < il2; i6++) {
          const morphAttribute = morphAttributesPosition[i6];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$7.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$7);
            _vector$7.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$7);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i6 = 0, il2 = position.count; i6 < il2; i6++) {
        _vector$7.fromBufferAttribute(position, i6);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
      }
      if (morphAttributesPosition) {
        for (let i6 = 0, il2 = morphAttributesPosition.length; i6 < il2; i6++) {
          const morphAttribute = morphAttributesPosition[i6];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl2 = morphAttribute.count; j < jl2; j++) {
            _vector$7.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$7.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = this.getAttribute("tangent").array;
    const tan1 = [], tan2 = [];
    for (let i6 = 0; i6 < nVertices; i6++) {
      tan1[i6] = new Vector3();
      tan2[i6] = new Vector3();
    }
    const vA2 = new Vector3(), vB2 = new Vector3(), vC2 = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b6, c) {
      vA2.fromArray(positions, a * 3);
      vB2.fromArray(positions, b6 * 3);
      vC2.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b6 * 2);
      uvC.fromArray(uvs, c * 2);
      vB2.sub(vA2);
      vC2.sub(vA2);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r))
        return;
      sdir.copy(vB2).multiplyScalar(uvC.y).addScaledVector(vC2, -uvB.y).multiplyScalar(r);
      tdir.copy(vC2).multiplyScalar(uvB.x).addScaledVector(vB2, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b6].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b6].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i6 = 0, il2 = groups.length; i6 < il2; ++i6) {
      const group = groups[i6];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl2 = start + count; j < jl2; j += 3) {
        handleTriangle(
          indices[j + 0],
          indices[j + 1],
          indices[j + 2]
        );
      }
    }
    const tmp = new Vector3(), tmp2 = new Vector3();
    const n = new Vector3(), n22 = new Vector3();
    function handleVertex(v6) {
      n.fromArray(normals, v6 * 3);
      n22.copy(n);
      const t = tan1[v6];
      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp2.crossVectors(n22, t);
      const test = tmp2.dot(tan2[v6]);
      const w6 = test < 0 ? -1 : 1;
      tangents[v6 * 4] = tmp.x;
      tangents[v6 * 4 + 1] = tmp.y;
      tangents[v6 * 4 + 2] = tmp.z;
      tangents[v6 * 4 + 3] = w6;
    }
    for (let i6 = 0, il2 = groups.length; i6 < il2; ++i6) {
      const group = groups[i6];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl2 = start + count; j < jl2; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i6 = 0, il2 = normalAttribute.count; i6 < il2; i6++) {
          normalAttribute.setXYZ(i6, 0, 0, 0);
        }
      }
      const pA2 = new Vector3(), pB2 = new Vector3(), pC2 = new Vector3();
      const nA2 = new Vector3(), nB2 = new Vector3(), nC2 = new Vector3();
      const cb2 = new Vector3(), ab2 = new Vector3();
      if (index) {
        for (let i6 = 0, il2 = index.count; i6 < il2; i6 += 3) {
          const vA2 = index.getX(i6 + 0);
          const vB2 = index.getX(i6 + 1);
          const vC2 = index.getX(i6 + 2);
          pA2.fromBufferAttribute(positionAttribute, vA2);
          pB2.fromBufferAttribute(positionAttribute, vB2);
          pC2.fromBufferAttribute(positionAttribute, vC2);
          cb2.subVectors(pC2, pB2);
          ab2.subVectors(pA2, pB2);
          cb2.cross(ab2);
          nA2.fromBufferAttribute(normalAttribute, vA2);
          nB2.fromBufferAttribute(normalAttribute, vB2);
          nC2.fromBufferAttribute(normalAttribute, vC2);
          nA2.add(cb2);
          nB2.add(cb2);
          nC2.add(cb2);
          normalAttribute.setXYZ(vA2, nA2.x, nA2.y, nA2.z);
          normalAttribute.setXYZ(vB2, nB2.x, nB2.y, nB2.z);
          normalAttribute.setXYZ(vC2, nC2.x, nC2.y, nC2.z);
        }
      } else {
        for (let i6 = 0, il2 = positionAttribute.count; i6 < il2; i6 += 3) {
          pA2.fromBufferAttribute(positionAttribute, i6 + 0);
          pB2.fromBufferAttribute(positionAttribute, i6 + 1);
          pC2.fromBufferAttribute(positionAttribute, i6 + 2);
          cb2.subVectors(pC2, pB2);
          ab2.subVectors(pA2, pB2);
          cb2.cross(ab2);
          normalAttribute.setXYZ(i6 + 0, cb2.x, cb2.y, cb2.z);
          normalAttribute.setXYZ(i6 + 1, cb2.x, cb2.y, cb2.z);
          normalAttribute.setXYZ(i6 + 2, cb2.x, cb2.y, cb2.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i6 = 0, il2 = normals.count; i6 < il2; i6++) {
      _vector$7.fromBufferAttribute(normals, i6);
      _vector$7.normalize();
      normals.setXYZ(i6, _vector$7.x, _vector$7.y, _vector$7.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i6 = 0, l = indices2.length; i6 < l; i6++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i6] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i6] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i6 = 0, il2 = morphAttribute.length; i6 < il2; i6++) {
        const attribute = morphAttribute[i6];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i6 = 0, l = groups.length; i6 < l; i6++) {
      const group = groups[i6];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i6 = 0, il2 = attributeArray.length; i6 < il2; i6++) {
        const attribute = attributeArray[i6];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i6 = 0, l = morphAttribute.length; i6 < l; i6++) {
        array.push(morphAttribute[i6].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i6 = 0, l = groups.length; i6 < l; i6++) {
      const group = groups[i6];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
const _ray$3 = /* @__PURE__ */ new Ray();
const _sphere$5 = /* @__PURE__ */ new Sphere();
const _sphereHitAt = /* @__PURE__ */ new Vector3();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _uvA$1 = /* @__PURE__ */ new Vector2();
const _uvB$1 = /* @__PURE__ */ new Vector2();
const _uvC$1 = /* @__PURE__ */ new Vector2();
const _normalA = /* @__PURE__ */ new Vector3();
const _normalB = /* @__PURE__ */ new Vector3();
const _normalC = /* @__PURE__ */ new Vector3();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml2 = morphAttribute.length; m < ml2; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i6 = 0, il2 = morphPosition.length; i6 < il2; i6++) {
        const influence = morphInfluences[i6];
        const morphAttribute = morphPosition[i6];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$5.copy(geometry.boundingSphere);
    _sphere$5.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$5.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$5, _sphereHitAt) === null)
        return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2)
        return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    this._computeIntersections(raycaster, intersects, _ray$3);
  }
  _computeIntersections(raycaster, intersects, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv2 = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i6 = 0, il2 = groups.length; i6 < il2; i6++) {
          const group = groups[i6];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl2 = end; j < jl2; j += 3) {
            const a = index.getX(j);
            const b6 = index.getX(j + 1);
            const c = index.getX(j + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv2, uv1, normal, a, b6, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i6 = start, il2 = end; i6 < il2; i6 += 3) {
          const a = index.getX(i6);
          const b6 = index.getX(i6 + 1);
          const c = index.getX(i6 + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv2, uv1, normal, a, b6, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i6 / 3);
            intersects.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i6 = 0, il2 = groups.length; i6 < il2; i6++) {
          const group = groups[i6];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl2 = end; j < jl2; j += 3) {
            const a = j;
            const b6 = j + 1;
            const c = j + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv2, uv1, normal, a, b6, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i6 = start, il2 = end; i6 < il2; i6 += 3) {
          const a = i6;
          const b6 = i6 + 1;
          const c = i6 + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv2, uv1, normal, a, b6, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i6 / 3);
            intersects.push(intersection);
          }
        }
      }
    }
  }
}
function checkIntersection(object, material, raycaster, ray, pA2, pB2, pC2, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC2, pB2, pA2, true, point);
  } else {
    intersect = ray.intersectTriangle(pA2, pB2, pC2, material.side === FrontSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv2, uv1, normal, a, b6, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b6, _vB$1);
  object.getVertexPosition(c, _vC$1);
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);
      _uvB$1.fromBufferAttribute(uv2, b6);
      _uvC$1.fromBufferAttribute(uv2, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv1) {
      _uvA$1.fromBufferAttribute(uv1, a);
      _uvB$1.fromBufferAttribute(uv1, b6);
      _uvC$1.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      intersection.uv2 = intersection.uv1;
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b6);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b: b6,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v6, w6, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy3 = 0; iy3 < gridY1; iy3++) {
        const y6 = iy3 * segmentHeight - heightHalf;
        for (let ix2 = 0; ix2 < gridX1; ix2++) {
          const x6 = ix2 * segmentWidth - widthHalf;
          vector[u] = x6 * udir;
          vector[v6] = y6 * vdir;
          vector[w6] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v6] = 0;
          vector[w6] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix2 / gridX);
          uvs.push(1 - iy3 / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy3 = 0; iy3 < gridY; iy3++) {
        for (let ix2 = 0; ix2 < gridX; ix2++) {
          const a = numberOfVertices + ix2 + gridX1 * iy3;
          const b6 = numberOfVertices + ix2 + gridX1 * (iy3 + 1);
          const c = numberOfVertices + (ix2 + 1) + gridX1 * (iy3 + 1);
          const d = numberOfVertices + (ix2 + 1) + gridX1 * iy3;
          indices.push(a, b6, d);
          indices.push(b6, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p6 in src[u]) {
      const property = src[u][p6];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u][p6] = null;
        } else {
          dst[u][p6] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u][p6] = property.slice();
      } else {
        dst[u][p6] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp = cloneUniforms(uniforms[u]);
    for (const p6 in tmp) {
      merged[p6] = tmp[p6];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer2) {
  if (renderer2.getRenderTarget() === null) {
    return renderer2.outputColorSpace;
  }
  return ColorManagement.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false
      // set to use shader texture LOD
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv1": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  }
}
class Camera extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x6, y6, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x6;
    this.view.offsetY = y6;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
const fov = -90;
const aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras)
      this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer2, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer2.coordinateSystem) {
      this.coordinateSystem = renderer2.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer2.getRenderTarget();
    const currentActiveCubeFace = renderer2.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer2.getActiveMipmapLevel();
    const currentXrEnabled = renderer2.xr.enabled;
    renderer2.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer2.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer2.render(scene, cameraPX);
    renderer2.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer2.render(scene, cameraNX);
    renderer2.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer2.render(scene, cameraPY);
    renderer2.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer2.render(scene, cameraNY);
    renderer2.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer2.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer2.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer2.render(scene, cameraNZ);
    renderer2.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
    renderer2.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size2 = 1, options = {}) {
    super(size2, size2, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size2, height: size2, depth: 1 };
    const images = [image, image, image, image, image, image];
    if (options.encoding !== void 0) {
      warnOnce("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.");
      options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer2, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer2, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer2, color, depth, stencil) {
    const currentRenderTarget = renderer2.getRenderTarget();
    for (let i6 = 0; i6 < 6; i6++) {
      renderer2.setRenderTarget(this, i6);
      renderer2.clear(color, depth, stencil);
    }
    renderer2.setRenderTarget(currentRenderTarget);
  }
}
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x6, y6, z, w6) {
    this.normal.set(x6, y6, z);
    this.constant = w6;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b6, c) {
    const normal = _vector1.subVectors(c, b6).cross(_vector2.subVectors(a, b6)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$4 = /* @__PURE__ */ new Sphere();
const _vector$6 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p02 = new Plane(), p12 = new Plane(), p22 = new Plane(), p32 = new Plane(), p42 = new Plane(), p52 = new Plane()) {
    this.planes = [p02, p12, p22, p32, p42, p52];
  }
  set(p02, p12, p22, p32, p42, p52) {
    const planes = this.planes;
    planes[0].copy(p02);
    planes[1].copy(p12);
    planes[2].copy(p22);
    planes[3].copy(p32);
    planes[4].copy(p42);
    planes[5].copy(p52);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i6 = 0; i6 < 6; i6++) {
      planes[i6].copy(frustum.planes[i6]);
    }
    return this;
  }
  setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
    const planes = this.planes;
    const me2 = m.elements;
    const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
    const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
    const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
    const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem) {
      planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      planes[5].setComponents(me22, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null)
        object.computeBoundingSphere();
      _sphere$4.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$4.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSprite(sprite) {
    _sphere$4.center.set(0, 0, 0);
    _sphere$4.radius = 0.7071067811865476;
    _sphere$4.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i6 = 0; i6 < 6; i6++) {
      const distance = planes[i6].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i6 = 0; i6 < 6; i6++) {
      const plane = planes[i6];
      _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$6) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i6 = 0; i6 < 6; i6++) {
      if (planes[i6].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl2, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer2 = gl2.createBuffer();
    gl2.bindBuffer(bufferType, buffer2);
    gl2.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl2.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = gl2.HALF_FLOAT;
        } else {
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = gl2.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl2.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl2.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl2.INT;
    } else if (array instanceof Int8Array) {
      type = gl2.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl2.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl2.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer: buffer2,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer2, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl2.bindBuffer(bufferType, buffer2);
    if (updateRange.count === -1) {
      gl2.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl2.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array,
          updateRange.offset,
          updateRange.count
        );
      } else {
        gl2.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
        );
      }
      updateRange.count = -1;
    }
    attribute.onUploadCallback();
  }
  function get2(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove2(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl2.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get2,
    remove: remove2,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy3 = 0; iy3 < gridY1; iy3++) {
      const y6 = iy3 * segment_height - height_half;
      for (let ix2 = 0; ix2 < gridX1; ix2++) {
        const x6 = ix2 * segment_width - width_half;
        vertices.push(x6, -y6, 0);
        normals.push(0, 0, 1);
        uvs.push(ix2 / gridX);
        uvs.push(1 - iy3 / gridY);
      }
    }
    for (let iy3 = 0; iy3 < gridY; iy3++) {
      for (let ix2 = 0; ix2 < gridX; ix2++) {
        const a = ix2 + gridX1 * iy3;
        const b6 = ix2 + gridX1 * (iy3 + 1);
        const c = ix2 + 1 + gridX1 * (iy3 + 1);
        const d = ix2 + 1 + gridX1 * iy3;
        indices.push(a, b6, d);
        indices.push(b6, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return sRGBTransferOETF( value );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	anisotropyV /= material.anisotropy;\n	material.anisotropy = saturate( material.anisotropy );\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  }
};
const ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        specular: { value: /* @__PURE__ */ new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color(0) },
      specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = { r: 0, b: 0, g: 0 };
function WebGLBackground(renderer2, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render2(renderList2, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer2.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer2.autoClear || forceClear) {
      renderer2.clear(renderer2.autoClearColor, renderer2.autoClearDepth, renderer2.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer3, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer2.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList2.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer2.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList2.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer2));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render: render2
  };
}
function WebGLBindingStates(gl2, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(object, geometry, program, index);
      if (updateBuffers)
        saveCache(object, geometry, program, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (index !== null) {
      attributes.update(index, gl2.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl2.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl2.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl2.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i6 = 0; i6 < maxVertexAttributes; i6++) {
      newAttributes[i6] = 0;
      enabledAttributes[i6] = 0;
      attributeDivisors[i6] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i6 = 0, il2 = newAttributes.length; i6 < il2; i6++) {
      newAttributes[i6] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl2.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl2 : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i6 = 0, il2 = enabledAttributes.length; i6 < il2; i6++) {
      if (enabledAttributes[i6] !== newAttributes[i6]) {
        gl2.disableVertexAttribArray(i6);
        enabledAttributes[i6] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size2, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl2.vertexAttribIPointer(index, size2, type, stride, offset);
    } else {
      gl2.vertexAttribPointer(index, size2, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size2 = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer2 = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = capabilities.isWebGL2 === true && (type === gl2.INT || type === gl2.UNSIGNED_INT || geometryAttribute.gpuType === IntType);
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i6 = 0; i6 < programAttribute.locationSize; i6++) {
                enableAttributeAndDivisor(programAttribute.location + i6, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i6 = 0; i6 < programAttribute.locationSize; i6++) {
                enableAttribute(programAttribute.location + i6);
              }
            }
            gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer2);
            for (let i6 = 0; i6 < programAttribute.locationSize; i6++) {
              vertexAttribPointer(
                programAttribute.location + i6,
                size2 / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size2 / programAttribute.locationSize * i6) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i6 = 0; i6 < programAttribute.locationSize; i6++) {
                enableAttributeAndDivisor(programAttribute.location + i6, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i6 = 0; i6 < programAttribute.locationSize; i6++) {
                enableAttribute(programAttribute.location + i6);
              }
            }
            gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer2);
            for (let i6 = 0; i6 < programAttribute.locationSize; i6++) {
              vertexAttribPointer(
                programAttribute.location + i6,
                size2 / programAttribute.locationSize,
                type,
                normalized,
                size2 * bytesPerElement,
                size2 / programAttribute.locationSize * i6 * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl2.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl2.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl2.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl2.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl2, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render2(start, count) {
    gl2.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl2;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl2, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl2.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl2.getShaderPrecisionFormat(gl2.VERTEX_SHADER, gl2.HIGH_FLOAT).precision > 0 && gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl2.getShaderPrecisionFormat(gl2.VERTEX_SHADER, gl2.MEDIUM_FLOAT).precision > 0 && gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl2.constructor.name === "WebGL2RenderingContext";
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl2.getParameter(gl2.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl2.getParameter(gl2.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl2.getParameter(gl2.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl2.getParameter(gl2.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl2.getParameter(gl2.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl2.getParameter(gl2.MAX_SAMPLES) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i6 = 0; i6 !== lGlobal; ++i6) {
        dstArray[i6] = globalState[i6];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i6 = 0, i42 = dstOffset; i6 !== nPlanes; ++i6, i42 += 4) {
          plane.copy(planes[i6]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i42);
          dstArray[i42 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer2) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get2(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer2, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x6, y6, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x6;
    this.view.offsetY = y6;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx2 = (this.right - this.left) / (2 * this.zoom);
    const dy2 = (this.top - this.bottom) / (2 * this.zoom);
    const cx2 = (this.right + this.left) / 2;
    const cy3 = (this.top + this.bottom) / 2;
    let left = cx2 - dx2;
    let right = cx2 + dx2;
    let top = cy3 + dy2;
    let bottom = cy3 - dy2;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
}
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
class PMREMGenerator {
  constructor(renderer2) {
    this._renderer = renderer2;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null)
      this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null)
      this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null)
      this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i6 = 0; i6 < this._lodPlanes.length; i6++) {
      this._lodPlanes[i6].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer2 = this._renderer;
    const originalAutoClear = renderer2.autoClear;
    const toneMapping = renderer2.toneMapping;
    renderer2.getClearColor(_clearColor);
    renderer2.toneMapping = NoToneMapping;
    renderer2.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i6 = 0; i6 < 6; i6++) {
      const col = i6 % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i6], 0);
        cubeCamera.lookAt(forwardSign[i6], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i6]);
        cubeCamera.lookAt(0, forwardSign[i6], 0);
      } else {
        cubeCamera.up.set(0, upSign[i6], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i6]);
      }
      const size2 = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size2, i6 > 2 ? size2 : 0, size2, size2);
      renderer2.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer2.render(backgroundBox, cubeCamera);
      }
      renderer2.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer2.toneMapping = toneMapping;
    renderer2.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer2 = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size2 = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size2, 2 * size2);
    renderer2.setRenderTarget(cubeUVRenderTarget);
    renderer2.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer2 = this._renderer;
    const autoClear = renderer2.autoClear;
    renderer2.autoClear = false;
    for (let i6 = 1; i6 < this._lodPlanes.length; i6++) {
      const sigma = Math.sqrt(this._sigmas[i6] * this._sigmas[i6] - this._sigmas[i6 - 1] * this._sigmas[i6 - 1]);
      const poleAxis = _axisDirections[(i6 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i6 - 1, i6, sigma, poleAxis);
    }
    renderer2.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer2 = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i6 = 0; i6 < MAX_SAMPLES; ++i6) {
      const x7 = i6 / sigmaPixels;
      const weight = Math.exp(-x7 * x7 / 2);
      weights.push(weight);
      if (i6 === 0) {
        sum += weight;
      } else if (i6 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i6 = 0; i6 < weights.length; i6++) {
      weights[i6] = weights[i6] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x6 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y6 = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x6, y6, 3 * outputSize, 2 * outputSize);
    renderer2.setRenderTarget(targetOut);
    renderer2.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i6 = 0; i6 < totalLods; i6++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i6 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i6 - lodMax + LOD_MIN - 1];
    } else if (i6 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv2 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x6 = face % 3 * 2 / 3 - 1;
      const y6 = face > 2 ? 0 : -1;
      const coordinates = [
        x6,
        y6,
        0,
        x6 + 2 / 3,
        y6,
        0,
        x6 + 2 / 3,
        y6 + 1,
        0,
        x6,
        y6,
        0,
        x6 + 2 / 3,
        y6 + 1,
        0,
        x6,
        y6 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv2.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv2, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x6, y6, width, height) {
  target.viewport.set(x6, y6, width, height);
  target.scissor.set(x6, y6, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer2) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get2(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
          texture.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture);
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer2);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer2);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i6 = 0; i6 < length; i6++) {
      if (image[i6] !== void 0)
        count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get: get2,
    dispose
  };
}
function WebGLExtensions(gl2) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl2.getExtension("WEBGL_depth_texture") || gl2.getExtension("MOZ_WEBGL_depth_texture") || gl2.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl2.getExtension("EXT_texture_filter_anisotropic") || gl2.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl2.getExtension("WEBGL_compressed_texture_s3tc") || gl2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl2.getExtension("WEBGL_compressed_texture_pvrtc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl2.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl2, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (const name in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name];
      for (let i6 = 0, l = array.length; i6 < l; i6++) {
        attributes.remove(array[i6]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get2(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl2.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i6 = 0, l = array.length; i6 < l; i6++) {
        attributes.update(array[i6], gl2.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version2 = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version2 = geometryIndex.version;
      for (let i6 = 0, l = array.length; i6 < l; i6 += 3) {
        const a = array[i6 + 0];
        const b6 = array[i6 + 1];
        const c = array[i6 + 2];
        indices.push(a, b6, b6, c, c, a);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version2 = geometryPosition.version;
      for (let i6 = 0, l = array.length / 3 - 1; i6 < l; i6 += 3) {
        const a = i6 + 0;
        const b6 = i6 + 1;
        const c = i6 + 2;
        indices.push(a, b6, b6, c, c, a);
      }
    } else {
      return;
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version2;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get: get2,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl2, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render2(start, count) {
    gl2.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl2;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl2) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render2 = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render2.calls++;
    switch (mode) {
      case gl2.TRIANGLES:
        render2.triangles += instanceCount * (count / 3);
        break;
      case gl2.LINES:
        render2.lines += instanceCount * (count / 2);
        break;
      case gl2.LINE_STRIP:
        render2.lines += instanceCount * (count - 1);
        break;
      case gl2.LINE_LOOP:
        render2.lines += instanceCount * count;
        break;
      case gl2.POINTS:
        render2.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render2.calls = 0;
    render2.triangles = 0;
    render2.points = 0;
    render2.lines = 0;
  }
  return {
    memory,
    render: render2,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a, b6) {
  return a[0] - b6[0];
}
function absNumericalSort(a, b6) {
  return Math.abs(b6[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl2, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  const workInfluences = [];
  for (let i6 = 0; i6 < 8; i6++) {
    workInfluences[i6] = [i6, 0];
  }
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture2 = function() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture2);
        };
        var disposeTexture = disposeTexture2;
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true)
          vertexDataCount = 1;
        if (hasMorphNormals === true)
          vertexDataCount = 2;
        if (hasMorphColors === true)
          vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer2 = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(buffer2, width, height, morphTargetsCount);
        texture.type = FloatType;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i6 = 0; i6 < morphTargetsCount; i6++) {
          const morphTarget = morphTargets[i6];
          const morphNormal = morphNormals[i6];
          const morphColor = morphColors[i6];
          const offset = width * height * 4 * i6;
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              buffer2[offset + stride + 0] = morph.x;
              buffer2[offset + stride + 1] = morph.y;
              buffer2[offset + stride + 2] = morph.z;
              buffer2[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              buffer2[offset + stride + 4] = morph.x;
              buffer2[offset + stride + 5] = morph.y;
              buffer2[offset + stride + 6] = morph.z;
              buffer2[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              buffer2[offset + stride + 8] = morph.x;
              buffer2[offset + stride + 9] = morph.y;
              buffer2[offset + stride + 10] = morph.z;
              buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture2);
      }
      let morphInfluencesSum = 0;
      for (let i6 = 0; i6 < objectInfluences.length; i6++) {
        morphInfluencesSum += objectInfluences[i6];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl2, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl2, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl2, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i6 = 0; i6 < length; i6++) {
          influences[i6] = [i6, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i6 = 0; i6 < length; i6++) {
        const influence = influences[i6];
        influence[0] = i6;
        influence[1] = objectInfluences[i6];
      }
      influences.sort(absNumericalSort);
      for (let i6 = 0; i6 < 8; i6++) {
        if (i6 < length && influences[i6][1]) {
          workInfluences[i6][0] = influences[i6][0];
          workInfluences[i6][1] = influences[i6][1];
        } else {
          workInfluences[i6][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i6][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i6 = 0; i6 < 8; i6++) {
        const influence = workInfluences[i6];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i6) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i6, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i6) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i6, morphNormals[index]);
          }
          morphInfluences[i6] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i6) === true) {
            geometry.deleteAttribute("morphTarget" + i6);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i6) === true) {
            geometry.deleteAttribute("morphNormal" + i6);
          }
          morphInfluences[i6] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl2, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
}
function WebGLObjects(gl2, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl2.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl2.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
const emptyTexture = /* @__PURE__ */ new Texture();
const emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
const empty3dTexture = /* @__PURE__ */ new Data3DTexture();
const emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i6 = 1, offset = 0; i6 !== nBlocks; ++i6) {
      offset += blockSize;
      array[i6].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b6) {
  if (a.length !== b6.length)
    return false;
  for (let i6 = 0, l = a.length; i6 < l; i6++) {
    if (a[i6] !== b6[i6])
      return false;
  }
  return true;
}
function copyArray(a, b6) {
  for (let i6 = 0, l = b6.length; i6 < l; i6++) {
    a[i6] = b6[i6];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i6 = 0; i6 !== n; ++i6) {
    r[i6] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl2, v6) {
  const cache = this.cache;
  if (cache[0] === v6)
    return;
  gl2.uniform1f(this.addr, v6);
  cache[0] = v6;
}
function setValueV2f(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y) {
      gl2.uniform2f(this.addr, v6.x, v6.y);
      cache[0] = v6.x;
      cache[1] = v6.y;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform2fv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueV3f(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y || cache[2] !== v6.z) {
      gl2.uniform3f(this.addr, v6.x, v6.y, v6.z);
      cache[0] = v6.x;
      cache[1] = v6.y;
      cache[2] = v6.z;
    }
  } else if (v6.r !== void 0) {
    if (cache[0] !== v6.r || cache[1] !== v6.g || cache[2] !== v6.b) {
      gl2.uniform3f(this.addr, v6.r, v6.g, v6.b);
      cache[0] = v6.r;
      cache[1] = v6.g;
      cache[2] = v6.b;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform3fv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueV4f(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y || cache[2] !== v6.z || cache[3] !== v6.w) {
      gl2.uniform4f(this.addr, v6.x, v6.y, v6.z, v6.w);
      cache[0] = v6.x;
      cache[1] = v6.y;
      cache[2] = v6.z;
      cache[3] = v6.w;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform4fv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueM2(gl2, v6) {
  const cache = this.cache;
  const elements = v6.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniformMatrix2fv(this.addr, false, v6);
    copyArray(cache, v6);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl2.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl2, v6) {
  const cache = this.cache;
  const elements = v6.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniformMatrix3fv(this.addr, false, v6);
    copyArray(cache, v6);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl2.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl2, v6) {
  const cache = this.cache;
  const elements = v6.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniformMatrix4fv(this.addr, false, v6);
    copyArray(cache, v6);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl2.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl2, v6) {
  const cache = this.cache;
  if (cache[0] === v6)
    return;
  gl2.uniform1i(this.addr, v6);
  cache[0] = v6;
}
function setValueV2i(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y) {
      gl2.uniform2i(this.addr, v6.x, v6.y);
      cache[0] = v6.x;
      cache[1] = v6.y;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform2iv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueV3i(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y || cache[2] !== v6.z) {
      gl2.uniform3i(this.addr, v6.x, v6.y, v6.z);
      cache[0] = v6.x;
      cache[1] = v6.y;
      cache[2] = v6.z;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform3iv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueV4i(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y || cache[2] !== v6.z || cache[3] !== v6.w) {
      gl2.uniform4i(this.addr, v6.x, v6.y, v6.z, v6.w);
      cache[0] = v6.x;
      cache[1] = v6.y;
      cache[2] = v6.z;
      cache[3] = v6.w;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform4iv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueV1ui(gl2, v6) {
  const cache = this.cache;
  if (cache[0] === v6)
    return;
  gl2.uniform1ui(this.addr, v6);
  cache[0] = v6;
}
function setValueV2ui(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y) {
      gl2.uniform2ui(this.addr, v6.x, v6.y);
      cache[0] = v6.x;
      cache[1] = v6.y;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform2uiv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueV3ui(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y || cache[2] !== v6.z) {
      gl2.uniform3ui(this.addr, v6.x, v6.y, v6.z);
      cache[0] = v6.x;
      cache[1] = v6.y;
      cache[2] = v6.z;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform3uiv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueV4ui(gl2, v6) {
  const cache = this.cache;
  if (v6.x !== void 0) {
    if (cache[0] !== v6.x || cache[1] !== v6.y || cache[2] !== v6.z || cache[3] !== v6.w) {
      gl2.uniform4ui(this.addr, v6.x, v6.y, v6.z, v6.w);
      cache[0] = v6.x;
      cache[1] = v6.y;
      cache[2] = v6.z;
      cache[3] = v6.w;
    }
  } else {
    if (arraysEqual(cache, v6))
      return;
    gl2.uniform4uiv(this.addr, v6);
    copyArray(cache, v6);
  }
}
function setValueT1(gl2, v6, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2D(v6 || emptyTexture, unit);
}
function setValueT3D1(gl2, v6, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v6 || empty3dTexture, unit);
}
function setValueT6(gl2, v6, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v6 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl2, v6, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v6 || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl2, v6) {
  gl2.uniform1fv(this.addr, v6);
}
function setValueV2fArray(gl2, v6) {
  const data = flatten(v6, this.size, 2);
  gl2.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl2, v6) {
  const data = flatten(v6, this.size, 3);
  gl2.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl2, v6) {
  const data = flatten(v6, this.size, 4);
  gl2.uniform4fv(this.addr, data);
}
function setValueM2Array(gl2, v6) {
  const data = flatten(v6, this.size, 4);
  gl2.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl2, v6) {
  const data = flatten(v6, this.size, 9);
  gl2.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl2, v6) {
  const data = flatten(v6, this.size, 16);
  gl2.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl2, v6) {
  gl2.uniform1iv(this.addr, v6);
}
function setValueV2iArray(gl2, v6) {
  gl2.uniform2iv(this.addr, v6);
}
function setValueV3iArray(gl2, v6) {
  gl2.uniform3iv(this.addr, v6);
}
function setValueV4iArray(gl2, v6) {
  gl2.uniform4iv(this.addr, v6);
}
function setValueV1uiArray(gl2, v6) {
  gl2.uniform1uiv(this.addr, v6);
}
function setValueV2uiArray(gl2, v6) {
  gl2.uniform2uiv(this.addr, v6);
}
function setValueV3uiArray(gl2, v6) {
  gl2.uniform3uiv(this.addr, v6);
}
function setValueV4uiArray(gl2, v6) {
  gl2.uniform4uiv(this.addr, v6);
}
function setValueT1Array(gl2, v6, textures) {
  const cache = this.cache;
  const n = v6.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl2.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i6 = 0; i6 !== n; ++i6) {
    textures.setTexture2D(v6[i6] || emptyTexture, units[i6]);
  }
}
function setValueT3DArray(gl2, v6, textures) {
  const cache = this.cache;
  const n = v6.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl2.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i6 = 0; i6 !== n; ++i6) {
    textures.setTexture3D(v6[i6] || empty3dTexture, units[i6]);
  }
}
function setValueT6Array(gl2, v6, textures) {
  const cache = this.cache;
  const n = v6.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl2.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i6 = 0; i6 !== n; ++i6) {
    textures.setTextureCube(v6[i6] || emptyCubeTexture, units[i6]);
  }
}
function setValueT2DArrayArray(gl2, v6, textures) {
  const cache = this.cache;
  const n = v6.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl2.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i6 = 0; i6 !== n; ++i6) {
    textures.setTexture2DArray(v6[i6] || emptyArrayTexture, units[i6]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(id2, activeInfo, addr) {
    this.id = id2;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
}
class PureArrayUniform {
  constructor(id2, activeInfo, addr) {
    this.id = id2;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
}
class StructuredUniform {
  constructor(id2) {
    this.id = id2;
    this.seq = [];
    this.map = {};
  }
  setValue(gl2, value, textures) {
    const seq = this.seq;
    for (let i6 = 0, n = seq.length; i6 !== n; ++i6) {
      const u = seq[i6];
      u.setValue(gl2, value[u.id], textures);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id2 = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id2 = id2 | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id2];
      if (next === void 0) {
        next = new StructuredUniform(id2);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
class WebGLUniforms {
  constructor(gl2, program) {
    this.seq = [];
    this.map = {};
    const n = gl2.getProgramParameter(program, gl2.ACTIVE_UNIFORMS);
    for (let i6 = 0; i6 < n; ++i6) {
      const info = gl2.getActiveUniform(program, i6), addr = gl2.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl2, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0)
      u.setValue(gl2, value, textures);
  }
  setOptional(gl2, object, name) {
    const v6 = object[name];
    if (v6 !== void 0)
      this.setValue(gl2, name, v6);
  }
  static upload(gl2, seq, values, textures) {
    for (let i6 = 0, n = seq.length; i6 !== n; ++i6) {
      const u = seq[i6], v6 = values[u.id];
      if (v6.needsUpdate !== false) {
        u.setValue(gl2, v6.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r = [];
    for (let i6 = 0, n = seq.length; i6 !== n; ++i6) {
      const u = seq[i6];
      if (u.id in values)
        r.push(u);
    }
    return r;
  }
}
function WebGLShader(gl2, type, string) {
  const shader = gl2.createShader(type);
  gl2.shaderSource(shader, string);
  gl2.compileShader(shader);
  return shader;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to2 = Math.min(errorLine + 6, lines.length);
  for (let i6 = from; i6 < to2; i6++) {
    const line = i6 + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i6]}`);
  }
  return lines2.join("\n");
}
function getEncodingComponents(colorSpace) {
  const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
  const encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
  let gamutMapping;
  if (workingPrimaries === encodingPrimaries) {
    gamutMapping = "";
  } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
    gamutMapping = "LinearDisplayP3ToLinearSRGB";
  } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
    gamutMapping = "LinearSRGBToLinearDisplayP3";
  }
  switch (colorSpace) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
      return [gamutMapping, "LinearTransferOETF"];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
      return [gamutMapping, "sRGBTransferOETF"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
      return [gamutMapping, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl2, shader, type) {
  const status = gl2.getShaderParameter(shader, gl2.COMPILE_STATUS);
  const errors = gl2.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl2.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`;
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl2, program) {
  const attributes = {};
  const n = gl2.getProgramParameter(program, gl2.ACTIVE_ATTRIBUTES);
  for (let i6 = 0; i6 < n; i6++) {
    const info = gl2.getActiveAttrib(program, i6);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl2.FLOAT_MAT2)
      locationSize = 2;
    if (info.type === gl2.FLOAT_MAT3)
      locationSize = 3;
    if (info.type === gl2.FLOAT_MAT4)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl2.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
const shaderChunkMap = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function includeReplacer(match, include) {
  let string = ShaderChunk[include];
  if (string === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
}
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i6 = parseInt(start); i6 < parseInt(end); i6++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i6 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i6);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer2, cacheKey, parameters, bindingStates) {
  const gl2 = renderer2.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl2.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "precision mediump sampler2DArray;",
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl2, gl2.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl2, gl2.FRAGMENT_SHADER, fragmentGlsl);
  gl2.attachShader(program, glVertexShader);
  gl2.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl2.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl2.bindAttribLocation(program, 0, "position");
  }
  gl2.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer2.debug.checkShaderErrors) {
      const programLog = gl2.getProgramInfoLog(program).trim();
      const vertexLog = gl2.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl2.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl2.getProgramParameter(program, gl2.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer2.debug.onShaderError === "function") {
          renderer2.debug.onShaderError(gl2, program, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = getShaderErrors(gl2, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl2, glFragmentShader, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + gl2.getError() + " - VALIDATE_STATUS " + gl2.getProgramParameter(program, gl2.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl2.deleteShader(glVertexShader);
    gl2.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl2, program);
    cachedAttributes = fetchAttributeLocations(gl2, program);
  }
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function() {
    if (programReady === false) {
      programReady = gl2.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl2.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
let _id$1 = 0;
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0)
        this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    let set2 = cache.get(material);
    if (set2 === void 0) {
      set2 = /* @__PURE__ */ new Set();
      cache.set(material, set2);
    }
    return set2;
  }
  _getShaderStage(code2) {
    const cache = this.shaderCache;
    let stage = cache.get(code2);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code2);
      cache.set(code2, stage);
    }
    return stage;
  }
}
class WebGLShaderStage {
  constructor(code2) {
    this.id = _id$1++;
    this.code = code2;
    this.usedTimes = 0;
  }
}
function WebGLPrograms(renderer2, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const programs = [];
  const IS_WEBGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    if (value === 0)
      return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0)
      morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0)
      morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0)
      morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer2.getRenderTarget();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    const HAS_ATTRIBUTE_UV1 = !!geometry.attributes.uv1;
    const HAS_ATTRIBUTE_UV2 = !!geometry.attributes.uv2;
    const HAS_ATTRIBUTE_UV3 = !!geometry.attributes.uv3;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer2.toneMapping;
      }
    }
    const parameters = {
      isWebGL2: IS_WEBGL2,
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer2.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUv1s: HAS_ATTRIBUTE_UV1,
      vertexUv2s: HAS_ATTRIBUTE_UV2,
      vertexUv3s: HAS_ATTRIBUTE_UV3,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer2.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer2.shadowMap.type,
      toneMapping,
      useLegacyLights: renderer2._useLegacyLights,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: HAS_EXTENSIONS && material.extensions.derivatives === true,
      extensionFragDepth: HAS_EXTENSIONS && material.extensions.fragDepth === true,
      extensionDrawBuffers: HAS_EXTENSIONS && material.extensions.drawBuffers === true,
      extensionShaderTextureLOD: HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,
      rendererExtensionFragDepth: IS_WEBGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: IS_WEBGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: IS_WEBGL2 || extensions.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer2.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2)
      _programLayers.enable(0);
    if (parameters.supportsVertexTextures)
      _programLayers.enable(1);
    if (parameters.instancing)
      _programLayers.enable(2);
    if (parameters.instancingColor)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    if (parameters.alphaHash)
      _programLayers.enable(18);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.skinning)
      _programLayers.enable(4);
    if (parameters.morphTargets)
      _programLayers.enable(5);
    if (parameters.morphNormals)
      _programLayers.enable(6);
    if (parameters.morphColors)
      _programLayers.enable(7);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(8);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(9);
    if (parameters.useLegacyLights)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p6 = 0, pl2 = programs.length; p6 < pl2; p6++) {
      const preexistingProgram = programs[p6];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer2, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i6 = programs.indexOf(program);
      programs[i6] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get2(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove2(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    remove: remove2,
    update,
    dispose
  };
}
function painterSortStable(a, b6) {
  if (a.groupOrder !== b6.groupOrder) {
    return a.groupOrder - b6.groupOrder;
  } else if (a.renderOrder !== b6.renderOrder) {
    return a.renderOrder - b6.renderOrder;
  } else if (a.material.id !== b6.material.id) {
    return a.material.id - b6.material.id;
  } else if (a.z !== b6.z) {
    return a.z - b6.z;
  } else {
    return a.id - b6.id;
  }
}
function reversePainterSortStable(a, b6) {
  if (a.groupOrder !== b6.groupOrder) {
    return a.groupOrder - b6.groupOrder;
  } else if (a.renderOrder !== b6.renderOrder) {
    return a.renderOrder - b6.renderOrder;
  } else if (a.z !== b6.z) {
    return b6.z - a.z;
  } else {
    return a.id - b6.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i6 = renderItemsIndex, il2 = renderItems.length; i6 < il2; i6++) {
      const renderItem = renderItems[i6];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get2(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let i6 = 0; i6 < 9; i6++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, useLegacyLights) {
    let r = 0, g6 = 0, b6 = 0;
    for (let i6 = 0; i6 < 9; i6++)
      state.probe[i6].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    const scaleFactor = useLegacyLights === true ? Math.PI : 1;
    for (let i6 = 0, l = lights.length; i6 < l; i6++) {
      const light = lights[i6];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity * scaleFactor;
        g6 += color.g * intensity * scaleFactor;
        b6 += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow)
            numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g6;
    state.ambient[2] = b6;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i6 = 0, l = lights.length; i6 < l; i6++) {
      const light = lights[i6];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(useLegacyLights) {
    lights.setup(lightsArray, useLegacyLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get2(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: get2,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i6 = 0, il2 = lights.length; i6 < il2; i6++) {
      const light = lights[i6];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp2 = 0; vp2 < viewportCount; vp2++) {
        const viewport = shadow.getViewport(vp2);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp2);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = _renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k7 = 0, kl2 = groups.length; k7 < kl2; k7++) {
            const group = groups[k7];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i6 = 0, l = children.length; i6 < l; i6++) {
      renderObject(children[i6], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl2, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl2.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g6, b6, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g6 *= a;
          b6 *= a;
        }
        color.set(r, g6, b6, a);
        if (currentColorClear.equals(color) === false) {
          gl2.clearColor(r, g6, b6, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl2.DEPTH_TEST);
        } else {
          disable(gl2.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl2.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl2.depthFunc(gl2.NEVER);
              break;
            case AlwaysDepth:
              gl2.depthFunc(gl2.ALWAYS);
              break;
            case LessDepth:
              gl2.depthFunc(gl2.LESS);
              break;
            case LessEqualDepth:
              gl2.depthFunc(gl2.LEQUAL);
              break;
            case EqualDepth:
              gl2.depthFunc(gl2.EQUAL);
              break;
            case GreaterEqualDepth:
              gl2.depthFunc(gl2.GEQUAL);
              break;
            case GreaterDepth:
              gl2.depthFunc(gl2.GREATER);
              break;
            case NotEqualDepth:
              gl2.depthFunc(gl2.NOTEQUAL);
              break;
            default:
              gl2.depthFunc(gl2.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl2.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl2.STENCIL_TEST);
          } else {
            disable(gl2.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl2.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl2.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl2.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl2.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl2.getParameter(gl2.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version2 = 0;
  const glVersion = gl2.getParameter(gl2.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version2 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version2 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl2.getParameter(gl2.SCISSOR_BOX);
  const viewportParam = gl2.getParameter(gl2.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl2.createTexture();
    gl2.bindTexture(type, texture);
    gl2.texParameteri(type, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
    gl2.texParameteri(type, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
    for (let i6 = 0; i6 < count; i6++) {
      if (isWebGL2 && (type === gl2.TEXTURE_3D || type === gl2.TEXTURE_2D_ARRAY)) {
        gl2.texImage3D(target, 0, gl2.RGBA, 1, 1, dimensions, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
      } else {
        gl2.texImage2D(target + i6, 0, gl2.RGBA, 1, 1, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl2.TEXTURE_2D] = createTexture(gl2.TEXTURE_2D, gl2.TEXTURE_2D, 1);
  emptyTextures[gl2.TEXTURE_CUBE_MAP] = createTexture(gl2.TEXTURE_CUBE_MAP, gl2.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  if (isWebGL2) {
    emptyTextures[gl2.TEXTURE_2D_ARRAY] = createTexture(gl2.TEXTURE_2D_ARRAY, gl2.TEXTURE_2D_ARRAY, 1, 1);
    emptyTextures[gl2.TEXTURE_3D] = createTexture(gl2.TEXTURE_3D, gl2.TEXTURE_3D, 1, 1);
  }
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl2.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl2.CULL_FACE);
  setBlending(NoBlending);
  function enable(id2) {
    if (enabledCapabilities[id2] !== true) {
      gl2.enable(id2);
      enabledCapabilities[id2] = true;
    }
  }
  function disable(id2) {
    if (enabledCapabilities[id2] !== false) {
      gl2.disable(id2);
      enabledCapabilities[id2] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl2.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === gl2.DRAW_FRAMEBUFFER) {
          currentBoundFramebuffers[gl2.FRAMEBUFFER] = framebuffer;
        }
        if (target === gl2.FRAMEBUFFER) {
          currentBoundFramebuffers[gl2.DRAW_FRAMEBUFFER] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures = renderTarget.texture;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl2.COLOR_ATTACHMENT0) {
          for (let i6 = 0, il2 = textures.length; i6 < il2; i6++) {
            drawBuffers2[i6] = gl2.COLOR_ATTACHMENT0 + i6;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== gl2.COLOR_ATTACHMENT0) {
          drawBuffers2[0] = gl2.COLOR_ATTACHMENT0;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers2[0] !== gl2.BACK) {
        drawBuffers2[0] = gl2.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl2.drawBuffers(drawBuffers2);
      } else {
        extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl2.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl2.FUNC_ADD,
    [SubtractEquation]: gl2.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl2.FUNC_REVERSE_SUBTRACT
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = gl2.MIN;
    equationToGL[MaxEquation] = gl2.MAX;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: gl2.ZERO,
    [OneFactor]: gl2.ONE,
    [SrcColorFactor]: gl2.SRC_COLOR,
    [SrcAlphaFactor]: gl2.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl2.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl2.DST_COLOR,
    [DstAlphaFactor]: gl2.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl2.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl2.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl2.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl2.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl2.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl2.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl2.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl2.ONE_MINUS_CONSTANT_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl2.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl2.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl2.blendEquation(gl2.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl2.blendFuncSeparate(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl2.blendFunc(gl2.ONE, gl2.ONE);
              break;
            case SubtractiveBlending:
              gl2.blendFuncSeparate(gl2.ZERO, gl2.ONE_MINUS_SRC_COLOR, gl2.ZERO, gl2.ONE);
              break;
            case MultiplyBlending:
              gl2.blendFuncSeparate(gl2.ZERO, gl2.SRC_COLOR, gl2.ZERO, gl2.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl2.blendFuncSeparate(gl2.SRC_ALPHA, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl2.blendFunc(gl2.SRC_ALPHA, gl2.ONE);
              break;
            case SubtractiveBlending:
              gl2.blendFuncSeparate(gl2.ZERO, gl2.ONE_MINUS_SRC_COLOR, gl2.ZERO, gl2.ONE);
              break;
            case MultiplyBlending:
              gl2.blendFunc(gl2.ZERO, gl2.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl2.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl2.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl2.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl2.CULL_FACE) : enable(gl2.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl2.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl2.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl2.frontFace(gl2.CW);
      } else {
        gl2.frontFace(gl2.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl2.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl2.cullFace(gl2.BACK);
        } else if (cullFace === CullFaceFront) {
          gl2.cullFace(gl2.FRONT);
        } else {
          gl2.cullFace(gl2.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl2.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl2.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl2.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl2.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl2.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl2.SCISSOR_TEST);
    } else {
      disable(gl2.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = gl2.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl2.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl2.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl2.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl2.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl2.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl2.compressedTexImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl2.compressedTexImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl2.texSubImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl2.texSubImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl2.compressedTexSubImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl2.compressedTexSubImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl2.texStorage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl2.texStorage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl2.texImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl2.texImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl2.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl2.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl2.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl2.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl2.disable(gl2.BLEND);
    gl2.disable(gl2.CULL_FACE);
    gl2.disable(gl2.DEPTH_TEST);
    gl2.disable(gl2.POLYGON_OFFSET_FILL);
    gl2.disable(gl2.SCISSOR_TEST);
    gl2.disable(gl2.STENCIL_TEST);
    gl2.disable(gl2.SAMPLE_ALPHA_TO_COVERAGE);
    gl2.blendEquation(gl2.FUNC_ADD);
    gl2.blendFunc(gl2.ONE, gl2.ZERO);
    gl2.blendFuncSeparate(gl2.ONE, gl2.ZERO, gl2.ONE, gl2.ZERO);
    gl2.blendColor(0, 0, 0, 0);
    gl2.colorMask(true, true, true, true);
    gl2.clearColor(0, 0, 0, 0);
    gl2.depthMask(true);
    gl2.depthFunc(gl2.LESS);
    gl2.clearDepth(1);
    gl2.stencilMask(4294967295);
    gl2.stencilFunc(gl2.ALWAYS, 0, 4294967295);
    gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.KEEP);
    gl2.clearStencil(0);
    gl2.cullFace(gl2.BACK);
    gl2.frontFace(gl2.CCW);
    gl2.polygonOffset(0, 0);
    gl2.activeTexture(gl2.TEXTURE0);
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
    if (isWebGL2 === true) {
      gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, null);
      gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, null);
    }
    gl2.useProgram(null);
    gl2.lineWidth(1);
    gl2.scissor(0, 0, gl2.canvas.width, gl2.canvas.height);
    gl2.viewport(0, 0, gl2.canvas.width, gl2.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl2.canvas.width, gl2.canvas.height);
    currentViewport.set(0, 0, gl2.canvas.width, gl2.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(width, height)
    ) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT)
        internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT)
        internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE)
        internalFormat = _gl.R8I;
      if (glType === _gl.SHORT)
        internalFormat = _gl.R16I;
      if (glType === _gl.INT)
        internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT)
        internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4)
        internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1)
        internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i6 = 0; i6 < 6; i6++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i6])) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i6].length; level++)
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i6][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i6]);
        }
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i6]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++)
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i6 = 0; i6 < renderTargetProperties.__webglColorRenderbuffer.length; i6++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i6])
            _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i6]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i6 = 0, il2 = texture.length; i6 < il2; i6++) {
        const attachmentProperties = properties.get(texture[i6]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i6]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.magFilter === NearestFilter)
        return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter)
        return;
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture)
      textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture)
      textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.colorSpace);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const levels = getMipLevels(texture, image, supportsMips);
      if (texture.isDepthTexture) {
        glInternalFormat = _gl.DEPTH_COMPONENT;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = _gl.DEPTH24_STENCIL8;
          } else {
            glInternalFormat = _gl.DEPTH_COMPONENT16;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedIntType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
          glInternalFormat = _gl.DEPTH_STENCIL;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i6 = 0, il2 = mipmaps.length; i6 < il2; i6++) {
            mipmap = mipmaps[i6];
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_2D, i6, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i6, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i6 = 0, il2 = mipmaps.length; i6 < il2; i6++) {
            mipmap = mipmaps[i6];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i6, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i6, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i6, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i6, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i6 = 0, il2 = mipmaps.length; i6 < il2; i6++) {
            mipmap = mipmaps[i6];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(_gl.TEXTURE_2D, i6, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i6, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_2D, i6, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i6, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i6 = 0; i6 < levels; i6++) {
              state.texImage2D(_gl.TEXTURE_2D, i6, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i6 = 0, il2 = mipmaps.length; i6 < il2; i6++) {
            mipmap = mipmaps[i6];
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_2D, i6, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i6, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i6 = 0; i6 < 6; i6++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i6] = resizeImage(texture.image[i6], false, true, maxCubemapSize);
        } else {
          cubeImage[i6] = isDataTexture ? texture.image[i6].image : texture.image[i6];
        }
        cubeImage[i6] = verifyColorSpace(texture, cubeImage[i6]);
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      let levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i6 = 0; i6 < 6; i6++) {
          mipmaps = cubeImage[i6].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0)
            levels++;
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i6 = 0; i6 < 6; i6++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, 0, 0, 0, cubeImage[i6].width, cubeImage[i6].height, glFormat, glType, cubeImage[i6].data);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, 0, glInternalFormat, cubeImage[i6].width, cubeImage[i6].height, 0, glFormat, glType, cubeImage[i6].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i6].image;
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, 0, 0, 0, glFormat, glType, cubeImage[i6]);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, 0, glInternalFormat, glFormat, glType, cubeImage[i6]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j + 1, 0, 0, glFormat, glType, mipmap.image[i6]);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i6]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = isWebGL2 === true ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i6 = 0; i6 < textures.length; i6++) {
        const texture = textures[i6];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i6 = 0; i6 < 6; i6++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i6]);
          renderTargetProperties.__webglDepthbuffer[i6] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i6], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i6 = 0; i6 < 6; i6++) {
        if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i6] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i6][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i6] = _gl.createFramebuffer();
        }
      }
    } else {
      if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i6 = 0, il2 = textures.length; i6 < il2; i6++) {
            const attachmentProperties = properties.get(textures[i6]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      }
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const textures = isMultipleRenderTargets ? texture : [texture];
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i6 = 0; i6 < textures.length; i6++) {
          const texture2 = textures[i6];
          renderTargetProperties.__webglColorRenderbuffer[i6] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i6]);
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i6, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i6]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      for (let i6 = 0; i6 < 6; i6++) {
        if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i6][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i6], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i6, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i6 = 0, il2 = textures.length; i6 < il2; i6++) {
        const attachment = textures[i6];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i6, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
        } else {
          console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i6 = 0, il2 = textures.length; i6 < il2; i6++) {
      const texture = textures[i6];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
      const width = renderTarget.width;
      const height = renderTarget.height;
      let mask = _gl.COLOR_BUFFER_BIT;
      const invalidationArray = [];
      const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const renderTargetProperties = properties.get(renderTarget);
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      if (isMultipleRenderTargets) {
        for (let i6 = 0; i6 < textures.length; i6++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i6, _gl.RENDERBUFFER, null);
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i6, _gl.TEXTURE_2D, null, 0);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
      for (let i6 = 0; i6 < textures.length; i6++) {
        invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i6);
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
        if (ignoreDepthValues === false) {
          if (renderTarget.depthBuffer)
            mask |= _gl.DEPTH_BUFFER_BIT;
          if (renderTarget.stencilBuffer)
            mask |= _gl.STENCIL_BUFFER_BIT;
        }
        if (isMultipleRenderTargets) {
          _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i6]);
        }
        if (ignoreDepthValues === true) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
        if (isMultipleRenderTargets) {
          const webglTexture = properties.get(textures[i6]).__webglTexture;
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
        }
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
        if (supportsInvalidateFramebuffer) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      if (isMultipleRenderTargets) {
        for (let i6 = 0; i6 < textures.length; i6++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i6, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i6]);
          const webglTexture = properties.get(textures[i6]).__webglTexture;
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i6, _gl.TEXTURE_2D, webglTexture, 0);
        }
      }
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
      return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        if (isWebGL2 === false) {
          if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
            texture.format = _SRGBAFormat;
            texture.minFilter = LinearFilter;
            texture.generateMipmaps = false;
          } else {
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl2, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p6, colorSpace = NoColorSpace) {
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p6 === UnsignedByteType)
      return gl2.UNSIGNED_BYTE;
    if (p6 === UnsignedShort4444Type)
      return gl2.UNSIGNED_SHORT_4_4_4_4;
    if (p6 === UnsignedShort5551Type)
      return gl2.UNSIGNED_SHORT_5_5_5_1;
    if (p6 === ByteType)
      return gl2.BYTE;
    if (p6 === ShortType)
      return gl2.SHORT;
    if (p6 === UnsignedShortType)
      return gl2.UNSIGNED_SHORT;
    if (p6 === IntType)
      return gl2.INT;
    if (p6 === UnsignedIntType)
      return gl2.UNSIGNED_INT;
    if (p6 === FloatType)
      return gl2.FLOAT;
    if (p6 === HalfFloatType) {
      if (isWebGL2)
        return gl2.HALF_FLOAT;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p6 === AlphaFormat)
      return gl2.ALPHA;
    if (p6 === RGBAFormat)
      return gl2.RGBA;
    if (p6 === LuminanceFormat)
      return gl2.LUMINANCE;
    if (p6 === LuminanceAlphaFormat)
      return gl2.LUMINANCE_ALPHA;
    if (p6 === DepthFormat)
      return gl2.DEPTH_COMPONENT;
    if (p6 === DepthStencilFormat)
      return gl2.DEPTH_STENCIL;
    if (p6 === _SRGBAFormat) {
      extension = extensions.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p6 === RedFormat)
      return gl2.RED;
    if (p6 === RedIntegerFormat)
      return gl2.RED_INTEGER;
    if (p6 === RGFormat)
      return gl2.RG;
    if (p6 === RGIntegerFormat)
      return gl2.RG_INTEGER;
    if (p6 === RGBAIntegerFormat)
      return gl2.RGBA_INTEGER;
    if (p6 === RGB_S3TC_DXT1_Format || p6 === RGBA_S3TC_DXT1_Format || p6 === RGBA_S3TC_DXT3_Format || p6 === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p6 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p6 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p6 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p6 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p6 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p6 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p6 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p6 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p6 === RGB_PVRTC_4BPPV1_Format || p6 === RGB_PVRTC_2BPPV1_Format || p6 === RGBA_PVRTC_4BPPV1_Format || p6 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p6 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p6 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p6 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p6 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p6 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p6 === RGB_ETC2_Format || p6 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p6 === RGB_ETC2_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p6 === RGBA_ETC2_EAC_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p6 === RGBA_ASTC_4x4_Format || p6 === RGBA_ASTC_5x4_Format || p6 === RGBA_ASTC_5x5_Format || p6 === RGBA_ASTC_6x5_Format || p6 === RGBA_ASTC_6x6_Format || p6 === RGBA_ASTC_8x5_Format || p6 === RGBA_ASTC_8x6_Format || p6 === RGBA_ASTC_8x8_Format || p6 === RGBA_ASTC_10x5_Format || p6 === RGBA_ASTC_10x6_Format || p6 === RGBA_ASTC_10x8_Format || p6 === RGBA_ASTC_10x10_Format || p6 === RGBA_ASTC_12x10_Format || p6 === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p6 === RGBA_ASTC_4x4_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p6 === RGBA_ASTC_5x4_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p6 === RGBA_ASTC_5x5_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p6 === RGBA_ASTC_6x5_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p6 === RGBA_ASTC_6x6_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p6 === RGBA_ASTC_8x5_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p6 === RGBA_ASTC_8x6_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p6 === RGBA_ASTC_8x8_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p6 === RGBA_ASTC_10x5_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p6 === RGBA_ASTC_10x6_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p6 === RGBA_ASTC_10x8_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p6 === RGBA_ASTC_10x10_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p6 === RGBA_ASTC_12x10_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p6 === RGBA_ASTC_12x12_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p6 === RGBA_BPTC_Format || p6 === RGB_BPTC_SIGNED_Format || p6 === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p6 === RGBA_BPTC_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p6 === RGB_BPTC_SIGNED_Format)
          return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p6 === RGB_BPTC_UNSIGNED_Format)
          return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p6 === RED_RGTC1_Format || p6 === SIGNED_RED_RGTC1_Format || p6 === RED_GREEN_RGTC2_Format || p6 === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p6 === RGBA_BPTC_Format)
          return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p6 === SIGNED_RED_RGTC1_Format)
          return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p6 === RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p6 === SIGNED_RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p6 === UnsignedInt248Type) {
      if (isWebGL2)
        return gl2.UNSIGNED_INT_24_8;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
    return gl2[p6] !== void 0 ? gl2[p6] : null;
  }
  return { convert };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
}
class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  // private method
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
}
class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null)
      data.compareFunction = this.compareFunction;
    return data;
  }
}
class WebXRManager extends EventDispatcher {
  constructor(renderer2, gl2) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const attributes = gl2.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    cameraXR.layers.enable(1);
    cameraXR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i6 = 0; i6 < controllers.length; i6++) {
        const inputSource = controllerInputSources[i6];
        if (inputSource === null)
          continue;
        controllerInputSources[i6] = null;
        controllers[i6].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer2.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer2.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl2.makeXRCompatible();
        }
        if (session.renderState.layers === void 0 || renderer2.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl2, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              colorSpace: renderer2.outputColorSpace,
              stencilBuffer: attributes.stencil
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl2.DEPTH24_STENCIL8 : gl2.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl2.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl2);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer2.outputColorSpace,
              samples: attributes.antialias ? 4 : 0
            }
          );
          const renderTargetProperties = renderer2.properties.get(newRenderTarget);
          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    function onInputSourcesChange(event) {
      for (let i6 = 0; i6 < event.removed.length; i6++) {
        const inputSource = event.removed[i6];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }
      for (let i6 = 0; i6 < event.added.length; i6++) {
        const inputSource = event.added[i6];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i7 = 0; i7 < controllers.length; i7++) {
            if (i7 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i7;
              break;
            } else if (controllerInputSources[i7] === null) {
              controllerInputSources[i7] = inputSource;
              controllerIndex = i7;
              break;
            }
          }
          if (controllerIndex === -1)
            break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null)
        return;
      cameraXR.near = cameraR.near = cameraL.near = camera.near;
      cameraXR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i6 = 0; i6 < cameras2.length; i6++) {
        updateCamera(cameras2[i6], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function() {
      return cameraXR;
    };
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer2.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer2.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i6 = 0; i6 < views.length; i6++) {
          const view = views[i6];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i6 === 0) {
              renderer2.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer2.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i6];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i6);
            camera.viewport = new Vector4();
            cameras[i6] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i6 === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
      }
      for (let i6 = 0; i6 < controllers.length; i6++) {
        const inputSource = controllerInputSources[i6];
        const controller = controllers[i6];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
function WebGLMaterials(renderer2, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer2));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      const scaleFactor = renderer2._useLegacyLights === true ? Math.PI : 1;
      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl2, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = capabilities.isWebGL2 ? gl2.getParameter(gl2.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer2 = buffers[uniformsGroup.id];
    if (buffer2 === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer2 = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer2;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer2 = gl2.createBuffer();
    const size2 = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl2.bindBuffer(gl2.UNIFORM_BUFFER, buffer2);
    gl2.bufferData(gl2.UNIFORM_BUFFER, size2, usage);
    gl2.bindBuffer(gl2.UNIFORM_BUFFER, null);
    gl2.bindBufferBase(gl2.UNIFORM_BUFFER, bindingPointIndex, buffer2);
    return buffer2;
  }
  function allocateBindingPointIndex() {
    for (let i6 = 0; i6 < maxBindingPoints; i6++) {
      if (allocatedBindingPoints.indexOf(i6) === -1) {
        allocatedBindingPoints.push(i6);
        return i6;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer2 = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl2.bindBuffer(gl2.UNIFORM_BUFFER, buffer2);
    for (let i6 = 0, il2 = uniforms.length; i6 < il2; i6++) {
      const uniform = uniforms[i6];
      if (hasUniformChanged(uniform, i6, cache) === true) {
        const offset = uniform.__offset;
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        let arrayOffset = 0;
        for (let i7 = 0; i7 < values.length; i7++) {
          const value = values[i7];
          const info2 = getUniformSize(value);
          if (typeof value === "number") {
            uniform.__data[0] = value;
            gl2.bufferSubData(gl2.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
          } else if (value.isMatrix3) {
            uniform.__data[0] = value.elements[0];
            uniform.__data[1] = value.elements[1];
            uniform.__data[2] = value.elements[2];
            uniform.__data[3] = value.elements[0];
            uniform.__data[4] = value.elements[3];
            uniform.__data[5] = value.elements[4];
            uniform.__data[6] = value.elements[5];
            uniform.__data[7] = value.elements[0];
            uniform.__data[8] = value.elements[6];
            uniform.__data[9] = value.elements[7];
            uniform.__data[10] = value.elements[8];
            uniform.__data[11] = value.elements[0];
          } else {
            value.toArray(uniform.__data, arrayOffset);
            arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
          }
        }
        gl2.bufferSubData(gl2.UNIFORM_BUFFER, offset, uniform.__data);
      }
    }
    gl2.bindBuffer(gl2.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, cache) {
    const value = uniform.value;
    if (cache[index] === void 0) {
      if (typeof value === "number") {
        cache[index] = value;
      } else {
        const values = Array.isArray(value) ? value : [value];
        const tempValues = [];
        for (let i6 = 0; i6 < values.length; i6++) {
          tempValues.push(values[i6].clone());
        }
        cache[index] = tempValues;
      }
      return true;
    } else {
      if (typeof value === "number") {
        if (cache[index] !== value) {
          cache[index] = value;
          return true;
        }
      } else {
        const cachedObjects = Array.isArray(cache[index]) ? cache[index] : [cache[index]];
        const values = Array.isArray(value) ? value : [value];
        for (let i6 = 0; i6 < cachedObjects.length; i6++) {
          const cachedObject = cachedObjects[i6];
          if (cachedObject.equals(values[i6]) === false) {
            cachedObject.copy(values[i6]);
            return true;
          }
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    let chunkOffset = 0;
    for (let i6 = 0, l = uniforms.length; i6 < l; i6++) {
      const uniform = uniforms[i6];
      const infos = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      };
      const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
      for (let j = 0, jl2 = values.length; j < jl2; j++) {
        const value = values[j];
        const info2 = getUniformSize(value);
        infos.boundary += info2.boundary;
        infos.storage += info2.storage;
      }
      uniform.__data = new Float32Array(infos.storage / Float32Array.BYTES_PER_ELEMENT);
      uniform.__offset = offset;
      if (i6 > 0) {
        chunkOffset = offset % chunkSize;
        const remainingSizeInChunk = chunkSize - chunkOffset;
        if (chunkOffset !== 0 && remainingSizeInChunk - infos.boundary < 0) {
          offset += chunkSize - chunkOffset;
          uniform.__offset = offset;
        }
      }
      offset += infos.storage;
    }
    chunkOffset = offset % chunkSize;
    if (chunkOffset > 0)
      offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl2.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id2 in buffers) {
      gl2.deleteBuffer(buffers[id2]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose
  };
}
class WebGLRenderer {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context = null,
      depth = true,
      stencil = true,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context !== null) {
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this._outputColorSpace = SRGBColorSpace;
    this._useLegacyLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    const _currentClearColor = new Color(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix2 = new Matrix4();
    const _vector22 = new Vector2();
    const _vector32 = new Vector3();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context;
    function getContext2(contextNames, contextAttributes) {
      for (let i6 = 0; i6 < contextNames.length; i6++) {
        const contextName = contextNames[i6];
        const context2 = canvas.getContext(contextName, contextAttributes);
        if (context2 !== null)
          return context2;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas)
        canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext2(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext2(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (typeof WebGLRenderingContext !== "undefined" && _gl instanceof WebGLRenderingContext) {
        console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.");
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr2 = new WebXRManager(_this, _gl);
    this.xr = xr2;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr2.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x6, y6, width, height) {
      if (x6.isVector4) {
        _viewport.set(x6.x, x6.y, x6.z, x6.w);
      } else {
        _viewport.set(x6, y6, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x6, y6, width, height) {
      if (x6.isVector4) {
        _scissor.set(x6.x, x6.y, x6.z, x6.w);
      } else {
        _scissor.set(x6, y6, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a = background.getClearAlpha();
          const r = clearColor.r;
          const g6 = clearColor.g;
          const b6 = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r;
            uintClearColor[1] = g6;
            uintClearColor[2] = b6;
            uintClearColor[3] = a;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r;
            intClearColor[1] = g6;
            intClearColor[2] = b6;
            intClearColor[3] = a;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2)
        bits |= _gl.DEPTH_BUFFER_BIT;
      if (stencil2) {
        bits |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(4294967295);
      }
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr2.dispose();
      xr2.removeEventListener("sessionstart", onXRSessionStart);
      xr2.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null)
        scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        if (index === void 0)
          return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity)
        return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer2 = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer2 = indexedBufferRenderer;
        renderer2.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer2.setMode(_gl.LINES);
        } else {
          renderer2.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer2.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer2.setMode(_gl.LINE_LOOP);
        } else {
          renderer2.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer2.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer2.setMode(_gl.TRIANGLES);
      }
      if (object.isInstancedMesh) {
        renderer2.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer2.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer2.render(drawStart, drawCount);
      }
    };
    function prepareMaterial(material, scene, object) {
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function(scene, camera, targetScene = null) {
      if (targetScene === null)
        targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights(_this._useLegacyLights);
      const materials2 = /* @__PURE__ */ new Set();
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i6 = 0; i6 < material.length; i6++) {
              const material2 = material[i6];
              prepareMaterial(material2, targetScene, object);
              materials2.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials2.add(material);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
      return materials2;
    };
    this.compileAsync = function(scene, camera, targetScene = null) {
      const materials2 = this.compile(scene, camera, targetScene);
      return new Promise((resolve2) => {
        function checkMaterialsReady() {
          materials2.forEach(function(material) {
            const materialProperties = properties.get(material);
            const program = materialProperties.currentProgram;
            if (program.isReady()) {
              materials2.delete(material);
            }
          });
          if (materials2.size === 0) {
            resolve2(scene);
            return;
          }
          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get("KHR_parallel_shader_compile") !== null) {
          checkMaterialsReady();
        } else {
          setTimeout(checkMaterialsReady, 10);
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined")
      animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr2.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr2.addEventListener("sessionstart", onXRSessionStart);
    xr2.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene.matrixWorldAutoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
        camera.updateMatrixWorld();
      if (xr2.enabled === true && xr2.isPresenting === true) {
        if (xr2.cameraAutoUpdate === true)
          xr2.updateCamera(camera);
        camera = xr2.getCamera();
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      background.render(currentRenderList, scene);
      currentRenderState.setupLights(_this._useLegacyLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i6 = 0, l = cameras.length; i6 < l; i6++) {
          const camera2 = cameras[i6];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true)
        scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null)
                  object.computeBoundingSphere();
                _vector32.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null)
                  geometry.computeBoundingSphere();
                _vector32.copy(geometry.boundingSphere.center);
              }
              _vector32.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i6 = 0, l = groups.length; i6 < l; i6++) {
                const group = groups[i6];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector32.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i6 = 0, l = children.length; i6 < l; i6++) {
        projectObject(children[i6], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true)
        clipping.setGlobalState(_this.clippingPlanes, camera);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
      if (viewport)
        state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      const isWebGL2 = capabilities.isWebGL2;
      if (_transmissionRenderTarget === null) {
        _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: isWebGL2 ? 4 : 0
        });
      }
      _this.getDrawingBufferSize(_vector22);
      if (isWebGL2) {
        _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
      } else {
        _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1)
        _this.setClearColor(16777215, 0.5);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      let renderTargetNeedsUpdate = false;
      for (let i6 = 0, l = transmissiveObjects.length; i6 < l; i6++) {
        const renderItem = transmissiveObjects[i6];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = renderItem.material;
        const group = renderItem.group;
        if (material.side === DoubleSide && object.layers.test(camera.layers)) {
          const currentSide = material.side;
          material.side = BackSide;
          material.needsUpdate = true;
          renderObject(object, scene, camera, geometry, material, group);
          material.side = currentSide;
          material.needsUpdate = true;
          renderTargetNeedsUpdate = true;
        }
      }
      if (renderTargetNeedsUpdate === true) {
        textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList2, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i6 = 0, l = renderList2.length; i6 < l; i6++) {
        const renderItem = renderList2[i6];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        const progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = _this.toneMapping;
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
          }
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i6 = 0, l = groups.length; i6 < l; i6++) {
          if (capabilities.isWebGL2) {
            const group = groups[i6];
            uniformsGroups.update(group, program);
            uniformsGroups.bind(group, program);
          } else {
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
          }
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      if (renderTargetProperties.__hasExternalTextures) {
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x6, y6, width, height, buffer2, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x6 >= 0 && x6 <= renderTarget.width - width && (y6 >= 0 && y6 <= renderTarget.height - height)) {
            _gl.readPixels(x6, y6, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer2);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(_gl.TEXTURE_2D);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width = sourceBox.max.x - sourceBox.min.x + 1;
      const height = sourceBox.max.y - sourceBox.min.y + 1;
      const depth2 = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedArrayTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(colorSpace) {
    this._outputColorSpace = colorSpace;
    const gl2 = this.getContext();
    gl2.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? "display-p3" : "srgb";
    gl2.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb";
  }
  get physicallyCorrectLights() {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
    return !this.useLegacyLights;
  }
  set physicallyCorrectLights(value) {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
    this.useLegacyLights = !value;
  }
  get outputEncoding() {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
    return this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  set outputEncoding(encoding) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
    this.outputColorSpace = encoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
  }
  get useLegacyLights() {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.");
    return this._useLegacyLights;
  }
  set useLegacyLights(value) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.");
    this._useLegacyLights = value;
  }
}
class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = true;
class Scene extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0)
      data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1)
      data.object.backgroundIntensity = this.backgroundIntensity;
    return data;
  }
}
class InterleavedBuffer {
  constructor(array, stride) {
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i6 = 0, l = this.stride; i6 < l; i6++) {
      this.array[index1 + i6] = attribute.array[index2 + i6];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib2 = new this.constructor(array, this.stride);
    ib2.setUsage(this.usage);
    return ib2;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const _vector$5 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m) {
    for (let i6 = 0, l = this.data.count; i6 < l; i6++) {
      _vector$5.fromBufferAttribute(this, i6);
      _vector$5.applyMatrix4(m);
      this.setXYZ(i6, _vector$5.x, _vector$5.y, _vector$5.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i6 = 0, l = this.count; i6 < l; i6++) {
      _vector$5.fromBufferAttribute(this, i6);
      _vector$5.applyNormalMatrix(m);
      this.setXYZ(i6, _vector$5.x, _vector$5.y, _vector$5.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i6 = 0, l = this.count; i6 < l; i6++) {
      _vector$5.fromBufferAttribute(this, i6);
      _vector$5.transformDirection(m);
      this.setXYZ(i6, _vector$5.x, _vector$5.y, _vector$5.z);
    }
    return this;
  }
  setX(index, x6) {
    if (this.normalized)
      x6 = normalize(x6, this.array);
    this.data.array[index * this.data.stride + this.offset] = x6;
    return this;
  }
  setY(index, y6) {
    if (this.normalized)
      y6 = normalize(y6, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y6;
    return this;
  }
  setZ(index, z) {
    if (this.normalized)
      z = normalize(z, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  setW(index, w6) {
    if (this.normalized)
      w6 = normalize(w6, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w6;
    return this;
  }
  getX(index) {
    let x6 = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized)
      x6 = denormalize(x6, this.array);
    return x6;
  }
  getY(index) {
    let y6 = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized)
      y6 = denormalize(y6, this.array);
    return y6;
  }
  getZ(index) {
    let z = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized)
      z = denormalize(z, this.array);
    return z;
  }
  getW(index) {
    let w6 = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized)
      w6 = denormalize(w6, this.array);
    return w6;
  }
  setXY(index, x6, y6) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x6 = normalize(x6, this.array);
      y6 = normalize(y6, this.array);
    }
    this.data.array[index + 0] = x6;
    this.data.array[index + 1] = y6;
    return this;
  }
  setXYZ(index, x6, y6, z) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x6 = normalize(x6, this.array);
      y6 = normalize(y6, this.array);
      z = normalize(z, this.array);
    }
    this.data.array[index + 0] = x6;
    this.data.array[index + 1] = y6;
    this.data.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x6, y6, z, w6) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x6 = normalize(x6, this.array);
      y6 = normalize(y6, this.array);
      z = normalize(z, this.array);
      w6 = normalize(w6, this.array);
    }
    this.data.array[index + 0] = x6;
    this.data.array[index + 1] = y6;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w6;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i6 = 0; i6 < this.count; i6++) {
        const index = i6 * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i6 = 0; i6 < this.count; i6++) {
        const index = i6 * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
const _basePosition = /* @__PURE__ */ new Vector3();
const _skinIndex = /* @__PURE__ */ new Vector4();
const _skinWeight = /* @__PURE__ */ new Vector4();
const _vector3 = /* @__PURE__ */ new Vector3();
const _matrix4 = /* @__PURE__ */ new Matrix4();
const _vertex = /* @__PURE__ */ new Vector3();
const _sphere$3 = /* @__PURE__ */ new Sphere();
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
const _ray$2 = /* @__PURE__ */ new Ray();
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.isSkinnedMesh = true;
    this.type = "SkinnedMesh";
    this.bindMode = AttachedBindMode;
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
    this.boundingBox = null;
    this.boundingSphere = null;
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i6 = 0; i6 < positionAttribute.count; i6++) {
      this.getVertexPosition(i6, _vertex);
      this.boundingBox.expandByPoint(_vertex);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i6 = 0; i6 < positionAttribute.count; i6++) {
      this.getVertexPosition(i6, _vertex);
      this.boundingSphere.expandByPoint(_vertex);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    if (source.boundingBox !== null)
      this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null)
      this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  raycast(raycaster, intersects) {
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (this.boundingSphere === null)
      this.computeBoundingSphere();
    _sphere$3.copy(this.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (this.boundingBox !== null) {
      if (_ray$2.intersectsBox(this.boundingBox) === false)
        return;
    }
    this._computeIntersections(raycaster, intersects, _ray$2);
  }
  getVertexPosition(index, target) {
    super.getVertexPosition(index, target);
    this.applyBoneTransform(index, target);
    return target;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i6 = 0, l = skinWeight.count; i6 < l; i6++) {
      vector.fromBufferAttribute(skinWeight, i6);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i6, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === AttachedBindMode) {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === DetachedBindMode) {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  applyBoneTransform(index, vector) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
    vector.set(0, 0, 0);
    for (let i6 = 0; i6 < 4; i6++) {
      const weight = _skinWeight.getComponent(i6);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i6);
        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
      }
    }
    return vector.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(index, vector) {
    console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151.");
    return this.applyBoneTransform(index, vector);
  }
}
class Bone extends Object3D {
  constructor() {
    super();
    this.isBone = true;
    this.type = "Bone";
  }
}
class DataTexture extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix$1 = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i6 = 0, il2 = this.bones.length; i6 < il2; i6++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i6 = 0, il2 = this.bones.length; i6 < il2; i6++) {
      const inverse = new Matrix4();
      if (this.bones[i6]) {
        inverse.copy(this.bones[i6].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i6 = 0, il2 = this.bones.length; i6 < il2; i6++) {
      const bone = this.bones[i6];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i6]).invert();
      }
    }
    for (let i6 = 0, il2 = this.bones.length; i6 < il2; i6++) {
      const bone = this.bones[i6];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i6 = 0, il2 = bones.length; i6 < il2; i6++) {
      const matrix = bones[i6] ? bones[i6].matrixWorld : _identityMatrix$1;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i6]);
      _offsetMatrix.toArray(boneMatrices, i6 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size2 = Math.sqrt(this.bones.length * 4);
    size2 = ceilPowerOfTwo(size2);
    size2 = Math.max(size2, 4);
    const boneMatrices = new Float32Array(size2 * size2 * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size2, size2, RGBAFormat, FloatType);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    this.boneTextureSize = size2;
    return this;
  }
  getBoneByName(name) {
    for (let i6 = 0, il2 = this.bones.length; i6 < il2; i6++) {
      const bone = this.bones[i6];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i6 = 0, l = json.bones.length; i6 < l; i6++) {
      const uuid = json.bones[i6];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i6]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i6 = 0, l = bones.length; i6 < l; i6++) {
      const bone = bones[i6];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i6];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    super(array, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
const _instanceIntersects = [];
const _box3 = /* @__PURE__ */ new Box3();
const _identity = /* @__PURE__ */ new Matrix4();
const _mesh = /* @__PURE__ */ new Mesh();
const _sphere$2 = /* @__PURE__ */ new Sphere();
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.isInstancedMesh = true;
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.boundingBox = null;
    this.boundingSphere = null;
    for (let i6 = 0; i6 < count; i6++) {
      this.setMatrixAt(i6, _identity);
    }
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    this.boundingBox.makeEmpty();
    for (let i6 = 0; i6 < count; i6++) {
      this.getMatrixAt(i6, _instanceLocalMatrix);
      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
      this.boundingBox.union(_box3);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    this.boundingSphere.makeEmpty();
    for (let i6 = 0; i6 < count; i6++) {
      this.getMatrixAt(i6, _instanceLocalMatrix);
      _sphere$2.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
      this.boundingSphere.union(_sphere$2);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    if (source.boundingBox !== null)
      this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null)
      this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  raycast(raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    if (this.boundingSphere === null)
      this.computeBoundingSphere();
    _sphere$2.copy(this.boundingSphere);
    _sphere$2.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$2) === false)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i6 = 0, l = _instanceIntersects.length; i6 < l; i6++) {
        const intersect = _instanceIntersects[i6];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
}
const _start$1 = /* @__PURE__ */ new Vector3();
const _end$1 = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i6 = 1, l = positionAttribute.count; i6 < l; i6++) {
        _start$1.fromBufferAttribute(positionAttribute, i6 - 1);
        _end$1.fromBufferAttribute(positionAttribute, i6);
        lineDistances[i6] = lineDistances[i6 - 1];
        lineDistances[i6] += _start$1.distanceTo(_end$1);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i6 = start, l = end - 1; i6 < l; i6 += step) {
        const a = index.getX(i6);
        const b6 = index.getX(i6 + 1);
        vStart.fromBufferAttribute(positionAttribute, a);
        vEnd.fromBufferAttribute(positionAttribute, b6);
        const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
        if (distSq > localThresholdSq)
          continue;
        interRay.applyMatrix4(this.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far)
          continue;
        intersects.push({
          distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i6,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i6 = start, l = end - 1; i6 < l; i6 += step) {
        vStart.fromBufferAttribute(positionAttribute, i6);
        vEnd.fromBufferAttribute(positionAttribute, i6 + 1);
        const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
        if (distSq > localThresholdSq)
          continue;
        interRay.applyMatrix4(this.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far)
          continue;
        intersects.push({
          distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i6,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml2 = morphAttribute.length; m < ml2; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i6 = 0, l = positionAttribute.count; i6 < l; i6 += 2) {
        _start.fromBufferAttribute(positionAttribute, i6);
        _end.fromBufferAttribute(positionAttribute, i6 + 1);
        lineDistances[i6] = i6 === 0 ? 0 : lineDistances[i6 - 1];
        lineDistances[i6 + 1] = lineDistances[i6] + _start.distanceTo(_end);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
}
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineLoop = true;
    this.type = "LineLoop";
  }
}
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.isPointsMaterial = true;
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
const _inverseMatrix = /* @__PURE__ */ new Matrix4();
const _ray = /* @__PURE__ */ new Ray();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3();
class Points extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.isPoints = true;
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i6 = start, il2 = end; i6 < il2; i6++) {
        const a = index.getX(i6);
        _position$2.fromBufferAttribute(positionAttribute, a);
        testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i6 = start, l = end; i6 < l; i6++) {
        _position$2.fromBufferAttribute(positionAttribute, i6);
        testPoint(_position$2, i6, localThresholdSq, matrixWorld, raycaster, intersects, this);
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml2 = morphAttribute.length; m < ml2; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.isMeshPhysicalMaterial = true;
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.anisotropyRotation = 0;
    this.anisotropyMap = null;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.iridescenceMap = null;
    this.iridescenceIOR = 1.3;
    this.iridescenceThicknessRange = [100, 400];
    this.iridescenceThicknessMap = null;
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = Infinity;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._anisotropy = 0;
    this._clearcoat = 0;
    this._iridescence = 0;
    this._sheen = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(value) {
    if (this._anisotropy > 0 !== value > 0) {
      this.version++;
    }
    this._anisotropy = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++;
    }
    this._iridescence = value;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.anisotropy = source.anisotropy;
    this.anisotropyRotation = source.anisotropyRotation;
    this.anisotropyMap = source.anisotropyMap;
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.ior = source.ior;
    this.iridescence = source.iridescence;
    this.iridescenceMap = source.iridescenceMap;
    this.iridescenceIOR = source.iridescenceIOR;
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
    this.iridescenceThicknessMap = source.iridescenceThicknessMap;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
}
function convertArray(array, type, forceClone) {
  if (!array || // let 'undefined' and 'null' pass
  !forceClone && array.constructor === type)
    return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
function getKeyframeOrder(times) {
  function compareTime(i6, j) {
    return times[i6] - times[j];
  }
  const n = times.length;
  const result = new Array(n);
  for (let i6 = 0; i6 !== n; ++i6)
    result[i6] = i6;
  result.sort(compareTime);
  return result;
}
function sortedArray(values, stride, order) {
  const nValues = values.length;
  const result = new values.constructor(nValues);
  for (let i6 = 0, dstOffset = 0; dstOffset !== nValues; ++i6) {
    const srcOffset = order[i6] * stride;
    for (let j = 0; j !== stride; ++j) {
      result[dstOffset++] = values[srcOffset + j];
    }
  }
  return result;
}
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  let i6 = 1, key = jsonKeys[0];
  while (key !== void 0 && key[valuePropertyName] === void 0) {
    key = jsonKeys[i6++];
  }
  if (key === void 0)
    return;
  let value = key[valuePropertyName];
  if (value === void 0)
    return;
  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push.apply(values, value);
      }
      key = jsonKeys[i6++];
    } while (key !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        value.toArray(values, values.length);
      }
      key = jsonKeys[i6++];
    } while (key !== void 0);
  } else {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push(value);
      }
      key = jsonKeys[i6++];
    } while (key !== void 0);
  }
}
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp2 = this.parameterPositions;
    let i12 = this._cachedIndex, t12 = pp2[i12], t02 = pp2[i12 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t < t12)) {
              for (let giveUpAt = i12 + 2; ; ) {
                if (t12 === void 0) {
                  if (t < t02)
                    break forward_scan;
                  i12 = pp2.length;
                  this._cachedIndex = i12;
                  return this.copySampleValue_(i12 - 1);
                }
                if (i12 === giveUpAt)
                  break;
                t02 = t12;
                t12 = pp2[++i12];
                if (t < t12) {
                  break seek;
                }
              }
              right = pp2.length;
              break linear_scan;
            }
          if (!(t >= t02)) {
            const t1global = pp2[1];
            if (t < t1global) {
              i12 = 2;
              t02 = t1global;
            }
            for (let giveUpAt = i12 - 2; ; ) {
              if (t02 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i12 === giveUpAt)
                break;
              t12 = t02;
              t02 = pp2[--i12 - 1];
              if (t >= t02) {
                break seek;
              }
            }
            right = i12;
            i12 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i12 < right) {
          const mid = i12 + right >>> 1;
          if (t < pp2[mid]) {
            right = mid;
          } else {
            i12 = mid + 1;
          }
        }
        t12 = pp2[i12];
        t02 = pp2[i12 - 1];
        if (t02 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t12 === void 0) {
          i12 = pp2.length;
          this._cachedIndex = i12;
          return this.copySampleValue_(i12 - 1);
        }
      }
      this._cachedIndex = i12;
      this.intervalChanged_(i12, t02, t12);
    }
    return this.interpolate_(i12, t02, t, t12);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i6 = 0; i6 !== stride; ++i6) {
      result[i6] = values[offset + i6];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i12, t02, t12) {
    const pp2 = this.parameterPositions;
    let iPrev = i12 - 2, iNext = i12 + 1, tPrev = pp2[iPrev], tNext = pp2[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i12;
          tPrev = 2 * t02 - t12;
          break;
        case WrapAroundEnding:
          iPrev = pp2.length - 2;
          tPrev = t02 + pp2[iPrev] - pp2[iPrev + 1];
          break;
        default:
          iPrev = i12;
          tPrev = t12;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i12;
          tNext = 2 * t12 - t02;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t12 + pp2[1] - pp2[0];
          break;
        default:
          iNext = i12 - 1;
          tNext = t02;
      }
    }
    const halfDt = (t12 - t02) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t02 - tPrev);
    this._weightNext = halfDt / (tNext - t12);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i12, t02, t, t12) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o12 = i12 * stride, o02 = o12 - stride, oP2 = this._offsetPrev, oN2 = this._offsetNext, wP2 = this._weightPrev, wN2 = this._weightNext, p6 = (t - t02) / (t12 - t02), pp2 = p6 * p6, ppp = pp2 * p6;
    const sP2 = -wP2 * ppp + 2 * wP2 * pp2 - wP2 * p6;
    const s02 = (1 + wP2) * ppp + (-1.5 - 2 * wP2) * pp2 + (-0.5 + wP2) * p6 + 1;
    const s12 = (-1 - wN2) * ppp + (1.5 + wN2) * pp2 + 0.5 * p6;
    const sN2 = wN2 * ppp - wN2 * pp2;
    for (let i6 = 0; i6 !== stride; ++i6) {
      result[i6] = sP2 * values[oP2 + i6] + s02 * values[o02 + i6] + s12 * values[o12 + i6] + sN2 * values[oN2 + i6];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i12, t02, t, t12) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i12 * stride, offset0 = offset1 - stride, weight1 = (t - t02) / (t12 - t02), weight0 = 1 - weight1;
    for (let i6 = 0; i6 !== stride; ++i6) {
      result[i6] = values[offset0 + i6] * weight0 + values[offset1 + i6] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i12) {
    return this.copySampleValue_(i12 - 1);
  }
}
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track2) {
    const trackType = track2.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track2);
    } else {
      json = {
        "name": track2.name,
        "times": convertArray(track2.times, Array),
        "values": convertArray(track2.values, Array)
      };
      const interpolation = track2.getInterpolation();
      if (interpolation !== track2.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track2.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i6 = 0, n = times.length; i6 !== n; ++i6) {
        times[i6] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i6 = 0, n = times.length; i6 !== n; ++i6) {
        times[i6] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to2 = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to2 !== -1 && times[to2] > endTime) {
      --to2;
    }
    ++to2;
    if (from !== 0 || to2 !== nKeys) {
      if (from >= to2) {
        to2 = Math.max(to2, 1);
        from = to2 - 1;
      }
      const stride = this.getValueSize();
      this.times = times.slice(from, to2);
      this.values = this.values.slice(from * stride, to2 * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i6 = 0; i6 !== nKeys; i6++) {
      const currTime = times[i6];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i6, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i6, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray(values)) {
        for (let i6 = 0, n = values.length; i6 !== n; ++i6) {
          const value = values[i6];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i6, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i6 = 1; i6 < lastIndex; ++i6) {
      let keep = false;
      const time = times[i6];
      const timeNext = times[i6 + 1];
      if (time !== timeNext && (i6 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i6 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i6 !== writeIndex) {
          times[writeIndex] = times[i6];
          const readOffset = i6 * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = times.slice(0, writeIndex);
      this.values = values.slice(0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = this.times.slice();
    const values = this.values.slice();
    const TypedKeyframeTrack = this.constructor;
    const track2 = new TypedKeyframeTrack(this.name, times, values);
    track2.createInterpolant = this.createInterpolant;
    return track2;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i12, t02, t, t12) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t02) / (t12 - t02);
    let offset = i12 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i6 = 0, n = jsonTracks.length; i6 !== n; ++i6) {
      tracks.push(parseKeyframeTrack(jsonTracks[i6]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i6 = 0, n = clipTracks.length; i6 !== n; ++i6) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i6]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i6 = 0; i6 < numMorphTargets; i6++) {
      let times = [];
      let values = [];
      times.push(
        (i6 + numMorphTargets - 1) % numMorphTargets,
        i6,
        (i6 + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      const order = getKeyframeOrder(times);
      times = sortedArray(times, 1, order);
      values = sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i6].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i6 = 0; i6 < clipArray.length; i6++) {
      if (clipArray[i6].name === name) {
        return clipArray[i6];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i6 = 0, il2 = morphTargets.length; i6 < il2; i6++) {
      const morphTarget = morphTargets[i6];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h6 = 0; h6 < hierarchyTracks.length; h6++) {
      const animationKeys = hierarchyTracks[h6].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k7;
        for (k7 = 0; k7 < animationKeys.length; k7++) {
          if (animationKeys[k7].morphTargets) {
            for (let m = 0; m < animationKeys[k7].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k7].morphTargets[m]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k7].morphTargets.length; ++m) {
            const animationKey = animationKeys[k7];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h6].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i6 = 0, n = tracks.length; i6 !== n; ++i6) {
      const track2 = this.tracks[i6];
      duration = Math.max(duration, track2.times[track2.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i6 = 0; i6 < this.tracks.length; i6++) {
      this.tracks[i6].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i6 = 0; i6 < this.tracks.length; i6++) {
      valid = valid && this.tracks[i6].validate();
    }
    return valid;
  }
  optimize() {
    for (let i6 = 0; i6 < this.tracks.length; i6++) {
      this.tracks[i6].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i6 = 0; i6 < this.tracks.length; i6++) {
      tracks.push(this.tracks[i6].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform2) {
      urlModifier = transform2;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i6 = 0, l = handlers.length; i6 < l; i6 += 2) {
        const regex = handlers[i6];
        const loader = handlers[i6 + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve2, reject) {
      scope.load(url, resolve2, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
}
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad)
          onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("Content-Length") || response.headers.get("X-File-Size");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i6 = 0, il2 = callbacks.length; i6 < il2; i6++) {
                    const callback = callbacks[i6];
                    if (callback.onProgress)
                      callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re2 = /charset="?([^;"\s]*)"?/i;
            const exec = re2.exec(mimeType);
            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder2 = new TextDecoder(label);
            return response.arrayBuffer().then((ab2) => decoder2.decode(ab2));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i6 = 0, il2 = callbacks.length; i6 < il2; i6++) {
        const callback = callbacks[i6];
        if (callback.onLoad)
          callback.onLoad(data);
      }
    }).catch((err) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err;
      }
      delete loading[url];
      for (let i6 = 0, il2 = callbacks.length; i6 < il2; i6++) {
        const callback = callbacks[i6];
        if (callback.onError)
          callback.onError(err);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
}
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
class SpotLight extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
    super(color, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 2) {
    super(color, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
}
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
}
class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s = "";
    for (let i6 = 0, il2 = array.length; i6 < il2; i6++) {
      s += String.fromCharCode(array[i6]);
    }
    try {
      return decodeURIComponent(escape(s));
    } catch (e) {
      return s;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.slice(0, index + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path + url;
  }
}
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.isImageBitmapLoader = true;
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options) {
    this.options = options;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e) {
      if (onError)
        onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
const _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i6 = this._targetGroup.nCachedObjects_, n = bindings.length; i6 !== n; ++i6) {
      bindings[i6].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i6 = this._targetGroup.nCachedObjects_, n = bindings.length; i6 !== n; ++i6) {
      bindings[i6].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i6 = this._targetGroup.nCachedObjects_, n = bindings.length; i6 !== n; ++i6) {
      bindings[i6].unbind();
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches2 = _trackRe.exec(trackName);
    if (matches2 === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches2[2],
      objectName: matches2[3],
      objectIndex: matches2[4],
      propertyName: matches2[5],
      // required
      propertyIndex: matches2[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i6 = 0; i6 < children.length; i6++) {
          const childNode = children[i6];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer2, offset) {
    buffer2[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer2, offset) {
    const source = this.resolvedProperty;
    for (let i6 = 0, n = source.length; i6 !== n; ++i6) {
      buffer2[offset++] = source[i6];
    }
  }
  _getValue_arrayElement(buffer2, offset) {
    buffer2[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer2, offset) {
    this.resolvedProperty.toArray(buffer2, offset);
  }
  // Direct
  _setValue_direct(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.targetObject[this.propertyName] = buffer2[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i6 = 0, n = dest.length; i6 !== n; ++i6) {
      dest[i6] = buffer2[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i6 = 0, n = dest.length; i6 !== n; ++i6) {
      dest[i6] = buffer2[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer2, offset) {
    const dest = this.resolvedProperty;
    for (let i6 = 0, n = dest.length; i6 !== n; ++i6) {
      dest[i6] = buffer2[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer2[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer2, offset) {
    this.resolvedProperty.fromArray(buffer2, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i6 = 0; i6 < targetObject.length; i6++) {
            if (targetObject[i6].name === objectIndex) {
              objectIndex = i6;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
var x = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof dist.global < "u" ? dist.global : typeof self < "u" ? self : {};
function M(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function w(n) {
  if (n.__esModule)
    return n;
  var t = n.default;
  if (typeof t == "function") {
    var i6 = function e() {
      if (this instanceof e) {
        var o = [null];
        o.push.apply(o, arguments);
        var s = Function.bind.apply(t, o);
        return new s();
      }
      return t.apply(this, arguments);
    };
    i6.prototype = t.prototype;
  } else
    i6 = {};
  return Object.defineProperty(i6, "__esModule", { value: true }), Object.keys(n).forEach(function(e) {
    var o = Object.getOwnPropertyDescriptor(n, e);
    Object.defineProperty(i6, e, o.get ? o : {
      enumerable: true,
      get: function() {
        return n[e];
      }
    });
  }), i6;
}
const h = (n, t) => {
  const i6 = 2 * Math.PI * t * n;
  return i6 / (i6 + 1);
}, p = (n, t, i6) => n * t + (1 - n) * i6;
class P {
  constructor({ minCutOff: t, beta: i6 }) {
    this.minCutOff = t, this.beta = i6, this.dCutOff = 1e-3, this.xPrev = null, this.dxPrev = null, this.tPrev = null, this.initialized = false;
  }
  reset() {
    this.initialized = false;
  }
  filter(t, i6) {
    if (!this.initialized)
      return this.initialized = true, this.xPrev = i6, this.dxPrev = i6.map(() => 0), this.tPrev = t, i6;
    const { xPrev: e, tPrev: o, dxPrev: s } = this, r = t - o, u = h(r, this.dCutOff), c = [], d = [], l = [];
    for (let a = 0; a < i6.length; a++) {
      c[a] = (i6[a] - e[a]) / r, d[a] = p(u, c[a], s[a]);
      const m = this.minCutOff + this.beta * Math.abs(d[a]), f = h(r, m);
      l[a] = p(f, i6[a], e[a]);
    }
    return this.xPrev = l, this.dxPrev = d, this.tPrev = t, l;
  }
}
const g = `<div class="mindar-ui-overlay mindar-ui-loading">
  <div class="loader"/>
</div>
`, v$1 = `<div class="mindar-ui-overlay mindar-ui-compatibility">
  <div class="content">
    <h1>Failed to launch :(</h1>
    <p>
      Looks like your device/browser is not compatible.
    </p>

    <br/>
    <br/>
    <p>
      Please try the following recommended browsers:
    </p>
    <p>
      For Android device - Chrome
    </p>
    <p>
      For iOS device - Safari
    </p>
  </div>
</div>
`, y = `<div class="mindar-ui-overlay mindar-ui-scanning">
  <div class="scanning">
    <div class="inner">
      <div class="scanline"/>
    </div>
  </div>
</div>
`, b = ".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:transparent;z-index:2}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid white;opacity:.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:black;color:#fff;opacity:.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media (min-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media (max-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:.8;background:linear-gradient(to right,white 10px,transparent 10px) 0 0,linear-gradient(to right,white 10px,transparent 10px) 0 100%,linear-gradient(to left,white 10px,transparent 10px) 100% 0,linear-gradient(to left,white 10px,transparent 10px) 100% 100%,linear-gradient(to bottom,white 10px,transparent 10px) 0 0,linear-gradient(to bottom,white 10px,transparent 10px) 100% 0,linear-gradient(to top,white 10px,transparent 10px) 0 100%,linear-gradient(to top,white 10px,transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:white;animation:move 2s linear infinite}@keyframes move{0%,to{top:0%}50%{top:calc(100% - 10px)}}";
let k$1 = class k {
  constructor({ uiLoading: t, uiScanning: i6, uiError: e }) {
    const o = document.createElement("style");
    o.innerText = b, document.head.appendChild(o), t === "yes" ? this.loadingModal = this._loadHTML(g) : t !== "no" && (this.loadingModal = document.querySelector(t)), e === "yes" ? this.compatibilityModal = this._loadHTML(v$1) : e !== "no" && (this.compatibilityModal = document.querySelector(e)), i6 === "yes" ? this.scanningMask = this._loadHTML(y) : i6 !== "no" && (this.scanningMask = document.querySelector(i6)), this.hideLoading(), this.hideCompatibility(), this.hideScanning();
  }
  showLoading() {
    this.loadingModal && this.loadingModal.classList.remove("hidden");
  }
  hideLoading() {
    this.loadingModal && this.loadingModal.classList.add("hidden");
  }
  showCompatibility() {
    this.compatibilityModal && this.compatibilityModal.classList.remove("hidden");
  }
  hideCompatibility() {
    this.compatibilityModal && this.compatibilityModal.classList.add("hidden");
  }
  showScanning() {
    this.scanningMask && this.scanningMask.classList.remove("hidden");
  }
  hideScanning() {
    this.scanningMask && this.scanningMask.classList.add("hidden");
  }
  _loadHTML(t) {
    const i6 = document.createElement("template");
    i6.innerHTML = t.trim();
    const e = i6.content.firstChild;
    return document.getElementsByTagName("body")[0].appendChild(e), e;
  }
};
function GI(n, t) {
  for (var e = 0; e < t.length; e++) {
    const s = t[e];
    if (typeof s != "string" && !Array.isArray(s)) {
      for (const o in s)
        if (o !== "default" && !(o in n)) {
          const r = Object.getOwnPropertyDescriptor(s, o);
          r && Object.defineProperty(n, o, r.get ? r : {
            enumerable: true,
            get: () => s[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EI = 1e-7, LI = 1e-4;
let Mg$1 = class Mg {
  constructor(t, e) {
    this.backend = t, this.dataMover = e, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
  }
  get(t) {
    return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);
  }
  set(t, e) {
    this.dataIdsCount++, this.data.set(t, e);
  }
  has(t) {
    return this.data.has(t);
  }
  delete(t) {
    return this.dataIdsCount--, this.data.delete(t);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
};
let Xd$1 = class Xd {
  refCount(t) {
    return _e$1("refCount");
  }
  incRef(t) {
    return _e$1("incRef");
  }
  timerAvailable() {
    return true;
  }
  time(t) {
    return _e$1("time");
  }
  read(t) {
    return _e$1("read");
  }
  readSync(t) {
    return _e$1("readSync");
  }
  readToGPU(t, e) {
    return _e$1("readToGPU");
  }
  numDataIds() {
    return _e$1("numDataIds");
  }
  disposeData(t, e) {
    return _e$1("disposeData");
  }
  write(t, e, s) {
    return _e$1("write");
  }
  move(t, e, s, o, r) {
    return _e$1("move");
  }
  createTensorFromGPUData(t, e, s) {
    return _e$1("createTensorFromGPUData");
  }
  memory() {
    return _e$1("memory");
  }
  /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
  floatPrecision() {
    return _e$1("floatPrecision");
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return this.floatPrecision() === 32 ? EI : LI;
  }
  dispose() {
    return _e$1("dispose");
  }
};
function _e$1(n) {
  throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Pd$1(n) {
  let t = n.length, e = 0;
  for (; t > 0; )
    e = Math.random() * t | 0, t--, us(n, t, e);
}
function MI(n, t) {
  if (n.length !== t.length)
    throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${t.length}`);
  let e = n.length, s = 0;
  for (; e > 0; )
    s = Math.random() * e | 0, e--, us(n, e, s), us(t, e, s);
}
function Fs(n, t, e) {
  return Math.max(n, Math.min(t, e));
}
function Wl(n) {
  return n % 2 === 0 ? n : n + 1;
}
function us(n, t, e) {
  const s = n[t];
  n[t] = n[e], n[e] = s;
}
function Wg$1(n) {
  let t = 0;
  for (let e = 0; e < n.length; e++)
    t += n[e];
  return t;
}
function WI(n, t) {
  const e = Math.random();
  return t * e + (1 - e) * n;
}
function DI(n, t) {
  let e = 0;
  for (let s = 0; s < n.length; s++) {
    const o = Number(n[s]) - Number(t[s]);
    e += o * o;
  }
  return e;
}
function v(n, t) {
  if (!n)
    throw new Error(typeof t == "string" ? t : t());
}
function Ve(n, t, e = "") {
  v(Rt$1(n, t), () => e + ` Shapes ${n} and ${t} must match`);
}
function Dl(n) {
  v(n != null, () => "The input to the tensor constructor must be a non-null value.");
}
function O(n) {
  if (n.length === 0)
    return 1;
  let t = n[0];
  for (let e = 1; e < n.length; e++)
    t *= n[e];
  return t;
}
function FI(n) {
  return n.length === 0;
}
function Rt$1(n, t) {
  if (n === t)
    return true;
  if (n == null || t == null || n.length !== t.length)
    return false;
  for (let e = 0; e < n.length; e++)
    if (n[e] !== t[e])
      return false;
  return true;
}
function go(n) {
  return n % 1 === 0;
}
function VI(n) {
  if (Math.tanh != null)
    return Math.tanh(n);
  if (n === 1 / 0)
    return 1;
  if (n === -1 / 0)
    return -1;
  {
    const t = Math.exp(2 * n);
    return (t - 1) / (t + 1);
  }
}
function el(n) {
  const t = Math.ceil(Math.sqrt(n));
  return [t, Math.ceil(n / t)];
}
function zI(n) {
  const t = new Uint32Array(n);
  for (let e = 0; e < n; ++e)
    t[e] = e;
  return Pd$1(t), t;
}
function ho(n, t) {
  return t <= n.length ? n : n + " ".repeat(t - n.length);
}
function td(n, t = (o) => 0, e, s) {
  return new Promise((o, r) => {
    let i6 = 0;
    const a = () => {
      if (n()) {
        o();
        return;
      }
      i6++;
      const l = t(i6);
      if (e != null && i6 >= e) {
        r();
        return;
      }
      s != null ? s(a, l) : setTimeout(a, l);
    };
    a();
  });
}
function Ad$1(n, t) {
  let e = 1, s = -1;
  for (let r = 0; r < n.length; ++r)
    if (n[r] >= 0)
      e *= n[r];
    else if (n[r] === -1) {
      if (s !== -1)
        throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);
      s = r;
    } else if (n[r] < 0)
      throw Error(`Shapes can not be < 0. Found ${n[r]} at dim ${r}`);
  if (s === -1) {
    if (t > 0 && t !== e)
      throw Error(`Size(${t}) must match the product of shape ${n}`);
    return n;
  }
  if (e === 0)
    throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);
  if (t % e !== 0)
    throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);
  const o = n.slice();
  return o[s] = t / e, o;
}
function Ct(n, t) {
  const e = t.length;
  return n = n == null ? t.map((s, o) => o) : [].concat(n), v(n.every((s) => s >= -e && s < e), () => `All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`), v(n.every((s) => go(s)), () => `All values in axis param must be integers but got axis ${n}`), n.map((s) => s < 0 ? e + s : s);
}
function gs(n, t) {
  const e = [], s = [], o = t != null && Array.isArray(t) && t.length === 0, r = t == null || o ? null : Ct(t, n).sort();
  let i6 = 0;
  for (let a = 0; a < n.length; ++a) {
    if (r != null) {
      if (r[i6] === a && n[a] !== 1)
        throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);
      (r[i6] == null || r[i6] > a) && n[a] === 1 && (e.push(n[a]), s.push(a)), r[i6] <= a && i6++;
    }
    n[a] !== 1 && (e.push(n[a]), s.push(a));
  }
  return { newShape: e, keptDims: s };
}
function xe$1(n, t) {
  let e = null;
  if (n == null || n === "float32")
    e = new Float32Array(t);
  else if (n === "int32")
    e = new Int32Array(t);
  else if (n === "bool")
    e = new Uint8Array(t);
  else
    throw new Error(`Unknown data type ${n}`);
  return e;
}
function oe(n, t) {
  let e = null;
  if (n == null || n === "float32")
    e = new Float32Array(t);
  else if (n === "int32")
    e = new Int32Array(t);
  else if (n === "bool")
    e = new Uint8Array(t);
  else if (n === "string")
    e = new Array(t);
  else
    throw new Error(`Unknown data type ${n}`);
  return e;
}
function Dg$1(n, t) {
  for (let e = 0; e < n.length; e++) {
    const s = n[e];
    if (isNaN(s) || !isFinite(s))
      throw Error(`A tensor of type ${t} being uploaded contains ${s}.`);
  }
}
function Fg$1(n) {
  return n === "bool" || n === "complex64" || n === "float32" || n === "int32" || n === "string";
}
function Od$1(n, t) {
  return !(t === "complex64" || t === "float32" && n !== "complex64" || t === "int32" && n !== "float32" && n !== "complex64" || t === "bool" && n === "bool");
}
function Ur(n) {
  if (n === "float32" || n === "int32")
    return 4;
  if (n === "complex64")
    return 8;
  if (n === "bool")
    return 1;
  throw new Error(`Unknown dtype ${n}`);
}
function Vg$1(n) {
  if (n == null)
    return 0;
  let t = 0;
  return n.forEach((e) => t += e.length), t;
}
function mr(n) {
  return typeof n == "string" || n instanceof String;
}
function zg$1(n) {
  return typeof n == "boolean";
}
function nl(n) {
  return typeof n == "number";
}
function gr(n) {
  return Array.isArray(n) ? gr(n[0]) : n instanceof Float32Array ? "float32" : n instanceof Int32Array || n instanceof Uint8Array || n instanceof Uint8ClampedArray ? "int32" : nl(n) ? "float32" : mr(n) ? "string" : zg$1(n) ? "bool" : "float32";
}
function Vs(n) {
  return !!(n && n.constructor && n.call && n.apply);
}
function sl(n, t) {
  for (let e = t; e < n; ++e)
    if (n % e === 0)
      return e;
  return n;
}
function dt(n) {
  const t = n.length;
  if (t < 2)
    return [];
  const e = new Array(t - 1);
  e[t - 2] = n[t - 1];
  for (let s = t - 3; s >= 0; --s)
    e[s] = e[s + 1] * n[s + 1];
  return e;
}
function Xg$1(n, t, e, s = false) {
  const o = new Array();
  if (t.length === 1) {
    const r = t[0] * (s ? 2 : 1);
    for (let i6 = 0; i6 < r; i6++)
      o[i6] = e[n + i6];
  } else {
    const r = t[0], i6 = t.slice(1), a = i6.reduce((l, c) => l * c) * (s ? 2 : 1);
    for (let l = 0; l < r; l++)
      o[l] = Xg$1(n + l * a, i6, e, s);
  }
  return o;
}
function Sn$1(n, t, e = false) {
  if (n.length === 0)
    return t[0];
  const s = n.reduce((o, r) => o * r) * (e ? 2 : 1);
  if (s === 0)
    return [];
  if (s !== t.length)
    throw new Error(`[${n}] does not match the input size ${t.length}${e ? " for a complex tensor" : ""}.`);
  return Xg$1(0, n, t, e);
}
function Pg$1(n, t) {
  if (Array.isArray(n))
    return n;
  if (t === "float32")
    return n instanceof Float32Array ? n : new Float32Array(n);
  if (t === "int32")
    return n instanceof Int32Array ? n : new Int32Array(n);
  if (t === "bool" || t === "string")
    return Uint8Array.from(new Int32Array(n));
  throw new Error(`Unknown dtype ${t}`);
}
function Fl(n, t) {
  const e = Se(n, t);
  for (let s = 0; s < e.length; s++)
    e[s] = 1;
  return e;
}
function Se(n, t) {
  if (t == null || t === "float32" || t === "complex64")
    return new Float32Array(n);
  if (t === "int32")
    return new Int32Array(n);
  if (t === "bool")
    return new Uint8Array(n);
  throw new Error(`Unknown data type ${t}`);
}
function Kd$1(n, t) {
  const e = n.reduce((s, o) => s * o, 1);
  if (t == null || t === "float32")
    return Sn$1(n, new Float32Array(e));
  if (t === "int32")
    return Sn$1(n, new Int32Array(e));
  if (t === "bool")
    return Sn$1(n, new Uint8Array(e));
  throw new Error(`Unknown data type ${t}`);
}
function is(n) {
  n.forEach((t) => {
    v(Number.isInteger(t) && t >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${n}].`);
  });
}
function zn$1(n, t, e) {
  if (t === 0)
    return 0;
  if (t === 1)
    return n[0];
  let s = n[n.length - 1];
  for (let o = 0; o < n.length - 1; ++o)
    s += e[o] * n[o];
  return s;
}
function Mo(n, t, e) {
  if (t === 0)
    return [];
  if (t === 1)
    return [n];
  const s = new Array(t);
  for (let o = 0; o < s.length - 1; ++o)
    s[o] = Math.floor(n / e[o]), n -= s[o] * e[o];
  return s[s.length - 1] = n, s;
}
function ui$1(n) {
  return n && n.then && typeof n.then == "function";
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Bf$1 = "tfjsflags";
class XI {
  // tslint:disable-next-line: no-any
  constructor(t) {
    this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = PI, this.populateURLFlags();
  }
  setPlatform(t, e) {
    this.platform != null && (F().getBool("IS_TEST") || F().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)), this.platformName = t, this.platform = e;
  }
  registerFlag(t, e, s) {
    if (this.flagRegistry[t] = { evaluationFn: e, setHook: s }, this.urlFlags[t] != null) {
      const o = this.urlFlags[t];
      F().getBool("IS_TEST") || F().getBool("PROD") || console.warn(`Setting feature override from URL ${t}: ${o}.`), this.set(t, o);
    }
  }
  async getAsync(t) {
    return t in this.flags ? this.flags[t] : (this.flags[t] = await this.evaluateFlag(t), this.flags[t]);
  }
  get(t) {
    if (t in this.flags)
      return this.flags[t];
    const e = this.evaluateFlag(t);
    if (ui$1(e))
      throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);
    return this.flags[t] = e, this.flags[t];
  }
  getNumber(t) {
    return this.get(t);
  }
  getBool(t) {
    return this.get(t);
  }
  getFlags() {
    return this.flags;
  }
  // For backwards compatibility.
  get features() {
    return this.flags;
  }
  set(t, e) {
    if (this.flagRegistry[t] == null)
      throw new Error(`Cannot set flag ${t} as it has not been registered.`);
    this.flags[t] = e, this.flagRegistry[t].setHook != null && this.flagRegistry[t].setHook(e);
  }
  evaluateFlag(t) {
    if (this.flagRegistry[t] == null)
      throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);
    return this.flagRegistry[t].evaluationFn();
  }
  setFlags(t) {
    this.flags = Object.assign({}, t);
  }
  reset() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  populateURLFlags() {
    if (typeof this.global > "u" || typeof this.global.location > "u" || typeof this.global.location.search > "u")
      return;
    const t = this.getQueryParams(this.global.location.search);
    Bf$1 in t && t[Bf$1].split(",").forEach((s) => {
      const [o, r] = s.split(":");
      this.urlFlags[o] = OI(o, r);
    });
  }
}
function PI(n) {
  const t = {};
  return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (e, ...s) => (AI(t, s[0], s[1]), s.join("="))), t;
}
function AI(n, t, e) {
  n[decodeURIComponent(t)] = decodeURIComponent(e || "");
}
function OI(n, t) {
  if (t = t.toLowerCase(), t === "true" || t === "false")
    return t === "true";
  if (`${+t}` === t)
    return +t;
  throw new Error(`Could not parse value flag value ${t} for flag ${n}.`);
}
function F() {
  return Ag$1;
}
let Ag$1 = null;
function KI(n) {
  Ag$1 = n;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let yu;
function Og$1() {
  if (yu == null) {
    let n;
    if (typeof window < "u")
      n = window;
    else if (typeof dist.global < "u")
      n = dist.global;
    else if (typeof dist.process < "u")
      n = dist.process;
    else if (typeof self < "u")
      n = self;
    else
      throw new Error("Could not find a global object");
    yu = n;
  }
  return yu;
}
function ZI() {
  const n = Og$1();
  return n._tfGlobals == null && (n._tfGlobals = /* @__PURE__ */ new Map()), n._tfGlobals;
}
function Zd$1(n, t) {
  const e = ZI();
  if (e.has(n))
    return e.get(n);
  {
    const s = t();
    return e.set(n, s), e.get(n);
  }
}
const Vl = "Abs", di = "Acos", hi = "Acosh", br = "Add", Bd$1 = "AddN", Hd$1 = "All", _d$1 = "Any", zl = "ArgMax", Xl = "ArgMin", pi = "Asin", fi = "Asinh", mi = "Atan", gi = "Atanh", bi = "Atan2", Pl = "AvgPool", Ud$1 = "AvgPoolGrad", Al = "AvgPool3D", Yd$1 = "AvgPool3DGrad", Ol = "BatchMatMul", Kl = "BatchToSpaceND", Qd$1 = "Bincount", BI = "BroadcastTo", Kg$1 = "BroadcastArgs", xi = "Cast", yi = "Ceil", wi = "ClipByValue", Jd$1 = "Complex", Zl = "ComplexAbs", Bl = "Concat", Hl = "Conv2D", jd$1 = "Conv2DBackpropFilter", _l = "Conv2DBackpropInput", Ul = "Conv3D", qd$1 = "Conv3DBackpropFilterV2", th$1 = "Conv3DBackpropInputV2", Ii = "Cos", Ci = "Cosh", eh$1 = "Cumprod", Yl = "Cumsum", nh$1 = "CropAndResize", sh$1 = "DenseBincount", oh$1 = "DepthToSpace", Ql = "DepthwiseConv2dNative", rh$1 = "DepthwiseConv2dNativeBackpropFilter", ih$1 = "DepthwiseConv2dNativeBackpropInput", Zg$1 = "Diag", Jl = "Dilation2D", ed = "Dilation2DBackpropInput", nd = "Dilation2DBackpropFilter", vi = "RealDiv", Bg$1 = "Einsum", Si = "Elu", ah$1 = "EluGrad", ki = "Erf", jl = "Equal", Ti = "Exp", ql = "ExpandDims", Ni = "Expm1", lh$1 = "FFT", ch$1 = "Fill", uh$1 = "FlipLeftRight", Ri = "Floor", $i = "FloorDiv", tc = "FusedBatchNorm", ec = "GatherV2", Hg$1 = "GatherNd", nc = "Greater", Gi = "GreaterEqual", Ei = "Identity", dh$1 = "IFFT", hh$1 = "Imag", Li = "IsFinite", Mi = "IsInf", Wi = "IsNan", sc = "LeakyRelu", oc = "Less", rc = "LessEqual", _g$1 = "LinSpace", Di = "Log", Fi = "Log1p", ic = "LogicalAnd", ac = "LogicalNot", lc = "LogicalOr", $4 = "LogicalXor", HI = "LogSoftmax", G4 = "LowerBound", cc = "LRN", ph$1 = "LRNGrad", uc = "Max", Vi = "Maximum", dc = "MaxPool", fh$1 = "MaxPoolGrad", hc = "MaxPool3D", mh$1 = "MaxPool3DGrad", Ug$1 = "MaxPoolWithArgmax", pc = "Mean", fc = "Min", zi = "Minimum", mc = "MirrorPad", Xi = "Mod", Yg$1 = "Multinomial", Pi = "Multiply", gc = "Neg", bc = "NotEqual", gh$1 = "NonMaxSuppressionV3", bh$1 = "NonMaxSuppressionV4", xh$1 = "NonMaxSuppressionV5", xc = "OnesLike", yc = "OneHot", wc = "Pack", Ic = "PadV2", E4 = "Pool", Ai = "Pow", Cc = "Prelu", vc = "Prod", Qg$1 = "RaggedGather", Jg$1 = "RaggedRange", jg$1 = "RaggedTensorToTensor", yh$1 = "Range", wh$1 = "Real", Oi = "Reciprocal", Ki = "Relu", Sc = "Reshape", kc = "ResizeNearestNeighbor", Ih$1 = "ResizeNearestNeighborGrad", Tc = "ResizeBilinear", Ch$1 = "ResizeBilinearGrad", Zi = "Relu6", Nc = "Reverse", Bi = "Round", Hi = "Rsqrt", qg$1 = "ScatterNd", tb$1 = "SearchSorted", Rc = "Select", _i = "Selu", $c = "Slice", Ui = "Sin", Yi = "Sinh", Qi = "Sign", Ji = "Sigmoid", ji = "Softplus", qi = "Sqrt", Gc = "Sum", Ec = "SpaceToBatchND", Lc = "SplitV", Mc = "Softmax", vh$1 = "SparseFillEmptyRows", Sh$1 = "SparseReshape", kh$1 = "SparseSegmentMean", Th$1 = "SparseSegmentSum", eb$1 = "SparseToDense", ta = "SquaredDifference", Nh$1 = "Square", Rh$1 = "StridedSlice", $h$1 = "StringNGrams", Gh$1 = "StringSplit", Eh$1 = "StringToHashBucketFast", ea = "Sub", na = "Tan", sa = "Tanh", oa = "Tile", Lh$1 = "TopK", Mh$1 = "Transform", Jo = "Transpose", Wh$1 = "Unique", Wc = "Unpack", Dc = "UnsortedSegmentSum", L4 = "UpperBound", Fc = "ZerosLike", ra = "Step", sd = "FromPixels", Dh$1 = "RotateWithOffset", ol = "_FusedMatMul", rl = "FusedConv2D", nb$1 = "FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rn$1(...n) {
  F().getBool("IS_TEST") || F().getBool("PROD") || console.warn(...n);
}
function _I(...n) {
  F().getBool("IS_TEST") || F().getBool("PROD") || console.log(...n);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sr = Zd$1("kernelRegistry", () => /* @__PURE__ */ new Map()), Yr$1 = Zd$1("gradRegistry", () => /* @__PURE__ */ new Map());
function od(n, t) {
  const e = Fh$1(n, t);
  return sr.get(e);
}
function Hf$1(n) {
  return Yr$1.get(n);
}
function rd(n) {
  const t = sr.entries(), e = [];
  for (; ; ) {
    const { done: s, value: o } = t.next();
    if (s)
      break;
    const [r, i6] = o, [a] = r.split("_");
    a === n && e.push(i6);
  }
  return e;
}
function en$1(n) {
  const { kernelName: t, backendName: e } = n, s = Fh$1(t, e);
  sr.has(s) && rn$1(`The kernel '${t}' for backend '${e}' is already registered`), sr.set(s, n);
}
function UI(n) {
  const { kernelName: t } = n;
  Yr$1.has(t) && F().getBool("DEBUG") && rn$1(`Overriding the gradient for '${t}'`), Yr$1.set(t, n);
}
function M4(n, t) {
  const e = Fh$1(n, t);
  if (!sr.has(e))
    throw new Error(`The kernel '${n}' for backend '${t}' is not registered`);
  sr.delete(e);
}
function W4(n) {
  if (!Yr$1.has(n))
    throw new Error(`The gradient '${n}' for backend is not registered`);
  Yr$1.delete(n);
}
function D4(n, t) {
  rd(n).forEach((s) => {
    const o = Object.assign({}, s, { backendName: t });
    en$1(o);
  });
}
function Fh$1(n, t) {
  return `${t}_${n}`;
}
var sb$1 = Bt$1, yn$1 = null;
try {
  yn$1 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch {
}
function Bt$1(n, t, e) {
  this.low = n | 0, this.high = t | 0, this.unsigned = !!e;
}
Bt$1.prototype.__isLong__;
Object.defineProperty(Bt$1.prototype, "__isLong__", { value: true });
function nn$1(n) {
  return (n && n.__isLong__) === true;
}
Bt$1.isLong = nn$1;
var _f$1 = {}, Uf$1 = {};
function Wo(n, t) {
  var e, s, o;
  return t ? (n >>>= 0, (o = 0 <= n && n < 256) && (s = Uf$1[n], s) ? s : (e = Ht$1(n, (n | 0) < 0 ? -1 : 0, true), o && (Uf$1[n] = e), e)) : (n |= 0, (o = -128 <= n && n < 128) && (s = _f$1[n], s) ? s : (e = Ht$1(n, n < 0 ? -1 : 0, false), o && (_f$1[n] = e), e));
}
Bt$1.fromInt = Wo;
function wn$1(n, t) {
  if (isNaN(n))
    return t ? lo : In$1;
  if (t) {
    if (n < 0)
      return lo;
    if (n >= ob$1)
      return ab$1;
  } else {
    if (n <= -Qf$1)
      return Qe$1;
    if (n + 1 >= Qf$1)
      return ib$1;
  }
  return n < 0 ? wn$1(-n, t).neg() : Ht$1(n % or | 0, n / or | 0, t);
}
Bt$1.fromNumber = wn$1;
function Ht$1(n, t, e) {
  return new Bt$1(n, t, e);
}
Bt$1.fromBits = Ht$1;
var il = Math.pow;
function Vh$1(n, t, e) {
  if (n.length === 0)
    throw Error("empty string");
  if (n === "NaN" || n === "Infinity" || n === "+Infinity" || n === "-Infinity")
    return In$1;
  if (typeof t == "number" ? (e = t, t = false) : t = !!t, e = e || 10, e < 2 || 36 < e)
    throw RangeError("radix");
  var s;
  if ((s = n.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (s === 0)
    return Vh$1(n.substring(1), t, e).neg();
  for (var o = wn$1(il(e, 8)), r = In$1, i6 = 0; i6 < n.length; i6 += 8) {
    var a = Math.min(8, n.length - i6), l = parseInt(n.substring(i6, i6 + a), e);
    if (a < 8) {
      var c = wn$1(il(e, a));
      r = r.mul(c).add(wn$1(l));
    } else
      r = r.mul(o), r = r.add(wn$1(l));
  }
  return r.unsigned = t, r;
}
Bt$1.fromString = Vh$1;
function Bn$1(n, t) {
  return typeof n == "number" ? wn$1(n, t) : typeof n == "string" ? Vh$1(n, t) : Ht$1(n.low, n.high, typeof t == "boolean" ? t : n.unsigned);
}
Bt$1.fromValue = Bn$1;
var Yf$1 = 65536, YI = 1 << 24, or = Yf$1 * Yf$1, ob$1 = or * or, Qf$1 = ob$1 / 2, Jf$1 = Wo(YI), In$1 = Wo(0);
Bt$1.ZERO = In$1;
var lo = Wo(0, true);
Bt$1.UZERO = lo;
var Yo = Wo(1);
Bt$1.ONE = Yo;
var rb$1 = Wo(1, true);
Bt$1.UONE = rb$1;
var id = Wo(-1);
Bt$1.NEG_ONE = id;
var ib$1 = Ht$1(-1, 2147483647, false);
Bt$1.MAX_VALUE = ib$1;
var ab$1 = Ht$1(-1, -1, true);
Bt$1.MAX_UNSIGNED_VALUE = ab$1;
var Qe$1 = Ht$1(0, -2147483648, false);
Bt$1.MIN_VALUE = Qe$1;
var tt = Bt$1.prototype;
tt.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
tt.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * or + (this.low >>> 0) : this.high * or + (this.low >>> 0);
};
tt.toString = function(t) {
  if (t = t || 10, t < 2 || 36 < t)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(Qe$1)) {
      var e = wn$1(t), s = this.div(e), o = s.mul(e).sub(this);
      return s.toString(t) + o.toInt().toString(t);
    } else
      return "-" + this.neg().toString(t);
  for (var r = wn$1(il(t, 6), this.unsigned), i6 = this, a = ""; ; ) {
    var l = i6.div(r), c = i6.sub(l.mul(r)).toInt() >>> 0, u = c.toString(t);
    if (i6 = l, i6.isZero())
      return u + a;
    for (; u.length < 6; )
      u = "0" + u;
    a = "" + u + a;
  }
};
tt.getHighBits = function() {
  return this.high;
};
tt.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
tt.getLowBits = function() {
  return this.low;
};
tt.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
tt.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(Qe$1) ? 64 : this.neg().getNumBitsAbs();
  for (var t = this.high != 0 ? this.high : this.low, e = 31; e > 0 && !(t & 1 << e); e--)
    ;
  return this.high != 0 ? e + 33 : e + 1;
};
tt.isZero = function() {
  return this.high === 0 && this.low === 0;
};
tt.eqz = tt.isZero;
tt.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
tt.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
tt.isOdd = function() {
  return (this.low & 1) === 1;
};
tt.isEven = function() {
  return (this.low & 1) === 0;
};
tt.equals = function(t) {
  return nn$1(t) || (t = Bn$1(t)), this.unsigned !== t.unsigned && this.high >>> 31 === 1 && t.high >>> 31 === 1 ? false : this.high === t.high && this.low === t.low;
};
tt.eq = tt.equals;
tt.notEquals = function(t) {
  return !this.eq(
    /* validates */
    t
  );
};
tt.neq = tt.notEquals;
tt.ne = tt.notEquals;
tt.lessThan = function(t) {
  return this.comp(
    /* validates */
    t
  ) < 0;
};
tt.lt = tt.lessThan;
tt.lessThanOrEqual = function(t) {
  return this.comp(
    /* validates */
    t
  ) <= 0;
};
tt.lte = tt.lessThanOrEqual;
tt.le = tt.lessThanOrEqual;
tt.greaterThan = function(t) {
  return this.comp(
    /* validates */
    t
  ) > 0;
};
tt.gt = tt.greaterThan;
tt.greaterThanOrEqual = function(t) {
  return this.comp(
    /* validates */
    t
  ) >= 0;
};
tt.gte = tt.greaterThanOrEqual;
tt.ge = tt.greaterThanOrEqual;
tt.compare = function(t) {
  if (nn$1(t) || (t = Bn$1(t)), this.eq(t))
    return 0;
  var e = this.isNegative(), s = t.isNegative();
  return e && !s ? -1 : !e && s ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;
};
tt.comp = tt.compare;
tt.negate = function() {
  return !this.unsigned && this.eq(Qe$1) ? Qe$1 : this.not().add(Yo);
};
tt.neg = tt.negate;
tt.add = function(t) {
  nn$1(t) || (t = Bn$1(t));
  var e = this.high >>> 16, s = this.high & 65535, o = this.low >>> 16, r = this.low & 65535, i6 = t.high >>> 16, a = t.high & 65535, l = t.low >>> 16, c = t.low & 65535, u = 0, d = 0, h6 = 0, p6 = 0;
  return p6 += r + c, h6 += p6 >>> 16, p6 &= 65535, h6 += o + l, d += h6 >>> 16, h6 &= 65535, d += s + a, u += d >>> 16, d &= 65535, u += e + i6, u &= 65535, Ht$1(h6 << 16 | p6, u << 16 | d, this.unsigned);
};
tt.subtract = function(t) {
  return nn$1(t) || (t = Bn$1(t)), this.add(t.neg());
};
tt.sub = tt.subtract;
tt.multiply = function(t) {
  if (this.isZero())
    return In$1;
  if (nn$1(t) || (t = Bn$1(t)), yn$1) {
    var e = yn$1.mul(
      this.low,
      this.high,
      t.low,
      t.high
    );
    return Ht$1(e, yn$1.get_high(), this.unsigned);
  }
  if (t.isZero())
    return In$1;
  if (this.eq(Qe$1))
    return t.isOdd() ? Qe$1 : In$1;
  if (t.eq(Qe$1))
    return this.isOdd() ? Qe$1 : In$1;
  if (this.isNegative())
    return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();
  if (t.isNegative())
    return this.mul(t.neg()).neg();
  if (this.lt(Jf$1) && t.lt(Jf$1))
    return wn$1(this.toNumber() * t.toNumber(), this.unsigned);
  var s = this.high >>> 16, o = this.high & 65535, r = this.low >>> 16, i6 = this.low & 65535, a = t.high >>> 16, l = t.high & 65535, c = t.low >>> 16, u = t.low & 65535, d = 0, h6 = 0, p6 = 0, f = 0;
  return f += i6 * u, p6 += f >>> 16, f &= 65535, p6 += r * u, h6 += p6 >>> 16, p6 &= 65535, p6 += i6 * c, h6 += p6 >>> 16, p6 &= 65535, h6 += o * u, d += h6 >>> 16, h6 &= 65535, h6 += r * c, d += h6 >>> 16, h6 &= 65535, h6 += i6 * l, d += h6 >>> 16, h6 &= 65535, d += s * u + o * c + r * l + i6 * a, d &= 65535, Ht$1(p6 << 16 | f, d << 16 | h6, this.unsigned);
};
tt.mul = tt.multiply;
tt.divide = function(t) {
  if (nn$1(t) || (t = Bn$1(t)), t.isZero())
    throw Error("division by zero");
  if (yn$1) {
    if (!this.unsigned && this.high === -2147483648 && t.low === -1 && t.high === -1)
      return this;
    var e = (this.unsigned ? yn$1.div_u : yn$1.div_s)(
      this.low,
      this.high,
      t.low,
      t.high
    );
    return Ht$1(e, yn$1.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? lo : In$1;
  var s, o, r;
  if (this.unsigned) {
    if (t.unsigned || (t = t.toUnsigned()), t.gt(this))
      return lo;
    if (t.gt(this.shru(1)))
      return rb$1;
    r = lo;
  } else {
    if (this.eq(Qe$1)) {
      if (t.eq(Yo) || t.eq(id))
        return Qe$1;
      if (t.eq(Qe$1))
        return Yo;
      var i6 = this.shr(1);
      return s = i6.div(t).shl(1), s.eq(In$1) ? t.isNegative() ? Yo : id : (o = this.sub(t.mul(s)), r = s.add(o.div(t)), r);
    } else if (t.eq(Qe$1))
      return this.unsigned ? lo : In$1;
    if (this.isNegative())
      return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();
    if (t.isNegative())
      return this.div(t.neg()).neg();
    r = In$1;
  }
  for (o = this; o.gte(t); ) {
    s = Math.max(1, Math.floor(o.toNumber() / t.toNumber()));
    for (var a = Math.ceil(Math.log(s) / Math.LN2), l = a <= 48 ? 1 : il(2, a - 48), c = wn$1(s), u = c.mul(t); u.isNegative() || u.gt(o); )
      s -= l, c = wn$1(s, this.unsigned), u = c.mul(t);
    c.isZero() && (c = Yo), r = r.add(c), o = o.sub(u);
  }
  return r;
};
tt.div = tt.divide;
tt.modulo = function(t) {
  if (nn$1(t) || (t = Bn$1(t)), yn$1) {
    var e = (this.unsigned ? yn$1.rem_u : yn$1.rem_s)(
      this.low,
      this.high,
      t.low,
      t.high
    );
    return Ht$1(e, yn$1.get_high(), this.unsigned);
  }
  return this.sub(this.div(t).mul(t));
};
tt.mod = tt.modulo;
tt.rem = tt.modulo;
tt.not = function() {
  return Ht$1(~this.low, ~this.high, this.unsigned);
};
tt.and = function(t) {
  return nn$1(t) || (t = Bn$1(t)), Ht$1(this.low & t.low, this.high & t.high, this.unsigned);
};
tt.or = function(t) {
  return nn$1(t) || (t = Bn$1(t)), Ht$1(this.low | t.low, this.high | t.high, this.unsigned);
};
tt.xor = function(t) {
  return nn$1(t) || (t = Bn$1(t)), Ht$1(this.low ^ t.low, this.high ^ t.high, this.unsigned);
};
tt.shiftLeft = function(t) {
  return nn$1(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? Ht$1(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : Ht$1(0, this.low << t - 32, this.unsigned);
};
tt.shl = tt.shiftLeft;
tt.shiftRight = function(t) {
  return nn$1(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? Ht$1(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : Ht$1(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
tt.shr = tt.shiftRight;
tt.shiftRightUnsigned = function(t) {
  if (nn$1(t) && (t = t.toInt()), t &= 63, t === 0)
    return this;
  var e = this.high;
  if (t < 32) {
    var s = this.low;
    return Ht$1(s >>> t | e << 32 - t, e >>> t, this.unsigned);
  } else
    return t === 32 ? Ht$1(e, 0, this.unsigned) : Ht$1(e >>> t - 32, 0, this.unsigned);
};
tt.shru = tt.shiftRightUnsigned;
tt.shr_u = tt.shiftRightUnsigned;
tt.toSigned = function() {
  return this.unsigned ? Ht$1(this.low, this.high, false) : this;
};
tt.toUnsigned = function() {
  return this.unsigned ? this : Ht$1(this.low, this.high, true);
};
tt.toBytes = function(t) {
  return t ? this.toBytesLE() : this.toBytesBE();
};
tt.toBytesLE = function() {
  var t = this.high, e = this.low;
  return [
    e & 255,
    e >>> 8 & 255,
    e >>> 16 & 255,
    e >>> 24,
    t & 255,
    t >>> 8 & 255,
    t >>> 16 & 255,
    t >>> 24
  ];
};
tt.toBytesBE = function() {
  var t = this.high, e = this.low;
  return [
    t >>> 24,
    t >>> 16 & 255,
    t >>> 8 & 255,
    t & 255,
    e >>> 24,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255
  ];
};
Bt$1.fromBytes = function(t, e, s) {
  return s ? Bt$1.fromBytesLE(t, e) : Bt$1.fromBytesBE(t, e);
};
Bt$1.fromBytesLE = function(t, e) {
  return new Bt$1(
    t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24,
    t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24,
    e
  );
};
Bt$1.fromBytesBE = function(t, e) {
  return new Bt$1(
    t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7],
    t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3],
    e
  );
};
const lb$1 = /* @__PURE__ */ M(sb$1), QI = /* @__PURE__ */ GI({
  __proto__: null,
  default: lb$1
}, [sb$1]);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oo = (
  // tslint:disable-next-line
  lb$1 || QI
);
function ia(n) {
  return oo.fromString(n, true, 16);
}
const cb$1 = ia("c3a5c85c97cb3127"), so = ia("b492b66fbe98f273"), Me = ia("9ae16a3b2f90404f");
function ad(n) {
  return n.xor(n.shru(47));
}
function ub$1(n, t, e) {
  const s = n.slice(t, t + e);
  return oo.fromBytes(Array.from(s), true, true);
}
function Pt$1(n, t) {
  return ub$1(n, t, 8);
}
function jf$1(n, t) {
  return ub$1(n, t, 4);
}
function me(n, t) {
  return t === 0 ? n : n.shru(t).or(n.shl(64 - t));
}
function Ms(n, t, e = ia("9ddfea08eb382d69")) {
  let s = n.xor(t).mul(e);
  s = s.xor(s.shru(47));
  let o = t.xor(s).mul(e);
  return o = o.xor(o.shru(47)), o = o.mul(e), o;
}
function JI(n, t, e, s, o, r) {
  o = o.add(n), r = me(r.add(o).add(s), 21);
  const i6 = o;
  return o = o.add(t), o = o.add(e), r = r.add(me(o, 44)), [o.add(s), r.add(i6)];
}
function Wa(n, t, e, s) {
  return JI(Pt$1(n, t), Pt$1(n, t + 8), Pt$1(n, t + 16), Pt$1(n, t + 24), e, s);
}
function jI(n, t = n.length) {
  if (t >= 8) {
    const e = Me.add(t * 2), s = Pt$1(n, 0).add(Me), o = Pt$1(n, t - 8), r = me(o, 37).mul(e).add(s), i6 = me(s, 25).add(o).mul(e);
    return Ms(r, i6, e);
  }
  if (t >= 4) {
    const e = Me.add(t * 2), s = jf$1(n, 0);
    return Ms(s.shl(3).add(t), jf$1(n, t - 4), e);
  }
  if (t > 0) {
    const e = n[0], s = n[t >> 1], o = n[t - 1], r = e + (s << 8), i6 = t + (o << 2);
    return ad(Me.mul(r).xor(cb$1.mul(i6))).mul(Me);
  }
  return Me;
}
function qI(n, t = n.length) {
  const e = Me.add(t * 2), s = Pt$1(n, 0).mul(so), o = Pt$1(n, 8), r = Pt$1(n, t - 8).mul(e), i6 = Pt$1(n, t - 16).mul(Me);
  return Ms(me(s.add(o), 43).add(me(r, 30)).add(i6), s.add(me(o.add(Me), 18)).add(r), e);
}
function tC(n, t = n.length) {
  const e = Me.add(t * 2), s = Pt$1(n, 0).mul(Me), o = Pt$1(n, 8), r = Pt$1(n, t - 8).mul(e), i6 = Pt$1(n, t - 16).mul(Me), a = me(s.add(o), 43).add(me(r, 30)).add(i6), l = Ms(a, s.add(me(o.add(Me), 18)).add(r), e), c = Pt$1(n, 16).mul(e), u = Pt$1(n, 24), d = a.add(Pt$1(n, t - 32)).mul(e), h6 = l.add(Pt$1(n, t - 24)).mul(e);
  return Ms(me(c.add(u), 43).add(me(d, 30)).add(h6), c.add(me(u.add(s), 18)).add(d), e);
}
function db$1(n, t = n.length) {
  const e = oo.fromNumber(81, true);
  if (t <= 32)
    return t <= 16 ? jI(n, t) : qI(n, t);
  if (t <= 64)
    return tC(n, t);
  let s = e, o = e.mul(so).add(113), r = ad(o.mul(Me).add(113)).mul(Me), i6 = [oo.UZERO, oo.UZERO], a = [oo.UZERO, oo.UZERO];
  s = s.mul(Me).add(Pt$1(n, 0));
  let l = 0;
  const c = (t - 1 >> 6) * 64, u = c + (t - 1 & 63) - 63;
  do
    s = me(s.add(o).add(i6[0]).add(Pt$1(n, l + 8)), 37).mul(so), o = me(o.add(i6[1]).add(Pt$1(n, l + 48)), 42).mul(so), s = s.xor(a[1]), o = o.add(i6[0]).add(Pt$1(n, l + 40)), r = me(r.add(a[0]), 33).mul(so), i6 = Wa(n, l, i6[1].mul(so), s.add(a[0])), a = Wa(n, l + 32, r.add(a[1]), o.add(Pt$1(n, l + 16))), [r, s] = [s, r], l += 64;
  while (l !== c);
  const d = so.add(r.and(255).shl(1));
  return l = u, a[0] = a[0].add(t - 1 & 63), i6[0] = i6[0].add(a[0]), a[0] = a[0].add(i6[0]), s = me(s.add(o).add(i6[0]).add(Pt$1(n, l + 8)), 37).mul(d), o = me(o.add(i6[1]).add(Pt$1(n, l + 48)), 42).mul(d), s = s.xor(a[1].mul(9)), o = o.add(i6[0].mul(9).add(Pt$1(n, l + 40))), r = me(r.add(a[0]), 33).mul(d), i6 = Wa(n, l, i6[1].mul(d), s.add(a[0])), a = Wa(n, l + 32, r.add(a[1]), o.add(Pt$1(n, l + 16))), [r, s] = [s, r], Ms(Ms(i6[0], a[0], d).add(ad(o).mul(cb$1)).add(r), Ms(i6[1], a[1], d).add(s), d);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bs(n, t) {
  return t === "string" ? hs(n) : Zs([n], t);
}
function eC(n, t) {
  return n instanceof Float32Array && t === "float32" || n instanceof Int32Array && t === "int32" || n instanceof Uint8Array && t === "bool";
}
function Zs(n, t) {
  if (t === "string")
    throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(n) && (n = zs(n)), F().getBool("DEBUG") && Dg$1(n, t), eC(n, t))
    return n;
  if (t == null || t === "float32" || t === "complex64")
    return new Float32Array(n);
  if (t === "int32")
    return new Int32Array(n);
  if (t === "bool") {
    const e = new Uint8Array(n.length);
    for (let s = 0; s < e.length; ++s)
      Math.round(n[s]) !== 0 && (e[s] = 1);
    return e;
  } else
    throw new Error(`Unknown data type ${t}`);
}
function Ce$1() {
  return F().platform.now();
}
function nC(n, t) {
  return F().platform.fetch(n, t);
}
function hs(n, t = "utf-8") {
  return t = t || "utf-8", F().platform.encode(n, t);
}
function ps(n, t = "utf-8") {
  return t = t || "utf-8", F().platform.decode(n, t);
}
function dn$1(n) {
  return F().platform.isTypedArray(n);
}
function zs(n, t = [], e = false) {
  if (t == null && (t = []), typeof n == "boolean" || typeof n == "number" || typeof n == "string" || ui$1(n) || n == null || dn$1(n) && e)
    t.push(n);
  else if (Array.isArray(n) || dn$1(n))
    for (let s = 0; s < n.length; ++s)
      zs(n[s], t, e);
  else {
    let s = -1;
    for (const o of Object.keys(n))
      /^([1-9]+[0-9]*|0)$/.test(o) && (s = Math.max(s, Number(o)));
    for (let o = 0; o <= s; o++)
      zs(n[o], t, e);
  }
  return t;
}
const F4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arraysEqual: Rt$1,
  assert: v,
  assertNonNegativeIntegerDimensions: is,
  assertNonNull: Dl,
  assertShapesMatch: Ve,
  bytesFromStringArray: Vg$1,
  bytesPerElement: Ur,
  checkConversionForErrors: Dg$1,
  clamp: Fs,
  computeStrides: dt,
  convertBackendValuesAndArrayBuffer: Pg$1,
  createScalarValue: bs,
  createShuffledIndices: zI,
  decodeString: ps,
  distSquared: DI,
  encodeString: hs,
  fetch: nC,
  fingerPrint64: db$1,
  flatten: zs,
  getArrayFromDType: oe,
  getTypedArrayFromDType: xe$1,
  hasEncodingLoss: Od$1,
  hexToLong: ia,
  indexToLoc: Mo,
  inferDtype: gr,
  inferFromImplicitShape: Ad$1,
  isBoolean: zg$1,
  isFunction: Vs,
  isInt: go,
  isNumber: nl,
  isPromise: ui$1,
  isScalarShape: FI,
  isString: mr,
  isTypedArray: dn$1,
  isValidDtype: Fg$1,
  locToIndex: zn$1,
  makeOnesTypedArray: Fl,
  makeZerosNestedTypedArray: Kd$1,
  makeZerosTypedArray: Se,
  nearestDivisor: sl,
  nearestLargerEven: Wl,
  now: Ce$1,
  parseAxisParam: Ct,
  randUniform: WI,
  repeatedTry: td,
  rightPad: ho,
  shuffle: Pd$1,
  shuffleCombo: MI,
  sizeFromShape: O,
  sizeToSquarishShape: el,
  squeezeShape: gs,
  sum: Wg$1,
  swap: us,
  tanh: VI,
  toNestedArray: Sn$1,
  toTypedArray: Zs
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class sC {
  constructor(t, e) {
    this.backendTimer = t, this.logger = e, e == null && (this.logger = new rC());
  }
  profileKernel(t, e, s) {
    let o;
    const r = () => {
      o = s();
    };
    let i6;
    const a = Ce$1();
    if (this.backendTimer.timerAvailable())
      i6 = this.backendTimer.time(r);
    else {
      r();
      for (const c of o)
        c.dataSync();
      i6 = Promise.resolve({ kernelMs: Ce$1() - a });
    }
    if (F().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
      for (let c = 0; c < o.length; c++) {
        const u = o[c];
        u.data().then((d) => {
          oC(d, u.dtype, t);
        });
      }
    return {
      kernelName: t,
      outputs: o,
      inputs: e,
      timeMs: i6.then((c) => c.kernelMs),
      extraInfo: i6.then((c) => c.getExtraProfileInfo != null ? c.getExtraProfileInfo() : "")
    };
  }
  logKernelProfile(t) {
    const { kernelName: e, outputs: s, timeMs: o, inputs: r, extraInfo: i6 } = t;
    s.forEach((a) => {
      Promise.all([a.data(), o, i6]).then((l) => {
        this.logger.logKernelProfile(e, a, l[0], l[1], r, l[2]);
      });
    });
  }
}
function oC(n, t, e) {
  if (t !== "float32")
    return false;
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    if (isNaN(o) || !isFinite(o))
      return console.warn(`Found ${o} in the result of '${e}'`), true;
  }
  return false;
}
class rC {
  logKernelProfile(t, e, s, o, r, i6) {
    const a = typeof o == "number" ? ho(`${o}ms`, 9) : o.error, l = ho(t, 25), c = e.rank, u = e.size, d = ho(e.shape.toString(), 14);
    let h6 = "";
    for (const p6 in r) {
      const f = r[p6];
      if (f != null) {
        const m = f.shape || e.shape, g6 = m.length;
        h6 += `${p6}: ${g6}D ${g6 > 0 ? m : ""} `;
      }
    }
    console.log(`%c${l}	%c${a}	%c${c}D ${d}	%c${u}	%c${h6}	%c${i6}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iC(n, t, e) {
  const s = {}, o = {};
  for (let l = 0; l < t.length; l++)
    s[t[l].id] = true;
  for (let l = 0; l < n.length; l++) {
    const c = n[l], u = c.inputs;
    for (const d in u) {
      const h6 = u[d];
      let p6 = false;
      for (let f = 0; f < t.length; f++)
        if (s[h6.id]) {
          c.outputs.forEach((m) => s[m.id] = true), p6 = true, o[c.id] = true;
          break;
        }
      if (p6)
        break;
    }
  }
  const r = {};
  r[e.id] = true;
  const i6 = {};
  for (let l = n.length - 1; l >= 0; l--) {
    const c = n[l], u = c.inputs;
    for (let d = 0; d < c.outputs.length; d++)
      if (r[c.outputs[d].id]) {
        for (const h6 in u)
          r[u[h6].id] = true, i6[c.id] = true;
        break;
      }
  }
  const a = [];
  for (let l = 0; l < n.length; l++) {
    const c = n[l];
    if (o[c.id] && i6[c.id]) {
      const u = {};
      for (const h6 in c.inputs) {
        const p6 = c.inputs[h6];
        s[p6.id] && (u[h6] = p6);
      }
      const d = Object.assign({}, c);
      d.inputs = u, d.outputs = c.outputs, a.push(d);
    }
  }
  return a;
}
function aC(n, t, e, s) {
  for (let o = t.length - 1; o >= 0; o--) {
    const r = t[o], i6 = [];
    if (r.outputs.forEach((l) => {
      const c = n[l.id];
      c != null ? i6.push(c) : i6.push(null);
    }), r.gradient == null)
      throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);
    const a = r.gradient(i6);
    for (const l in r.inputs) {
      if (!(l in a))
        throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);
      const c = e(() => a[l]());
      if (c.dtype !== "float32")
        throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);
      const u = r.inputs[l];
      if (!Rt$1(c.shape, u.shape))
        throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);
      if (n[u.id] == null)
        n[u.id] = c;
      else {
        const d = n[u.id];
        n[u.id] = s(d, c), d.dispose();
      }
    }
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qf$1 = 20, Mr$1 = 3, wu = 7;
function lC(n, t, e, s) {
  const o = dt(t), r = cC(n, t, e, o), i6 = t.length, a = Ja(n, t, e, o, r), l = ["Tensor"];
  return s && (l.push(`  dtype: ${e}`), l.push(`  rank: ${i6}`), l.push(`  shape: [${t}]`), l.push("  values:")), l.push(a.map((c) => "    " + c).join(`
`)), l.join(`
`);
}
function cC(n, t, e, s) {
  const o = O(t), r = s[s.length - 1], i6 = new Array(r).fill(0), a = t.length, l = e === "complex64" ? Pr(n) : n;
  if (a > 1)
    for (let c = 0; c < o / r; c++) {
      const u = c * r;
      for (let d = 0; d < r; d++)
        i6[d] = Math.max(i6[d], Xr(l[u + d], 0, e).length);
    }
  return i6;
}
function Xr(n, t, e) {
  let s;
  return Array.isArray(n) ? s = `${parseFloat(n[0].toFixed(wu))} + ${parseFloat(n[1].toFixed(wu))}j` : mr(n) ? s = `'${n}'` : e === "bool" ? s = hb$1(n) : s = parseFloat(n.toFixed(wu)).toString(), ho(s, t);
}
function hb$1(n) {
  return n === 0 ? "false" : "true";
}
function Ja(n, t, e, s, o, r = true) {
  const i6 = e === "complex64" ? 2 : 1, a = t[0], l = t.length;
  if (l === 0) {
    if (e === "complex64") {
      const m = Pr(n);
      return [Xr(m[0], 0, e)];
    }
    return e === "bool" ? [hb$1(n[0])] : [n[0].toString()];
  }
  if (l === 1) {
    if (a > qf$1) {
      const g6 = Mr$1 * i6;
      let b6 = Array.from(n.slice(0, g6)), x6 = Array.from(n.slice((a - Mr$1) * i6, a * i6));
      return e === "complex64" && (b6 = Pr(b6), x6 = Pr(x6)), [
        "[" + b6.map((w6, y6) => Xr(w6, o[y6], e)).join(", ") + ", ..., " + x6.map((w6, y6) => Xr(w6, o[a - Mr$1 + y6], e)).join(", ") + "]"
      ];
    }
    return [
      "[" + (e === "complex64" ? Pr(n) : Array.from(n)).map((g6, b6) => Xr(g6, o[b6], e)).join(", ") + "]"
    ];
  }
  const c = t.slice(1), u = s.slice(1), d = s[0] * i6, h6 = [];
  if (a > qf$1) {
    for (let m = 0; m < Mr$1; m++) {
      const g6 = m * d, b6 = g6 + d;
      h6.push(...Ja(
        n.slice(g6, b6),
        c,
        e,
        u,
        o,
        false
        /* isLast */
      ));
    }
    h6.push("...");
    for (let m = a - Mr$1; m < a; m++) {
      const g6 = m * d, b6 = g6 + d;
      h6.push(...Ja(
        n.slice(g6, b6),
        c,
        e,
        u,
        o,
        m === a - 1
        /* isLast */
      ));
    }
  } else
    for (let m = 0; m < a; m++) {
      const g6 = m * d, b6 = g6 + d;
      h6.push(...Ja(
        n.slice(g6, b6),
        c,
        e,
        u,
        o,
        m === a - 1
        /* isLast */
      ));
    }
  const p6 = l === 2 ? "," : "";
  h6[0] = "[" + (a > 0 ? h6[0] + p6 : "");
  for (let m = 1; m < h6.length - 1; m++)
    h6[m] = " " + h6[m] + p6;
  let f = `,
`;
  for (let m = 2; m < l; m++)
    f += `
`;
  return h6[h6.length - 1] = " " + h6[h6.length - 1] + "]" + (r ? "" : f), h6;
}
function Pr(n) {
  const t = [];
  for (let e = 0; e < n.length; e += 2)
    t.push([n[e], n[e + 1]]);
  return t;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class $e {
  constructor(t, e, s) {
    if (this.dtype = e, this.shape = t.slice(), this.size = O(t), s != null) {
      const o = s.length;
      v(o === this.size, () => `Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`);
    }
    if (e === "complex64")
      throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = s || oe(e, this.size), this.strides = dt(t);
  }
  /**
   * Sets a value in the buffer at a given location.
   *
   * @param value The value to set.
   * @param locs  The location indices.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  set(t, ...e) {
    e.length === 0 && (e = [0]), v(e.length === this.rank, () => `The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);
    const s = this.locToIndex(e);
    this.values[s] = t;
  }
  /**
   * Returns the value in the buffer at the provided location.
   *
   * @param locs The location indices.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  get(...t) {
    t.length === 0 && (t = [0]);
    let e = 0;
    for (const o of t) {
      if (o < 0 || o >= this.shape[e]) {
        const r = `Requested out of range element at ${t}.   Buffer shape=${this.shape}`;
        throw new Error(r);
      }
      e++;
    }
    let s = t[t.length - 1];
    for (let o = 0; o < t.length - 1; ++o)
      s += this.strides[o] * t[o];
    return this.values[s];
  }
  locToIndex(t) {
    if (this.rank === 0)
      return 0;
    if (this.rank === 1)
      return t[0];
    let e = t[t.length - 1];
    for (let s = 0; s < t.length - 1; ++s)
      e += this.strides[s] * t[s];
    return e;
  }
  indexToLoc(t) {
    if (this.rank === 0)
      return [];
    if (this.rank === 1)
      return [t];
    const e = new Array(this.shape.length);
    for (let s = 0; s < e.length - 1; ++s)
      e[s] = Math.floor(t / this.strides[s]), t -= e[s] * this.strides[s];
    return e[e.length - 1] = t, e;
  }
  get rank() {
    return this.shape.length;
  }
  /**
   * Creates an immutable `tf.Tensor` object from the buffer.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  toTensor() {
    return Dn$1().makeTensor(this.values, this.shape, this.dtype);
  }
}
let Dn$1 = null, _o = null;
function uC(n) {
  Dn$1 = n;
}
function dC(n) {
  _o = n;
}
let Lt$1 = class Lt {
  constructor(t, e, s, o) {
    this.kept = false, this.isDisposedInternal = false, this.shape = t.slice(), this.dtype = e || "float32", this.size = O(t), this.strides = dt(t), this.dataId = s, this.id = o, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  /**
   * Returns a promise of `tf.TensorBuffer` that holds the underlying data.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async buffer() {
    const t = await this.data();
    return _o.buffer(this.shape, this.dtype, t);
  }
  /**
   * Returns a `tf.TensorBuffer` that holds the underlying data.
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  bufferSync() {
    return _o.buffer(this.shape, this.dtype, this.dataSync());
  }
  /**
   * Returns the tensor data as a nested array. The transfer of data is done
   * asynchronously.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async array() {
    const t = await this.data();
    return Sn$1(this.shape, t, this.dtype === "complex64");
  }
  /**
   * Returns the tensor data as a nested array. The transfer of data is done
   * synchronously.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  arraySync() {
    return Sn$1(this.shape, this.dataSync(), this.dtype === "complex64");
  }
  /**
   * Asynchronously downloads the values from the `tf.Tensor`. Returns a
   * promise of `TypedArray` that resolves when the computation has finished.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async data() {
    this.throwIfDisposed();
    const t = Dn$1().read(this.dataId);
    if (this.dtype === "string") {
      const e = await t;
      try {
        return e.map((s) => ps(s));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return t;
  }
  /**
   * Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`
   * and `data()`, this method prevents data from being downloaded to CPU.
   *
   * For WebGL backend, the data will be stored on a densely packed texture.
   * This means that the texture will use the RGBA channels to store value.
   *
   * For WebGPU backend, the data will be stored on a buffer. There is no
   * parameter, so can not use a user-defined size to create the buffer.
   *
   * @param options:
   *     For WebGL,
   *         - customTexShape: Optional. If set, will use the user defined
   *     texture shape to create the texture.
   *
   * @returns For WebGL backend, a GPUData contains the new texture and
   *     its information.
   *     {
   *        tensorRef: The tensor that is associated with this texture,
   *        texture: WebGLTexture,
   *        texShape: [number, number] // [height, width]
   *     }
   *
   *     For WebGPU backend, a GPUData contains the new buffer and
   *     its information.
   *     {
   *        tensorRef: The tensor that is associated with this buffer,
   *        buffer: GPUBuffer,
   *        bufSize: number
   *     }
   *
   *     Remember to dispose the GPUData after it is used by
   *     `res.tensorRef.dispose()`.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dataToGPU(t) {
    return this.throwIfDisposed(), Dn$1().readToGPU(this.dataId, t);
  }
  /**
   * Synchronously downloads the values from the `tf.Tensor`. This blocks the
   * UI thread until the values are ready, which can cause performance issues.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dataSync() {
    this.throwIfDisposed();
    const t = Dn$1().readSync(this.dataId);
    if (this.dtype === "string")
      try {
        return t.map((e) => ps(e));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    return t;
  }
  /** Returns the underlying bytes of the tensor's data. */
  async bytes() {
    this.throwIfDisposed();
    const t = await Dn$1().read(this.dataId);
    return this.dtype === "string" ? t : new Uint8Array(t.buffer);
  }
  /**
   * Disposes `tf.Tensor` from memory.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dispose() {
    this.isDisposed || (Dn$1().disposeTensor(this), this.isDisposedInternal = true);
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed)
      throw new Error("Tensor is disposed.");
  }
  /**
   * Prints the `tf.Tensor`. See `tf.print` for details.
   *
   * @param verbose Whether to print verbose information about the tensor,
   *    including dtype and size.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  print(t = false) {
    return _o.print(this, t);
  }
  /**
   * Returns a copy of the tensor. See `tf.clone` for details.
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  clone() {
    return this.throwIfDisposed(), _o.clone(this);
  }
  /**
   * Returns a human-readable description of the tensor. Useful for logging.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  toString(t = false) {
    const e = this.dataSync();
    return lC(e, this.shape, this.dtype, t);
  }
  cast(t) {
    return this.throwIfDisposed(), _o.cast(this, t);
  }
  variable(t = true, e, s) {
    return this.throwIfDisposed(), Dn$1().makeVariable(this, t, e, s);
  }
};
Object.defineProperty(Lt$1, Symbol.hasInstance, {
  value: (n) => !!n && n.data != null && n.dataSync != null && n.throwIfDisposed != null
});
function K$1() {
  return Zd$1("Tensor", () => Lt$1);
}
K$1();
class al extends Lt$1 {
  constructor(t, e, s, o) {
    super(t.shape, t.dtype, t.dataId, o), this.trainable = e, this.name = s;
  }
  /**
   * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
   * the same shape and dtype as the old `tf.Tensor`.
   *
   * @param newValue New tensor to be assigned to this variable.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  assign(t) {
    if (t.dtype !== this.dtype)
      throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);
    if (!Rt$1(t.shape, this.shape))
      throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);
    Dn$1().disposeTensor(this), this.dataId = t.dataId, Dn$1().incRef(
      this,
      null
      /* backend */
    );
  }
  dispose() {
    Dn$1().disposeVariable(this), this.isDisposedInternal = true;
  }
}
Object.defineProperty(al, Symbol.hasInstance, {
  value: (n) => n instanceof Lt$1 && n.assign != null && n.assign instanceof Function
});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var tm;
(function(n) {
  n.R0 = "R0", n.R1 = "R1", n.R2 = "R2", n.R3 = "R3", n.R4 = "R4", n.R5 = "R5", n.R6 = "R6";
})(tm || (tm = {}));
var ld;
(function(n) {
  n.float32 = "float32", n.int32 = "int32", n.bool = "int32", n.complex64 = "complex64";
})(ld || (ld = {}));
var cd;
(function(n) {
  n.float32 = "float32", n.int32 = "int32", n.bool = "bool", n.complex64 = "complex64";
})(cd || (cd = {}));
var ud;
(function(n) {
  n.float32 = "float32", n.int32 = "float32", n.bool = "float32", n.complex64 = "complex64";
})(ud || (ud = {}));
var dd;
(function(n) {
  n.float32 = "complex64", n.int32 = "complex64", n.bool = "complex64", n.complex64 = "complex64";
})(dd || (dd = {}));
const hC = {
  float32: ud,
  int32: ld,
  bool: cd,
  complex64: dd
};
function je$1(n, t) {
  if (n === "string" || t === "string") {
    if (n === "string" && t === "string")
      return "string";
    throw new Error(`Can not upcast ${n} with ${t}`);
  }
  return hC[n][t];
}
function zh$1(n) {
  return je$1(n, "int32");
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ne$1(n, t) {
  if (n.dtype === t.dtype)
    return [n, t];
  const e = je$1(n.dtype, t.dtype);
  return [n.cast(e), t.cast(e)];
}
function pC(n, t) {
  v(n.dtype === t.dtype, () => `The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`);
}
function Vc(n, t) {
  return t.some((e) => e.id === n.id);
}
function fs(n) {
  const t = [];
  return pb$1(n, t, /* @__PURE__ */ new Set()), t;
}
function pb$1(n, t, e) {
  if (n == null)
    return;
  if (n instanceof Lt$1) {
    t.push(n);
    return;
  }
  if (!fC(n))
    return;
  const s = n;
  for (const o in s) {
    const r = s[o];
    e.has(r) || (e.add(r), pb$1(r, t, e));
  }
}
function fC(n) {
  return Array.isArray(n) || typeof n == "object";
}
const V4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertTypesMatch: pC,
  getTensorsInContainer: fs,
  isTensorInList: Vc,
  makeTypesMatch: ne$1
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Iu(n) {
  return n.kernelName != null;
}
class em {
  constructor() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,
      get kernelNames() {
        return Array.from(new Set(this.kernels.map((t) => t.name)));
      }
    };
  }
  dispose() {
    for (const t in this.registeredVariables)
      this.registeredVariables[t].dispose();
  }
}
class rr {
  constructor(t) {
    this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new em();
  }
  async ready() {
    if (this.pendingBackendInit != null)
      return this.pendingBackendInit.then(() => {
      });
    if (this.backendInstance != null)
      return;
    const t = this.getSortedBackends();
    for (let e = 0; e < t.length; e++) {
      const s = t[e];
      if (await this.initializeBackend(s).success) {
        await this.setBackend(s);
        return;
      }
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  get backend() {
    if (this.pendingBackendInit != null)
      throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
    if (this.backendInstance == null) {
      const { name: t, asyncInit: e } = this.initializeBackendsAndReturnBest();
      if (e)
        throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      this.setBackend(t);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(t) {
    if (!(t in this.registry))
      if (t in this.registryFactory) {
        const { asyncInit: e } = this.initializeBackend(t);
        if (e)
          return null;
      } else
        return null;
    return this.registry[t];
  }
  findBackendFactory(t) {
    return t in this.registryFactory ? this.registryFactory[t].factory : null;
  }
  registerBackend(t, e, s = 1) {
    return t in this.registryFactory ? (rn$1(`${t} backend was already registered. Reusing existing backend factory.`), false) : (this.registryFactory[t] = { factory: e, priority: s }, true);
  }
  async setBackend(t) {
    if (this.registryFactory[t] == null)
      throw new Error(`Backend name '${t}' not found in registry`);
    if (this.backendName = t, this.registry[t] == null) {
      this.backendInstance = null;
      const { success: e, asyncInit: s } = this.initializeBackend(t);
      if (!(s ? await e : e))
        return false;
    }
    return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new sC(this.backendInstance), true;
  }
  setupRegisteredKernels() {
    rd(this.backendName).forEach((e) => {
      e.setupFunc != null && e.setupFunc(this.backendInstance);
    });
  }
  disposeRegisteredKernels(t) {
    rd(t).forEach((s) => {
      s.disposeFunc != null && s.disposeFunc(this.registry[t]);
    });
  }
  /**
   * Initializes a backend by looking up the backend name in the factory
   * registry and calling the factory method. Returns a boolean representing
   * whether the initialization of the backend suceeded. Throws an error if
   * there is no backend in the factory registry.
   */
  initializeBackend(t) {
    const e = this.registryFactory[t];
    if (e == null)
      throw new Error(`Cannot initialize backend ${t}, no registration found.`);
    try {
      const s = e.factory();
      if (s && !(s instanceof Xd$1) && typeof s.then == "function") {
        const o = ++this.pendingBackendInitId, r = s.then((i6) => o < this.pendingBackendInitId ? false : (this.registry[t] = i6, this.pendingBackendInit = null, true)).catch((i6) => (o < this.pendingBackendInitId || (this.pendingBackendInit = null, rn$1(`Initialization of backend ${t} failed`), rn$1(i6.stack || i6.message)), false));
        return this.pendingBackendInit = r, { success: r, asyncInit: true };
      } else
        return this.registry[t] = s, { success: true, asyncInit: false };
    } catch (s) {
      return rn$1(`Initialization of backend ${t} failed`), rn$1(s.stack || s.message), { success: false, asyncInit: false };
    }
  }
  removeBackend(t) {
    if (!(t in this.registryFactory))
      throw new Error(`${t} backend not found in registry`);
    this.backendName === t && this.pendingBackendInit != null && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }
  getSortedBackends() {
    if (Object.keys(this.registryFactory).length === 0)
      throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort((t, e) => this.registryFactory[e].priority - this.registryFactory[t].priority);
  }
  initializeBackendsAndReturnBest() {
    const t = this.getSortedBackends();
    for (let e = 0; e < t.length; e++) {
      const s = t[e], { success: o, asyncInit: r } = this.initializeBackend(s);
      if (r || o)
        return { name: s, asyncInit: r };
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  moveData(t, e) {
    const s = this.state.tensorInfo.get(e), o = s.backend, r = this.readSync(e), i6 = o.refCount(e);
    o.disposeData(e, true), s.backend = t, t.move(e, r, s.shape, s.dtype, i6), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }
  tidy(t, e) {
    let s = null;
    if (e == null) {
      if (typeof t != "function")
        throw new Error("Please provide a function to tidy()");
      e = t;
    } else {
      if (typeof t != "string" && !(t instanceof String))
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if (typeof e != "function")
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      s = t;
    }
    let o;
    return this.scopedRun(() => this.startScope(s), () => this.endScope(o), () => (o = e(), o instanceof Promise && console.error("Cannot return a Promise inside of tidy."), o));
  }
  scopedRun(t, e, s) {
    t();
    try {
      const o = s();
      return e(), o;
    } catch (o) {
      throw e(), o;
    }
  }
  nextTensorId() {
    return rr.nextTensorId++;
  }
  nextVariableId() {
    return rr.nextVariableId++;
  }
  /**
   * This method is called instead of the public-facing tensor.clone() when
   * saving a tensor for backwards pass. It makes sure to add the clone
   * operation to the tape regardless of being called inside a kernel
   * execution.
   */
  clone(t) {
    const e = $$1.runKernel(Ei, { x: t }), s = { x: t }, o = (i6) => ({
      x: () => {
        const a = "float32", l = { x: i6 }, c = { dtype: a };
        return $$1.runKernel(
          xi,
          l,
          // tslint:disable-next-line: no-unnecessary-type-assertion
          c
        );
      }
    }), r = [];
    return this.addTapeNode(this.state.activeScope.name, s, [e], o, r, {}), e;
  }
  /**
   * Execute a kernel with the given name and return the output tensor.
   *
   * @param kernelName The name of the kernel to execute.
   * @param inputs A map of input names to tensors.
   * @param attrs A map of attribute names to their values. An attribute is a
   *     primitive (non-tensor) input to the kernel.
   * @param inputsToSave A list of tensors, inputs to save for the backprop
   *     computation.
   * @param outputsToSave A list of booleans, specifying which output to save
   *     for the backprop computation. These are booleans since the output
   * tensors are not visible to the user.
   */
  runKernel(t, e, s) {
    if (this.backendName == null && this.backend, !(od(t, this.backendName) != null))
      throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);
    return this.runKernelFunc({ kernelName: t, inputs: e, attrs: s });
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(t, e, s) {
    const o = this.backend.numDataIds();
    let r = 0;
    s.forEach((l) => {
      r += l.dtype === "complex64" ? 3 : 1;
    });
    const i6 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], a = o - e - r - i6;
    if (a > 0)
      throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`);
  }
  /**
   * Internal helper method to execute a kernel Func
   *
   * Use `runKernel` to execute kernels from outside of engine.
   */
  runKernelFunc(t) {
    let e, s = [];
    const o = this.isTapeOn(), r = this.state.numBytes, i6 = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    let a;
    this.backendName == null && this.backend;
    let l;
    const c = Iu(t) ? t.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
    if (Iu(t)) {
      const { kernelName: f, inputs: m, attrs: g6 } = t;
      this.backendName == null && this.backend;
      const b6 = od(f, this.backendName);
      v(b6 != null, () => `Cannot find registered kernel '${f}' for backend '${this.backendName}'`), a = () => {
        const x6 = this.backend.numDataIds();
        l = b6.kernelFunc({ inputs: m, attrs: g6, backend: this.backend });
        const w6 = Array.isArray(l) ? l : [l];
        this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(f, x6, w6);
        const y6 = w6.map((I) => I.rank != null ? I : this.makeTensorFromTensorInfo(I));
        if (o) {
          const I = this.getTensorsForGradient(f, m, y6);
          s = this.saveTensorsForBackwardMode(I);
        }
        return y6;
      };
    } else {
      const { forwardFunc: f } = t, m = (g6) => {
        o && (s = g6.map((b6) => this.keep(this.clone(b6))));
      };
      a = () => {
        const g6 = this.backend.numDataIds();
        l = this.tidy(() => f(this.backend, m));
        const b6 = Array.isArray(l) ? l : [l];
        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(c, g6, b6), b6;
      };
    }
    const { inputs: u, attrs: d } = t, h6 = Iu(t) ? null : t.backwardsFunc;
    let p6;
    return this.scopedRun(
      // Stop recording to a tape when running a kernel.
      () => this.state.kernelDepth++,
      () => this.state.kernelDepth--,
      () => {
        !this.ENV.getBool("DEBUG") && !this.state.profiling ? e = a() : (p6 = this.profiler.profileKernel(c, u, () => a()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(p6), e = p6.outputs);
      }
    ), o && this.addTapeNode(c, u, e, h6, s, d), this.state.profiling && this.state.activeProfile.kernels.push({
      name: c,
      bytesAdded: this.state.numBytes - r,
      totalBytesSnapshot: this.state.numBytes,
      tensorsAdded: this.state.numTensors - i6,
      totalTensorsSnapshot: this.state.numTensors,
      inputShapes: Object.keys(u).map((f) => u[f] != null ? u[f].shape : null),
      outputShapes: e.map((f) => f.shape),
      kernelTimeMs: p6.timeMs,
      extraInfo: p6.extraInfo
    }), Array.isArray(l) ? e : e[0];
  }
  /**
   * Saves tensors used in forward mode for use in backward mode.
   *
   * @param tensors the list of tensors to save.
   */
  saveTensorsForBackwardMode(t) {
    return t.map((s) => this.keep(this.clone(s)));
  }
  /**
   * Returns a list of tensors to save for a given gradient calculation.
   *
   * @param kernelName name of kernel to look up gradient for.
   * @param inputs a map of input tensors.
   * @param outputs an array of output tensors from forward mode of kernel.
   */
  getTensorsForGradient(t, e, s) {
    const o = Hf$1(t);
    if (o != null) {
      const r = o.inputsToSave || [], i6 = o.outputsToSave || [];
      let a;
      o.saveAllInputs ? (v(Array.isArray(e), () => "saveAllInputs is true, expected inputs to be an array."), a = Object.keys(e).map((c) => e[c])) : a = r.map((c) => e[c]);
      const l = s.filter((c, u) => i6[u]);
      return a.concat(l);
    }
    return [];
  }
  /**
   * Internal method used by public APIs for tensor creation. Makes a new
   * tensor with the provided shape, dtype and values. It always
   * creates a new data id and writes the values to the underlying backend.
   */
  makeTensor(t, e, s, o) {
    if (t == null)
      throw new Error("Values passed to engine.makeTensor() are null");
    s = s || "float32", o = o || this.backend;
    let r = t;
    s === "string" && mr(t[0]) && (r = t.map((l) => hs(l)));
    const i6 = o.write(r, e, s), a = new Lt$1(e, s, i6, this.nextTensorId());
    if (this.trackTensor(a, o), s === "string") {
      const l = this.state.tensorInfo.get(i6), c = Vg$1(r);
      this.state.numBytes += c - l.bytes, l.bytes = c;
    }
    return a;
  }
  /**
   * Internal method used by backends. Makes a new tensor
   * that is a wrapper around an existing data id. It doesn't create
   * a new data id, only increments the ref count used in memory tracking.
   * @deprecated
   */
  makeTensorFromDataId(t, e, s, o) {
    s = s || "float32";
    const r = { dataId: t, shape: e, dtype: s };
    return this.makeTensorFromTensorInfo(r, o);
  }
  /**
   * Internal method used by backends. Makes a new tensor that is a wrapper
   * around an existing data id in TensorInfo. It doesn't create a new data id,
   * only increments the ref count used in memory tracking.
   */
  makeTensorFromTensorInfo(t, e) {
    const { dataId: s, shape: o, dtype: r } = t, i6 = new Lt$1(o, r, s, this.nextTensorId());
    return this.trackTensor(i6, e), i6;
  }
  makeVariable(t, e = true, s, o) {
    s = s || this.nextVariableId().toString(), o != null && o !== t.dtype && (t = t.cast(o));
    const r = new al(t, e, s, this.nextTensorId());
    if (this.state.registeredVariables[r.name] != null)
      throw new Error(`Variable with name ${r.name} was already registered`);
    return this.state.registeredVariables[r.name] = r, this.incRef(r, this.backend), r;
  }
  trackTensor(t, e) {
    this.state.numTensors++, t.dtype === "string" && this.state.numStringTensors++;
    let s = 0;
    t.dtype !== "complex64" && t.dtype !== "string" && (s = t.size * Ur(t.dtype)), this.state.numBytes += s, this.state.tensorInfo.has(t.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(t.dataId, {
      backend: e || this.backend,
      dtype: t.dtype,
      shape: t.shape,
      bytes: s
    })), t instanceof al || this.track(t);
  }
  // Track the tensor by dataId and increase the refCount for the dataId in the
  // backend.
  // TODO(pyu10055): This is currently used by makeVariable method, to increase
  // refCount on the backend for the dataId. It can potentially be replaced with
  // Identity op indead of calling backend directly.
  incRef(t, e) {
    this.trackTensor(t, e), this.backend.incRef(t.dataId);
  }
  removeDataId(t, e) {
    this.state.tensorInfo.has(t) && this.state.tensorInfo.get(t).backend === e && (this.state.tensorInfo.delete(t), this.state.numDataBuffers--);
  }
  disposeTensor(t) {
    if (!this.state.tensorInfo.has(t.dataId))
      return;
    const e = this.state.tensorInfo.get(t.dataId);
    if (this.state.numTensors--, t.dtype === "string" && (this.state.numStringTensors--, this.state.numBytes -= e.bytes), t.dtype !== "complex64" && t.dtype !== "string") {
      const s = t.size * Ur(t.dtype);
      this.state.numBytes -= s;
    }
    e.backend.disposeData(t.dataId) && this.removeDataId(t.dataId, e.backend);
  }
  disposeVariables() {
    for (const t in this.state.registeredVariables) {
      const e = this.state.registeredVariables[t];
      this.disposeVariable(e);
    }
  }
  disposeVariable(t) {
    this.disposeTensor(t), this.state.registeredVariables[t.name] != null && delete this.state.registeredVariables[t.name];
  }
  memory() {
    const t = this.backend.memory();
    return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = true, t.reasons == null && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t;
  }
  async profile(t) {
    this.state.profiling = true;
    const e = this.state.numBytes, s = this.state.numTensors;
    this.state.activeProfile.kernels = [], this.state.activeProfile.result = await t(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((o) => o.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - s;
    for (const o of this.state.activeProfile.kernels)
      o.kernelTimeMs = await o.kernelTimeMs, o.extraInfo = await o.extraInfo;
    return this.state.activeProfile;
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }
  addTapeNode(t, e, s, o, r, i6) {
    const a = { id: this.state.nextTapeNodeId++, kernelName: t, inputs: e, outputs: s, saved: r }, l = Hf$1(t);
    l != null && (o = l.gradFunc), o != null && (a.gradient = (c) => (c = c.map((u, d) => {
      if (u == null) {
        const h6 = s[d], p6 = Se(h6.size, h6.dtype);
        return this.makeTensor(p6, h6.shape, h6.dtype);
      }
      return u;
    }), o(c.length > 1 ? c : c[0], r, i6))), this.state.activeTape.push(a);
  }
  keep(t) {
    return t.kept = true, t;
  }
  startTape() {
    this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  /**
   * Start a scope. Use this with endScope() to achieve the same functionality
   * as scope() without the need for a function closure.
   */
  startScope(t) {
    const e = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e;
  }
  /**
   * End a scope. Use this with startScope() to achieve the same functionality
   * as scope() without the need for a function closure.
   */
  endScope(t) {
    const e = fs(t), s = new Set(e.map((r) => r.id));
    for (let r = 0; r < this.state.activeScope.track.length; r++) {
      const i6 = this.state.activeScope.track[r];
      !i6.kept && !s.has(i6.id) && i6.dispose();
    }
    const o = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], e.forEach((r) => {
      !r.kept && r.scopeId === o.id && this.track(r);
    });
  }
  /**
   * Returns gradients of `f` with respect to each of the `xs`. The gradients
   * returned are of the same length as `xs`, but some might be null if `f`
   * was not a function of that `x`. It also takes optional dy to multiply the
   * gradient, which defaults to `1`.
   */
  gradients(t, e, s, o = false) {
    if (v(e.length > 0, () => "gradients() received an empty list of xs."), s != null && s.dtype !== "float32")
      throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);
    const r = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", t));
    v(r instanceof Lt$1, () => "The result y returned by f() must be a tensor.");
    const i6 = iC(this.state.activeTape, e, r);
    if (!o && i6.length === 0 && e.length > 0)
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", () => {
      const a = {};
      a[r.id] = s ?? mC(r.shape), aC(
        a,
        i6,
        // Pass the tidy function to avoid circular dep with `tape.ts`.
        (c) => this.tidy(c),
        // Pass an add function to avoide a circular dep with `tape.ts`.
        gC
      );
      const l = e.map((c) => a[c.id]);
      return this.state.gradientDepth === 0 && (this.state.activeTape.forEach((c) => {
        for (const u of c.saved)
          u.dispose();
      }), this.state.activeTape = null), { value: r, grads: l };
    });
  }
  customGrad(t) {
    return v(Vs(t), () => "The f passed in customGrad(f) must be a function."), (...e) => {
      v(e.every((a) => a instanceof Lt$1), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let s;
      const o = {};
      e.forEach((a, l) => {
        o[l] = a;
      });
      const r = (a, l) => (s = t(...e, l), v(s.value instanceof Lt$1, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), v(Vs(s.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), s.value), i6 = (a, l) => {
        const c = s.gradFunc(a, l), u = Array.isArray(c) ? c : [c];
        v(u.length === e.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), v(u.every((h6) => h6 instanceof Lt$1), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        const d = {};
        return u.forEach((h6, p6) => {
          d[p6] = () => h6;
        }), d;
      };
      return this.runKernelFunc({
        forwardFunc: r,
        backwardsFunc: i6,
        inputs: o
      });
    };
  }
  readSync(t) {
    return this.state.tensorInfo.get(t).backend.readSync(t);
  }
  read(t) {
    return this.state.tensorInfo.get(t).backend.read(t);
  }
  readToGPU(t, e) {
    return this.state.tensorInfo.get(t).backend.readToGPU(t, e);
  }
  async time(t) {
    const e = Ce$1(), s = await this.backend.time(t);
    return s.wallMs = Ce$1() - e, s;
  }
  /**
   * Tracks a Tensor in the current scope to be automatically cleaned up
   * when the current scope ends, and returns the value.
   *
   * @param result The Tensor to track in the current scope.
   */
  track(t) {
    return this.state.activeScope != null && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  /**
   * Resets the engine state. Removes all backends but does not remove
   * registered backend factories.
   */
  reset() {
    this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new em();
    for (const t in this.registry)
      this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }
}
rr.nextTensorId = 0;
rr.nextVariableId = 0;
function mC(n) {
  const t = Fl(O(n), "float32");
  return $$1.makeTensor(t, n, "float32");
}
function fb$1() {
  const n = Og$1();
  if (n._tfengine == null) {
    const t = new XI(n);
    n._tfengine = new rr(t);
  }
  return KI(n._tfengine.ENV), uC(() => n._tfengine), n._tfengine;
}
const $$1 = fb$1();
function gC(n, t) {
  const e = { a: n, b: t };
  return $$1.runKernel(br, e);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bC() {
  return typeof navigator < "u" && navigator != null;
}
let hd$1;
function xC(n) {
  hd$1 = n;
}
function Xh$1(n) {
  if (hd$1 !== void 0)
    return hd$1;
  if (n || bC()) {
    if (n || (n = navigator), n.product === "ReactNative")
      return true;
    const t = n.userAgent || n.vendor || // tslint:disable-next-line:no-any
    (typeof window < "u" ? window.opera : "");
    if (!t) {
      const e = n;
      return e.userAgentData && e.userAgentData.mobile;
    }
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || // tslint:disable-next-line:max-line-length
    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4));
  }
  return false;
}
function Ph$1() {
  return typeof window < "u" && window.document != null || //@ts-ignore
  typeof WorkerGlobalScope < "u";
}
const z4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isBrowser: Ph$1,
  isMobile: Xh$1,
  mockIsMobile: xC
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hn$1 = F();
hn$1.registerFlag("DEBUG", () => false, (n) => {
  n && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
});
hn$1.registerFlag("IS_BROWSER", () => Ph$1());
hn$1.registerFlag("IS_NODE", () => typeof dist.process < "u" && typeof dist.process.versions < "u" && typeof dist.process.versions.node < "u");
hn$1.registerFlag("IS_CHROME", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
hn$1.registerFlag("PROD", () => false);
hn$1.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => hn$1.getBool("DEBUG"));
hn$1.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
hn$1.registerFlag("IS_TEST", () => false);
hn$1.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => true);
hn$1.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
hn$1.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
hn$1.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aa(n, t) {
  let e = n;
  if (dn$1(n))
    return t === "string" ? [] : [n.length];
  if (typeof n == "object") {
    if ("texture" in n) {
      const r = n.channels || "RGBA";
      return [n.height, n.width * r.length];
    } else if ("buffer" in n && !(n.buffer instanceof ArrayBuffer))
      return [n.buffer.size / (t == null ? 4 : Ur(t))];
  }
  if (!Array.isArray(n))
    return [];
  const o = [];
  for (; Array.isArray(e) || dn$1(e) && t !== "string"; )
    o.push(e.length), e = e[0];
  return Array.isArray(n) && F().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && mb$1(n, o, []), o;
}
function mb$1(n, t, e) {
  if (e = e || [], !Array.isArray(n) && !dn$1(n)) {
    v(t.length === 0, () => `Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);
    return;
  }
  v(t.length > 0, () => `Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`), v(n.length === t[0], () => `Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);
  const s = t.slice(1);
  for (let o = 0; o < n.length; ++o)
    mb$1(n[o], s, e.concat(o));
}
function nm(n, t, e, s) {
  if (n !== "string_or_numeric") {
    if (n == null)
      throw new Error("Expected dtype cannot be null.");
    if (n !== "numeric" && n !== t || n === "numeric" && t === "string")
      throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`);
  }
}
function T(n, t, e, s = "numeric") {
  if (n instanceof Lt$1)
    return nm(s, n.dtype, t, e), n;
  let o = gr(n);
  if (o !== "string" && ["bool", "int32", "float32"].indexOf(s) >= 0 && (o = s), nm(s, o, t, e), n == null || !dn$1(n) && !Array.isArray(n) && typeof n != "number" && typeof n != "boolean" && typeof n != "string") {
    const l = n == null ? "null" : n.constructor.name;
    throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`);
  }
  const r = aa(n, o);
  !dn$1(n) && !Array.isArray(n) && (n = [n]);
  const a = o !== "string" ? Zs(n, o) : zs(n, [], true);
  return $$1.makeTensor(a, r, o);
}
function Ah$1(n, t, e, s = "numeric") {
  if (!Array.isArray(n))
    throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);
  return n.map((r, i6) => T(r, `${t}[${i6}]`, e, s));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yC = "__op";
function L(n) {
  const t = Object.keys(n);
  if (t.length !== 1)
    throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);
  let e = t[0];
  const s = n[e];
  e.endsWith("_") && (e = e.substring(0, e.length - 1)), e = e + yC;
  const o = (...r) => {
    $$1.startScope(e);
    try {
      const i6 = s(...r);
      return ui$1(i6) && console.error("Cannot return a Promise inside of tidy."), $$1.endScope(i6), i6;
    } catch (i6) {
      throw $$1.endScope(null), i6;
    }
  };
  return Object.defineProperty(o, "name", { value: e, configurable: true }), o;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wC(n, t) {
  const e = T(n, "real", "complex"), s = T(t, "imag", "complex");
  Ve(e.shape, s.shape, `real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);
  const o = { real: e, imag: s };
  return $$1.runKernel(Jd$1, o);
}
const bo = /* @__PURE__ */ L({ complex_: wC });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function la(n, t, e, s) {
  if (s == null)
    s = gr(n);
  else if (s === "complex64")
    throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (typeof n == "object" && ("texture" in n || "buffer" in n && !(n.buffer instanceof ArrayBuffer))) {
    if (s !== "float32" && s !== "int32")
      throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);
    return $$1.backend.createTensorFromGPUData(n, t || e, s);
  }
  if (!dn$1(n) && !Array.isArray(n) && typeof n != "number" && typeof n != "boolean" && typeof n != "string")
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (t != null) {
    is(t);
    const o = O(t), r = O(e);
    v(o === r, () => `Based on the provided shape, [${t}], the tensor should have ${o} values but has ${r}`);
    for (let i6 = 0; i6 < e.length; ++i6) {
      const a = e[i6], l = i6 === e.length - 1 ? a !== O(t.slice(i6)) : true;
      v(e[i6] === t[i6] || !l, () => `Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `);
    }
  }
  return !dn$1(n) && !Array.isArray(n) && (n = [n]), t = t || e, n = s !== "string" ? Zs(n, s) : zs(n, [], true), $$1.makeTensor(n, t, s);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Re$1(n, t, e) {
  const s = aa(n, e);
  return la(n, t, s, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pd = {
  float32: 4,
  float16: 2,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1,
  complex64: 8
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ll = 4;
async function sm(n, t) {
  const e = [], s = [], o = Array.isArray(n) ? n.map((i6) => i6.name) : Object.keys(n);
  for (let i6 = 0; i6 < o.length; ++i6) {
    const a = o[i6], l = Array.isArray(n) ? n[i6].tensor : n[a];
    if (l.dtype !== "float32" && l.dtype !== "int32" && l.dtype !== "bool" && l.dtype !== "string" && l.dtype !== "complex64")
      throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);
    const c = { name: a, shape: l.shape, dtype: l.dtype };
    if (l.dtype === "string") {
      const u = new Promise(async (d) => {
        const h6 = await l.bytes(), p6 = h6.reduce((g6, b6) => g6 + b6.length, 0) + ll * h6.length, f = new Uint8Array(p6);
        let m = 0;
        for (let g6 = 0; g6 < h6.length; g6++) {
          const b6 = h6[g6], x6 = new Uint8Array(new Uint32Array([b6.length]).buffer);
          f.set(x6, m), m += ll, f.set(b6, m), m += b6.length;
        }
        d(f);
      });
      s.push(u);
    } else
      s.push(l.data());
    t != null && (c.group = t), e.push(c);
  }
  const r = await Promise.all(s);
  return { data: IC(r), specs: e };
}
function gb$1(n, t) {
  const e = {};
  let s, o = 0;
  for (const r of t) {
    const i6 = r.name, a = r.dtype, l = r.shape, c = O(l);
    let u;
    if ("quantization" in r) {
      const d = r.quantization;
      if (d.dtype === "uint8" || d.dtype === "uint16") {
        if (!("min" in d && "scale" in d))
          throw new Error(`Weight ${r.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`);
      } else if (d.dtype === "float16") {
        if (a !== "float32")
          throw new Error(`Weight ${r.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`);
      } else
        throw new Error(`Weight ${r.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
      const h6 = pd[d.dtype], p6 = n.slice(o, o + c * h6), f = d.dtype === "uint8" ? new Uint8Array(p6) : new Uint16Array(p6);
      if (a === "float32")
        if (d.dtype === "uint8" || d.dtype === "uint16") {
          u = new Float32Array(f.length);
          for (let m = 0; m < f.length; m++) {
            const g6 = f[m];
            u[m] = g6 * d.scale + d.min;
          }
        } else if (d.dtype === "float16")
          s === void 0 && (s = EC()), u = s(f);
        else
          throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);
      else if (a === "int32") {
        if (d.dtype !== "uint8" && d.dtype !== "uint16")
          throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);
        u = new Int32Array(f.length);
        for (let m = 0; m < f.length; m++) {
          const g6 = f[m];
          u[m] = Math.round(g6 * d.scale + d.min);
        }
      } else
        throw new Error(`Unsupported dtype in weight '${i6}': ${a}`);
      o += c * h6;
    } else if (a === "string") {
      const d = O(r.shape);
      u = [];
      for (let h6 = 0; h6 < d; h6++) {
        const p6 = new Uint32Array(n.slice(o, o + ll))[0];
        o += ll;
        const f = new Uint8Array(n.slice(o, o + p6));
        u.push(f), o += p6;
      }
    } else {
      const d = pd[a], h6 = n.slice(o, o + c * d);
      if (a === "float32")
        u = new Float32Array(h6);
      else if (a === "int32")
        u = new Int32Array(h6);
      else if (a === "bool")
        u = new Uint8Array(h6);
      else if (a === "complex64") {
        u = new Float32Array(h6);
        const p6 = new Float32Array(u.length / 2), f = new Float32Array(u.length / 2);
        for (let b6 = 0; b6 < p6.length; b6++)
          p6[b6] = u[b6 * 2], f[b6] = u[b6 * 2 + 1];
        const m = Re$1(p6, l, "float32"), g6 = Re$1(f, l, "float32");
        e[i6] = bo(m, g6), m.dispose(), g6.dispose();
      } else
        throw new Error(`Unsupported dtype in weight '${i6}': ${a}`);
      o += c * d;
    }
    a !== "complex64" && (e[i6] = Re$1(u, l, a));
  }
  return e;
}
function IC(n) {
  if (n === null)
    throw new Error(`Invalid input value: ${JSON.stringify(n)}`);
  let t = 0;
  const e = [];
  n.forEach((r) => {
    if (t += r.byteLength, e.push(r.byteLength === r.buffer.byteLength ? r : new r.constructor(r)), !(r instanceof Float32Array || r instanceof Int32Array || r instanceof Uint8Array))
      throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`);
  });
  const s = new Uint8Array(t);
  let o = 0;
  return e.forEach((r) => {
    s.set(new Uint8Array(r.buffer), o), o += r.byteLength;
  }), s.buffer;
}
const Oh$1 = typeof dist.Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
function om(n) {
  return Oh$1 ? dist.Buffer.byteLength(n) : new Blob([n]).size;
}
function CC(n) {
  if (Oh$1)
    return dist.Buffer.from(n).toString("base64");
  const t = new Uint8Array(n);
  let e = "";
  for (let s = 0, o = t.length; s < o; s++)
    e += String.fromCharCode(t[s]);
  return btoa(e);
}
function vC(n) {
  if (Oh$1) {
    const s = dist.Buffer.from(n, "base64");
    return s.buffer.slice(s.byteOffset, s.byteOffset + s.byteLength);
  }
  const t = atob(n), e = new Uint8Array(t.length);
  for (let s = 0; s < t.length; ++s)
    e.set([t.charCodeAt(s)], s);
  return e.buffer;
}
function bb$1(n) {
  if (n.length === 1)
    return n[0];
  let t = 0;
  n.forEach((o) => {
    t += o.byteLength;
  });
  const e = new Uint8Array(t);
  let s = 0;
  return n.forEach((o) => {
    e.set(new Uint8Array(o), s), s += o.byteLength;
  }), e.buffer;
}
function X4(n) {
  const t = "/";
  for (n = n.trim(); n.endsWith(t); )
    n = n.slice(0, n.length - 1);
  const e = n.split(t);
  return e[e.length - 1];
}
function SC(n, t) {
  const e = {
    modelTopology: n.modelTopology,
    format: n.format,
    generatedBy: n.generatedBy,
    convertedBy: n.convertedBy,
    weightsManifest: t
  };
  return n.signature != null && (e.signature = n.signature), n.userDefinedMetadata != null && (e.userDefinedMetadata = n.userDefinedMetadata), n.modelInitializer != null && (e.modelInitializer = n.modelInitializer), n.initializerSignature != null && (e.initializerSignature = n.initializerSignature), n.trainingConfig != null && (e.trainingConfig = n.trainingConfig), e;
}
function kC(n, t, e) {
  const s = {
    modelTopology: n.modelTopology,
    format: n.format,
    generatedBy: n.generatedBy,
    convertedBy: n.convertedBy
  };
  if (n.trainingConfig != null && (s.trainingConfig = n.trainingConfig), n.weightsManifest != null) {
    if (!t)
      throw new Error("modelJSON has weightsManifest but weightSpecs is null");
    if (!e)
      throw new Error("modelJSON has weightsManifest but weightData is null");
    s.weightSpecs = t, s.weightData = e;
  }
  return n.signature != null && (s.signature = n.signature), n.userDefinedMetadata != null && (s.userDefinedMetadata = n.userDefinedMetadata), n.modelInitializer != null && (s.modelInitializer = n.modelInitializer), n.initializerSignature != null && (s.initializerSignature = n.initializerSignature), s;
}
async function TC(n, t) {
  let e, s;
  return n.weightsManifest != null && ([e, s] = await t(n.weightsManifest)), kC(n, e, s);
}
function Kh$1(n) {
  if (n.modelTopology instanceof ArrayBuffer)
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: /* @__PURE__ */ new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: n.modelTopology == null ? 0 : om(JSON.stringify(n.modelTopology)),
    weightSpecsBytes: n.weightSpecs == null ? 0 : om(JSON.stringify(n.weightSpecs)),
    weightDataBytes: n.weightData == null ? 0 : n.weightData.byteLength
  };
}
function NC(n) {
  const t = [];
  for (const e of n)
    t.push(...e.weights);
  return t;
}
function RC() {
  const n = (e) => {
    let s = e << 13, o = 0;
    for (; !(s & 8388608); )
      o -= 8388608, s <<= 1;
    return s &= -8388609, o += 947912704, s | o;
  }, t = new Uint32Array(2048);
  t[0] = 0;
  for (let e = 1; e < 1024; e++)
    t[e] = n(e);
  for (let e = 1024; e < 2048; e++)
    t[e] = 939524096 + (e - 1024 << 13);
  return t;
}
function $C() {
  const n = new Uint32Array(64);
  n[0] = 0, n[31] = 1199570944, n[32] = 2147483648, n[63] = 3347054592;
  for (let t = 1; t < 31; t++)
    n[t] = t << 23;
  for (let t = 33; t < 63; t++)
    n[t] = 2147483648 + (t - 32 << 23);
  return n;
}
function GC() {
  const n = new Uint32Array(64);
  for (let t = 0; t < 64; t++)
    n[t] = 1024;
  return n[0] = n[32] = 0, n;
}
function EC() {
  const n = RC(), t = $C(), e = GC();
  return (s) => {
    const o = new ArrayBuffer(4 * s.length), r = new Uint32Array(o);
    for (let i6 = 0; i6 < s.length; i6++) {
      const a = s[i6], l = n[e[a >> 10] + (a & 1023)] + t[a >> 10];
      r[i6] = l;
    }
    return new Float32Array(o);
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ee {
  constructor() {
    this.saveRouters = [], this.loadRouters = [];
  }
  static getInstance() {
    return ee.instance == null && (ee.instance = new ee()), ee.instance;
  }
  /**
   * Register a save-handler router.
   *
   * @param saveRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `save` method defined or `null`.
   */
  static registerSaveRouter(t) {
    ee.getInstance().saveRouters.push(t);
  }
  /**
   * Register a load-handler router.
   *
   * @param loadRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `load` method defined or `null`.
   */
  static registerLoadRouter(t) {
    ee.getInstance().loadRouters.push(t);
  }
  /**
   * Look up IOHandler for saving, given a URL-like string.
   *
   * @param url
   * @returns If only one match is found, an instance of IOHandler with the
   * `save` method defined. If no match is found, `null`.
   * @throws Error, if more than one match is found.
   */
  static getSaveHandlers(t) {
    return ee.getHandlers(t, "save");
  }
  /**
   * Look up IOHandler for loading, given a URL-like string.
   *
   * @param url
   * @param loadOptions Optional, custom load options.
   * @returns All valid handlers for `url`, given the currently registered
   *   handler routers.
   */
  static getLoadHandlers(t, e) {
    return ee.getHandlers(t, "load", e);
  }
  static getHandlers(t, e, s) {
    const o = [];
    return (e === "load" ? ee.getInstance().loadRouters : ee.getInstance().saveRouters).forEach((i6) => {
      const a = i6(t, s);
      a !== null && o.push(a);
    }), o;
  }
}
const P4 = (n) => ee.registerSaveRouter(n), A4 = (n) => ee.registerLoadRouter(n), LC = (n) => ee.getSaveHandlers(n), MC = (n, t) => ee.getLoadHandlers(n, t);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fd$1 = "tensorflowjs", md = 1, co = "models_store", Rs = "model_info_store";
function xb() {
  if (!F().getBool("IS_BROWSER"))
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  const n = typeof window > "u" ? self : window, t = n.indexedDB || n.mozIndexedDB || n.webkitIndexedDB || n.msIndexedDB || n.shimIndexedDB;
  if (t == null)
    throw new Error("The current browser does not appear to support IndexedDB.");
  return t;
}
function gd$1(n) {
  const t = n.result;
  t.createObjectStore(co, { keyPath: "modelPath" }), t.createObjectStore(Rs, { keyPath: "modelPath" });
}
class xo {
  constructor(t) {
    if (this.indexedDB = xb(), t == null || !t)
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = t;
  }
  async save(t) {
    if (t.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    return this.databaseAction(this.modelPath, t);
  }
  async load() {
    return this.databaseAction(this.modelPath);
  }
  /**
   * Perform database action to put model artifacts into or read model artifacts
   * from IndexedDB object store.
   *
   * Whether the action is put or get depends on whether `modelArtifacts` is
   * specified. If it is specified, the action will be put; otherwise the action
   * will be get.
   *
   * @param modelPath A unique string path for the model.
   * @param modelArtifacts If specified, it will be the model artifacts to be
   *   stored in IndexedDB.
   * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`
   *   of `ModelArtifacts`, if the action is get.
   */
  databaseAction(t, e) {
    return new Promise((s, o) => {
      const r = this.indexedDB.open(fd$1, md);
      r.onupgradeneeded = () => gd$1(r), r.onsuccess = () => {
        const i6 = r.result;
        if (e == null) {
          const a = i6.transaction(co, "readonly"), c = a.objectStore(co).get(this.modelPath);
          c.onsuccess = () => {
            if (c.result == null)
              return i6.close(), o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
            s(c.result.modelArtifacts);
          }, c.onerror = (u) => (i6.close(), o(c.error)), a.oncomplete = () => i6.close();
        } else {
          const a = Kh$1(e), l = i6.transaction(Rs, "readwrite");
          let c = l.objectStore(Rs);
          const u = c.put({ modelPath: this.modelPath, modelArtifactsInfo: a });
          let d;
          u.onsuccess = () => {
            d = i6.transaction(co, "readwrite");
            const p6 = d.objectStore(co).put({
              modelPath: this.modelPath,
              modelArtifacts: e,
              modelArtifactsInfo: a
            });
            p6.onsuccess = () => s({ modelArtifactsInfo: a }), p6.onerror = (f) => {
              c = l.objectStore(Rs);
              const m = c.delete(this.modelPath);
              m.onsuccess = () => (i6.close(), o(p6.error)), m.onerror = (g6) => (i6.close(), o(p6.error));
            };
          }, u.onerror = (h6) => (i6.close(), o(u.error)), l.oncomplete = () => {
            d == null ? i6.close() : d.oncomplete = () => i6.close();
          };
        }
      }, r.onerror = (i6) => o(r.error);
    });
  }
}
xo.URL_SCHEME = "indexeddb://";
const yb$1 = (n) => F().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(xo.URL_SCHEME) ? WC(n.slice(xo.URL_SCHEME.length)) : null;
ee.registerSaveRouter(yb$1);
ee.registerLoadRouter(yb$1);
function WC(n) {
  return new xo(n);
}
function DC(n) {
  return n.startsWith(xo.URL_SCHEME) ? n.slice(xo.URL_SCHEME.length) : n;
}
class FC {
  constructor() {
    this.indexedDB = xb();
  }
  async listModels() {
    return new Promise((t, e) => {
      const s = this.indexedDB.open(fd$1, md);
      s.onupgradeneeded = () => gd$1(s), s.onsuccess = () => {
        const o = s.result, r = o.transaction(Rs, "readonly"), a = r.objectStore(Rs).getAll();
        a.onsuccess = () => {
          const l = {};
          for (const c of a.result)
            l[c.modelPath] = c.modelArtifactsInfo;
          t(l);
        }, a.onerror = (l) => (o.close(), e(a.error)), r.oncomplete = () => o.close();
      }, s.onerror = (o) => e(s.error);
    });
  }
  async removeModel(t) {
    return t = DC(t), new Promise((e, s) => {
      const o = this.indexedDB.open(fd$1, md);
      o.onupgradeneeded = () => gd$1(o), o.onsuccess = () => {
        const r = o.result, i6 = r.transaction(Rs, "readwrite"), a = i6.objectStore(Rs), l = a.get(t);
        let c;
        l.onsuccess = () => {
          if (l.result == null)
            return r.close(), s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));
          {
            const u = a.delete(t), d = () => {
              c = r.transaction(co, "readwrite");
              const p6 = c.objectStore(co).delete(t);
              p6.onsuccess = () => e(l.result.modelArtifactsInfo), p6.onerror = (f) => s(l.error);
            };
            u.onsuccess = d, u.onerror = (h6) => (d(), r.close(), s(l.error));
          }
        }, l.onerror = (u) => (r.close(), s(l.error)), i6.oncomplete = () => {
          c == null ? r.close() : c.oncomplete = () => r.close();
        };
      }, o.onerror = (r) => s(o.error);
    });
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ds = "/", Uo = "tensorflowjs_models", wb$1 = "info", VC = "model_topology", zC = "weight_specs", XC = "weight_data", PC = "model_metadata";
function Ib(n) {
  return {
    info: [Uo, n, wb$1].join(ds),
    topology: [Uo, n, VC].join(ds),
    weightSpecs: [Uo, n, zC].join(ds),
    weightData: [Uo, n, XC].join(ds),
    modelMetadata: [Uo, n, PC].join(ds)
  };
}
function Cb(n) {
  for (const t of Object.values(n))
    window.localStorage.removeItem(t);
}
function AC(n) {
  const t = n.split(ds);
  if (t.length < 3)
    throw new Error(`Invalid key format: ${n}`);
  return t.slice(1, t.length - 1).join(ds);
}
function OC(n) {
  return n.startsWith(yo.URL_SCHEME) ? n.slice(yo.URL_SCHEME.length) : n;
}
class yo {
  constructor(t) {
    if (!F().getBool("IS_BROWSER") || typeof window > "u" || typeof window.localStorage > "u")
      throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, t == null || !t)
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = t, this.keys = Ib(this.modelPath);
  }
  /**
   * Save model artifacts to browser local storage.
   *
   * See the documentation to `browserLocalStorage` for details on the saved
   * artifacts.
   *
   * @param modelArtifacts The model artifacts to be stored.
   * @returns An instance of SaveResult.
   */
  async save(t) {
    if (t.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    {
      const e = JSON.stringify(t.modelTopology), s = JSON.stringify(t.weightSpecs), o = Kh$1(t);
      try {
        this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, s), this.LS.setItem(this.keys.weightData, CC(t.weightData));
        const r = {
          format: t.format,
          generatedBy: t.generatedBy,
          convertedBy: t.convertedBy,
          signature: t.signature != null ? t.signature : void 0,
          userDefinedMetadata: t.userDefinedMetadata != null ? t.userDefinedMetadata : void 0,
          modelInitializer: t.modelInitializer != null ? t.modelInitializer : void 0,
          initializerSignature: t.initializerSignature != null ? t.initializerSignature : void 0,
          trainingConfig: t.trainingConfig != null ? t.trainingConfig : void 0
        };
        return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(r)), { modelArtifactsInfo: o };
      } catch {
        throw Cb(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`);
      }
    }
  }
  /**
   * Load a model from local storage.
   *
   * See the documentation to `browserLocalStorage` for details on the saved
   * artifacts.
   *
   * @returns The loaded model (if loading succeeds).
   */
  async load() {
    const t = JSON.parse(this.LS.getItem(this.keys.info));
    if (t == null)
      throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
    if (t.modelTopologyType !== "JSON")
      throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
    const e = {}, s = JSON.parse(this.LS.getItem(this.keys.topology));
    if (s == null)
      throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
    e.modelTopology = s;
    const o = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
    if (o == null)
      throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
    e.weightSpecs = o;
    const r = this.LS.getItem(this.keys.modelMetadata);
    if (r != null) {
      const a = JSON.parse(r);
      e.format = a.format, e.generatedBy = a.generatedBy, e.convertedBy = a.convertedBy, a.signature != null && (e.signature = a.signature), a.userDefinedMetadata != null && (e.userDefinedMetadata = a.userDefinedMetadata), a.modelInitializer != null && (e.modelInitializer = a.modelInitializer), a.initializerSignature != null && (e.initializerSignature = a.initializerSignature), a.trainingConfig != null && (e.trainingConfig = a.trainingConfig);
    }
    const i6 = this.LS.getItem(this.keys.weightData);
    if (i6 == null)
      throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
    return e.weightData = vC(i6), e;
  }
}
yo.URL_SCHEME = "localstorage://";
const vb = (n) => F().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(yo.URL_SCHEME) ? KC(n.slice(yo.URL_SCHEME.length)) : null;
ee.registerSaveRouter(vb);
ee.registerLoadRouter(vb);
function KC(n) {
  return new yo(n);
}
class ZC {
  constructor() {
    v(F().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), v(typeof window > "u" || typeof window.localStorage < "u", () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
  }
  async listModels() {
    const t = {}, e = Uo + ds, s = ds + wb$1;
    for (let o = 0; o < this.LS.length; ++o) {
      const r = this.LS.key(o);
      if (r.startsWith(e) && r.endsWith(s)) {
        const i6 = AC(r);
        t[i6] = JSON.parse(this.LS.getItem(r));
      }
    }
    return t;
  }
  async removeModel(t) {
    t = OC(t);
    const e = Ib(t);
    if (this.LS.getItem(e.info) == null)
      throw new Error(`Cannot find model at path '${t}'`);
    const s = JSON.parse(this.LS.getItem(e.info));
    return Cb(e), s;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jo = "://";
class Le {
  constructor() {
    this.managers = {};
  }
  static getInstance() {
    return Le.instance == null && (Le.instance = new Le()), Le.instance;
  }
  /**
   * Register a save-handler router.
   *
   * @param saveRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `save` method defined or `null`.
   */
  static registerManager(t, e) {
    v(t != null, () => "scheme must not be undefined or null."), t.endsWith(jo) && (t = t.slice(0, t.indexOf(jo))), v(t.length > 0, () => "scheme must not be an empty string.");
    const s = Le.getInstance();
    v(s.managers[t] == null, () => `A model store manager is already registered for scheme '${t}'.`), s.managers[t] = e;
  }
  static getManager(t) {
    const e = Le.getInstance().managers[t];
    if (e == null)
      throw new Error(`Cannot find model manager for scheme '${t}'`);
    return e;
  }
  static getSchemes() {
    return Object.keys(Le.getInstance().managers);
  }
}
function ja(n) {
  if (n.indexOf(jo) === -1)
    throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Le.getSchemes().join(",")}`);
  return {
    scheme: n.split(jo)[0],
    path: n.split(jo)[1]
  };
}
async function Sb(n, t, e = false) {
  v(n !== t, () => `Old path and new path are the same: '${n}'`);
  const s = ee.getLoadHandlers(n);
  v(s.length > 0, () => `Copying failed because no load handler is found for source URL ${n}.`), v(s.length < 2, () => `Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);
  const o = s[0], r = ee.getSaveHandlers(t);
  v(r.length > 0, () => `Copying failed because no save handler is found for destination URL ${t}.`), v(r.length < 2, () => `Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);
  const i6 = r[0], a = ja(n).scheme, l = ja(n).path, c = a === ja(n).scheme, u = await o.load();
  e && c && await Le.getManager(a).removeModel(l);
  const d = await i6.save(u);
  return e && !c && await Le.getManager(a).removeModel(l), d.modelArtifactsInfo;
}
async function O4() {
  const n = Le.getSchemes(), t = {};
  for (const e of n) {
    const s = await Le.getManager(e).listModels();
    for (const o in s) {
      const r = e + jo + o;
      t[r] = s[o];
    }
  }
  return t;
}
async function K4(n) {
  const t = ja(n);
  return Le.getManager(t.scheme).removeModel(t.path);
}
async function Z4(n, t) {
  return Sb(n, t, false);
}
async function B4(n, t) {
  return Sb(n, t, true);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class BC {
  constructor() {
    this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = false;
  }
  fetch(t, e) {
    return fetch(t, e);
  }
  now() {
    return performance.now();
  }
  encode(t, e) {
    if (e !== "utf-8" && e !== "utf8")
      throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);
    return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t);
  }
  decode(t, e) {
    return new TextDecoder(e).decode(t);
  }
  // If the setTimeout nesting level is greater than 5 and timeout is less
  // than 4ms, timeout will be clamped to 4ms, which hurts the perf.
  // Interleaving window.postMessage and setTimeout will trick the browser and
  // avoid the clamp.
  setTimeoutCustom(t, e) {
    if (typeof window > "u" || !F().getBool("USE_SETTIMEOUTCUSTOM")) {
      setTimeout(t, e);
      return;
    }
    this.functionRefs.push(t), setTimeout(() => {
      window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
    }, e), this.hasEventListener || (this.hasEventListener = true, window.addEventListener("message", (s) => {
      if (s.source === window && s.data.name === this.messageName) {
        s.stopPropagation();
        const o = this.functionRefs[s.data.index];
        o(), this.handledMessageCount++, this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], this.handledMessageCount = 0);
      }
    }, true));
  }
  isTypedArray(t) {
    return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray;
  }
}
if (F().get("IS_BROWSER")) {
  F().setPlatform("browser", new BC());
  try {
    Le.registerManager(yo.URL_SCHEME, new ZC());
  } catch {
  }
  try {
    Le.registerManager(xo.URL_SCHEME, new FC());
  } catch {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const HC = {
  // tslint:disable-next-line:no-require-imports
  importFetch: () => require("node-fetch")
};
let Cu;
class _C {
  constructor() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }
  fetch(t, e) {
    return F().global.fetch != null ? F().global.fetch(t, e) : (Cu == null && (Cu = HC.importFetch()), Cu(t, e));
  }
  now() {
    const t = dist.process.hrtime();
    return t[0] * 1e3 + t[1] / 1e6;
  }
  encode(t, e) {
    if (e !== "utf-8" && e !== "utf8")
      throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);
    return this.textEncoder.encode(t);
  }
  decode(t, e) {
    return t.length === 0 ? "" : new this.util.TextDecoder(e).decode(t);
  }
  isTypedArray(t) {
    return this.util.types.isFloat32Array(t) || this.util.types.isInt32Array(t) || this.util.types.isUint8Array(t) || this.util.types.isUint8ClampedArray(t);
  }
}
F().get("IS_NODE") && !F().get("IS_BROWSER") && F().setPlatform("node", new _C());
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vt$1(n, t = "float32", e) {
  return t = t || "float32", is(n), new $e(n, t, e);
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UC(n, t) {
  const e = T(n, "x", "cast");
  if (!Fg$1(t))
    throw new Error(`Failed to cast to unknown dtype ${t}`);
  if (t === "string" && e.dtype !== "string" || t !== "string" && e.dtype === "string")
    throw new Error("Only strings can be casted to strings");
  const s = { x: e }, o = { dtype: t };
  return $$1.runKernel(xi, s, o);
}
const et = /* @__PURE__ */ L({ cast_: UC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YC(n) {
  const e = { x: T(n, "x", "clone", "string_or_numeric") };
  return $$1.runKernel(Ei, e);
}
const po = /* @__PURE__ */ L({ clone_: YC });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QC(n, t = false) {
  console.log(n.toString(t));
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
fb$1();
const JC = {
  buffer: vt$1,
  cast: et,
  clone: po,
  print: QC
};
dC(JC);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H4() {
  F().set("PROD", true);
}
function _4() {
  F().set("DEBUG", true);
}
function U4() {
  F().set("DEPRECATION_WARNINGS_ENABLED", false), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}
function Y4(n) {
  F().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(n + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function Q4() {
  $$1.disposeVariables();
}
function Xt() {
  return $$1;
}
function cl() {
  return $$1.memory();
}
function J4(n) {
  return $$1.profile(n);
}
function D(n, t) {
  return $$1.tidy(n, t);
}
function yt$1(n) {
  fs(n).forEach((e) => e.dispose());
}
function cn$1(n) {
  return $$1.keep(n);
}
function j4(n) {
  return $$1.time(n);
}
function q4(n) {
  return $$1.setBackend(n);
}
function tY() {
  return $$1.ready();
}
function eY() {
  return $$1.backendName;
}
function nY(n) {
  $$1.removeBackend(n);
}
function sY(n) {
  return $$1.findBackend(n);
}
function oY(n) {
  return $$1.findBackendFactory(n);
}
function kb(n, t, e = 1) {
  return $$1.registerBackend(n, t, e);
}
function $s() {
  return $$1.backend;
}
function rY(n, t) {
  F().setPlatform(n, t);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jC(n, t) {
  let e = T(n, "a", "add"), s = T(t, "b", "add");
  [e, s] = ne$1(e, s);
  const o = { a: e, b: s };
  return $$1.runKernel(br, o);
}
const U = /* @__PURE__ */ L({ add_: jC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qC(n, t) {
  let e = T(n, "a", "floorDiv"), s = T(t, "b", "floorDiv");
  [e, s] = ne$1(e, s);
  const o = { a: e, b: s };
  return $$1.runKernel($i, o);
}
const Tb$1 = /* @__PURE__ */ L({ floorDiv_: qC });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t2(n, t) {
  let e = T(n, "a", "div"), s = T(t, "b", "div");
  if ([e, s] = ne$1(e, s), e.dtype === "int32" && s.dtype === "int32")
    return Tb$1(e, s);
  const o = { a: e, b: s }, r = {};
  return $$1.runKernel(vi, o, r);
}
const ut = /* @__PURE__ */ L({ div_: t2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e2(n, t) {
  let e = T(n, "a", "mul"), s = T(t, "b", "mul");
  [e, s] = ne$1(e, s);
  const o = { a: e, b: s };
  return $$1.runKernel(Pi, o);
}
const G = /* @__PURE__ */ L({ mul_: e2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function n2(n) {
  const t = T(n, "x", "abs");
  if (t.dtype === "complex64") {
    const e = { x: t };
    return $$1.runKernel(Zl, e);
  } else {
    const e = { x: t };
    return $$1.runKernel(Vl, e);
  }
}
const fe$1 = /* @__PURE__ */ L({ abs_: n2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function s2(n) {
  const e = { x: T(n, "x", "acos") };
  return $$1.runKernel(di, e);
}
const o2 = /* @__PURE__ */ L({ acos_: s2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function r2(n) {
  const e = { x: T(n, "x", "acosh") };
  return $$1.runKernel(hi, e);
}
const i2 = /* @__PURE__ */ L({ acosh_: r2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function a2(n, t = null, e = false) {
  const o = { x: T(n, "x", "all", "bool") }, r = { axis: t, keepDims: e };
  return $$1.runKernel(Hd$1, o, r);
}
const Nb$1 = /* @__PURE__ */ L({ all_: a2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l2(n, t = null, e = false) {
  const o = { x: T(n, "x", "any", "bool") }, r = { axis: t, keepDims: e };
  return $$1.runKernel(_d$1, o, r);
}
const bd$1 = /* @__PURE__ */ L({ any_: l2 });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c2(n, t = 0) {
  const s = { x: T(n, "x", "argMax") }, o = { axis: t };
  return $$1.runKernel(zl, s, o);
}
const Qr = /* @__PURE__ */ L({ argMax_: c2 });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u2(n, t = 0) {
  const s = { x: T(n, "x", "argMin") }, o = { axis: t };
  return $$1.runKernel(Xl, s, o);
}
const d2 = /* @__PURE__ */ L({ argMin_: u2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function h2(n) {
  const e = { x: T(n, "x", "asin") };
  return $$1.runKernel(pi, e);
}
const p2 = /* @__PURE__ */ L({ asin_: h2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function f2(n) {
  const e = { x: T(n, "x", "asinh") };
  return $$1.runKernel(fi, e);
}
const m2 = /* @__PURE__ */ L({ asinh_: f2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g2(n) {
  const e = { x: T(n, "x", "atan") };
  return $$1.runKernel(mi, e);
}
const b2 = /* @__PURE__ */ L({ atan_: g2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function x2(n, t) {
  let e = T(n, "a", "atan2"), s = T(t, "b", "atan2");
  [e, s] = ne$1(e, s);
  const o = { a: e, b: s };
  return $$1.runKernel(bi, o);
}
const y2 = /* @__PURE__ */ L({ atan2_: x2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function w2(n) {
  const e = { x: T(n, "x", "atanh") };
  return $$1.runKernel(gi, e);
}
const I2 = /* @__PURE__ */ L({ atanh_: w2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ca(n, t, e, s, o = "NHWC", r) {
  const i6 = n[3], a = [...t, i6], l = ys(o);
  return ke(n, a, e, r, s, null, null, l);
}
function $n$1(n, t, e, s, o, r, i6 = "channelsLast") {
  const [a, l] = Jr(t);
  let c;
  if (i6 === "channelsLast")
    c = [a, l, n[3], n[3]];
  else if (i6 === "channelsFirst")
    c = [a, l, n[1], n[1]];
  else
    throw new Error(`Unknown dataFormat ${i6}`);
  return ke(n, c, e, s, o, r, false, i6);
}
function xs(n, t, e, s, o, r, i6 = "NDHWC") {
  const [a, l, c] = xd$1(t);
  let u, d;
  if (i6 === "NDHWC")
    d = "channelsLast", u = [a, l, c, n[4], n[4]];
  else if (i6 === "NCDHW")
    d = "channelsFirst", u = [a, l, c, n[1], n[1]];
  else
    throw new Error(`Unknown dataFormat ${i6}`);
  return Bs(n, u, e, s, o, false, d, r);
}
function ke(n, t, e, s, o, r, i6 = false, a = "channelsLast") {
  let [l, c, u, d] = [-1, -1, -1, -1];
  if (a === "channelsLast")
    [l, c, u, d] = n;
  else if (a === "channelsFirst")
    [l, d, c, u] = n;
  else
    throw new Error(`Unknown dataFormat ${a}`);
  const [h6, p6, , f] = t, [m, g6] = Jr(e), [b6, x6] = Jr(s), w6 = qo(h6, b6), y6 = qo(p6, x6), { padInfo: I, outHeight: C6, outWidth: k7 } = S2(o, c, u, m, g6, w6, y6, r, a), S = i6 ? f * d : f;
  let N;
  return a === "channelsFirst" ? N = [l, S, C6, k7] : a === "channelsLast" && (N = [l, C6, k7, S]), {
    batchSize: l,
    dataFormat: a,
    inHeight: c,
    inWidth: u,
    inChannels: d,
    outHeight: C6,
    outWidth: k7,
    outChannels: S,
    padInfo: I,
    strideHeight: m,
    strideWidth: g6,
    filterHeight: h6,
    filterWidth: p6,
    effectiveFilterHeight: w6,
    effectiveFilterWidth: y6,
    dilationHeight: b6,
    dilationWidth: x6,
    inShape: n,
    outShape: N,
    filterShape: t
  };
}
function Bs(n, t, e, s, o, r = false, i6 = "channelsLast", a) {
  let [l, c, u, d, h6] = [-1, -1, -1, -1, -1];
  if (i6 === "channelsLast")
    [l, c, u, d, h6] = n;
  else if (i6 === "channelsFirst")
    [l, h6, c, u, d] = n;
  else
    throw new Error(`Unknown dataFormat ${i6}`);
  const [p6, f, m, , g6] = t, [b6, x6, w6] = xd$1(e), [y6, I, C6] = xd$1(s), k7 = qo(p6, y6), S = qo(f, I), N = qo(m, C6), { padInfo: R, outDepth: M6, outHeight: V, outWidth: z } = k2(o, c, u, d, b6, x6, w6, k7, S, N, a), X = r ? g6 * h6 : g6;
  let P6;
  return i6 === "channelsFirst" ? P6 = [l, X, M6, V, z] : i6 === "channelsLast" && (P6 = [l, M6, V, z, X]), {
    batchSize: l,
    dataFormat: i6,
    inDepth: c,
    inHeight: u,
    inWidth: d,
    inChannels: h6,
    outDepth: M6,
    outHeight: V,
    outWidth: z,
    outChannels: X,
    padInfo: R,
    strideDepth: b6,
    strideHeight: x6,
    strideWidth: w6,
    filterDepth: p6,
    filterHeight: f,
    filterWidth: m,
    effectiveFilterDepth: k7,
    effectiveFilterHeight: S,
    effectiveFilterWidth: N,
    dilationDepth: y6,
    dilationHeight: I,
    dilationWidth: C6,
    inShape: n,
    outShape: P6,
    filterShape: t
  };
}
function C2(n, t, e, s, o) {
  s == null && (s = Zh$1(n, t, e));
  const r = n[0], i6 = n[1], a = jr((r - t + 2 * s) / e + 1, o), l = jr((i6 - t + 2 * s) / e + 1, o);
  return [a, l];
}
function v2(n, t, e, s, o, r) {
  o == null && (o = Zh$1(n, t[0], s[0]));
  const i6 = [0, 0, 0, e];
  for (let a = 0; a < 3; a++)
    n[a] + 2 * o >= t[a] && (i6[a] = jr((n[a] - t[a] + 2 * o) / s[a] + 1, r));
  return i6;
}
function Zh$1(n, t, e, s = 1) {
  const o = qo(t, s);
  return Math.floor((n[0] * (e - 1) - e + o) / 2);
}
function Jr(n) {
  return typeof n == "number" ? [n, n, n] : n.length === 2 ? [n[0], n[1], 1] : n;
}
function xd$1(n) {
  return typeof n == "number" ? [n, n, n] : n;
}
function qo(n, t) {
  return t <= 1 ? n : n + (n - 1) * (t - 1);
}
function S2(n, t, e, s, o, r, i6, a, l) {
  let c, u, d;
  if (typeof n == "number") {
    c = { top: n, bottom: n, left: n, right: n, type: n === 0 ? "VALID" : "NUMBER" };
    const p6 = C2([t, e], r, s, n, a);
    u = p6[0], d = p6[1];
  } else if (n === "same") {
    u = Math.ceil(t / s), d = Math.ceil(e / o);
    const h6 = Math.max(0, (u - 1) * s + r - t), p6 = Math.max(0, (d - 1) * o + i6 - e), f = Math.floor(h6 / 2), m = h6 - f, g6 = Math.floor(p6 / 2), b6 = p6 - g6;
    c = { top: f, bottom: m, left: g6, right: b6, type: "SAME" };
  } else if (n === "valid")
    c = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, u = Math.ceil((t - r + 1) / s), d = Math.ceil((e - i6 + 1) / o);
  else if (typeof n == "object") {
    const h6 = l === "channelsLast" ? n[1][0] : n[2][0], p6 = l === "channelsLast" ? n[1][1] : n[2][1], f = l === "channelsLast" ? n[2][0] : n[3][0], m = l === "channelsLast" ? n[2][1] : n[3][1];
    c = { top: h6, bottom: p6, left: f, right: m, type: h6 === 0 && p6 === 0 && f === 0 && m === 0 ? "VALID" : "EXPLICIT" }, u = jr((t - r + h6 + p6) / s + 1, a), d = jr((e - i6 + f + m) / o + 1, a);
  } else
    throw Error(`Unknown padding parameter: ${n}`);
  return { padInfo: c, outHeight: u, outWidth: d };
}
function k2(n, t, e, s, o, r, i6, a, l, c, u) {
  let d, h6, p6, f;
  if (n === "valid" && (n = 0), typeof n == "number") {
    d = {
      top: n,
      bottom: n,
      left: n,
      right: n,
      front: n,
      back: n,
      type: n === 0 ? "VALID" : "NUMBER"
    };
    const g6 = v2([t, e, s, 1], [a, l, c], 1, [o, r, i6], n, u);
    h6 = g6[0], p6 = g6[1], f = g6[2];
  } else if (n === "same") {
    h6 = Math.ceil(t / o), p6 = Math.ceil(e / r), f = Math.ceil(s / i6);
    const m = (h6 - 1) * o + a - t, g6 = (p6 - 1) * r + l - e, b6 = (f - 1) * i6 + c - s, x6 = Math.floor(m / 2), w6 = m - x6, y6 = Math.floor(g6 / 2), I = g6 - y6, C6 = Math.floor(b6 / 2), k7 = b6 - C6;
    d = { top: y6, bottom: I, left: C6, right: k7, front: x6, back: w6, type: "SAME" };
  } else
    throw Error(`Unknown padding parameter: ${n}`);
  return { padInfo: d, outDepth: h6, outHeight: p6, outWidth: f };
}
function jr(n, t) {
  if (!t)
    return Math.trunc(n);
  switch (t) {
    case "round":
      return Math.round(n);
    case "ceil":
      return Math.ceil(n);
    case "floor":
      return Math.floor(n);
    default:
      throw new Error(`Unknown roundingMode ${t}`);
  }
}
function wo(n) {
  const [t, e, s] = Jr(n);
  return t === 1 && e === 1 && s === 1;
}
function Ee$1(n, t) {
  return wo(n) || wo(t);
}
function Io(n) {
  return Jr(n).every((t) => t > 0);
}
function ys(n) {
  if (n === "NHWC")
    return "channelsLast";
  if (n === "NCHW")
    return "channelsFirst";
  throw new Error(`Unknown dataFormat ${n}`);
}
function Be$1(n, t, e) {
  if (e != null) {
    if (typeof t == "string")
      throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);
    if (typeof t == "number")
      v(go(t), () => `Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);
    else if (typeof t == "object")
      t.forEach((s) => {
        s.forEach((o) => {
          v(go(o), () => `Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`);
        });
      });
    else
      throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function T2(n, t) {
  const s = { x: T(n, "x", "reshape", "string_or_numeric") }, o = { shape: t };
  return $$1.runKernel(Sc, s, o);
}
const W = /* @__PURE__ */ L({ reshape_: T2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N2(n, t, e, s, o) {
  const r = T(n, "x", "avgPool", "float32"), i6 = 1;
  v(Ee$1(e, i6), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i6}'`);
  let a = r, l = false;
  r.rank === 3 && (l = true, a = W(r, [1, r.shape[0], r.shape[1], r.shape[2]])), v(a.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${a.rank}.`), Be$1("avgPool", s, o);
  const c = { x: a }, u = { filterSize: t, strides: e, pad: s, dimRoundingMode: o };
  let d = $$1.runKernel(Pl, c, u);
  return d = et(d, r.dtype), l ? W(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
}
const Bh$1 = /* @__PURE__ */ L({ avgPool_: N2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R2(n, t, e, s, o, r = "NDHWC") {
  const i6 = T(n, "x", "avgPool3d", "float32");
  let a = i6, l = false;
  i6.rank === 4 && (l = true, a = W(i6, [1, i6.shape[0], i6.shape[1], i6.shape[2], i6.shape[3]])), v(a.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`), v(r === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`), v(typeof e == "number" && e > 0 || Array.isArray(e) && e[0] > 0 && e[1] > 0 && e[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${e}'`), Be$1("avgPool3d", s, o);
  const c = { x: a }, u = { filterSize: t, strides: e, pad: s, dimRoundingMode: o, dataFormat: r };
  let d = $$1.runKernel(Al, c, u);
  return d = et(d, a.dtype), l ? W(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
}
const $2 = /* @__PURE__ */ L({ avgPool3d_: R2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function G2(n, t = 0) {
  v(n.length >= 1, () => "Pass at least one tensor to concat");
  const e = Ah$1(n, "tensors", "concat", "string_or_numeric");
  if (e[0].dtype === "complex64" && e.forEach((r) => {
    if (r.dtype !== "complex64")
      throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `);
  }), e.length === 1)
    return po(e[0]);
  const s = e, o = { axis: t };
  return $$1.runKernel(Bl, s, o);
}
const Ge$1 = /* @__PURE__ */ L({ concat_: G2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E2(n, t, e = false, s = false) {
  let o = T(n, "a", "matMul"), r = T(t, "b", "matMul");
  [o, r] = ne$1(o, r);
  const i6 = { a: o, b: r }, a = { transposeA: e, transposeB: s };
  return $$1.runKernel(Ol, i6, a);
}
const Gt = /* @__PURE__ */ L({ matMul_: E2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function L2(n) {
  const e = { x: T(n, "x", "sigmoid", "float32") };
  return $$1.runKernel(Ji, e);
}
const xr = /* @__PURE__ */ L({ sigmoid_: L2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function M2(n, t, e) {
  const s = T(n, "x", "slice", "string_or_numeric");
  if (s.rank === 0)
    throw new Error("Slicing scalar is not possible");
  const o = { x: s }, r = { begin: t, size: e };
  return $$1.runKernel($c, o, r);
}
const Dt = /* @__PURE__ */ L({ slice_: M2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function W2(n) {
  const e = { x: T(n, "x", "tanh", "float32") };
  return $$1.runKernel(sa, e);
}
const Hh$1 = /* @__PURE__ */ L({ tanh_: W2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D2(n, t, e) {
  const s = T(n, "x", "batchToSpaceND"), o = t.reduce((a, l) => a * l);
  v(s.rank >= 1 + t.length, () => `input rank is ${s.rank} but should be > than blockShape.length ${t.length}`), v(e.length === t.length, () => `crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`), v(s.shape[0] % o === 0, () => `input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);
  const r = { x: s }, i6 = { blockShape: t, crops: e };
  return $$1.runKernel(Kl, r, i6);
}
const _h$1 = /* @__PURE__ */ L({ batchToSpaceND_: D2 });
function F2(n) {
  let t;
  return n.rank === 0 || n.rank === 1 ? t = W(n, [1, 1, 1, n.size]) : n.rank === 2 ? t = W(n, [1, 1, n.shape[0], n.shape[1]]) : n.rank === 3 ? t = W(n, [1, n.shape[0], n.shape[1], n.shape[2]]) : t = n, t;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function V2(n, t, e, s, o, r) {
  r == null && (r = 1e-3);
  const i6 = T(n, "x", "batchNorm"), a = T(t, "mean", "batchNorm"), l = T(e, "variance", "batchNorm");
  let c;
  o != null && (c = T(o, "scale", "batchNorm"));
  let u;
  s != null && (u = T(s, "offset", "batchNorm")), v(a.rank === l.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), v(u == null || a.rank === u.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), v(c == null || a.rank === c.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  const h6 = {
    x: F2(i6),
    scale: c,
    offset: u,
    mean: a,
    variance: l
  }, p6 = { varianceEpsilon: r }, f = $$1.runKernel(tc, h6, p6);
  return W(f, i6.shape);
}
const zc = /* @__PURE__ */ L({ batchNorm_: V2 });
function z2(n, t, e, s, o, r) {
  const i6 = T(n, "x", "batchNorm"), a = T(t, "mean", "batchNorm"), l = T(e, "variance", "batchNorm");
  let c;
  o != null && (c = T(o, "scale", "batchNorm"));
  let u;
  return s != null && (u = T(s, "offset", "batchNorm")), v(i6.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${i6.rank}.`), v(a.rank === 2 || a.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`), v(l.rank === 2 || l.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`), c != null && v(c.rank === 2 || c.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`), u != null && v(u.rank === 2 || u.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`), zc(i6, a, l, u, c, r);
}
const X2 = /* @__PURE__ */ L({ batchNorm2d_: z2 });
function P2(n, t, e, s, o, r) {
  const i6 = T(n, "x", "batchNorm"), a = T(t, "mean", "batchNorm"), l = T(e, "variance", "batchNorm");
  let c;
  o != null && (c = T(o, "scale", "batchNorm"));
  let u;
  return s != null && (u = T(s, "offset", "batchNorm")), v(i6.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${i6.rank}.`), v(a.rank === 3 || a.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`), v(l.rank === 3 || l.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`), c != null && v(c.rank === 3 || c.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`), u != null && v(u.rank === 3 || u.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`), zc(i6, a, l, u, c, r);
}
const A2 = /* @__PURE__ */ L({ batchNorm3d_: P2 });
function O2(n, t, e, s, o, r) {
  const i6 = T(n, "x", "batchNorm"), a = T(t, "mean", "batchNorm"), l = T(e, "variance", "batchNorm");
  let c;
  o != null && (c = T(o, "scale", "batchNorm"));
  let u;
  return s != null && (u = T(s, "offset", "batchNorm")), v(i6.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${i6.rank}.`), v(a.rank === 4 || a.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`), v(l.rank === 4 || l.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`), c != null && v(c.rank === 4 || c.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`), u != null && v(u.rank === 4 || u.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`), zc(i6, a, l, u, c, r);
}
const K2 = /* @__PURE__ */ L({ batchNorm4d_: O2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Z2(n, t, e) {
  const s = T(n, "x", "bincount"), o = T(t, "weights", "bincount");
  v(s.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${s.dtype}`), v(e >= 0, () => `size must be non-negative, but got ${e}.`), v(o.size === s.size || o.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${o.shape}.`);
  const r = { x: s, weights: o }, i6 = { size: e };
  return $$1.runKernel(Qd$1, r, i6);
}
const B2 = /* @__PURE__ */ L({ bincount_: Z2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H2(n, t) {
  let e = T(n, "broadcastTo", "x");
  const s = e.shape;
  if (is(t), t.length < e.rank)
    throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);
  if (t.length > e.rank) {
    const c = e.shape.slice();
    for (; c.length < t.length; )
      c.unshift(1);
    e = W(e, c);
  }
  const o = e.shape, r = Array.from(t);
  for (let c = t.length - 1; c >= 0; c--)
    if (o[c] === t[c])
      r[c] = 1;
    else if (e.shape[c] !== 1)
      throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);
  if (r.map((c, u) => c > 1 ? u : -1).filter((c) => c >= 0).length === 0)
    return po(e);
  const a = { x: e }, l = { reps: r };
  return $$1.runKernel(oa, a, l);
}
const Br = /* @__PURE__ */ L({ broadcastTo_: H2 });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _2(n) {
  const e = { x: T(n, "x", "ceil", "float32") };
  return $$1.runKernel(yi, e);
}
const U2 = /* @__PURE__ */ L({ ceil_: _2 });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ua(n, t, e) {
  is(n);
  const s = { shape: n, value: t, dtype: e };
  return $$1.runKernel(ch$1, {}, s);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Y2(n, t, e) {
  const s = T(n, "x", "clipByValue");
  if (v(t <= e, () => `Error in clip: min (${t}) must be less than or equal to max (${e}).`), t === e)
    return ua(s.shape, t, s.dtype);
  const o = { x: s }, r = { clipValueMin: t, clipValueMax: e };
  return $$1.runKernel(wi, o, r);
}
const pn$1 = /* @__PURE__ */ L({ clipByValue_: Y2 });
function Q2(n) {
  return Ge$1(
    n,
    0
    /* axis */
  );
}
const J2 = /* @__PURE__ */ L({ concat1d_: Q2 });
function j2(n, t) {
  return Ge$1(n, t);
}
const q2 = /* @__PURE__ */ L({ concat2d_: j2 });
function tv(n, t) {
  return Ge$1(n, t);
}
const ev = /* @__PURE__ */ L({ concat3d_: tv });
function nv(n, t) {
  return Ge$1(n, t);
}
const sv = /* @__PURE__ */ L({ concat4d_: nv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ov(n, t, e, s, o = "NHWC", r = [1, 1], i6) {
  const a = T(n, "x", "conv2d", "float32"), l = T(t, "filter", "conv2d", "float32");
  let c = a, u = false;
  a.rank === 3 && (u = true, c = W(a, [1, a.shape[0], a.shape[1], a.shape[2]])), v(c.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${c.rank}.`), v(l.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`), Be$1("conv2d", s, i6);
  const d = o === "NHWC" ? c.shape[3] : c.shape[1];
  v(d === l.shape[2], () => `Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`), v(Ee$1(e, r), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`), v(Io(r), () => "Error in conv2D: Dilated rates should be larger than 0."), v(Io(e), () => "Error in conv2D: Strides should be larger than 0.");
  const h6 = { x: c, filter: l }, p6 = { strides: e, pad: s, dataFormat: o, dilations: r, dimRoundingMode: i6 }, f = $$1.runKernel(Hl, h6, p6);
  return u ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f;
}
const Co = /* @__PURE__ */ L({ conv2d_: ov });
function rv(n, t, e, s, o = "NWC", r = 1, i6) {
  const a = T(n, "x", "conv1d"), l = T(t, "filter", "conv1d");
  let c = a, u = false;
  a.rank === 2 && (u = true, c = W(a, [1, a.shape[0], a.shape[1]])), v(c.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${c.rank}.`), v(l.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`), Be$1("conv1d", s, i6), v(c.shape[2] === l.shape[1], () => `Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`), v(Ee$1(e, r), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${r}'`), v(Io(r), () => "Error in conv1D: Dilated rates should be larger than 0."), v(Io(e), () => "Error in conv1D: Stride should be larger than 0."), v(o === "NWC", () => `Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);
  const d = W(l, [1, l.shape[0], l.shape[1], l.shape[2]]), h6 = W(c, [c.shape[0], 1, c.shape[1], c.shape[2]]), g6 = Co(h6, d, [1, e], s, "NHWC", [1, r], i6);
  return u ? W(g6, [g6.shape[2], g6.shape[3]]) : W(g6, [g6.shape[0], g6.shape[2], g6.shape[3]]);
}
const Rb = /* @__PURE__ */ L({ conv1d_: rv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iv(n, t, e, s, o, r = "NHWC", i6) {
  v(n.length === t.rank, () => `Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);
  let a = n, l = t, c = false;
  t.rank === 3 && (c = true, l = W(t, [1, t.shape[0], t.shape[1], t.shape[2]]), a = [1, n[0], n[1], n[2]]), v(a.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`), v(l.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`), v(e.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);
  const u = r === "NHWC" ? a[3] : a[1], d = r === "NHWC" ? l.shape[3] : l.shape[1];
  v(u === e.shape[2], () => `Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`), v(d === e.shape[3], () => `Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`), Be$1("conv2dDerInput", o, i6);
  const h6 = { dy: l, filter: e }, p6 = { strides: s, pad: o, dataFormat: r, dimRoundingMode: i6, inputShape: a }, f = $$1.runKernel(_l, h6, p6);
  return c ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f;
}
const Uh$1 = /* @__PURE__ */ L({ conv2DBackpropInput_: iv });
function av(n, t, e, s, o, r) {
  const i6 = T(n, "x", "conv2dTranspose"), a = T(t, "filter", "conv2dTranspose");
  return Uh$1(e, i6, a, s, o, "NHWC", r);
}
const $b = /* @__PURE__ */ L({ conv2dTranspose_: av });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lv(n, t, e, s, o = "NDHWC", r = [1, 1, 1]) {
  const i6 = T(n, "x", "conv3d"), a = T(t, "filter", "conv3d");
  let l = i6, c = false;
  i6.rank === 4 && (c = true, l = W(i6, [1, i6.shape[0], i6.shape[1], i6.shape[2], i6.shape[3]])), v(l.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${l.rank}.`), v(a.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`), v(l.shape[4] === a.shape[3], () => `Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`), v(Ee$1(e, r), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`), v(o === "NDHWC", () => `Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`), v(Io(r), () => "Error in conv3D: Dilated rates should be larger than 0."), v(Io(e), () => "Error in conv3D: Strides should be larger than 0.");
  const u = { x: l, filter: a }, d = { strides: e, pad: s, dataFormat: o, dilations: r }, h6 = $$1.runKernel(Ul, u, d);
  return c ? W(h6, [h6.shape[1], h6.shape[2], h6.shape[3], h6.shape[4]]) : h6;
}
const cv = /* @__PURE__ */ L({ conv3d_: lv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uv(n, t, e, s, o) {
  v(n.length === t.rank, () => `Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);
  let r = n, i6 = t, a = false;
  t.rank === 4 && (a = true, i6 = W(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), r = [1, n[0], n[1], n[2], n[3]]);
  const l = r[4], c = i6.shape[4];
  v(r.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`), v(i6.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${i6.rank}`), v(e.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`), v(l === e.shape[3], () => `Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`), v(c === e.shape[4], () => `Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);
  const u = { dy: i6, filter: e }, d = { pad: o, strides: s, inputShape: r }, h6 = $$1.runKernel(th$1, u, d);
  return a ? W(h6, [h6.shape[1], h6.shape[2], h6.shape[3], h6.shape[4]]) : h6;
}
const Gb = /* @__PURE__ */ L({ conv3DBackpropInput_: uv });
function dv(n, t, e, s, o) {
  const r = T(n, "x", "conv3dTranspose"), i6 = T(t, "filter", "conv3dTranspose");
  return Gb(e, r, i6, s, o);
}
const hv = /* @__PURE__ */ L({ conv3dTranspose_: dv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pv(n) {
  const e = { x: T(n, "x", "cos", "float32") };
  return $$1.runKernel(Ii, e);
}
const Yh$1 = /* @__PURE__ */ L({ cos_: pv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fv(n) {
  const e = { x: T(n, "x", "cosh", "float32") };
  return $$1.runKernel(Ci, e);
}
const Eb = /* @__PURE__ */ L({ cosh_: fv });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mv(n, t = 0, e = false, s = false) {
  const r = { x: T(n, "x", "cumprod") }, i6 = { axis: t, exclusive: e, reverse: s };
  return $$1.runKernel(eh$1, r, i6);
}
const yd$1 = /* @__PURE__ */ L({ cumprod_: mv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gv(n, t = 0, e = false, s = false) {
  const r = { x: T(n, "x", "cumsum") }, i6 = { axis: t, exclusive: e, reverse: s };
  return $$1.runKernel(Yl, r, i6);
}
const Lb = /* @__PURE__ */ L({ cumsum_: gv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bv(n, t, e, s = false) {
  const o = T(n, "x", "denseBincount"), r = T(t, "weights", "denseBincount");
  v(o.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${o.dtype}`), v(o.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`), v(e >= 0, () => `size must be non-negative, but got ${e}.`), v(r.size === o.size || r.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${r.shape}.`);
  const i6 = { x: o, weights: r }, a = { size: e, binaryOutput: s };
  return $$1.runKernel(sh$1, i6, a);
}
const rm = /* @__PURE__ */ L({ denseBincount_: bv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xv(n, t, e = "NHWC") {
  const s = T(n, "x", "depthToSpace", "float32"), o = e === "NHWC" ? s.shape[1] : s.shape[2], r = e === "NHWC" ? s.shape[2] : s.shape[3], i6 = e === "NHWC" ? s.shape[3] : s.shape[1];
  v(t > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${t}`), v(o * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${s.shape}`), v(r * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${r} and ${t} for depthToSpace with input shape
        ${s.shape}`), v(i6 % (t * t) === 0, () => `Dimension size must be evenly divisible by ${t * t} but is ${i6} for depthToSpace with input shape ${s.shape}`);
  const a = { x: s }, l = { blockSize: t, dataFormat: e };
  return $$1.runKernel(oh$1, a, l);
}
const yv = /* @__PURE__ */ L({ depthToSpace_: xv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wv(n, t, e, s, o = "NHWC", r = [1, 1], i6) {
  const a = T(n, "x", "depthwiseConv2d", "float32"), l = T(t, "filter", "depthwiseConv2d", "float32");
  let c = a, u = false;
  a.rank === 3 && (u = true, c = W(a, [1, a.shape[0], a.shape[1], a.shape[2]])), v(c.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`), v(l.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);
  const d = o === "NHWC" ? c.shape[3] : c.shape[1];
  v(d === l.shape[2], () => `Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`), Be$1("depthwiseConv2d", s, i6);
  const h6 = { x: c, filter: l }, p6 = { strides: e, pad: s, dataFormat: o, dilations: r, dimRoundingMode: i6 }, f = $$1.runKernel(Ql, h6, p6);
  return u ? W(f, [f.shape[1], f.shape[2], f.shape[3]]) : f;
}
const Qh$1 = /* @__PURE__ */ L({ depthwiseConv2d_: wv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Iv(n, t, e, s, o = [1, 1], r = "NHWC") {
  const i6 = T(n, "x", "dilation2d"), a = T(t, "filter", "dilation2d");
  v(i6.rank === 3 || i6.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${i6.rank}.`), v(a.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`), v(r === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);
  let l = i6, c = false;
  i6.rank === 3 && (l = W(i6, [1, i6.shape[0], i6.shape[1], i6.shape[2]]), c = true), v(l.shape[3] === a.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);
  const u = { x: l, filter: a }, d = { strides: e, pad: s, dilations: o }, h6 = $$1.runKernel(Jl, u, d);
  return c ? W(h6, [h6.shape[1], h6.shape[2], h6.shape[3]]) : h6;
}
const Cv = /* @__PURE__ */ L({ dilation2d_: Iv });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vo(n, t) {
  const e = n.length, s = [];
  for (let o = 0; o < e; o++) {
    const r = e - 1 - o, i6 = n[r] || 1;
    (t[t.length - 1 - o] || 1) > 1 && i6 === 1 && s.unshift(r);
  }
  return s;
}
function le(n, t) {
  const e = [];
  for (let s = 0; s < t.length; s++) {
    const o = n[n.length - s - 1], r = t.length - s - 1, i6 = t[r];
    (o == null || o === 1 && i6 > 1) && e.unshift(r);
  }
  return e;
}
function bt$1(n, t) {
  const e = [], s = Math.max(n.length, t.length);
  for (let o = 0; o < s; o++) {
    let r = n[n.length - o - 1];
    r == null && (r = 1);
    let i6 = t[t.length - o - 1];
    if (i6 == null && (i6 = 1), r === 1)
      e.unshift(i6);
    else if (i6 === 1)
      e.unshift(r);
    else if (r !== i6) {
      const a = `Operands could not be broadcast together with shapes ${n} and ${t}.`;
      throw Error(a);
    } else
      e.unshift(r);
  }
  return e;
}
const iY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertAndGetBroadcastShape: bt$1,
  getBroadcastDims: vo,
  getReductionAxes: le
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vv(n, t) {
  let e = T(n, "a", "equal", "string_or_numeric"), s = T(t, "b", "equal", "string_or_numeric");
  [e, s] = ne$1(e, s), bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(jl, o);
}
const kn$1 = /* @__PURE__ */ L({ equal_: vv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sv(n, t, e) {
  const s = T(t, "a", "where"), o = T(e, "b", "where"), r = T(n, "condition", "where", "bool"), i6 = bt$1(bt$1(r.shape, s.shape), o.shape), a = Br(r, i6), l = Br(s, i6), c = Br(o, i6), u = {
    condition: a,
    t: l,
    e: c
  };
  return $$1.runKernel(Rc, u);
}
const Oe = /* @__PURE__ */ L({ where_: Sv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kv(n) {
  const e = { x: T(n, "x", "zerosLike") };
  return $$1.runKernel(Fc, e);
}
const Tt$1 = /* @__PURE__ */ L({ zerosLike_: kv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tv(n, t) {
  let e = T(n, "a", "div"), s = T(t, "b", "div");
  [e, s] = ne$1(e, s);
  const o = ut(e, s), r = Tt$1(o), i6 = kn$1(s, r);
  return Oe(i6, r, o);
}
const Nv = /* @__PURE__ */ L({ divNoNan_: Tv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rv(n, t) {
  const e = T(n, "t1", "dot"), s = T(t, "t2", "dot");
  v((e.rank === 1 || e.rank === 2) && (s.rank === 1 || s.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);
  const o = e.rank === 1 ? e.size : e.shape[1], r = s.rank === 1 ? s.size : s.shape[0];
  if (v(o === r, () => `Error in dot: inner dimensions of inputs must match, but got ${o} and ${r}.`), e.rank === 1 && s.rank === 1) {
    const i6 = W(e, [1, -1]), a = W(s, [-1, 1]), l = Gt(i6, a);
    return W(l, []);
  } else if (e.rank === 1 && s.rank === 2) {
    const i6 = W(e, [1, -1]), a = W(s, [s.shape[0], s.shape[1]]), l = Gt(i6, a);
    return W(l, [l.size]);
  } else if (e.rank === 2 && s.rank === 1) {
    const i6 = W(s, [-1, 1]), a = Gt(e, i6);
    return W(a, [a.size]);
  } else {
    const i6 = W(s, [s.shape[0], s.shape[1]]);
    return Gt(e, i6);
  }
}
const $v = /* @__PURE__ */ L({ dot_: Rv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gv(n) {
  const e = { x: T(n, "x", "elu", "float32") };
  return $$1.runKernel(Si, e);
}
const Xc = /* @__PURE__ */ L({ elu_: Gv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ev(n) {
  let t = T(n, "x", "erf");
  v(t.dtype === "int32" || t.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), t.dtype === "int32" && (t = et(t, "float32"));
  const e = { x: t };
  return $$1.runKernel(ki, e);
}
const Lv = /* @__PURE__ */ L({ erf_: Ev });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jh$1(n, t) {
  for (let e = 0; e < n.length; ++e)
    if (n[n.length - e - 1] !== t - 1 - e)
      return false;
  return true;
}
function Mb(n, t, e) {
  const s = n.length + t.length, o = [];
  let r = 0, i6 = 0;
  for (let a = 0; a < s; a++)
    e.indexOf(a) === -1 ? o.push(n[r++]) : o.push(t[i6++]);
  return o;
}
function ye$1(n, t) {
  const e = [], s = n.length;
  for (let r = 0; r < s; r++)
    t.indexOf(r) === -1 && e.push(n[r]);
  const o = t.map((r) => n[r]);
  return [e, o];
}
function re$1(n, t) {
  const e = t.map((s) => 1);
  return Mb(n, e, t);
}
function Te(n, t, e) {
  v(Jh$1(t, e), () => `${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`);
}
function qt$1(n, t) {
  if (Jh$1(n, t))
    return null;
  const e = [];
  for (let s = 0; s < t; ++s)
    n.indexOf(s) === -1 && e.push(s);
  return n.forEach((s) => e.push(s)), e;
}
function Hs(n) {
  return n.map((t, e) => [e, t]).sort((t, e) => t[1] - e[1]).map((t) => t[0]);
}
function ie(n, t) {
  const e = [];
  for (let s = t - n; s < t; ++s)
    e.push(s);
  return e;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mv(n, t = null, e = false) {
  const o = { x: T(n, "x", "max") }, r = { reductionIndices: t, keepDims: e };
  return $$1.runKernel(uc, o, r);
}
const Xn$1 = /* @__PURE__ */ L({ max_: Mv });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wv(n, t = null, e = false) {
  const o = { x: T(n, "x", "min") }, r = { axis: t, keepDims: e };
  return $$1.runKernel(fc, o, r);
}
const ul = /* @__PURE__ */ L({ min_: Wv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dv(n, t) {
  let e = T(n, "base", "pow"), s = T(t, "exp", "pow");
  [e, s] = ne$1(e, s);
  const o = { a: e, b: s };
  return $$1.runKernel(Ai, o);
}
const ir = /* @__PURE__ */ L({ pow_: Dv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gt$1(n, t) {
  if ((dn$1(n) && t !== "string" || Array.isArray(n)) && t !== "complex64")
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if (t === "string" && dn$1(n) && !(n instanceof Uint8Array))
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return la(n, [], [], t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fv(n) {
  const e = { x: T(n, "x", "sqrt", "float32") };
  return $$1.runKernel(qi, e);
}
const De$1 = /* @__PURE__ */ L({ sqrt_: Fv });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vv(n) {
  const t = T(n, "x", "square"), e = {};
  return $$1.runKernel("Square", { x: t }, e);
}
const At$1 = /* @__PURE__ */ L({ square_: Vv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zv(n, t = null, e = false) {
  let s = T(n, "x", "sum");
  s.dtype === "bool" && (s = et(s, "int32"));
  const o = { x: s }, r = { axis: t, keepDims: e };
  return $$1.runKernel(Gc, o, r);
}
const at = /* @__PURE__ */ L({ sum_: zv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xv(n, t = "euclidean", e = null, s = false) {
  n = T(n, "x", "norm");
  const o = Wb(n, t, e);
  let r = o.shape;
  if (s) {
    const i6 = Ct(e, n.shape);
    r = re$1(o.shape, i6);
  }
  return W(o, r);
}
function Wb(n, t, e = null) {
  if (n.rank === 0)
    return fe$1(n);
  if (n.rank !== 1 && e === null)
    return Wb(W(n, [-1]), t, e);
  if (n.rank === 1 || typeof e == "number" || Array.isArray(e) && e.length === 1) {
    if (t === 1)
      return at(fe$1(n), e);
    if (t === 1 / 0)
      return Xn$1(fe$1(n), e);
    if (t === -1 / 0)
      return ul(fe$1(n), e);
    if (t === "euclidean" || t === 2)
      return De$1(at(ir(fe$1(n), gt$1(2, "int32")), e));
    throw new Error(`Error in norm: invalid ord value: ${t}`);
  }
  if (Array.isArray(e) && e.length === 2) {
    if (t === 1)
      return Xn$1(at(fe$1(n), e[0]), e[1] - 1);
    if (t === 1 / 0)
      return Xn$1(at(fe$1(n), e[1]), e[0]);
    if (t === -1 / 0)
      return ul(at(fe$1(n), e[1]), e[0]);
    if (t === "fro" || t === "euclidean")
      return De$1(at(At$1(n), e));
    throw new Error(`Error in norm: invalid ord value: ${t}`);
  }
  throw new Error(`Error in norm: invalid axis: ${e}`);
}
const Pc = /* @__PURE__ */ L({ norm_: Xv });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Pv(n, t = null, e = false) {
  return Pc(n, "euclidean", t, e);
}
const Av = /* @__PURE__ */ L({ euclideanNorm_: Pv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ov(n) {
  const e = { x: T(n, "x", "exp") };
  return $$1.runKernel(Ti, e);
}
const Tn$1 = /* @__PURE__ */ L({ exp_: Ov });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kv(n, t = 0) {
  const e = T(n, "x", "expandDims", "string_or_numeric");
  v(t <= e.rank, () => "Axis must be <= rank of the tensor");
  const s = { input: e }, o = { dim: t };
  return $$1.runKernel(ql, s, o);
}
const Ue$1 = /* @__PURE__ */ L({ expandDims_: Kv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zv(n) {
  const e = { x: T(n, "x", "expm1") };
  return $$1.runKernel(Ni, e);
}
const Bv = /* @__PURE__ */ L({ expm1_: Zv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hv(n, t) {
  const e = T(n, "x", "tile", "string_or_numeric");
  v(e.rank === t.length, () => `Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);
  const s = { x: e }, o = { reps: t };
  return $$1.runKernel(oa, s, o);
}
const Vn$1 = /* @__PURE__ */ L({ tile_: Hv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _v(n, t, e, s = "float32") {
  t == null && (t = n);
  const o = vt$1([n, t], s), r = n <= t ? n : t;
  for (let a = 0; a < r; ++a)
    o.set(1, a, a);
  const i6 = W(o.toTensor(), [n, t]);
  if (e == null)
    return i6;
  if (e.length === 1)
    return Vn$1(Ue$1(i6, 0), [e[0], 1, 1]);
  if (e.length === 2)
    return Vn$1(Ue$1(Ue$1(i6, 0), 0), [e[0], e[1], 1, 1]);
  if (e.length === 3)
    return Vn$1(Ue$1(Ue$1(Ue$1(i6, 0), 0), 0), [
      e[0],
      e[1],
      e[2],
      1,
      1
    ]);
  throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`);
}
const Db = /* @__PURE__ */ L({ eye_: _v });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Uv(n) {
  const e = { x: T(n, "x", "floor", "float32") };
  return $$1.runKernel(Ri, e);
}
const Ac = /* @__PURE__ */ L({ floor_: Uv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yv(n, t, e = 0, s = 0) {
  const o = T(n, "x", "gather"), r = T(t, "indices", "gather", "int32"), i6 = { x: o, indices: r }, a = { axis: e, batchDims: s };
  return $$1.runKernel(ec, i6, a);
}
const jh$1 = /* @__PURE__ */ L({ gather_: Yv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qv(n, t) {
  let e = T(n, "a", "greater", "string_or_numeric"), s = T(t, "b", "greater", "string_or_numeric");
  [e, s] = ne$1(e, s), bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(nc, o);
}
const sn$1 = /* @__PURE__ */ L({ greater_: Qv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Jv(n, t) {
  let e = T(n, "a", "greaterEqual", "string_or_numeric"), s = T(t, "b", "greaterEqual", "string_or_numeric");
  [e, s] = ne$1(e, s), bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(Gi, o);
}
const Do = /* @__PURE__ */ L({ greaterEqual_: Jv });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jv(n) {
  const e = { input: T(n, "input", "imag") };
  return $$1.runKernel(hh$1, e);
}
const qh$1 = /* @__PURE__ */ L({ imag_: jv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qv(n) {
  const e = { x: T(n, "x", "isFinite") };
  return $$1.runKernel(Li, e);
}
const tS = /* @__PURE__ */ L({ isFinite_: qv });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eS(n) {
  const e = { x: T(n, "x", "isInf") };
  return $$1.runKernel(Mi, e);
}
const nS = /* @__PURE__ */ L({ isInf_: eS });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sS(n) {
  const e = { x: T(n, "x", "isNaN") };
  return $$1.runKernel(Wi, e);
}
const oS = /* @__PURE__ */ L({ isNaN_: sS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rS(n, t = 0.2) {
  const s = { x: T(n, "x", "leakyRelu") }, o = { alpha: t };
  return $$1.runKernel(sc, s, o);
}
const tp = /* @__PURE__ */ L({ leakyRelu_: rS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iS(n, t) {
  let e = T(n, "a", "less", "string_or_numeric"), s = T(t, "b", "less", "string_or_numeric");
  [e, s] = ne$1(e, s), bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(oc, o);
}
const Fb = /* @__PURE__ */ L({ less_: iS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aS(n, t) {
  let e = T(n, "a", "lessEqual", "string_or_numeric"), s = T(t, "b", "lessEqual", "string_or_numeric");
  [e, s] = ne$1(e, s), bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(rc, o);
}
const yr = /* @__PURE__ */ L({ lessEqual_: aS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lS(n, t = 5, e = 1, s = 1, o = 0.5) {
  const r = T(n, "x", "localResponseNormalization");
  v(r.rank === 4 || r.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`), v(go(t), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);
  let i6 = r, a = false;
  r.rank === 3 && (a = true, i6 = W(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
  const l = { x: i6 }, c = { depthRadius: t, bias: e, alpha: s, beta: o }, u = $$1.runKernel(cc, l, c);
  return a ? W(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
}
const cS = /* @__PURE__ */ L({ localResponseNormalization_: lS });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uS(n) {
  const e = { x: T(n, "x", "log", "float32") };
  return $$1.runKernel(Di, e);
}
const Nn$1 = /* @__PURE__ */ L({ log_: uS });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dS(n) {
  const e = { x: T(n, "x", "log1p") };
  return $$1.runKernel(Fi, e);
}
const ep = /* @__PURE__ */ L({ log1p_: dS });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aY(n) {
  return v(Vs(n), () => "The f passed in grad(f) must be a function"), (t, e) => {
    const s = T(t, "x", "tf.grad", "string_or_numeric"), o = e != null ? T(e, "dy", "tf.grad") : null;
    return $$1.tidy(() => {
      const { value: r, grads: i6 } = $$1.gradients(() => n(s), [s], o);
      return o != null && Ve(r.shape, o.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), Oc(i6), i6[0];
    });
  };
}
function lY(n) {
  return v(Vs(n), () => "The f passed in grads(f) must be a function"), (t, e) => {
    v(Array.isArray(t), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
    const s = Ah$1(t, "args", "tf.grads", "string_or_numeric"), o = e != null ? T(e, "dy", "tf.grads") : null;
    return $$1.tidy(() => {
      const { value: r, grads: i6 } = $$1.gradients(() => n(...s), s, o);
      return o != null && Ve(r.shape, o.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), Oc(i6), i6;
    });
  };
}
function cY(n) {
  return v(Vs(n), () => "The f passed in valueAndGrad(f) must be a function"), (t, e) => {
    v(t instanceof Lt$1, () => "The x passed in valueAndGrad(f)(x) must be a tensor"), v(e == null || e instanceof Lt$1, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
    const { grads: s, value: o } = $$1.gradients(() => n(t), [t], e);
    return Oc(s), { grad: s[0], value: o };
  };
}
function uY(n) {
  return v(Vs(n), () => "The f passed in valueAndGrads(f) must be a function"), (t, e) => {
    v(Array.isArray(t) && t.every((o) => o instanceof Lt$1), () => "The args passed in valueAndGrads(f)(args) must be array of tensors"), v(e == null || e instanceof Lt$1, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
    const s = $$1.gradients(() => n(...t), t, e);
    return e != null && Ve(s.value.shape, e.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), Oc(s.grads), s;
  };
}
function hS(n, t) {
  v(Vs(n), () => "The f passed in variableGrads(f) must be a function"), v(t == null || Array.isArray(t) && t.every((c) => c instanceof al), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
  const e = t != null;
  if (!e) {
    t = [];
    for (const c in $$1.registeredVariables)
      t.push($$1.registeredVariables[c]);
  }
  const s = e ? t.filter((c) => !c.trainable) : null, o = t.length;
  t = t.filter((c) => c.trainable), v(t.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);
  const r = true, { value: i6, grads: a } = $$1.gradients(n, t, null, r);
  v(a.some((c) => c != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), v(i6.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i6.rank} tensor`);
  const l = {};
  return t.forEach((c, u) => {
    a[u] != null && (l[c.name] = a[u]);
  }), s != null && s.forEach((c) => l[c.name] = null), { value: i6, grads: l };
}
function So(n) {
  return $$1.customGrad(n);
}
function Oc(n) {
  if (n.filter((e) => e == null).length > 0)
    throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pS(n) {
  const e = { x: T(n, "x", "neg") };
  return $$1.runKernel(gc, e);
}
const jt$1 = /* @__PURE__ */ L({ neg_: pS });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fS(n) {
  const e = { x: T(n, "x", "softplus") };
  return $$1.runKernel(ji, e);
}
const da = /* @__PURE__ */ L({ softplus_: fS });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mS(n) {
  const t = T(n, "x", "logSigmoid");
  return So((s) => ({ value: jt$1(da(jt$1(s))), gradFunc: (i6) => G(i6, xr(jt$1(s))) }))(t);
}
const gS = /* @__PURE__ */ L({ logSigmoid_: mS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bS(n, t) {
  let e = T(n, "a", "sub"), s = T(t, "b", "sub");
  [e, s] = ne$1(e, s);
  const o = { a: e, b: s };
  return $$1.runKernel(ea, o);
}
const lt = /* @__PURE__ */ L({ sub_: bS });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xS(n, t = -1) {
  const e = T(n, "logits", "logSoftmax");
  if (t === -1 && (t = e.rank - 1), t !== e.rank - 1)
    throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);
  return So((o, r) => {
    const a = Xn$1(o, t, true), l = lt(o, a), c = lt(et(l, "float32"), Nn$1(at(Tn$1(l), t, true)));
    return r([c]), { value: c, gradFunc: (d, h6) => {
      const [p6] = h6, f = true, m = Tn$1(p6);
      return lt(d, G(at(d, t, f), m));
    } };
  })(e);
}
const Vb = /* @__PURE__ */ L({ logSoftmax_: xS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yS(n, t = null, e = false) {
  const s = T(n, "x", "logSumExp"), o = Ct(t, s.shape), r = Xn$1(
    s,
    o,
    true
    /* keepDims */
  ), i6 = lt(s, r), a = Tn$1(i6), l = at(a, o), c = Nn$1(l), u = U(W(r, c.shape), c);
  if (e) {
    const d = re$1(u.shape, o);
    return W(u, d);
  }
  return u;
}
const zb = /* @__PURE__ */ L({ logSumExp_: yS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wS(n, t) {
  const e = T(n, "a", "logicalAnd", "bool"), s = T(t, "b", "logicalAnd", "bool");
  bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(ic, o);
}
const ss = /* @__PURE__ */ L({ logicalAnd_: wS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IS(n) {
  const e = { x: T(n, "x", "logicalNot", "bool") };
  return $$1.runKernel(ac, e);
}
const np = /* @__PURE__ */ L({ logicalNot_: IS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CS(n, t) {
  const e = T(n, "a", "logicalOr", "bool"), s = T(t, "b", "logicalOr", "bool");
  bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(lc, o);
}
const Xb = /* @__PURE__ */ L({ logicalOr_: CS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vS(n, t) {
  const e = T(n, "a", "logicalXor", "bool"), s = T(t, "b", "logicalXor", "bool");
  return bt$1(e.shape, s.shape), ss(Xb(n, t), np(ss(n, t)));
}
const SS = /* @__PURE__ */ L({ logicalXor_: vS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kS(n, t, e, s, o) {
  const r = T(n, "x", "maxPool"), i6 = 1;
  let a = r, l = false;
  r.rank === 3 && (l = true, a = W(r, [1, r.shape[0], r.shape[1], r.shape[2]])), v(a.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${a.rank}.`), v(Ee$1(e, i6), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i6}'`), Be$1("maxPool", s, o);
  const c = { x: a }, u = { filterSize: t, strides: e, pad: s, dimRoundingMode: o }, d = $$1.runKernel(dc, c, u);
  return l ? W(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
}
const sp = /* @__PURE__ */ L({ maxPool_: kS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TS(n, t = [1, 1, 1], e, s, o, r = "NDHWC") {
  const i6 = T(n, "x", "maxPool3d");
  let a = i6, l = false;
  i6.rank === 4 && (l = true, a = W(i6, [1, i6.shape[0], i6.shape[1], i6.shape[2], i6.shape[3]])), v(a.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`), v(r === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`), Be$1("maxPool3d", s, o);
  const c = { x: a }, u = { filterSize: t, strides: e, pad: s, dimRoundingMode: o, dataFormat: r }, d = $$1.runKernel(hc, c, u);
  return l ? W(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
}
const NS = /* @__PURE__ */ L({ maxPool3d_: TS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RS(n, t) {
  let e = T(n, "a", "maximum"), s = T(t, "b", "maximum");
  [e, s] = ne$1(e, s), e.dtype === "bool" && (e = et(e, "int32"), s = et(s, "int32")), bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(Vi, o);
}
const _s = /* @__PURE__ */ L({ maximum_: RS });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $S(n, t = null, e = false) {
  const o = { x: T(n, "x", "mean") }, r = { axis: t, keepDims: e };
  return $$1.runKernel(pc, o, r);
}
const se = /* @__PURE__ */ L({ mean_: $S });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ge$1(n, t = "float32") {
  if (is(n), t === "complex64") {
    const s = ge$1(n, "float32"), o = ge$1(n, "float32");
    return bo(s, o);
  }
  const e = Se(O(n), t);
  return $$1.makeTensor(e, n, t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Us(n, t = "float32") {
  if (is(n), t === "complex64") {
    const s = Us(n, "float32"), o = ge$1(n, "float32");
    return bo(s, o);
  }
  const e = Fl(O(n), t);
  return $$1.makeTensor(e, n, t);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GS(n, t) {
  let e = T(n, "a", "minimum"), s = T(t, "b", "minimum");
  [e, s] = ne$1(e, s), e.dtype === "bool" && (e = et(e, "int32"), s = et(s, "int32")), bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(zi, o);
}
const Kc = /* @__PURE__ */ L({ minimum_: GS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ES(n, t, e) {
  v(e === "reflect" || e === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);
  const s = T(n, "x", "mirrorPad");
  if (s.rank === 0)
    throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
  v(t.length === s.rank, () => `Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);
  const o = e === "reflect" ? 1 : 0;
  for (let a = 0; a < s.rank; a++)
    v(t[a].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), v(t[a][0] >= 0 && t[a][0] <= s.shape[a] - o && t[a][1] >= 0 && t[a][1] <= s.shape[a] - o, () => `Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a] - o} or less than 0 for input of shape ${s.shape}`);
  const r = { paddings: t, mode: e }, i6 = { x: s };
  return $$1.runKernel(mc, i6, r);
}
const LS = /* @__PURE__ */ L({ mirrorPad_: ES });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MS(n, t) {
  let e = T(n, "a", "mod"), s = T(t, "b", "mod");
  [e, s] = ne$1(e, s);
  const o = { a: e, b: s };
  return $$1.runKernel(Xi, o);
}
const WS = /* @__PURE__ */ L({ mod_: MS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DS(n, t = null, e = false) {
  n = T(n, "x", "moments");
  const s = Ct(t, n.shape), o = se(n, s, e);
  let r = o.shape;
  e || (r = re$1(o.shape, s));
  const i6 = At$1(lt(et(n, "float32"), W(o, r))), a = se(i6, s, e);
  return { mean: o, variance: a };
}
const op = /* @__PURE__ */ L({ moments_: DS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FS(n, t) {
  let e = T(n, "a", "notEqual", "string_or_numeric"), s = T(t, "b", "notEqual", "string_or_numeric");
  [e, s] = ne$1(e, s), bt$1(e.shape, s.shape);
  const o = { a: e, b: s };
  return $$1.runKernel(bc, o);
}
const qr = /* @__PURE__ */ L({ notEqual_: FS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VS(n, t, e = 1, s = 0, o = "int32") {
  if (t < 2)
    throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);
  const i6 = { indices: T(n, "indices", "oneHot", "int32") }, a = { dtype: o, depth: t, onValue: e, offValue: s };
  return $$1.runKernel(yc, i6, a);
}
const Pb = /* @__PURE__ */ L({ oneHot_: VS });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zS(n) {
  const e = { x: T(n, "x", "onesLike") };
  return $$1.runKernel(xc, e);
}
const Rn$1 = /* @__PURE__ */ L({ onesLike_: zS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XS(n, t, e = 0) {
  const s = T(n, "x", "pad");
  if (s.rank === 0)
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  const o = { paddings: t, constantValue: e }, r = { x: s };
  return $$1.runKernel(Ic, r, o);
}
const rp = /* @__PURE__ */ L({ pad_: XS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PS(n, t, e) {
  const s = T(n, "x", "spaceToBatchND");
  v(s.rank >= 1 + t.length, () => `input rank ${s.rank} should be > than [blockShape] ${t.length}`), v(e.length === t.length, () => `paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`), v(s.shape.reduce((i6, a, l) => l > 0 && l <= t.length ? i6 && (a + e[l - 1][0] + e[l - 1][1]) % t[l - 1] === 0 : i6, true), () => `input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);
  const o = { x: s }, r = { blockShape: t, paddings: e };
  return $$1.runKernel(Ec, o, r);
}
const ip = /* @__PURE__ */ L({ spaceToBatchND_: PS });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AS(n, t, e, s, o, r, i6) {
  o == null && (o = [1, 1]), r == null && (r = 1), s === 0 && (s = "valid");
  const a = T(n, "x", "maxPool");
  let l = a, c = false;
  a.rank === 3 && (c = true, l = W(a, [1, a.shape[0], a.shape[1], a.shape[2]])), v(Ee$1(r, o), () => `Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${o}'`);
  const u = $n$1(l.shape, t, r, o, s), d = [u.dilationHeight, u.dilationWidth];
  let h6;
  s === "same" ? h6 = KS([u.filterHeight, u.filterWidth], d) : h6 = [[0, 0], [0, 0]];
  const p6 = d[0] === 1 && d[1] === 1, [f, m] = OS([u.inHeight, u.inWidth], d, h6), g6 = p6 ? s : "valid", b6 = p6 ? l : ip(l, d, f), w6 = (e === "avg" ? () => Bh$1(b6, t, r, g6, i6) : () => sp(b6, t, r, g6, i6))(), y6 = p6 ? w6 : _h$1(w6, d, m);
  return c ? W(y6, [y6.shape[1], y6.shape[2], y6.shape[3]]) : y6;
}
function OS(n, t, e) {
  const s = e.map((u) => u[0]), o = e.map((u) => u[1]), r = n.concat(s, o), i6 = t.map((u, d) => (u - r[d] % u) % u), a = o.map((u, d) => u + i6[d]), l = t.map((u, d) => [s[d], a[d]]), c = t.map((u, d) => [0, i6[d]]);
  return [l, c];
}
function KS(n, t) {
  const s = n.map((i6, a) => i6 + (i6 - 1) * (t[a] - 1)).map((i6) => i6 - 1), o = s.map((i6) => Math.floor(i6 / 2)), r = s.map((i6, a) => i6 - o[a]);
  return s.map((i6, a) => [o[a], r[a]]);
}
const ZS = /* @__PURE__ */ L({ pool_: AS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BS(n, t) {
  const e = T(n, "x", "prelu"), s = T(t, "alpha", "prelu"), o = { x: e, alpha: s };
  return $$1.runKernel(Cc, o);
}
const ap = /* @__PURE__ */ L({ prelu_: BS });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HS(n, t = null, e = false) {
  let s = T(n, "x", "prod");
  s.dtype === "bool" && (s = et(s, "int32"));
  const o = { x: s }, r = { axis: t, keepDims: e };
  return $$1.runKernel(vc, o, r);
}
const _S = /* @__PURE__ */ L({ prod_: HS });
var lp = { exports: {} };
(function(n) {
  (function(t, e, s) {
    function o(l) {
      var c = this, u = a();
      c.next = function() {
        var d = 2091639 * c.s0 + c.c * 23283064365386963e-26;
        return c.s0 = c.s1, c.s1 = c.s2, c.s2 = d - (c.c = d | 0);
      }, c.c = 1, c.s0 = u(" "), c.s1 = u(" "), c.s2 = u(" "), c.s0 -= u(l), c.s0 < 0 && (c.s0 += 1), c.s1 -= u(l), c.s1 < 0 && (c.s1 += 1), c.s2 -= u(l), c.s2 < 0 && (c.s2 += 1), u = null;
    }
    function r(l, c) {
      return c.c = l.c, c.s0 = l.s0, c.s1 = l.s1, c.s2 = l.s2, c;
    }
    function i6(l, c) {
      var u = new o(l), d = c && c.state, h6 = u.next;
      return h6.int32 = function() {
        return u.next() * 4294967296 | 0;
      }, h6.double = function() {
        return h6() + (h6() * 2097152 | 0) * 11102230246251565e-32;
      }, h6.quick = h6, d && (typeof d == "object" && r(d, u), h6.state = function() {
        return r(u, {});
      }), h6;
    }
    function a() {
      var l = 4022871197, c = function(u) {
        u = String(u);
        for (var d = 0; d < u.length; d++) {
          l += u.charCodeAt(d);
          var h6 = 0.02519603282416938 * l;
          l = h6 >>> 0, h6 -= l, h6 *= l, l = h6 >>> 0, h6 -= l, l += h6 * 4294967296;
        }
        return (l >>> 0) * 23283064365386963e-26;
      };
      return c;
    }
    e && e.exports ? e.exports = i6 : s && s.amd ? s(function() {
      return i6;
    }) : this.alea = i6;
  })(
    x,
    n,
    // present in node.js
    false
    // present with an AMD loader
  );
})(lp);
var US = lp.exports, cp = { exports: {} };
(function(n) {
  (function(t, e, s) {
    function o(a) {
      var l = this, c = "";
      l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.next = function() {
        var d = l.x ^ l.x << 11;
        return l.x = l.y, l.y = l.z, l.z = l.w, l.w ^= l.w >>> 19 ^ d ^ d >>> 8;
      }, a === (a | 0) ? l.x = a : c += a;
      for (var u = 0; u < c.length + 64; u++)
        l.x ^= c.charCodeAt(u) | 0, l.next();
    }
    function r(a, l) {
      return l.x = a.x, l.y = a.y, l.z = a.z, l.w = a.w, l;
    }
    function i6(a, l) {
      var c = new o(a), u = l && l.state, d = function() {
        return (c.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var h6 = c.next() >>> 11, p6 = (c.next() >>> 0) / 4294967296, f = (h6 + p6) / (1 << 21);
        while (f === 0);
        return f;
      }, d.int32 = c.next, d.quick = d, u && (typeof u == "object" && r(u, c), d.state = function() {
        return r(c, {});
      }), d;
    }
    e && e.exports ? e.exports = i6 : s && s.amd ? s(function() {
      return i6;
    }) : this.xor128 = i6;
  })(
    x,
    n,
    // present in node.js
    false
    // present with an AMD loader
  );
})(cp);
var YS = cp.exports, up = { exports: {} };
(function(n) {
  (function(t, e, s) {
    function o(a) {
      var l = this, c = "";
      l.next = function() {
        var d = l.x ^ l.x >>> 2;
        return l.x = l.y, l.y = l.z, l.z = l.w, l.w = l.v, (l.d = l.d + 362437 | 0) + (l.v = l.v ^ l.v << 4 ^ (d ^ d << 1)) | 0;
      }, l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.v = 0, a === (a | 0) ? l.x = a : c += a;
      for (var u = 0; u < c.length + 64; u++)
        l.x ^= c.charCodeAt(u) | 0, u == c.length && (l.d = l.x << 10 ^ l.x >>> 4), l.next();
    }
    function r(a, l) {
      return l.x = a.x, l.y = a.y, l.z = a.z, l.w = a.w, l.v = a.v, l.d = a.d, l;
    }
    function i6(a, l) {
      var c = new o(a), u = l && l.state, d = function() {
        return (c.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var h6 = c.next() >>> 11, p6 = (c.next() >>> 0) / 4294967296, f = (h6 + p6) / (1 << 21);
        while (f === 0);
        return f;
      }, d.int32 = c.next, d.quick = d, u && (typeof u == "object" && r(u, c), d.state = function() {
        return r(c, {});
      }), d;
    }
    e && e.exports ? e.exports = i6 : s && s.amd ? s(function() {
      return i6;
    }) : this.xorwow = i6;
  })(
    x,
    n,
    // present in node.js
    false
    // present with an AMD loader
  );
})(up);
var QS = up.exports, dp = { exports: {} };
(function(n) {
  (function(t, e, s) {
    function o(a) {
      var l = this;
      l.next = function() {
        var u = l.x, d = l.i, h6, p6;
        return h6 = u[d], h6 ^= h6 >>> 7, p6 = h6 ^ h6 << 24, h6 = u[d + 1 & 7], p6 ^= h6 ^ h6 >>> 10, h6 = u[d + 3 & 7], p6 ^= h6 ^ h6 >>> 3, h6 = u[d + 4 & 7], p6 ^= h6 ^ h6 << 7, h6 = u[d + 7 & 7], h6 = h6 ^ h6 << 13, p6 ^= h6 ^ h6 << 9, u[d] = p6, l.i = d + 1 & 7, p6;
      };
      function c(u, d) {
        var h6, p6 = [];
        if (d === (d | 0))
          p6[0] = d;
        else
          for (d = "" + d, h6 = 0; h6 < d.length; ++h6)
            p6[h6 & 7] = p6[h6 & 7] << 15 ^ d.charCodeAt(h6) + p6[h6 + 1 & 7] << 13;
        for (; p6.length < 8; )
          p6.push(0);
        for (h6 = 0; h6 < 8 && p6[h6] === 0; ++h6)
          ;
        for (h6 == 8 ? p6[7] = -1 : p6[h6], u.x = p6, u.i = 0, h6 = 256; h6 > 0; --h6)
          u.next();
      }
      c(l, a);
    }
    function r(a, l) {
      return l.x = a.x.slice(), l.i = a.i, l;
    }
    function i6(a, l) {
      a == null && (a = +/* @__PURE__ */ new Date());
      var c = new o(a), u = l && l.state, d = function() {
        return (c.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var h6 = c.next() >>> 11, p6 = (c.next() >>> 0) / 4294967296, f = (h6 + p6) / (1 << 21);
        while (f === 0);
        return f;
      }, d.int32 = c.next, d.quick = d, u && (u.x && r(u, c), d.state = function() {
        return r(c, {});
      }), d;
    }
    e && e.exports ? e.exports = i6 : s && s.amd ? s(function() {
      return i6;
    }) : this.xorshift7 = i6;
  })(
    x,
    n,
    // present in node.js
    false
    // present with an AMD loader
  );
})(dp);
var JS = dp.exports, hp = { exports: {} };
(function(n) {
  (function(t, e, s) {
    function o(a) {
      var l = this;
      l.next = function() {
        var u = l.w, d = l.X, h6 = l.i, p6, f;
        return l.w = u = u + 1640531527 | 0, f = d[h6 + 34 & 127], p6 = d[h6 = h6 + 1 & 127], f ^= f << 13, p6 ^= p6 << 17, f ^= f >>> 15, p6 ^= p6 >>> 12, f = d[h6] = f ^ p6, l.i = h6, f + (u ^ u >>> 16) | 0;
      };
      function c(u, d) {
        var h6, p6, f, m, g6, b6 = [], x6 = 128;
        for (d === (d | 0) ? (p6 = d, d = null) : (d = d + "\0", p6 = 0, x6 = Math.max(x6, d.length)), f = 0, m = -32; m < x6; ++m)
          d && (p6 ^= d.charCodeAt((m + 32) % d.length)), m === 0 && (g6 = p6), p6 ^= p6 << 10, p6 ^= p6 >>> 15, p6 ^= p6 << 4, p6 ^= p6 >>> 13, m >= 0 && (g6 = g6 + 1640531527 | 0, h6 = b6[m & 127] ^= p6 + g6, f = h6 == 0 ? f + 1 : 0);
        for (f >= 128 && (b6[(d && d.length || 0) & 127] = -1), f = 127, m = 4 * 128; m > 0; --m)
          p6 = b6[f + 34 & 127], h6 = b6[f = f + 1 & 127], p6 ^= p6 << 13, h6 ^= h6 << 17, p6 ^= p6 >>> 15, h6 ^= h6 >>> 12, b6[f] = p6 ^ h6;
        u.w = g6, u.X = b6, u.i = f;
      }
      c(l, a);
    }
    function r(a, l) {
      return l.i = a.i, l.w = a.w, l.X = a.X.slice(), l;
    }
    function i6(a, l) {
      a == null && (a = +/* @__PURE__ */ new Date());
      var c = new o(a), u = l && l.state, d = function() {
        return (c.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var h6 = c.next() >>> 11, p6 = (c.next() >>> 0) / 4294967296, f = (h6 + p6) / (1 << 21);
        while (f === 0);
        return f;
      }, d.int32 = c.next, d.quick = d, u && (u.X && r(u, c), d.state = function() {
        return r(c, {});
      }), d;
    }
    e && e.exports ? e.exports = i6 : s && s.amd ? s(function() {
      return i6;
    }) : this.xor4096 = i6;
  })(
    x,
    // window object or global
    n,
    // present in node.js
    false
    // present with an AMD loader
  );
})(hp);
var jS = hp.exports, pp = { exports: {} };
(function(n) {
  (function(t, e, s) {
    function o(a) {
      var l = this, c = "";
      l.next = function() {
        var d = l.b, h6 = l.c, p6 = l.d, f = l.a;
        return d = d << 25 ^ d >>> 7 ^ h6, h6 = h6 - p6 | 0, p6 = p6 << 24 ^ p6 >>> 8 ^ f, f = f - d | 0, l.b = d = d << 20 ^ d >>> 12 ^ h6, l.c = h6 = h6 - p6 | 0, l.d = p6 << 16 ^ h6 >>> 16 ^ f, l.a = f - d | 0;
      }, l.a = 0, l.b = 0, l.c = -1640531527, l.d = 1367130551, a === Math.floor(a) ? (l.a = a / 4294967296 | 0, l.b = a | 0) : c += a;
      for (var u = 0; u < c.length + 20; u++)
        l.b ^= c.charCodeAt(u) | 0, l.next();
    }
    function r(a, l) {
      return l.a = a.a, l.b = a.b, l.c = a.c, l.d = a.d, l;
    }
    function i6(a, l) {
      var c = new o(a), u = l && l.state, d = function() {
        return (c.next() >>> 0) / 4294967296;
      };
      return d.double = function() {
        do
          var h6 = c.next() >>> 11, p6 = (c.next() >>> 0) / 4294967296, f = (h6 + p6) / (1 << 21);
        while (f === 0);
        return f;
      }, d.int32 = c.next, d.quick = d, u && (typeof u == "object" && r(u, c), d.state = function() {
        return r(c, {});
      }), d;
    }
    e && e.exports ? e.exports = i6 : s && s.amd ? s(function() {
      return i6;
    }) : this.tychei = i6;
  })(
    x,
    n,
    // present in node.js
    false
    // present with an AMD loader
  );
})(pp);
var qS = pp.exports, Ab = { exports: {} };
const tk = {}, ek = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: tk
}, Symbol.toStringTag, { value: "Module" })), nk = /* @__PURE__ */ w(ek);
(function(n) {
  (function(t, e, s) {
    var o = 256, r = 6, i6 = 52, a = "random", l = s.pow(o, r), c = s.pow(2, i6), u = c * 2, d = o - 1, h6;
    function p6(y6, I, C6) {
      var k7 = [];
      I = I == true ? { entropy: true } : I || {};
      var S = b6(g6(
        I.entropy ? [y6, w6(e)] : y6 ?? x6(),
        3
      ), k7), N = new f(k7), R = function() {
        for (var M6 = N.g(r), V = l, z = 0; M6 < c; )
          M6 = (M6 + z) * o, V *= o, z = N.g(1);
        for (; M6 >= u; )
          M6 /= 2, V /= 2, z >>>= 1;
        return (M6 + z) / V;
      };
      return R.int32 = function() {
        return N.g(4) | 0;
      }, R.quick = function() {
        return N.g(4) / 4294967296;
      }, R.double = R, b6(w6(N.S), e), (I.pass || C6 || function(M6, V, z, X) {
        return X && (X.S && m(X, N), M6.state = function() {
          return m(N, {});
        }), z ? (s[a] = M6, V) : M6;
      })(
        R,
        S,
        "global" in I ? I.global : this == s,
        I.state
      );
    }
    function f(y6) {
      var I, C6 = y6.length, k7 = this, S = 0, N = k7.i = k7.j = 0, R = k7.S = [];
      for (C6 || (y6 = [C6++]); S < o; )
        R[S] = S++;
      for (S = 0; S < o; S++)
        R[S] = R[N = d & N + y6[S % C6] + (I = R[S])], R[N] = I;
      (k7.g = function(M6) {
        for (var V, z = 0, X = k7.i, P6 = k7.j, A6 = k7.S; M6--; )
          V = A6[X = d & X + 1], z = z * o + A6[d & (A6[X] = A6[P6 = d & P6 + V]) + (A6[P6] = V)];
        return k7.i = X, k7.j = P6, z;
      })(o);
    }
    function m(y6, I) {
      return I.i = y6.i, I.j = y6.j, I.S = y6.S.slice(), I;
    }
    function g6(y6, I) {
      var C6 = [], k7 = typeof y6, S;
      if (I && k7 == "object")
        for (S in y6)
          try {
            C6.push(g6(y6[S], I - 1));
          } catch {
          }
      return C6.length ? C6 : k7 == "string" ? y6 : y6 + "\0";
    }
    function b6(y6, I) {
      for (var C6 = y6 + "", k7, S = 0; S < C6.length; )
        I[d & S] = d & (k7 ^= I[d & S] * 19) + C6.charCodeAt(S++);
      return w6(I);
    }
    function x6() {
      try {
        var y6;
        return h6 && (y6 = h6.randomBytes) ? y6 = y6(o) : (y6 = new Uint8Array(o), (t.crypto || t.msCrypto).getRandomValues(y6)), w6(y6);
      } catch {
        var I = t.navigator, C6 = I && I.plugins;
        return [+/* @__PURE__ */ new Date(), t, C6, t.screen, w6(e)];
      }
    }
    function w6(y6) {
      return String.fromCharCode.apply(0, y6);
    }
    if (b6(s.random(), e), n.exports) {
      n.exports = p6;
      try {
        h6 = nk;
      } catch {
      }
    } else
      s["seed" + a] = p6;
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self < "u" ? self : x,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );
})(Ab);
var sk = Ab.exports, ok = US, rk = YS, ik = QS, ak = JS, lk = jS, ck = qS, Fo = sk;
Fo.alea = ok;
Fo.xor128 = rk;
Fo.xorwow = ik;
Fo.xorshift7 = ak;
Fo.xor4096 = lk;
Fo.tychei = ck;
var wr = Fo;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fp {
  constructor(t, e, s, o, r) {
    this.mean = t, this.stdDev = e, this.dtype = s, this.nextVal = NaN, this.truncated = o, this.truncated && (this.upper = this.mean + this.stdDev * 2, this.lower = this.mean - this.stdDev * 2);
    const i6 = r || Math.random();
    this.random = wr.alea(i6.toString());
  }
  /** Returns next sample from a Gaussian distribution. */
  nextValue() {
    if (!isNaN(this.nextVal)) {
      const o = this.nextVal;
      return this.nextVal = NaN, o;
    }
    let t, e, s = false;
    for (; !s; ) {
      let o, r, i6;
      do
        o = 2 * this.random() - 1, r = 2 * this.random() - 1, i6 = o * o + r * r;
      while (i6 >= 1 || i6 === 0);
      const a = Math.sqrt(-2 * Math.log(i6) / i6);
      t = this.mean + this.stdDev * o * a, e = this.mean + this.stdDev * r * a, (!this.truncated || this.isValidTruncated(t)) && (s = true);
    }
    return (!this.truncated || this.isValidTruncated(e)) && (this.nextVal = this.convertValue(e)), this.convertValue(t);
  }
  /** Handles proper rounding for non-floating-point numbers. */
  convertValue(t) {
    return this.dtype == null || this.dtype === "float32" ? t : Math.round(t);
  }
  /** Returns true if less than 2-standard-deviations from the mean. */
  isValidTruncated(t) {
    return t <= this.upper && t >= this.lower;
  }
}
class dY {
  constructor(t, e, s, o) {
    this.alpha = t, this.beta = 1 / e, this.dtype = s;
    const r = o || Math.random();
    this.randu = wr.alea(r.toString()), this.randn = new fp(0, 1, s, false, this.randu()), t < 1 ? this.d = t + 2 / 3 : this.d = t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  /** Returns next sample from a gamma distribution. */
  nextValue() {
    let t, e, s, o, r, i6;
    for (; ; ) {
      do
        o = this.randn.nextValue(), i6 = 1 + this.c * o;
      while (i6 <= 0);
      if (i6 *= i6 * i6, t = o * o, e = 1 - 0.331 * t * t, s = 0.5 * t + this.d * (1 - i6 + Math.log(i6)), r = this.randu(), r < e || Math.log(r) < s)
        break;
    }
    return i6 = 1 / this.beta * this.d * i6, this.alpha < 1 && (i6 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(i6);
  }
  /** Handles proper rounding for non-floating-point numbers. */
  convertValue(t) {
    return this.dtype === "float32" ? t : Math.round(t);
  }
}
class uk {
  constructor(t = 0, e = 1, s, o) {
    if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", this.min = t, this.range = e - t, this.dtype = s, o == null && (o = Math.random()), typeof o == "number" && (o = o.toString()), !this.canReturnFloat() && this.range <= 1)
      throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);
    this.random = wr.alea(o);
  }
  convertValue(t) {
    return this.canReturnFloat() ? t : Math.round(t);
  }
  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dk(n, t = 0, e = 1, s, o) {
  if (is(n), s != null && s === "bool")
    throw new Error(`Unsupported data type ${s}`);
  const r = new fp(t, e, s, false, o), i6 = vt$1(n, s);
  for (let a = 0; a < i6.values.length; a++)
    i6.values[a] = r.nextValue();
  return i6.toTensor();
}
const hk = /* @__PURE__ */ L({ randomNormal_: dk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pk(n, t = 0, e = 1, s = "float32", o) {
  is(n);
  const r = vt$1(n, s), i6 = new uk(t, e, null, o);
  for (let a = 0; a < r.values.length; a++)
    r.values[a] = i6.nextValue();
  return r.toTensor();
}
const Zc = /* @__PURE__ */ L({ randomUniform_: pk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ti$1(n, t, e = 1, s = "float32") {
  if (e === 0)
    throw new Error("Cannot have a step of zero");
  const o = { start: n, stop: t, step: e, dtype: s };
  return $$1.runKernel(yh$1, {}, o);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fk(n) {
  const e = { input: T(n, "input", "real") };
  return $$1.runKernel(wh$1, e);
}
const dl = /* @__PURE__ */ L({ real_: fk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mk(n) {
  const e = { x: T(n, "x", "reciprocal") };
  return $$1.runKernel(Oi, e);
}
const gk = /* @__PURE__ */ L({ reciprocal_: mk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bk(n) {
  const e = { x: T(n, "x", "relu") };
  return $$1.runKernel(Ki, e);
}
const ws = /* @__PURE__ */ L({ relu_: bk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xk(n) {
  const e = { x: T(n, "x", "relu6") };
  return $$1.runKernel(Zi, e);
}
const Ob = /* @__PURE__ */ L({ relu6_: xk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yk(n, t) {
  const s = { x: T(n, "x", "reverse") }, o = { dims: t };
  return $$1.runKernel(Nc, s, o);
}
const ko = /* @__PURE__ */ L({ reverse_: yk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wk(n) {
  const e = { x: T(n, "x", "round") };
  return $$1.runKernel(Bi, e);
}
const Kb = /* @__PURE__ */ L({ round_: wk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ik(n) {
  const e = { x: T(n, "x", "rsqrt", "float32") };
  return $$1.runKernel(Hi, e);
}
const Zb = /* @__PURE__ */ L({ rsqrt_: Ik });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ck(n) {
  const e = { x: T(n, "x", "selu") };
  return $$1.runKernel(_i, e);
}
const Bb = /* @__PURE__ */ L({ selu_: Ck });
function vk(n, t, e, s, o, r = [1, 1], i6 = "NHWC") {
  const a = T(n, "x", "separableConv2d"), l = T(t, "depthwiseFilter", "separableConv2d"), c = T(e, "pointwiseFilter", "separableConv2d");
  let u = a, d = false;
  if (a.rank === 3 && (d = true, u = W(a, [1, a.shape[0], a.shape[1], a.shape[2]])), i6 === "NCHW")
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  v(u.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`), v(l.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`), v(c.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`), v(c.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`), v(c.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);
  const h6 = l.shape[2], p6 = l.shape[3];
  v(c.shape[2] === h6 * p6, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${h6 * p6}, but got ${c.shape[2]}.`);
  const f = Qh$1(u, l, s, o, i6, r), g6 = Co(f, c, 1, "valid", i6);
  return d ? W(g6, [g6.shape[1], g6.shape[2], g6.shape[3]]) : g6;
}
const Hb = /* @__PURE__ */ L({ separableConv2d_: vk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sk(n) {
  const e = { x: T(n, "x", "sign") };
  return $$1.runKernel(Qi, e);
}
const kk = /* @__PURE__ */ L({ sign_: Sk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tk(n) {
  const e = { x: T(n, "x", "sin", "float32") };
  return $$1.runKernel(Ui, e);
}
const _b = /* @__PURE__ */ L({ sin_: Tk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nk(n) {
  const e = { x: T(n, "x", "sinh") };
  return $$1.runKernel(Yi, e);
}
const Ub = /* @__PURE__ */ L({ sinh_: Nk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rk(n, t, e) {
  const s = T(n, "x", "slice1d");
  return v(s.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`), Dt(s, [t], [e]);
}
const mp = /* @__PURE__ */ L({ slice1d_: Rk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $k(n, t, e) {
  const s = T(n, "x", "slice2d");
  return v(s.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`), Dt(s, t, e);
}
const Yb = /* @__PURE__ */ L({ slice2d_: $k });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gk(n, t, e) {
  const s = T(n, "x", "slice3d");
  return v(s.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`), Dt(s, t, e);
}
const gp = /* @__PURE__ */ L({ slice3d_: Gk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ek(n, t, e) {
  const s = T(n, "x", "slice4d");
  return v(s.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`), Dt(s, t, e);
}
const hl = /* @__PURE__ */ L({ slice4d_: Ek });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Lk(n, t = -1) {
  const e = T(n, "logits", "softmax", "float32");
  if (t === -1 && (t = e.rank - 1), t !== e.rank - 1)
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);
  const s = { logits: e }, o = { dim: t };
  return $$1.runKernel(Mc, s, o);
}
const bp = /* @__PURE__ */ L({ softmax_: Lk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mk(n) {
  v(n.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);
  const t = { input: n };
  return $$1.runKernel(lh$1, t);
}
const xp = /* @__PURE__ */ L({ fft_: Mk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wk(n) {
  v(n.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);
  const t = { input: n };
  return $$1.runKernel(dh$1, t);
}
const pl = /* @__PURE__ */ L({ ifft_: Wk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dk(n) {
  const t = n.shape[n.shape.length - 1], e = n.size / t;
  let s;
  if (t <= 2) {
    const o = W(n, [e, t]);
    s = pl(o);
  } else {
    const o = [e, 2 * (t - 1)], r = W(dl(n), [e, t]), i6 = W(qh$1(n), [e, t]), a = ko(Dt(r, [0, 1], [e, t - 2]), 1), l = G(ko(Dt(i6, [0, 1], [e, t - 2]), 1), gt$1(-1)), c = Ge$1([r, a], 1), u = Ge$1([i6, l], 1), d = W(bo(c, u), [o[0], o[1]]);
    s = pl(d);
  }
  if (s = dl(s), n.rank === 3 && n.shape[0] !== 0) {
    const o = s, r = n.shape[0];
    s = W(s, [r, s.shape[0] / r, s.shape[1]]), o.dispose();
  }
  return s;
}
const Qb = /* @__PURE__ */ L({ irfft_: Dk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fk(n, t, e = 0) {
  const o = { x: T(n, "x", "split") }, r = { numOrSizeSplits: t, axis: e };
  return $$1.runKernel(Lc, o, r);
}
const un$1 = /* @__PURE__ */ L({ split_: Fk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vk(n, t) {
  v(n.dtype === "float32", () => `The dtype for rfft() must be real value but got ${n.dtype}`);
  let e = n.shape[n.shape.length - 1];
  const s = n.size / e;
  let o;
  if (t != null && t < e) {
    const f = n.shape.map((g6) => 0), m = n.shape.map((g6) => g6);
    m[n.shape.length - 1] = t, o = Dt(n, f, m), e = t;
  } else if (t != null && t > e) {
    const f = n.shape.map((m) => m);
    f[n.shape.length - 1] = t - e, o = Ge$1([n, ge$1(f)], n.shape.length - 1), e = t;
  } else
    o = n;
  const r = Tt$1(o), i6 = W(bo(o, r), [s, e]), a = xp(i6), l = Math.floor(e / 2) + 1, c = dl(a), u = qh$1(a), d = un$1(c, [l, e - l], c.shape.length - 1), h6 = un$1(u, [l, e - l], u.shape.length - 1), p6 = o.shape.slice();
  return p6[o.shape.length - 1] = l, W(bo(d[0], h6[0]), p6);
}
const yp = /* @__PURE__ */ L({ rfft_: Vk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zk(n, t) {
  let e = T(n, "a", "squaredDifference"), s = T(t, "b", "squaredDifference");
  [e, s] = ne$1(e, s), bt$1(e.shape, s.shape);
  const o = { a: e, b: s }, r = {};
  return $$1.runKernel(ta, o, r);
}
const Jb = /* @__PURE__ */ L({ squaredDifference_: zk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xk(n, t) {
  const e = T(n, "x", "squeeze", "string_or_numeric");
  return W(e, gs(e.shape, t).newShape);
}
const ha = /* @__PURE__ */ L({ squeeze_: Xk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Pk(n, t = 0) {
  const e = Ah$1(n, "tensors", "stack", "string_or_numeric");
  v(e.length >= 1, () => "Pass at least one tensor to tf.stack"), e.length > 0 && v(t <= e[0].rank, () => "Axis must be <= rank of the tensor");
  const s = e, o = { axis: t };
  return $$1.runKernel(wc, s, o);
}
const os = /* @__PURE__ */ L({ stack_: Pk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ak(n, t = 0) {
  const s = { x: T(n, "x", "step") }, o = { alpha: t };
  return $$1.runKernel(ra, s, o);
}
const pa = /* @__PURE__ */ L({ step_: Ak });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ok(n, t, e, s, o = 0, r = 0, i6 = 0, a = 0, l = 0) {
  const u = { x: T(n, "x", "stridedSlice", "string_or_numeric") }, d = {
    begin: t,
    end: e,
    strides: s,
    beginMask: o,
    endMask: r,
    ellipsisMask: i6,
    newAxisMask: a,
    shrinkAxisMask: l
  };
  return $$1.runKernel(Rh$1, u, d);
}
const Kk = /* @__PURE__ */ L({ stridedSlice_: Ok });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zk(n) {
  const e = { x: T(n, "x", "tan", "float32") };
  return $$1.runKernel(na, e);
}
const Bk = /* @__PURE__ */ L({ tan_: Zk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Je$1(n, t) {
  Dl(n);
  const e = aa(n, t);
  if (e.length !== 1)
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return la(n, null, e, t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qa(n, t, e) {
  if (Dl(n), t != null && t.length !== 2)
    throw new Error("tensor2d() requires shape to have two numbers");
  const s = aa(n, e);
  if (s.length !== 2 && s.length !== 1)
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (s.length === 1 && t == null)
    throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return la(n, t, s, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hk(n, t, e) {
  if (Dl(n), t != null && t.length !== 3)
    throw new Error("tensor3d() requires shape to have three numbers");
  const s = aa(n, e);
  if (s.length !== 3 && s.length !== 1)
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (s.length === 1 && t == null)
    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return la(n, t, s, e);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _k(n, t = 1, e = true) {
  const s = T(n, "x", "topk");
  if (s.rank === 0)
    throw new Error("topk() expects the input to be of rank 1 or higher");
  const o = s.shape[s.shape.length - 1];
  if (t < 0)
    throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);
  if (t > o)
    throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);
  const r = { x: s }, i6 = { k: t, sorted: e }, [a, l] = $$1.runKernel(Lh$1, r, i6);
  return { values: a, indices: l };
}
const Uk = /* @__PURE__ */ L({ topk_: _k });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yk(n, t = 0, e = 1, s, o) {
  if (is(n), s != null && s === "bool")
    throw new Error("Unsupported data type $ { dtype }");
  const r = new fp(t, e, s, true, o), i6 = vt$1(n, s);
  for (let a = 0; a < i6.values.length; a++)
    i6.values[a] = r.nextValue();
  return i6.toTensor();
}
const jb = /* @__PURE__ */ L({ truncatedNormal_: Yk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qk(n, t = 0) {
  const e = T(n, "x", "unique", "string_or_numeric");
  v(e.rank > 0, () => "The input tensor must be at least 1D");
  const s = { x: e }, o = { axis: t }, [r, i6] = $$1.runKernel(Wh$1, s, o);
  return { values: r, indices: i6 };
}
const Jk = /* @__PURE__ */ L({ unique_: Qk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jk(n, t, e) {
  const s = T(n, "x", "unsortedSegmentSum"), o = T(t, "segmentIds", "unsortedSegmentSum", "int32");
  v(go(e), () => "numSegments must be of dtype int");
  const r = { x: s, segmentIds: o }, i6 = { numSegments: e };
  return $$1.runKernel(Dc, r, i6);
}
const qb = /* @__PURE__ */ L({ unsortedSegmentSum_: jk });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qk(n, t = 0) {
  const e = T(n, "x", "unstack", "string_or_numeric");
  v(t >= -e.shape.length && t < e.shape.length, () => `Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);
  const s = { value: e }, o = { axis: t };
  return $$1.runKernel(Wc, s, o);
}
const To = /* @__PURE__ */ L({ unstack_: qk });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tT(n, t = true, e, s) {
  return $$1.makeVariable(n, t, e, s);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function t0(n, t) {
  const e = [];
  for (let r = 0; r < t.length; r++)
    t[r] && e.push(r);
  const s = vt$1(n, "int32"), o = vt$1([e.length, n.length], "int32");
  for (let r = 0; r < e.length; r++) {
    const i6 = s.indexToLoc(e[r]), a = r * n.length;
    o.values.set(i6, a);
  }
  return o.toTensor();
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eT(n, t, e) {
  const s = T(n, "x", "transpose");
  if (t == null && (t = s.shape.map((i6, a) => a).reverse()), v(s.rank === t.length, () => `Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`), t.forEach((i6) => {
    v(i6 >= 0 && i6 < s.rank, () => `All entries in 'perm' must be between 0 and ${s.rank - 1} but got ${t}`);
  }), s.rank <= 1)
    return s.clone();
  const o = { x: s }, r = { perm: t };
  return s.dtype === "complex64" ? D(() => {
    let i6 = dl(s), a = qh$1(s);
    return i6 = $$1.runKernel(Jo, { x: i6 }, r), a = $$1.runKernel(Jo, { x: a }, r), e && (a = jt$1(a)), bo(i6, a);
  }) : $$1.runKernel(Jo, o, r);
}
const kt = /* @__PURE__ */ L({ transpose_: eT });
function wp(n, t, e) {
  const s = t.rank > 1 ? t.shape[t.rank - 1] : 1, o = t.rank > 1 ? t.rank - 1 : 1, r = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${o}.`;
  if (e.rank < o)
    throw new Error(r + ` update.rank < ${o}. `);
  if (n.length < s + (e.rank - o))
    throw new Error(r + ` Output shape length < ${s + (e.rank - o)}`);
  if (e.rank !== o + n.length - s)
    throw new Error(r + ` update.rank != ${o + n.length - s}`);
  for (let i6 = 0; i6 < o; ++i6)
    if (e.shape[i6] !== t.shape[i6])
      throw new Error(r + ` updates.shape[${i6}] (${e.shape[i6]}) != indices.shape[${i6}] (${t.shape[i6]}).`);
  for (let i6 = 0; i6 < e.rank - o; ++i6)
    if (e.shape[i6 + o] !== n[i6 + s])
      throw new Error(r + ` updates.shape[${i6 + o}] (${e.shape[i6 + o]}) != shape[${i6 + o}] (${n[i6 + o]})`);
}
function e0(n, t, e) {
  if (t.rank < 1)
    throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);
  if (n.rank < 1)
    throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);
  if (t.dtype !== "int32")
    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);
  if (e.length < 1)
    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);
  if (e.length === 0) {
    if (t.size === 0)
      throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);
    if (n.size === 0)
      throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`);
  }
  wp(e, t, n);
}
function Ir(n, t, e) {
  const s = t.shape.length, o = s > 1 ? t.shape[s - 1] : 1, r = e.length;
  let i6 = 1;
  for (let d = o; d < r; ++d)
    i6 *= e[d];
  const a = o < 1 ? 1 : o, l = O(t.shape) / a, c = [...dt(e.slice(0, o)), 1], u = O(e);
  return { sliceRank: o, numUpdates: l, sliceSize: i6, strides: c, outputSize: u };
}
const hY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  calculateShapes: Ir,
  validateInput: e0,
  validateUpdateShape: wp
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nT(n, t) {
  if (t == null)
    return n.shape.slice();
  if (Rt$1(n.shape, t))
    return t;
  if (n.shape.length === t.length) {
    const e = [];
    for (let s = 0; s < n.shape.length; s++)
      t[s] == null && n.shape[s] != null ? e.push(n.shape[s]) : e.push(t[s]);
    return e;
  }
  return t;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sT(n, t, e, s) {
  const o = T(n, "x", "dropout");
  if (v(o.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`), v(t >= 0 && t < 1, () => `rate must be a float in the range [0, 1), but got ${t}.`), t === 0)
    return n instanceof Lt$1 ? o.clone() : o;
  const r = nT(o, e), i6 = 1 - t, a = ut(Ac(U(Zc(r, 0, 1, "float32", s), i6)), i6);
  return G(o, a);
}
const oT = /* @__PURE__ */ L({ dropout_: sT });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rT(n) {
  return Math.floor(Math.pow(2, Math.ceil(Math.log(n) / Math.log(2))));
}
function n0(n, t, e) {
  const s = 1 - n % 2, o = new Float32Array(n);
  for (let r = 0; r < n; ++r) {
    const i6 = 2 * Math.PI * r / (n + s - 1);
    o[r] = t - e * Math.cos(i6);
  }
  return Je$1(o, "float32");
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iT(n, t, e, s, o, r = "NHWC", i6) {
  let a = n;
  n.rank === 3 && (a = W(n, [1, n.shape[0], n.shape[1], n.shape[2]]));
  let l = t;
  l.rank === 3 && (l = W(t, [1, t.shape[0], t.shape[1], t.shape[2]])), v(a.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`), v(l.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`), v(e.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);
  const c = r === "NHWC" ? a.shape[3] : a.shape[1], u = r === "NHWC" ? l.shape[3] : l.shape[1];
  v(c === e[2], () => `Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`), v(u === e[3], () => `Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`), Be$1("conv2dDerFilter", o, i6);
  const d = { x: a, dy: l }, h6 = { strides: s, pad: o, dataFormat: r, dimRoundingMode: i6, filterShape: e };
  return $$1.runKernel(jd$1, d, h6);
}
const Ip = /* @__PURE__ */ L({ conv2DBackpropFilter_: iT });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cp(n, t, e) {
  if (e == null || e === "linear")
    return n;
  if (e === "relu")
    return G(n, pa(t));
  throw new Error(`Cannot compute gradient for fused activation ${e}.`);
}
function vp(n, t) {
  let e = t;
  const s = le(n.shape, t.shape);
  return s.length > 0 && (e = at(e, s)), W(e, n.shape);
}
function Sp(n, t, e, s) {
  if (t === "linear")
    return n;
  if (t === "relu")
    return ws(n);
  if (t === "elu")
    return Xc(n);
  if (t === "relu6")
    return Ob(n);
  if (t === "prelu")
    return ap(n, e);
  if (t === "leakyrelu")
    return tp(n, s);
  if (t === "sigmoid")
    return xr(n);
  throw new Error(`Unknown fused activation ${t}.`);
}
const kp = (n, t) => !(n > 0) || t === "linear";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aT({ x: n, filter: t, strides: e, pad: s, dataFormat: o = "NHWC", dilations: r = [1, 1], dimRoundingMode: i6, bias: a, activation: l = "linear", preluActivationWeights: c, leakyreluAlpha: u }) {
  if (l = l || "linear", kp($$1.state.gradientDepth, l) === false) {
    v(o === "NHWC", () => `Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
    let C6 = Co(n, t, e, s, o, r, i6);
    return a != null && (C6 = U(C6, a)), Sp(C6, l, c, u);
  }
  const d = T(n, "x", "conv2d", "float32"), h6 = T(t, "filter", "conv2d", "float32");
  let p6 = d, f = false;
  d.rank === 3 && (f = true, p6 = W(d, [1, d.shape[0], d.shape[1], d.shape[2]])), v(p6.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${p6.rank}.`), v(h6.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${h6.rank}.`), Be$1("fused conv2d", s, i6);
  const m = o === "NHWC" ? p6.shape[3] : p6.shape[1];
  v(h6.shape[2] === m, () => `Error in conv2d: depth of input (${m}) must match input depth for filter ${h6.shape[2]}.`), v(Ee$1(e, r), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`);
  const g6 = ke(p6.shape, h6.shape, e, r, s, i6);
  let b6;
  a != null && (b6 = T(a, "bias", "fused conv2d"), [b6] = ne$1(b6, d), o === "NHWC" ? bt$1(g6.outShape, b6.shape) : (v(b6.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b6.shape.length}.`), v(b6.shape.length === 0 || b6.shape[0] === g6.outChannels || b6.shape[0] === 1, () => `Error in fused conv2d: bias shape (${b6.shape}) is not compatible with the number of output channels (${g6.outChannels})`)));
  let x6;
  if (c != null) {
    const C6 = c.shape;
    if (v(C6.length <= 1 || C6.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C6.length}.`), C6.length === 1)
      v(C6[0] === 1 || C6[0] === g6.outChannels, () => `Error in fused conv2d: PReLU activation weights (${C6}) is not compatible with the number of output channels (${g6.outChannels}).`);
    else if (C6.length === 3)
      try {
        bt$1(C6, g6.outShape);
      } catch {
        const S = `Error in fused conv2d: PReLU activation weights (${C6}) is not compatible with the output shape of the conv2d (${g6.outShape}).`;
        throw Error(S);
      }
    x6 = T(c, "prelu weights", "fused conv2d");
  }
  const w6 = (C6, k7) => {
    v(o === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);
    const [S, N, R, M6] = k7, V = Cp(C6, R, l);
    v(wo(r), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);
    const z = Uh$1(N.shape, V, S, e, s), X = Ip(N, V, S.shape, e, s), P6 = [z, X];
    if (M6 != null) {
      const A6 = vp(M6, V);
      P6.push(A6);
    }
    return P6;
  }, y6 = {
    x: p6,
    filter: h6,
    bias: b6,
    preluActivationWeights: x6
  }, I = {
    strides: e,
    pad: s,
    dataFormat: o,
    dilations: r,
    dimRoundingMode: i6,
    activation: l,
    leakyreluAlpha: u
  };
  return a == null ? So((k7, S, N) => {
    let R = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      $$1.runKernel(rl, y6, I)
    );
    return N([S, k7, R]), f && (R = W(R, [R.shape[1], R.shape[2], R.shape[3]])), { value: R, gradFunc: w6 };
  })(p6, h6) : So((k7, S, N, R) => {
    let M6 = $$1.runKernel(rl, y6, I);
    return R([S, k7, M6, N]), f && (M6 = W(M6, [M6.shape[1], M6.shape[2], M6.shape[3]])), { value: M6, gradFunc: w6 };
  })(p6, h6, b6);
}
const lT = /* @__PURE__ */ L({ fusedConv2d_: aT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cT(n, t, e, s, o, r = [1, 1], i6) {
  let a = n;
  n.rank === 3 && (a = W(n, [1, n.shape[0], n.shape[1], n.shape[2]]));
  let l = t;
  l.rank === 3 && (l = W(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
  const c = { x: a, dy: l }, u = { strides: s, pad: o, dimRoundingMode: i6, dilations: r, filterShape: e };
  return $$1.runKernel(rh$1, c, u);
}
const uT = L({ depthwiseConv2dNativeBackpropFilter_: cT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dT(n, t, e, s, o, r = [1, 1], i6) {
  let a = t, l = false;
  t.rank === 3 && (l = true, a = W(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
  const c = { dy: a, filter: e }, u = { strides: s, pad: o, dimRoundingMode: i6, dilations: r, inputShape: n }, d = (
    // tslint:disable-next-line: no-unnecessary-type-assertion
    $$1.runKernel(ih$1, c, u)
  );
  return l ? W(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
}
const hT = L({ depthwiseConv2dNativeBackpropInput_: dT });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pT({ a: n, b: t, transposeA: e = false, transposeB: s = false, bias: o, activation: r = "linear", preluActivationWeights: i6, leakyreluAlpha: a = 0.2 }) {
  if (kp($$1.state.gradientDepth, r) === false) {
    let M6 = Gt(n, t, e, s);
    return o != null && (M6 = U(M6, o)), Sp(M6, r, i6, a);
  }
  let l = T(n, "a", "fused matMul"), c = T(t, "b", "fused matMul");
  [l, c] = ne$1(l, c);
  const u = e ? l.shape[l.rank - 2] : l.shape[l.rank - 1], d = s ? c.shape[c.rank - 1] : c.shape[c.rank - 2], h6 = e ? l.shape[l.rank - 1] : l.shape[l.rank - 2], p6 = s ? c.shape[c.rank - 2] : c.shape[c.rank - 1], f = l.shape.slice(0, -2), m = c.shape.slice(0, -2), g6 = O(f), b6 = O(m);
  v(u === d, () => `Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${s} must match.`);
  const w6 = bt$1(l.shape.slice(0, -2), c.shape.slice(0, -2)).concat([h6, p6]), y6 = e ? W(l, [g6, u, h6]) : W(l, [g6, h6, u]), I = s ? W(c, [b6, p6, d]) : W(c, [b6, d, p6]);
  let C6;
  o != null && (C6 = T(o, "bias", "fused matMul"), [C6] = ne$1(C6, l), bt$1(w6, C6.shape));
  let k7;
  i6 != null && (k7 = T(i6, "prelu weights", "fused matMul"));
  const S = (M6, V) => {
    const [z, X, P6, A6] = V, B6 = Cp(W(M6, P6.shape), P6, r);
    let Z, H6;
    if (!e && !s ? (Z = Gt(B6, X, false, true), H6 = Gt(z, B6, true, false)) : !e && s ? (Z = Gt(B6, X, false, false), H6 = Gt(B6, z, true, false)) : e && !s ? (Z = Gt(X, B6, false, true), H6 = Gt(z, B6, false, false)) : (Z = Gt(X, B6, true, true), H6 = Gt(B6, z, true, true)), o != null) {
      const Y = vp(A6, B6);
      return [Z, H6, Y];
    } else
      return [Z, H6];
  }, N = {
    a: y6,
    b: I,
    bias: C6,
    preluActivationWeights: k7
  }, R = { transposeA: e, transposeB: s, activation: r, leakyreluAlpha: a };
  return o == null ? So((V, z, X) => {
    const P6 = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      $$1.runKernel(ol, N, R)
    );
    return X([V, z, P6]), { value: W(P6, w6), gradFunc: S };
  })(y6, I) : So((V, z, X, P6) => {
    const A6 = (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      $$1.runKernel(ol, N, R)
    );
    return P6([V, z, A6, X]), { value: W(A6, w6), gradFunc: S };
  })(y6, I, C6);
}
const im = /* @__PURE__ */ L({ fusedMatMul_: pT });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fT(n) {
  return n0(n, 0.54, 0.46);
}
const mT = /* @__PURE__ */ L({ hammingWindow_: fT });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gT(n) {
  return n0(n, 0.5, 0.5);
}
const s0 = /* @__PURE__ */ L({ hannWindow_: gT });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bT(n, t, e, s = false, o = 0) {
  let r = 0;
  const i6 = [];
  for (; r + t <= n.size; )
    i6.push(Dt(n, r, t)), r += e;
  if (s)
    for (; r < n.size; ) {
      const a = r + t - n.size, l = Ge$1([
        Dt(n, r, t - a),
        ua([a], o)
      ]);
      i6.push(l), r += e;
    }
  return i6.length === 0 ? qa([], [0, t]) : W(Ge$1(i6), [i6.length, t]);
}
const o0 = /* @__PURE__ */ L({ frame_: bT });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xT(n, t, e, s, o = s0) {
  s == null && (s = rT(t));
  const r = o0(n, t, e), i6 = G(r, o(t));
  return yp(i6, s);
}
const yT = /* @__PURE__ */ L({ stft_: xT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wT(n, t, e, s, o = "bilinear", r = 0) {
  const i6 = T(n, "image", "cropAndResize"), a = T(t, "boxes", "cropAndResize", "float32"), l = T(e, "boxInd", "cropAndResize", "int32"), c = a.shape[0];
  v(i6.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${i6.rank}.`), v(a.rank === 2 && a.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`), v(l.rank === 1 && l.shape[0] === c, () => `Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`), v(s.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`), v(s[0] >= 1 && s[1] >= 1, () => `cropSize must be atleast [1,1], but was ${s}`), v(o === "bilinear" || o === "nearest", () => `method must be bilinear or nearest, but was ${o}`);
  const u = { image: i6, boxes: a, boxInd: l }, d = { method: o, extrapolationValue: r, cropSize: s };
  return $$1.runKernel(nh$1, u, d);
}
const IT = /* @__PURE__ */ L({ cropAndResize_: wT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CT(n) {
  const t = T(n, "image", "flipLeftRight", "float32");
  v(t.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);
  const e = { image: t };
  return $$1.runKernel(uh$1, e, {});
}
const vT = /* @__PURE__ */ L({ flipLeftRight_: CT });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ST(n) {
  const t = T(n, "image", "grayscaleToRGB"), e = t.rank - 1, s = t.shape[e];
  v(t.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`), v(s === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);
  const o = new Array(t.rank);
  return o.fill(1, 0, e), o[e] = 3, Vn$1(t, o);
}
const kT = /* @__PURE__ */ L({ grayscaleToRGB_: ST });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TT(n, t, e = 0, s = 0.5) {
  const o = T(n, "image", "rotateWithOffset", "float32");
  v(o.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);
  const r = { image: o }, i6 = { radians: t, fillValue: e, center: s };
  return $$1.runKernel(Dh$1, r, i6);
}
const NT = /* @__PURE__ */ L({ rotateWithOffset_: TT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Cr(n, t, e, s, o, r) {
  s == null && (s = 0.5), o == null && (o = Number.NEGATIVE_INFINITY), r == null && (r = 0);
  const i6 = n.shape[0];
  return e = Math.min(e, i6), v(0 <= s && s <= 1, () => `iouThreshold must be in [0, 1], but was '${s}'`), v(n.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${n.rank}'`), v(n.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`), v(t.rank === 1, () => "scores must be a 1D tensor"), v(t.shape[0] === i6, () => `scores has incompatible shape with boxes. Expected ${i6}, but was ${t.shape[0]}`), v(0 <= r && r <= 1, () => `softNmsSigma must be in [0, 1], but was '${r}'`), { maxOutputSize: e, iouThreshold: s, scoreThreshold: o, softNmsSigma: r };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RT(n, t, e, s = 0.5, o = Number.NEGATIVE_INFINITY) {
  const r = T(n, "boxes", "nonMaxSuppression", "float32"), i6 = T(t, "scores", "nonMaxSuppression", "float32"), a = Cr(r, i6, e, s, o);
  e = a.maxOutputSize, s = a.iouThreshold, o = a.scoreThreshold;
  const l = { maxOutputSize: e, iouThreshold: s, scoreThreshold: o };
  return $$1.runKernel(gh$1, { boxes: r, scores: i6 }, l);
}
const $T = /* @__PURE__ */ L({ nonMaxSuppression_: RT });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GT(n, t, e) {
  const s = ET(n, t, e), o = s < 0 ? -(s + 1) : s;
  n.splice(o, 0, t);
}
function ET(n, t, e) {
  return MT(n, t, e || LT);
}
function LT(n, t) {
  return n > t ? 1 : n < t ? -1 : 0;
}
function MT(n, t, e) {
  let s = 0, o = n.length, r = 0, i6 = false;
  for (; s < o; ) {
    r = s + (o - s >>> 1);
    const a = e(t, n[r]);
    a > 0 ? s = r + 1 : (o = r, i6 = !a);
  }
  return i6 ? s : -s - 1;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tp(n, t, e, s, o) {
  return $p(
    n,
    t,
    e,
    s,
    o,
    0
    /* softNmsSigma */
  );
}
function Np(n, t, e, s, o, r) {
  return $p(
    n,
    t,
    e,
    s,
    o,
    0,
    false,
    r,
    true
    /* returnValidOutputs */
  );
}
function Rp(n, t, e, s, o, r) {
  return $p(
    n,
    t,
    e,
    s,
    o,
    r,
    true
    /* returnScoresTensor */
  );
}
function $p(n, t, e, s, o, r, i6 = false, a = false, l = false) {
  const c = [];
  for (let g6 = 0; g6 < t.length; g6++)
    t[g6] > o && c.push({ score: t[g6], boxIndex: g6, suppressBeginIndex: 0 });
  c.sort(am);
  const u = r > 0 ? -0.5 / r : 0, d = [], h6 = [];
  for (; d.length < e && c.length > 0; ) {
    const g6 = c.pop(), { score: b6, boxIndex: x6, suppressBeginIndex: w6 } = g6;
    if (b6 < o)
      break;
    let y6 = false;
    for (let I = d.length - 1; I >= w6; --I) {
      const C6 = WT(n, x6, d[I]);
      if (C6 >= s) {
        y6 = true;
        break;
      }
      if (g6.score = g6.score * DT(s, u, C6), g6.score <= o)
        break;
    }
    g6.suppressBeginIndex = d.length, y6 || (g6.score === b6 ? (d.push(x6), h6.push(g6.score)) : g6.score > o && GT(c, g6, am));
  }
  const p6 = d.length, f = e - p6;
  a && f > 0 && (d.push(...new Array(f).fill(0)), h6.push(...new Array(f).fill(0)));
  const m = { selectedIndices: d };
  return i6 && (m.selectedScores = h6), l && (m.validOutputs = p6), m;
}
function WT(n, t, e) {
  const s = n.subarray(t * 4, t * 4 + 4), o = n.subarray(e * 4, e * 4 + 4), r = Math.min(s[0], s[2]), i6 = Math.min(s[1], s[3]), a = Math.max(s[0], s[2]), l = Math.max(s[1], s[3]), c = Math.min(o[0], o[2]), u = Math.min(o[1], o[3]), d = Math.max(o[0], o[2]), h6 = Math.max(o[1], o[3]), p6 = (a - r) * (l - i6), f = (d - c) * (h6 - u);
  if (p6 <= 0 || f <= 0)
    return 0;
  const m = Math.max(r, c), g6 = Math.max(i6, u), b6 = Math.min(a, d), x6 = Math.min(l, h6), w6 = Math.max(b6 - m, 0) * Math.max(x6 - g6, 0);
  return w6 / (p6 + f - w6);
}
function DT(n, t, e) {
  const s = Math.exp(t * e * e);
  return e <= n ? s : 0;
}
function am(n, t) {
  return n.score - t.score || n.score === t.score && t.boxIndex - n.boxIndex;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function FT(n, t, e, s = 0.5, o = Number.NEGATIVE_INFINITY) {
  const r = T(n, "boxes", "nonMaxSuppressionAsync"), i6 = T(t, "scores", "nonMaxSuppressionAsync"), a = Cr(r, i6, e, s, o);
  e = a.maxOutputSize, s = a.iouThreshold, o = a.scoreThreshold;
  const l = await Promise.all([r.data(), i6.data()]), c = l[0], u = l[1], { selectedIndices: d } = Tp(c, u, e, s, o);
  return r !== n && r.dispose(), i6 !== t && i6.dispose(), Je$1(d, "int32");
}
const VT = FT;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zT(n, t, e, s = 0.5, o = Number.NEGATIVE_INFINITY, r = 0) {
  const i6 = T(n, "boxes", "nonMaxSuppression"), a = T(t, "scores", "nonMaxSuppression"), l = Cr(i6, a, e, s, o, r);
  e = l.maxOutputSize, s = l.iouThreshold, o = l.scoreThreshold, r = l.softNmsSigma;
  const c = { boxes: i6, scores: a }, u = { maxOutputSize: e, iouThreshold: s, scoreThreshold: o, softNmsSigma: r }, d = $$1.runKernel(xh$1, c, u);
  return { selectedIndices: d[0], selectedScores: d[1] };
}
const XT = /* @__PURE__ */ L({ nonMaxSuppressionWithScore_: zT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function PT(n, t, e, s = 0.5, o = Number.NEGATIVE_INFINITY, r = 0) {
  const i6 = T(n, "boxes", "nonMaxSuppressionAsync"), a = T(t, "scores", "nonMaxSuppressionAsync"), l = Cr(i6, a, e, s, o, r);
  e = l.maxOutputSize, s = l.iouThreshold, o = l.scoreThreshold, r = l.softNmsSigma;
  const c = await Promise.all([i6.data(), a.data()]), u = c[0], d = c[1], { selectedIndices: h6, selectedScores: p6 } = Rp(u, d, e, s, o, r);
  return i6 !== n && i6.dispose(), a !== t && a.dispose(), {
    selectedIndices: Je$1(h6, "int32"),
    selectedScores: Je$1(p6)
  };
}
const AT = PT;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OT(n, t, e, s = 0.5, o = Number.NEGATIVE_INFINITY, r = false) {
  const i6 = T(n, "boxes", "nonMaxSuppression"), a = T(t, "scores", "nonMaxSuppression"), l = Cr(
    i6,
    a,
    e,
    s,
    o,
    null
    /* softNmsSigma */
  ), c = l.maxOutputSize, u = l.iouThreshold, d = l.scoreThreshold, h6 = { boxes: i6, scores: a }, p6 = {
    maxOutputSize: c,
    iouThreshold: u,
    scoreThreshold: d,
    padToMaxOutputSize: r
  }, f = $$1.runKernel(bh$1, h6, p6);
  return { selectedIndices: f[0], validOutputs: f[1] };
}
const KT = /* @__PURE__ */ L({ nonMaxSuppressionPadded_: OT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function ZT(n, t, e, s = 0.5, o = Number.NEGATIVE_INFINITY, r = false) {
  const i6 = T(n, "boxes", "nonMaxSuppressionAsync"), a = T(t, "scores", "nonMaxSuppressionAsync"), l = Cr(
    i6,
    a,
    e,
    s,
    o,
    null
    /* softNmsSigma */
  ), c = l.maxOutputSize, u = l.iouThreshold, d = l.scoreThreshold, [h6, p6] = await Promise.all([i6.data(), a.data()]), { selectedIndices: f, validOutputs: m } = Np(h6, p6, c, u, d, r);
  return i6 !== n && i6.dispose(), a !== t && a.dispose(), {
    selectedIndices: Je$1(f, "int32"),
    validOutputs: gt$1(m, "int32")
  };
}
const BT = ZT;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HT(n, t, e = false, s = false) {
  const o = T(n, "images", "resizeBilinear");
  v(o.rank === 3 || o.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`), v(t.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${t}.`), v(s === false || e === false, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
  let r = o, i6 = false;
  o.rank === 3 && (i6 = true, r = W(o, [1, o.shape[0], o.shape[1], o.shape[2]]));
  const a = { images: r }, l = { alignCorners: e, halfPixelCenters: s, size: t }, c = $$1.runKernel(Tc, a, l);
  return i6 ? W(c, [c.shape[1], c.shape[2], c.shape[3]]) : c;
}
const r0 = /* @__PURE__ */ L({ resizeBilinear_: HT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _T(n, t, e = false, s = false) {
  const o = T(n, "images", "resizeNearestNeighbor");
  v(o.rank === 3 || o.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`), v(t.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`), v(o.dtype === "float32" || o.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), v(s === false || e === false, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
  let r = o, i6 = false;
  o.rank === 3 && (i6 = true, r = W(o, [1, o.shape[0], o.shape[1], o.shape[2]]));
  const a = { images: r }, l = { alignCorners: e, halfPixelCenters: s, size: t }, c = $$1.runKernel(kc, a, l);
  return i6 ? W(c, [c.shape[1], c.shape[2], c.shape[3]]) : c;
}
const i0 = /* @__PURE__ */ L({ resizeNearestNeighbor_: _T });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UT(n, t = "binary", e = false, s = 0.5) {
  const o = T(n, "image", "threshold"), r = 0.2989, i6 = 0.587, a = 0.114, l = o.shape[0] * o.shape[1];
  let c = G(Je$1([s]), 255), u, d, h6, p6;
  if (v(o.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${o.rank}.`), v(o.shape[2] === 3 || o.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`), v(o.dtype === "int32" || o.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`), v(t === "otsu" || t === "binary", () => `Method must be binary or otsu, but was ${t}`), o.shape[2] === 3) {
    [u, d, h6] = un$1(o, [1, 1, 1], -1);
    const g6 = G(u, r), b6 = G(d, i6), x6 = G(h6, a);
    p6 = U(U(g6, b6), x6);
  } else
    p6 = n;
  if (t === "otsu") {
    const g6 = B2(et(Kb(p6), "int32"), Re$1([]), 256);
    c = YT(g6, l);
  }
  const f = e ? yr(p6, c) : sn$1(p6, c);
  return et(G(f, 255), "int32");
}
function YT(n, t) {
  let e = Je$1([-1]), s = Je$1([0]), o = Je$1([0]), r, i6, a, l, c, u;
  for (let d = 0; d < n.size - 1; d++) {
    r = Dt(n, 0, d + 1), i6 = Dt(n, d + 1), c = ut(at(r), t), u = ut(at(i6), t);
    const h6 = at(G(r, ti$1(0, r.size)));
    a = ut(h6, at(r));
    const p6 = ua(i6.shape, r.size), f = U(ti$1(0, i6.size), p6), m = G(i6, f);
    l = ut(at(m), at(i6));
    const g6 = lt(a, l), b6 = lt(a, l), x6 = G(c, u);
    o = G(G(x6, g6), b6);
    const w6 = sn$1(o, s);
    s = Oe(w6, o, s), e = Oe(w6, Je$1([d]), e);
  }
  return e;
}
const QT = /* @__PURE__ */ L({ threshold_: UT });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JT(n, t, e = "nearest", s = "constant", o = 0, r) {
  const i6 = T(n, "image", "transform", "float32"), a = T(t, "transforms", "transform", "float32");
  v(i6.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${i6.rank}.`), v(a.rank === 2 && (a.shape[0] === i6.shape[0] || a.shape[0] === 1) && a.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), v(r == null || r.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${r}.`);
  const l = { image: i6, transforms: a }, c = { interpolation: e, fillMode: s, fillValue: o, outputShape: r };
  return $$1.runKernel(Mh$1, l, c);
}
const jT = /* @__PURE__ */ L({ transform_: JT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qT(n, t, e) {
  v(t % 1 === 0, () => `bandPart(): numLower must be an integer, got ${t}.`), v(e % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${e}.`);
  const s = T(n, "a", "bandPart");
  v(s.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${s.rank}.`);
  const o = s.shape, [r, i6] = s.shape.slice(-2);
  if (!(t <= r))
    throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${r}).`);
  if (!(e <= i6))
    throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i6}).`);
  t < 0 && (t = r), e < 0 && (e = i6);
  const a = W(ti$1(0, r, 1, "int32"), [-1, 1]), l = ti$1(0, i6, 1, "int32"), c = lt(a, l), u = ss(yr(c, gt$1(+t, "int32")), Do(c, gt$1(-e, "int32"))), d = ge$1([r, i6], s.dtype);
  return W(os(To(W(s, [-1, r, i6])).map((h6) => Oe(u, h6, d))), o);
}
const tN = /* @__PURE__ */ L({ bandPart_: qT });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eN(n) {
  let t;
  if (Array.isArray(n)) {
    t = false, v(n != null && n.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
    const o = n[0].shape[0];
    for (let r = 1; r < n.length; ++r)
      v(n[r].shape[0] === o, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${o})`);
  } else
    t = true, n = un$1(n, n.shape[0], 0).map((o) => ha(o, [0]));
  v(n.length <= n[0].shape[0], () => `Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);
  const e = [], s = n;
  for (let o = 0; o < n.length; ++o)
    e.push($$1.tidy(() => {
      let r = s[o];
      if (o > 0)
        for (let i6 = 0; i6 < o; ++i6) {
          const a = G(at(G(e[i6], r)), e[i6]);
          r = lt(r, a);
        }
      return ut(r, Pc(r, "euclidean"));
    }));
  return t ? os(e, 0) : e;
}
const nN = /* @__PURE__ */ L({ gramSchmidt_: eN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sN(n, t = false) {
  if (v(n.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`), n.rank === 2)
    return lm(n, t);
  {
    const e = n.shape.slice(0, n.shape.length - 2).reduce((l, c) => l * c), s = To(W(n, [
      e,
      n.shape[n.shape.length - 2],
      n.shape[n.shape.length - 1]
    ]), 0), o = [], r = [];
    s.forEach((l) => {
      const [c, u] = lm(l, t);
      o.push(c), r.push(u);
    });
    const i6 = W(os(o, 0), n.shape), a = W(os(r, 0), n.shape);
    return [i6, a];
  }
}
function lm(n, t = false) {
  return $$1.tidy(() => {
    v(n.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);
    const e = n.shape[0], s = n.shape[1];
    let o = Db(e), r = po(n);
    const i6 = qa([[1]], [1, 1]);
    let a = po(i6);
    const l = e >= s ? s : e;
    for (let c = 0; c < l; ++c) {
      const u = r, d = a, h6 = o;
      [a, r, o] = $$1.tidy(() => {
        const p6 = Dt(r, [c, c], [e - c, 1]), f = Pc(p6), m = Dt(r, [c, c], [1, 1]), g6 = Oe(sn$1(m, 0), qa([[-1]]), qa([[1]])), b6 = lt(m, G(g6, f)), x6 = ut(p6, b6);
        x6.shape[0] === 1 ? a = po(i6) : a = Ge$1([
          i6,
          Dt(x6, [1, 0], [x6.shape[0] - 1, x6.shape[1]])
        ], 0);
        const w6 = jt$1(ut(Gt(g6, b6), f)), y6 = Dt(r, [c, 0], [e - c, s]), I = G(w6, a), C6 = kt(a);
        if (c === 0)
          r = lt(y6, Gt(I, Gt(C6, y6)));
        else {
          const N = lt(y6, Gt(I, Gt(C6, y6)));
          r = Ge$1([Dt(r, [0, 0], [c, s]), N], 0);
        }
        const k7 = kt(I), S = Dt(o, [0, c], [e, o.shape[1] - c]);
        if (c === 0)
          o = lt(S, Gt(Gt(S, a), k7));
        else {
          const N = lt(S, Gt(Gt(S, a), k7));
          o = Ge$1([Dt(o, [0, 0], [e, c]), N], 1);
        }
        return [a, r, o];
      }), yt$1([u, d, h6]);
    }
    return !t && e > s && (o = Dt(o, [0, 0], [e, s]), r = Dt(r, [0, 0], [s, s])), [o, r];
  });
}
const oN = /* @__PURE__ */ L({ qr_: sN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Ae$1;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.MEAN = 1] = "MEAN", n[n.SUM = 2] = "SUM", n[n.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Ae$1 || (Ae$1 = {}));
function rN(n, t, e = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  const s = T(n, "losses", "computeWeightedLoss");
  let o = null;
  t != null && (o = T(t, "weights", "computeWeightedLoss"));
  const r = o == null ? s : G(s, o);
  if (e === Ae$1.NONE)
    return r;
  if (e === Ae$1.SUM)
    return at(r);
  if (e === Ae$1.MEAN) {
    if (o == null)
      return se(r);
    {
      const i6 = s.size / o.size, a = ut(at(r), at(o));
      return i6 > 1 ? ut(a, gt$1(i6)) : a;
    }
  }
  if (e === Ae$1.SUM_BY_NONZERO_WEIGHTS) {
    if (o == null)
      return ut(at(r), gt$1(s.size));
    {
      const i6 = G(o, Us(s.shape)), a = et(at(qr(i6, gt$1(0))), "float32");
      return ut(at(r), a);
    }
  }
  throw Error(`Unknown reduction: ${e}`);
}
const Is = /* @__PURE__ */ L({ computeWeightedLoss_: rN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iN(n, t, e, s = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  const o = T(n, "labels", "absoluteDifference"), r = T(t, "predictions", "absoluteDifference");
  let i6 = null;
  e != null && (i6 = T(e, "weights", "absoluteDifference")), Ve(o.shape, r.shape, "Error in absoluteDifference: ");
  const a = fe$1(lt(o, r));
  return Is(a, i6, s);
}
const aN = /* @__PURE__ */ L({ absoluteDifference_: iN });
function lN(n, t, e, s, o = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  const r = T(n, "labels", "cosineDistance"), i6 = T(t, "predictions", "cosineDistance");
  let a = null;
  s != null && (a = T(s, "weights", "cosineDistance")), Ve(r.shape, i6.shape, "Error in cosineDistance: ");
  const l = gt$1(1), c = lt(l, at(G(r, i6), e, true));
  return Is(c, a, o);
}
const cN = /* @__PURE__ */ L({ cosineDistance_: lN });
function uN(n, t, e, s = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  let o = T(n, "labels", "hingeLoss");
  const r = T(t, "predictions", "hingeLoss");
  let i6 = null;
  e != null && (i6 = T(e, "weights", "hingeLoss")), Ve(o.shape, r.shape, "Error in hingeLoss: ");
  const a = gt$1(1);
  o = lt(G(gt$1(2), o), a);
  const l = ws(lt(a, G(o, r)));
  return Is(l, i6, s);
}
const dN = /* @__PURE__ */ L({ hingeLoss_: uN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hN(n, t, e, s = 1, o = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  const r = T(n, "labels", "huberLoss"), i6 = T(t, "predictions", "huberLoss");
  let a = null;
  e != null && (a = T(e, "weights", "huberLoss")), Ve(r.shape, i6.shape, "Error in huberLoss: ");
  const l = gt$1(s), c = fe$1(lt(i6, r)), u = Kc(c, l), d = lt(c, u), h6 = U(G(gt$1(0.5), At$1(u)), G(l, d));
  return Is(h6, a, o);
}
const pN = /* @__PURE__ */ L({ huberLoss_: hN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fN(n, t, e, s = 1e-7, o = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  const r = T(n, "labels", "logLoss"), i6 = T(t, "predictions", "logLoss");
  let a = null;
  e != null && (a = T(e, "weights", "logLoss")), Ve(r.shape, i6.shape, "Error in logLoss: ");
  const l = gt$1(1), c = gt$1(s), u = jt$1(G(r, Nn$1(U(i6, c)))), d = G(lt(l, r), Nn$1(U(lt(l, i6), c))), h6 = lt(u, d);
  return Is(h6, a, o);
}
const mN = /* @__PURE__ */ L({ logLoss_: fN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gN(n, t, e, s = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  const o = T(n, "labels", "meanSquaredError"), r = T(t, "predictions", "meanSquaredError");
  let i6 = null;
  e != null && (i6 = T(e, "weights", "meanSquaredError")), Ve(o.shape, r.shape, "Error in meanSquaredError: ");
  const a = Jb(o, r);
  return Is(a, i6, s);
}
const bN = /* @__PURE__ */ L({ meanSquaredError_: gN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xN(n, t) {
  const e = T(n, "labels", "sigmoidCrossEntropyWithLogits"), s = T(t, "logits", "sigmoidCrossEntropyWithLogits");
  Ve(e.shape, s.shape, "Error in sigmoidCrossEntropyWithLogits: ");
  const o = ws(s), r = G(s, e), i6 = ep(Tn$1(jt$1(fe$1(s))));
  return U(lt(o, r), i6);
}
function yN(n, t, e, s = 0, o = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  let r = T(n, "multiClassLabels", "sigmoidCrossEntropy");
  const i6 = T(t, "logits", "sigmoidCrossEntropy");
  let a = null;
  if (e != null && (a = T(e, "weights", "sigmoidCrossEntropy")), Ve(r.shape, i6.shape, "Error in sigmoidCrossEntropy: "), s > 0) {
    const c = gt$1(s), u = gt$1(1), d = gt$1(0.5);
    r = U(G(r, lt(u, c)), G(d, c));
  }
  const l = xN(r, i6);
  return Is(l, a, o);
}
const wN = /* @__PURE__ */ L({ sigmoidCrossEntropy_: yN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IN(n, t, e = -1) {
  if (e === -1 && (e = t.rank - 1), e !== t.rank - 1)
    throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);
  return So((o, r, i6) => {
    const l = zb(r, [e], true), c = lt(et(r, "float32"), l);
    i6([o, c]);
    const u = jt$1(G(c, o));
    return { value: at(u, [e]), gradFunc: (p6, f) => {
      const [m, g6] = f, b6 = re$1(p6.shape, [e]);
      return [
        G(W(p6, b6), lt(et(m, "float32"), Tn$1(g6))),
        G(W(p6, b6), lt(Tn$1(g6), et(m, "float32")))
      ];
    } };
  })(n, t);
}
function CN(n, t, e, s = 0, o = Ae$1.SUM_BY_NONZERO_WEIGHTS) {
  let r = T(n, "onehotLabels", "softmaxCrossEntropy");
  const i6 = T(t, "logits", "softmaxCrossEntropy");
  let a = null;
  if (e != null && (a = T(e, "weights", "softmaxCrossEntropy")), Ve(r.shape, i6.shape, "Error in softmaxCrossEntropy: "), s > 0) {
    const c = gt$1(s), u = gt$1(1), d = gt$1(r.shape[1]);
    r = U(G(r, lt(u, c)), ut(c, d));
  }
  const l = IN(r, i6);
  return Is(l, a, o);
}
const vN = /* @__PURE__ */ L({ softmaxCrossEntropy_: CN });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SN(n, t, e, s) {
  const o = T(n, "indices", "sparseFillEmptyRows", "int32"), r = T(t, "values", "sparseFillEmptyRows"), i6 = T(e, "denseShape", "sparseFillEmptyRows", "int32"), a = T(s, "defaultValue", "sparseFillEmptyRows", r.dtype);
  if (o.rank !== 2)
    throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);
  if (r.rank !== 1)
    throw new Error(`Values should be Tensor1D but received shape ${r.shape}`);
  if (i6.rank !== 1)
    throw new Error(`Dense shape should be Tensor1D but received shape ${i6.shape}`);
  if (a.rank !== 0)
    throw new Error(`Default value should be a scalar but received shape ${a.shape}`);
  const l = {
    indices: o,
    values: r,
    denseShape: i6,
    defaultValue: a
  }, c = $$1.runKernel(vh$1, l);
  return {
    outputIndices: c[0],
    outputValues: c[1],
    emptyRowIndicator: c[2],
    reverseIndexMap: c[3]
  };
}
const kN = /* @__PURE__ */ L({ sparseFillEmptyRows_: SN });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TN(n, t, e) {
  const s = T(n, "inputIndices", "sparseReshape", "int32"), o = T(t, "inputShape", "sparseReshape", "int32"), r = T(e, "newShape", "sparseReshape", "int32");
  if (s.rank !== 2)
    throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);
  if (o.rank !== 1)
    throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);
  if (r.rank !== 1)
    throw new Error(`New shape should be Tensor1D but received shape ${r.shape}`);
  const i6 = {
    inputIndices: s,
    inputShape: o,
    newShape: r
  }, a = $$1.runKernel(Sh$1, i6);
  return { outputIndices: a[0], outputShape: a[1] };
}
const NN = /* @__PURE__ */ L({ sparseReshape_: TN });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function RN(n, t, e) {
  const s = T(n, "data", "sparseSegmentMean"), o = T(t, "indices", "sparseSegmentMean", "int32"), r = T(e, "segmentIds", "sparseSegmentMean", "int32");
  if (s.rank < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (o.rank !== 1)
    throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);
  if (r.rank !== 1)
    throw new Error(`Segment ids should be Tensor1D but received shape
          ${r.shape}`);
  const i6 = {
    data: s,
    indices: o,
    segmentIds: r
  };
  return $$1.runKernel(kh$1, i6);
}
const $N = /* @__PURE__ */ L({ sparseSegmentMean_: RN });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GN(n, t, e) {
  const s = T(n, "data", "sparseSegmentSum"), o = T(t, "indices", "sparseSegmentSum", "int32"), r = T(e, "segmentIds", "sparseSegmentSum", "int32");
  if (s.rank < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (o.rank !== 1)
    throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);
  if (r.rank !== 1)
    throw new Error(`Segment ids should be Tensor1D but received shape
         ${r.shape}`);
  const i6 = {
    data: s,
    indices: o,
    segmentIds: r
  };
  return $$1.runKernel(Th$1, i6);
}
const EN = /* @__PURE__ */ L({ sparseSegmentSum_: GN });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LN(n, t, e, s, o, r, i6, a) {
  const l = T(n, "data", "stringNGrams", "string");
  if (l.dtype !== "string")
    throw new Error("Data must be of datatype string");
  if (l.shape.length !== 1)
    throw new Error(`Data must be a vector, saw: ${l.shape}`);
  const c = T(t, "dataSplits", "stringNGrams");
  if (c.dtype !== "int32")
    throw new Error("Data splits must be of datatype int32");
  const u = {
    separator: e,
    nGramWidths: s,
    leftPad: o,
    rightPad: r,
    padWidth: i6,
    preserveShortSequences: a
  }, d = { data: l, dataSplits: c }, h6 = $$1.runKernel($h$1, d, u);
  return { nGrams: h6[0], nGramsSplits: h6[1] };
}
const MN = /* @__PURE__ */ L({ stringNGrams_: LN });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WN(n, t, e = true) {
  const s = T(n, "input", "stringSplit", "string"), o = T(t, "delimiter", "stringSplit", "string");
  if (s.rank !== 1)
    throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);
  if (o.rank !== 0)
    throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);
  const r = { skipEmpty: e }, i6 = { input: s, delimiter: o }, a = $$1.runKernel(Gh$1, i6, r);
  return { indices: a[0], values: a[1], shape: a[2] };
}
const DN = /* @__PURE__ */ L({ stringSplit_: WN });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FN(n, t) {
  const e = T(n, "input", "stringToHashBucketFast", "string"), s = { numBuckets: t };
  if (t <= 0)
    throw new Error("Number of buckets must be at least 1");
  const o = { input: e };
  return $$1.runKernel(Eh$1, o, s);
}
const VN = /* @__PURE__ */ L({ stringToHashBucketFast_: FN });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pY = {
  fft: xp,
  ifft: pl,
  rfft: yp,
  irfft: Qb
}, fY = {
  hammingWindow: mT,
  hannWindow: s0,
  frame: o0,
  stft: yT
}, uo = {
  flipLeftRight: vT,
  grayscaleToRGB: kT,
  resizeNearestNeighbor: i0,
  resizeBilinear: r0,
  rotateWithOffset: NT,
  cropAndResize: IT,
  nonMaxSuppression: $T,
  nonMaxSuppressionAsync: VT,
  nonMaxSuppressionWithScore: XT,
  nonMaxSuppressionWithScoreAsync: AT,
  nonMaxSuppressionPadded: KT,
  nonMaxSuppressionPaddedAsync: BT,
  threshold: QT,
  transform: jT
}, zN = {
  bandPart: tN,
  gramSchmidt: nN,
  qr: oN
}, mY = {
  absoluteDifference: aN,
  computeWeightedLoss: Is,
  cosineDistance: cN,
  hingeLoss: dN,
  huberLoss: pN,
  logLoss: mN,
  meanSquaredError: bN,
  sigmoidCrossEntropy: wN,
  softmaxCrossEntropy: vN
}, gY = {
  sparseFillEmptyRows: kN,
  sparseReshape: NN,
  sparseSegmentMean: $N,
  sparseSegmentSum: EN
}, bY = {
  stringNGrams: MN,
  stringSplit: DN,
  stringToHashBucketFast: VN
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Vo {
  /**
   * Return the class name for this class to use in serialization contexts.
   *
   * Generally speaking this will be the same thing that constructor.name
   * would have returned.  However, the class name needs to be robust
   * against minification for serialization/deserialization to work properly.
   *
   * There's also places such as initializers.VarianceScaling, where
   * implementation details between different languages led to different
   * class hierarchies and a non-leaf node is used for serialization purposes.
   */
  getClassName() {
    return this.constructor.className;
  }
  /**
   * Creates an instance of T from a ConfigDict.
   *
   * This works for most descendants of serializable.  A few need to
   * provide special handling.
   * @param cls A Constructor for the class to instantiate.
   * @param config The Configuration for the object.
   */
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e);
  }
}
let an$1 = class an {
  constructor() {
    this.classNameMap = {};
  }
  /**
   * Returns the singleton instance of the map.
   */
  static getMap() {
    return an.instance == null && (an.instance = new an()), an.instance;
  }
  /**
   * Registers the class as serializable.
   */
  static register(t) {
    an.getMap().classNameMap[t.className] = [t, t.fromConfig];
  }
};
function _(n) {
  v(n.className != null, () => "Class being registered does not have the static className property defined."), v(typeof n.className == "string", () => "className is required to be a string, but got type " + typeof n.className), v(n.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), an$1.register(n);
}
const xY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Serializable: Vo,
  SerializationMap: an$1,
  registerClass: _
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Ys extends Vo {
  /**
   * Executes `f()` and minimizes the scalar output of `f()` by computing
   * gradients of y with respect to the list of trainable variables provided by
   * `varList`. If no list is provided, it defaults to all trainable variables.
   *
   * @param f The function to execute and whose output to minimize.
   * @param returnCost Whether to return the scalar cost value produced by
   * executing `f()`.
   * @param varList An optional list of variables to update. If specified, only
   * the trainable variables in varList will be updated by minimize. Defaults to
   * all trainable variables.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers'}
   */
  minimize(t, e = false, s) {
    const { value: o, grads: r } = this.computeGradients(t, s);
    if (s != null) {
      const i6 = s.map((a) => ({ name: a.name, tensor: r[a.name] }));
      this.applyGradients(i6);
    } else
      this.applyGradients(r);
    return yt$1(r), e ? o : (o.dispose(), null);
  }
  /**
   * The number of iterations that this optimizer instance has been invoked for.
   */
  get iterations() {
    return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
  }
  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }
  /**
   * Executes f() and computes the gradient of the scalar output of f() with
   * respect to the list of trainable variables provided by `varList`. If no
   * list is provided, it defaults to all trainable variables.
   *
   * @param f The function to execute and whose output to use for computing
   * gradients with respect to variables.
   * @param varList An optional list of variables to compute gradients with
   * respect to. If specified, only the trainable variables in varList will have
   * gradients computed with respect to. Defaults to all trainable variables.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers'}
   */
  computeGradients(t, e) {
    return hS(t, e);
  }
  /**
   * Dispose the variables (if any) owned by this optimizer instance.
   */
  dispose() {
    this.iterations_ != null && yt$1(this.iterations_);
  }
  async saveIterations() {
    return this.iterations_ == null && (this.iterations_ = 0), {
      name: "iter",
      // TODO(cais): Use 'int64' type when available.
      tensor: gt$1(this.iterations_, "int32")
    };
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for this optimizer yet.");
  }
  async setWeights(t) {
    throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
  }
  /**
   * Extract the first element of the weight values and set it
   * as the iterations counter variable of this instance of optimizer.
   *
   * @param weightValues
   * @returns Weight values with the first element consumed and excluded.
   */
  async extractIterations(t) {
    return this.iterations_ = (await t[0].tensor.data())[0], t.slice(1);
  }
}
Object.defineProperty(Ys, Symbol.hasInstance, {
  value: (n) => n.minimize != null && n.computeGradients != null && n.applyGradients != null
});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class a0 extends Ys {
  constructor(t, e, s = null) {
    super(), this.learningRate = t, this.rho = e, this.epsilon = s, this.accumulatedGrads = [], this.accumulatedUpdates = [], s == null && (this.epsilon = $$1.backend.epsilon());
  }
  /** @nocollapse */
  static get className() {
    return "Adadelta";
  }
  applyGradients(t) {
    (Array.isArray(t) ? t.map((s) => s.name) : Object.keys(t)).forEach((s, o) => {
      const r = $$1.registeredVariables[s], i6 = false;
      this.accumulatedGrads[o] == null && (this.accumulatedGrads[o] = {
        originalName: `${s}/accum_grad`,
        variable: D(() => Tt$1(r).variable(i6))
      }), this.accumulatedUpdates[o] == null && (this.accumulatedUpdates[o] = {
        originalName: `${s}/accum_var`,
        variable: D(() => Tt$1(r).variable(i6))
      });
      const a = Array.isArray(t) ? t[o].tensor : t[s];
      if (a == null)
        return;
      const l = this.accumulatedGrads[o].variable, c = this.accumulatedUpdates[o].variable;
      D(() => {
        const u = U(G(l, this.rho), G(At$1(a), 1 - this.rho)), d = G(ut(De$1(U(c, this.epsilon)), De$1(U(l, this.epsilon))), a), h6 = U(G(c, this.rho), G(At$1(d), 1 - this.rho));
        l.assign(u), c.assign(h6);
        const p6 = U(G(d, -this.learningRate), r);
        r.assign(p6);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedUpdates != null && (yt$1(this.accumulatedGrads.map((t) => t.variable)), yt$1(this.accumulatedUpdates.map((t) => t.variable)));
  }
  async getWeights() {
    const t = [...this.accumulatedGrads, ...this.accumulatedUpdates];
    return [await this.saveIterations()].concat(t.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(t) {
    t = await this.extractIterations(t);
    const e = t.length / 2, s = false;
    this.accumulatedGrads = t.slice(0, e).map((o) => ({
      originalName: o.name,
      variable: o.tensor.variable(s)
    })), this.accumulatedUpdates = t.slice(e, e * 2).map((o) => ({
      originalName: o.name,
      variable: o.tensor.variable(s)
    }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      rho: this.rho,
      epsilon: this.epsilon
    };
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e.learningRate, e.rho, e.epsilon);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class l0 extends Ys {
  constructor(t, e = 0.1) {
    super(), this.learningRate = t, this.initialAccumulatorValue = e, this.accumulatedGrads = [];
  }
  /** @nocollapse */
  static get className() {
    return "Adagrad";
  }
  applyGradients(t) {
    (Array.isArray(t) ? t.map((s) => s.name) : Object.keys(t)).forEach((s, o) => {
      const r = $$1.registeredVariables[s];
      this.accumulatedGrads[o] == null && (this.accumulatedGrads[o] = {
        originalName: `${s}/accumulator`,
        variable: D(() => ua(r.shape, this.initialAccumulatorValue).variable(false))
      });
      const i6 = Array.isArray(t) ? t[o].tensor : t[s];
      if (i6 == null)
        return;
      const a = this.accumulatedGrads[o].variable;
      D(() => {
        const l = U(a, At$1(i6));
        a.assign(l);
        const c = U(G(ut(i6, De$1(U(l, $$1.backend.epsilon()))), -this.learningRate), r);
        r.assign(c);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedGrads != null && yt$1(this.accumulatedGrads.map((t) => t.variable));
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulatedGrads.map((t) => ({ name: t.originalName, tensor: t.variable })));
  }
  async setWeights(t) {
    t = await this.extractIterations(t);
    const e = false;
    this.accumulatedGrads = t.map((s) => ({ originalName: s.name, variable: s.tensor.variable(e) }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      initialAccumulatorValue: this.initialAccumulatorValue
    };
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e.learningRate, e.initialAccumulatorValue);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class c0 extends Ys {
  constructor(t, e, s, o = null) {
    super(), this.learningRate = t, this.beta1 = e, this.beta2 = s, this.epsilon = o, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], D(() => {
      this.accBeta1 = gt$1(e).variable(), this.accBeta2 = gt$1(s).variable();
    }), o == null && (this.epsilon = $$1.backend.epsilon());
  }
  /** @nocollapse */
  static get className() {
    return "Adam";
  }
  applyGradients(t) {
    const e = Array.isArray(t) ? t.map((s) => s.name) : Object.keys(t);
    D(() => {
      const s = lt(1, this.accBeta1), o = lt(1, this.accBeta2);
      e.forEach((r, i6) => {
        const a = $$1.registeredVariables[r], l = false;
        this.accumulatedFirstMoment[i6] == null && (this.accumulatedFirstMoment[i6] = {
          originalName: `${r}/m`,
          variable: D(() => Tt$1(a).variable(l))
        }), this.accumulatedSecondMoment[i6] == null && (this.accumulatedSecondMoment[i6] = {
          originalName: `${r}/v`,
          variable: D(() => Tt$1(a).variable(l))
        });
        const c = Array.isArray(t) ? t[i6].tensor : t[r];
        if (c == null)
          return;
        const u = this.accumulatedFirstMoment[i6].variable, d = this.accumulatedSecondMoment[i6].variable, h6 = U(G(u, this.beta1), G(c, 1 - this.beta1)), p6 = U(G(d, this.beta2), G(At$1(c), 1 - this.beta2)), f = ut(h6, s), m = ut(p6, o);
        u.assign(h6), d.assign(p6);
        const g6 = U(G(ut(f, U(De$1(m), this.epsilon)), -this.learningRate), a);
        a.assign(g6);
      }), this.accBeta1.assign(G(this.accBeta1, this.beta1)), this.accBeta2.assign(G(this.accBeta2, this.beta2));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && yt$1(this.accumulatedFirstMoment.map((t) => t.variable)), this.accumulatedSecondMoment != null && yt$1(this.accumulatedSecondMoment.map((t) => t.variable));
  }
  async getWeights() {
    const t = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
    return [await this.saveIterations()].concat(t.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(t) {
    t = await this.extractIterations(t), D(() => {
      this.accBeta1.assign(ir(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(ir(this.beta2, this.iterations_ + 1));
    });
    const e = t.length / 2, s = false;
    this.accumulatedFirstMoment = t.slice(0, e).map((o) => ({
      originalName: o.name,
      variable: o.tensor.variable(s)
    })), this.accumulatedSecondMoment = t.slice(e, e * 2).map((o) => ({
      originalName: o.name,
      variable: o.tensor.variable(s)
    }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon
    };
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class u0 extends Ys {
  constructor(t, e, s, o = null, r = 0) {
    super(), this.learningRate = t, this.beta1 = e, this.beta2 = s, this.epsilon = o, this.decay = r, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], D(() => {
      this.iteration = gt$1(0).variable(), this.accBeta1 = gt$1(e).variable();
    }), o == null && (this.epsilon = $$1.backend.epsilon());
  }
  /** @nocollapse */
  static get className() {
    return "Adamax";
  }
  applyGradients(t) {
    const e = Array.isArray(t) ? t.map((s) => s.name) : Object.keys(t);
    D(() => {
      const s = lt(1, this.accBeta1), o = ut(-this.learningRate, U(G(this.iteration, this.decay), 1));
      e.forEach((r, i6) => {
        const a = $$1.registeredVariables[r], l = false;
        this.accumulatedFirstMoment[i6] == null && (this.accumulatedFirstMoment[i6] = {
          originalName: `${r}/m`,
          variable: Tt$1(a).variable(l)
        }), this.accumulatedWeightedInfNorm[i6] == null && (this.accumulatedWeightedInfNorm[i6] = {
          originalName: `${r}/v`,
          variable: Tt$1(a).variable(l)
        });
        const c = Array.isArray(t) ? t[i6].tensor : t[r];
        if (c == null)
          return;
        const u = this.accumulatedFirstMoment[i6].variable, d = this.accumulatedWeightedInfNorm[i6].variable, h6 = U(G(u, this.beta1), G(c, 1 - this.beta1)), p6 = G(d, this.beta2), f = fe$1(c), m = _s(p6, f);
        u.assign(h6), d.assign(m);
        const g6 = U(G(ut(o, s), ut(h6, U(m, this.epsilon))), a);
        a.assign(g6);
      }), this.iteration.assign(U(this.iteration, 1)), this.accBeta1.assign(G(this.accBeta1, this.beta1));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && yt$1(this.accumulatedFirstMoment.map((t) => t.variable)), this.accumulatedWeightedInfNorm != null && yt$1(this.accumulatedWeightedInfNorm.map((t) => t.variable));
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for Adamax yet.");
  }
  async setWeights(t) {
    throw new Error("setWeights() is not implemented for Adamax yet.");
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      beta1: this.beta1,
      beta2: this.beta2,
      epsilon: this.epsilon,
      decay: this.decay
    };
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Gp extends Ys {
  constructor(t) {
    super(), this.learningRate = t, this.setLearningRate(t);
  }
  /** @nocollapse */
  static get className() {
    return "SGD";
  }
  applyGradients(t) {
    (Array.isArray(t) ? t.map((s) => s.name) : Object.keys(t)).forEach((s, o) => {
      const r = Array.isArray(t) ? t[o].tensor : t[s];
      if (r == null)
        return;
      const i6 = $$1.registeredVariables[s];
      D(() => {
        const a = U(G(this.c, r), i6);
        i6.assign(a);
      });
    }), this.incrementIterations();
  }
  /**
   * Sets the learning rate of the optimizer.
   */
  setLearningRate(t) {
    this.learningRate = t, this.c != null && this.c.dispose(), this.c = cn$1(gt$1(-t));
  }
  dispose() {
    this.c.dispose();
  }
  async getWeights() {
    return [await this.saveIterations()];
  }
  async setWeights(t) {
    if (t = await this.extractIterations(t), t.length !== 0)
      throw new Error("SGD optimizer does not have settable weights.");
  }
  getConfig() {
    return { learningRate: this.learningRate };
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e.learningRate);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class d0 extends Gp {
  constructor(t, e, s = false) {
    super(t), this.learningRate = t, this.momentum = e, this.useNesterov = s, this.accumulations = [], this.m = gt$1(this.momentum);
  }
  /** @nocollapse */
  // Name matters for Python compatibility.
  static get className() {
    return "Momentum";
  }
  applyGradients(t) {
    (Array.isArray(t) ? t.map((s) => s.name) : Object.keys(t)).forEach((s, o) => {
      const r = $$1.registeredVariables[s];
      this.accumulations[o] == null && (this.accumulations[o] = {
        originalName: `${s}/momentum`,
        variable: D(() => Tt$1(r).variable(false))
      });
      const i6 = this.accumulations[o].variable, a = Array.isArray(t) ? t[o].tensor : t[s];
      a != null && D(() => {
        let l;
        const c = U(G(this.m, i6), a);
        this.useNesterov ? l = U(G(this.c, U(a, G(c, this.m))), r) : l = U(G(this.c, c), r), i6.assign(c), r.assign(l);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.m.dispose(), this.accumulations != null && yt$1(this.accumulations.map((t) => t.variable));
  }
  /**
   * Sets the momentum of the optimizer.
   *
   * @param momentum
   */
  setMomentum(t) {
    this.momentum = t;
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulations.map((t) => ({ name: t.originalName, tensor: t.variable })));
  }
  async setWeights(t) {
    t = await this.extractIterations(t);
    const e = false;
    this.accumulations = t.map((s) => ({ originalName: s.name, variable: s.tensor.variable(e) }));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      momentum: this.momentum,
      useNesterov: this.useNesterov
    };
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e.learningRate, e.momentum, e.useNesterov);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class h0 extends Ys {
  constructor(t, e = 0.9, s = 0, o = null, r = false) {
    if (super(), this.learningRate = t, this.decay = e, this.momentum = s, this.epsilon = o, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = r, o == null && (this.epsilon = $$1.backend.epsilon()), t == null)
      throw new Error("learningRate for RMSPropOptimizer must be defined.");
  }
  /** @nocollapse */
  static get className() {
    return "RMSProp";
  }
  applyGradients(t) {
    (Array.isArray(t) ? t.map((s) => s.name) : Object.keys(t)).forEach((s, o) => {
      const r = $$1.registeredVariables[s], i6 = false;
      this.accumulatedMeanSquares[o] == null && (this.accumulatedMeanSquares[o] = {
        originalName: `${s}/rms`,
        variable: D(() => Tt$1(r).variable(i6))
      }), this.accumulatedMoments[o] == null && (this.accumulatedMoments[o] = {
        originalName: `${s}/momentum`,
        variable: D(() => Tt$1(r).variable(i6))
      }), this.accumulatedMeanGrads[o] == null && this.centered && (this.accumulatedMeanGrads[o] = {
        originalName: `${s}/mg`,
        variable: D(() => Tt$1(r).variable(i6))
      });
      const a = Array.isArray(t) ? t[o].tensor : t[s];
      if (a == null)
        return;
      const l = this.accumulatedMeanSquares[o].variable, c = this.accumulatedMoments[o].variable;
      D(() => {
        const u = U(G(l, this.decay), G(At$1(a), 1 - this.decay));
        if (this.centered) {
          const d = this.accumulatedMeanGrads[o].variable, h6 = U(G(d, this.decay), G(a, 1 - this.decay)), p6 = ut(G(a, this.learningRate), De$1(lt(u, U(At$1(h6), this.epsilon)))), f = U(G(c, this.momentum), p6);
          l.assign(u), d.assign(h6), c.assign(f);
          const m = lt(r, f);
          r.assign(m);
        } else {
          const d = U(G(l, this.decay), G(At$1(a), 1 - this.decay)), h6 = U(G(c, this.momentum), ut(G(a, this.learningRate), De$1(U(d, this.epsilon))));
          l.assign(d), c.assign(h6);
          const p6 = lt(r, h6);
          r.assign(p6);
        }
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.accumulatedMeanSquares != null && yt$1(this.accumulatedMeanSquares.map((t) => t.variable)), this.accumulatedMeanGrads != null && this.centered && yt$1(this.accumulatedMeanGrads.map((t) => t.variable)), this.accumulatedMoments != null && yt$1(this.accumulatedMoments.map((t) => t.variable));
  }
  async getWeights() {
    const t = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
    return this.centered && t.push(...this.accumulatedMeanGrads), [await this.saveIterations()].concat(t.map((e) => ({ name: e.originalName, tensor: e.variable })));
  }
  async setWeights(t) {
    t = await this.extractIterations(t);
    const e = this.centered ? t.length / 3 : t.length / 2, s = false;
    this.accumulatedMeanSquares = t.slice(0, e).map((o) => ({
      originalName: o.name,
      variable: o.tensor.variable(s)
    })), this.accumulatedMoments = t.slice(e, e * 2).map((o) => ({
      originalName: o.name,
      variable: o.tensor.variable(s)
    })), this.centered && (this.accumulatedMeanGrads = t.slice(e * 2, e * 3).map((o) => ({
      originalName: o.name,
      variable: o.tensor.variable(s)
    })));
  }
  getConfig() {
    return {
      learningRate: this.learningRate,
      decay: this.decay,
      momentum: this.momentum,
      epsilon: this.epsilon,
      centered: this.centered
    };
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const XN = [
  a0,
  l0,
  c0,
  u0,
  d0,
  h0,
  Gp
];
function PN() {
  for (const n of XN)
    _(n);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cm(n, t, e, s) {
  i6(n), e = e ?? 0, s = s ?? 1, a(e, s);
  let o = 0;
  const r = (l) => (l.then((c) => {
    const u = e + ++o / n.length * (s - e);
    return t(u), c;
  }), l);
  function i6(l) {
    v(l != null && Array.isArray(l) && l.length > 0, () => "promises must be a none empty array");
  }
  function a(l, c) {
    v(l >= 0 && l <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${l}`), v(c >= 0 && c <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${c}`), v(c >= l, () => `startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`);
  }
  return Promise.all(n.map(r));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function p0(n, t) {
  t == null && (t = {});
  const e = t.fetchFunc == null ? F().platform.fetch : t.fetchFunc, s = n.map((d) => e(d, t.requestInit, { isBinary: true })), o = 0, r = 0.5, a = (t.onProgress == null ? await Promise.all(s) : await cm(s, t.onProgress, o, r)).map((d) => d.arrayBuffer()), l = 0.5, c = 1;
  return t.onProgress == null ? await Promise.all(a) : await cm(a, t.onProgress, l, c);
}
async function AN(n, t = "", e, s) {
  return ON((i6) => p0(i6, { requestInit: s }))(n, t, e);
}
function ON(n) {
  return async (t, e = "", s) => {
    const o = t.map(() => false), r = {}, i6 = s != null ? s.map(() => false) : [], a = [];
    if (t.forEach((p6, f) => {
      let m = 0;
      p6.weights.forEach((g6) => {
        const b6 = "quantization" in g6 ? g6.quantization.dtype : g6.dtype, x6 = pd[b6] * O(g6.shape), w6 = () => {
          o[f] = true, r[f] == null && (r[f] = []), r[f].push({
            manifestEntry: g6,
            groupOffset: m,
            sizeBytes: x6
          });
        };
        s != null ? s.forEach((y6, I) => {
          y6 === g6.name && (w6(), i6[I] = true);
        }) : w6(), a.push(g6.name), m += x6;
      });
    }), !i6.every((p6) => p6)) {
      const p6 = s.filter((f, m) => !i6[m]);
      throw new Error(`Could not find weights in manifest with names: ${p6.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`);
    }
    const l = o.reduce((p6, f, m) => (f && p6.push(m), p6), []), c = [];
    l.forEach((p6) => {
      t[p6].paths.forEach((f) => {
        const m = e + (e.endsWith("/") ? "" : "/") + f;
        c.push(m);
      });
    });
    const u = await n(c), d = {};
    let h6 = 0;
    return l.forEach((p6) => {
      const f = t[p6].paths.length;
      let m = 0;
      for (let y6 = 0; y6 < f; y6++)
        m += u[h6 + y6].byteLength;
      const g6 = new ArrayBuffer(m), b6 = new Uint8Array(g6);
      let x6 = 0;
      for (let y6 = 0; y6 < f; y6++) {
        const I = new Uint8Array(u[h6 + y6]);
        b6.set(I, x6), x6 += I.byteLength;
      }
      r[p6].forEach((y6) => {
        const I = g6.slice(y6.groupOffset, y6.groupOffset + y6.sizeBytes), C6 = gb$1(I, [y6.manifestEntry]);
        for (const k7 in C6)
          d[k7] = C6[k7];
      }), h6 += f;
    }), d;
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KN = "application/octet-stream", ZN = "application/json";
class Ep {
  constructor(t, e) {
    if (this.DEFAULT_METHOD = "POST", e == null && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, this.weightUrlConverter = e.weightUrlConverter, e.fetchFunc != null ? (v(typeof e.fetchFunc == "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = e.fetchFunc) : this.fetch = F().platform.fetch, v(t != null && t.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(t) && v(t.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${t.length}).`), this.path = t, e.requestInit != null && e.requestInit.body != null)
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = e.requestInit || {};
  }
  async save(t) {
    if (t.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
    const e = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
    e.body = new FormData();
    const s = [{
      paths: ["./model.weights.bin"],
      weights: t.weightSpecs
    }], o = SC(t, s);
    e.body.append("model.json", new Blob([JSON.stringify(o)], { type: ZN }), "model.json"), t.weightData != null && e.body.append("model.weights.bin", new Blob([t.weightData], { type: KN }), "model.weights.bin");
    const r = await this.fetch(this.path, e);
    if (r.ok)
      return {
        modelArtifactsInfo: Kh$1(t),
        responses: [r]
      };
    throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`);
  }
  /**
   * Load model artifacts via HTTP request(s).
   *
   * See the documentation to `tf.io.http` for details on the saved
   * artifacts.
   *
   * @returns The loaded model artifacts (if loading succeeds).
   */
  async load() {
    const t = await this.fetch(this.path, this.requestInit);
    if (!t.ok)
      throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);
    let e;
    try {
      e = await t.json();
    } catch {
      let i6 = `Failed to parse model JSON of response from ${this.path}.`;
      throw this.path.endsWith(".pb") ? i6 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : i6 += " Please make sure the server is serving valid JSON for this request.", new Error(i6);
    }
    const s = e.modelTopology, o = e.weightsManifest;
    if (s == null && o == null)
      throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
    return TC(e, (r) => this.loadWeights(r));
  }
  async loadWeights(t) {
    const e = Array.isArray(this.path) ? this.path[1] : this.path, [s, o] = BN(e), r = this.weightPathPrefix || s, i6 = NC(t), a = [], l = [];
    for (const u of t)
      for (const d of u.paths)
        this.weightUrlConverter != null ? l.push(this.weightUrlConverter(d)) : a.push(r + d + o);
    this.weightUrlConverter && a.push(...await Promise.all(l));
    const c = await p0(a, {
      requestInit: this.requestInit,
      fetchFunc: this.fetch,
      onProgress: this.onProgress
    });
    return [i6, bb$1(c)];
  }
}
Ep.URL_SCHEME_REGEX = /^https?:\/\//;
function BN(n) {
  const t = n.lastIndexOf("/"), e = n.lastIndexOf("?"), s = n.substring(0, t), o = e > t ? n.substring(e) : "";
  return [s + "/", o];
}
function um(n) {
  return n.match(Ep.URL_SCHEME_REGEX) != null;
}
const f0 = (n, t) => {
  if (typeof fetch > "u" && (t == null || t.fetchFunc == null))
    return null;
  {
    let e = true;
    if (Array.isArray(n) ? e = n.every((s) => um(s)) : e = um(n), e)
      return m0(n, t);
  }
  return null;
};
ee.registerSaveRouter(f0);
ee.registerLoadRouter(f0);
function m0(n, t) {
  return new Ep(n, t);
}
function HN(n, t) {
  return m0(n, t);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let to;
function g0(n, t = 3) {
  if (t > 4)
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  if (n == null)
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  let e = false, s = false, o = false, r = false, i6 = false, a = false;
  if (n.data instanceof Uint8Array)
    e = true;
  else if (typeof ImageData < "u" && n instanceof ImageData)
    s = true;
  else if (typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement)
    o = true;
  else if (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement)
    r = true;
  else if (n.getContext != null)
    i6 = true;
  else if (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    a = true;
  else
    throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);
  if (od(sd, $$1.backendName) != null) {
    const f = { pixels: n }, m = { numChannels: t };
    return $$1.runKernel(sd, f, m);
  }
  const [c, u] = o ? [
    n.videoWidth,
    n.videoHeight
  ] : [n.width, n.height];
  let d;
  if (i6)
    d = // tslint:disable-next-line:no-any
    n.getContext("2d").getImageData(0, 0, c, u).data;
  else if (s || e)
    d = n.data;
  else if (r || o || a) {
    if (to == null)
      if (typeof document > "u")
        if (typeof OffscreenCanvas < "u" && typeof OffscreenCanvasRenderingContext2D < "u")
          to = new OffscreenCanvas(1, 1).getContext("2d");
        else
          throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
      else
        to = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
    to.canvas.width = c, to.canvas.height = u, to.drawImage(n, 0, 0, c, u), d = to.getImageData(0, 0, c, u).data;
  }
  let h6;
  if (t === 4)
    h6 = new Int32Array(d);
  else {
    const f = c * u;
    h6 = new Int32Array(f * t);
    for (let m = 0; m < f; m++)
      for (let g6 = 0; g6 < t; ++g6)
        h6[m * t + g6] = d[m * 4 + g6];
  }
  return Hk(h6, [u, c, t], "int32");
}
function _N(n) {
  return n != null && n.data instanceof Uint8Array;
}
function UN() {
  return typeof window < "u" && typeof ImageBitmap < "u" && window.hasOwnProperty("createImageBitmap");
}
function YN(n) {
  return n != null && n.width !== 0 && n.height !== 0;
}
function QN(n) {
  return UN() && !(n instanceof ImageBitmap) && YN(n) && !_N(n);
}
async function JN(n, t = 3) {
  let e = null;
  if (F().getBool("WRAP_TO_IMAGEBITMAP") && QN(n)) {
    let s;
    try {
      s = await createImageBitmap(n, { premultiplyAlpha: "none" });
    } catch {
      s = null;
    }
    s != null && s.width === n.width && s.height === n.height ? e = s : e = n;
  } else
    e = n;
  return g0(e, t);
}
async function jN(n, t) {
  let e = T(n, "img", "toPixels");
  if (!(n instanceof Lt$1)) {
    const c = e;
    e = et(c, "int32"), c.dispose();
  }
  if (e.rank !== 2 && e.rank !== 3)
    throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);
  const [s, o] = e.shape.slice(0, 2), r = e.rank === 2 ? 1 : e.shape[2];
  if (r > 4 || r === 2)
    throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${r}`);
  if (e.dtype !== "float32" && e.dtype !== "int32")
    throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);
  const i6 = await e.data(), a = e.dtype === "float32" ? 255 : 1, l = new Uint8ClampedArray(o * s * 4);
  for (let c = 0; c < s * o; ++c) {
    const u = [0, 0, 0, 255];
    for (let h6 = 0; h6 < r; h6++) {
      const p6 = i6[c * r + h6];
      if (e.dtype === "float32") {
        if (p6 < 0 || p6 > 1)
          throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p6}.`);
      } else if (e.dtype === "int32" && (p6 < 0 || p6 > 255))
        throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p6}.`);
      r === 1 ? (u[0] = p6 * a, u[1] = p6 * a, u[2] = p6 * a) : u[h6] = p6 * a;
    }
    const d = c * 4;
    l[d + 0] = Math.round(u[0]), l[d + 1] = Math.round(u[1]), l[d + 2] = Math.round(u[2]), l[d + 3] = Math.round(u[3]);
  }
  if (t != null) {
    t.width = o, t.height = s;
    const c = t.getContext("2d"), u = new ImageData(l, o, s);
    c.putImageData(u, 0, 0);
  }
  return e !== n && e.dispose(), l;
}
const b0 = /* @__PURE__ */ L({ fromPixels_: g0 }), yY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromPixels: b0,
  fromPixelsAsync: JN,
  toPixels: jN
}, Symbol.toStringTag, { value: "Module" }));
function Bc(n, t) {
  const e = n.shape.length, s = t.shape.length;
  if (e < 1)
    throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);
  if (s < 1)
    throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);
  if (t.dtype !== "int32")
    throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
  if (t.shape[s - 1] > e)
    throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s - 1]} vs. ${e}`);
  if (O(n.shape) === 0)
    throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);
  const o = t.shape, r = o[o.length - 1];
  let i6 = 1;
  for (let d = 0; d < o.length - 1; ++d)
    i6 *= o[d];
  const a = n.shape, l = o.slice();
  l.pop();
  let c = 1;
  for (let d = r; d < e; ++d)
    c *= a[d], l.push(a[d]);
  const u = [
    ...dt(n.shape).map((d) => d / c),
    1
  ].slice(0, r);
  return [l, i6, c, u];
}
const wY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  prepareAndValidate: Bc
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wd$1 = -2, qN = -1;
function Lp(n, t, e) {
  const s = n.shape.length;
  v(s === t.length, () => `Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`), v(s === e.length, () => `Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);
  for (let o = 0; o < s; ++o)
    v(t[o] + e[o] <= n.shape[o], () => `Error in slice${s}D: begin[${o}] + size[${o}] (${t[o] + e[o]}) would overflow input.shape[${o}] (${n.shape[o]})`);
}
function tR(n) {
  const t = [];
  let e = 0;
  for (; n > 0; )
    n & 1 && t.push(e), n /= 2, e++;
  return t;
}
function Mp(n, t, e) {
  const s = [];
  for (let o = 0; o < n.length; o++)
    s[o] = Math.ceil((t[o] - n[o]) / e[o]);
  return s;
}
function x0(n, t, e, s) {
  const o = [...n];
  for (let r = o.length; r < s.length; r++)
    o.push(1);
  for (let r = 0; r < e; r++)
    r === 0 ? o[t] = 1 : (o.splice(
      t,
      0,
      1
      /* element to add */
    ), o.pop());
  return o;
}
function y0(n, t, e) {
  return e <= n ? e : e - (t - 1);
}
function w0(n, t) {
  const e = [];
  for (let s = 0; s < n; s++)
    e.push(t + s);
  return e;
}
function eR(n, t, e, s, o, r, i6, a, l) {
  const c = n.length;
  let u = new Array(c), d = new Array(c), h6 = new Array(c);
  if (t.length && e > 0) {
    const p6 = t[0], f = e + 1;
    u = I0(i6, p6, f, s, n), d = C0(a, p6, f, o, n), h6 = x0(r, p6, f, n);
  } else
    for (let p6 = 0; p6 < c; p6++)
      u[p6] = S0(i6, s, r, n, p6, l), d[p6] = k0(a, o, r, n, p6, l), h6[p6] = v0(r, p6, l);
  return {
    begin: u,
    end: d,
    strides: h6
  };
}
function I0(n, t, e, s, o) {
  const r = [...o], i6 = w0(e, t);
  for (let a = 0; a < r.length; a++)
    if (i6.indexOf(a) > -1)
      r[a] = 0;
    else {
      const l = y0(t, e, a);
      let c = s[l];
      n & 1 << l && (c = 0), r[a] = c;
    }
  return r;
}
function C0(n, t, e, s, o) {
  const r = [...o], i6 = w0(e, t);
  for (let a = 0; a < r.length; a++)
    if (i6.indexOf(a) > -1)
      r[a] = Number.MAX_SAFE_INTEGER;
    else {
      const l = y0(t, e, a);
      let c = s[l];
      n & 1 << l && (c = Number.MAX_SAFE_INTEGER), r[a] = c;
    }
  for (let a = 0; a < r.length; a++) {
    const l = o[a];
    r[a] < 0 && (r[a] += l), r[a] = Fs(0, r[a], o[a]);
  }
  return r;
}
function v0(n, t, e) {
  let s = n[t];
  return (e & 1 << t || s == null) && (s = 1), s;
}
function S0(n, t, e, s, o, r) {
  let i6 = t[o];
  const a = e[o] || 1;
  (n & 1 << o || r & 1 << o || i6 == null) && (a > 0 ? i6 = Number.MIN_SAFE_INTEGER : i6 = Number.MAX_SAFE_INTEGER);
  const l = s[o];
  return i6 < 0 && (i6 += l), i6 = Fs(0, i6, l - 1), i6;
}
function k0(n, t, e, s, o, r) {
  let i6 = t[o];
  const a = e[o] || 1;
  (n & 1 << o || r & 1 << o || i6 == null) && (a > 0 ? i6 = Number.MAX_SAFE_INTEGER : i6 = Number.MIN_SAFE_INTEGER);
  const l = s[o];
  return i6 < 0 && (i6 += l), a > 0 ? i6 = Fs(0, i6, l) : i6 = Fs(-1, i6, l - 1), i6;
}
function Wp(n, t, e) {
  let s = e.length;
  for (let o = 0; o < e.length; o++)
    if (e[o] > 1) {
      s = o;
      break;
    }
  for (let o = s + 1; o < e.length; o++)
    if (t[o] > 0 || e[o] !== n[o])
      return false;
  return true;
}
function Dp(n, t) {
  let e = n.length > 0 ? n[n.length - 1] : 1;
  for (let s = 0; s < n.length - 1; s++)
    e += n[s] * t[s];
  return e;
}
function Hc(n, t, e) {
  let s;
  const o = n.shape.length;
  typeof t == "number" ? s = [t, ...new Array(o - 1).fill(0)] : t.length < o ? s = t.concat(new Array(o - t.length).fill(0)) : s = t.slice(), s.forEach((i6) => {
    v(i6 !== -1, () => "slice() does not support negative begin indexing.");
  });
  let r;
  return e == null ? r = new Array(o).fill(-1) : typeof e == "number" ? r = [e, ...new Array(o - 1).fill(-1)] : e.length < o ? r = e.concat(new Array(o - e.length).fill(-1)) : r = e, r = r.map((i6, a) => i6 >= 0 ? i6 : (v(i6 === -1, () => `Negative size values should be exactly -1 but got ${i6} for the slice() size at index ${a}.`), n.shape[a] - s[a])), [s, r];
}
function Fp(n, t, e, s, o, r, i6, a, l) {
  let c;
  if (s == null ? (c = new Array(t.length), c.fill(1)) : c = s, i6 != null && i6 & i6 - 1)
    throw new Error("Multiple ellipses in slice is not allowed.");
  let u = false;
  const d = {
    dims: c.length,
    numAddAxisAfterEllipsis: 0,
    begin: t.slice(),
    end: e.slice(),
    strides: c.slice(),
    beginMask: o,
    endMask: r,
    ellipsisMask: i6,
    newAxisMask: a,
    shrinkAxisMask: l
  };
  for (let w6 = 0; w6 < d.dims; w6++)
    u && 1 << w6 & a && d.numAddAxisAfterEllipsis++, 1 << w6 & i6 && (u = true);
  u || (d.ellipsisMask |= 1 << d.dims, d.dims++);
  const h6 = {
    dims: n.length,
    beginMask: 0,
    endMask: 0,
    beginValid: false,
    endValid: false
  };
  nR(d, h6);
  let p6 = true, f = true, m = true;
  const g6 = [], b6 = [];
  for (let w6 = 0; w6 < n.length; ++w6) {
    if (h6.strides[w6] === 0)
      throw Error(`strides[${w6}] must be non-zero`);
    const y6 = !!(h6.shrinkAxisMask & 1 << w6), I = n[w6];
    if (I === -1) {
      g6.push(y6 ? 1 : -1);
      continue;
    }
    const C6 = [h6.beginMask & 1 << w6, h6.endMask & 1 << w6], k7 = [
      h6.strides[w6] > 0 ? 0 : -1,
      h6.strides[w6] > 0 ? I : I - 1
    ];
    if (y6 && h6.strides[w6] <= 0)
      throw Error("only stride 1 allowed on non-range indexing.");
    m = m && h6.strides[w6] === 1;
    const S = !!(h6.beginMask & 1 << w6 && h6.endMask & 1 << w6);
    if (h6.beginValid && h6.endValid) {
      if (y6) {
        const V = h6.begin[w6] < 0 ? I + h6.begin[w6] : h6.begin[w6];
        if (h6.begin[w6] = V, h6.end[w6] = h6.begin[w6] + 1, V < 0 || V >= I)
          throw Error(`slice index ${h6.begin[w6]} of dimension ${w6} out of bounds.`);
      } else
        h6.begin[w6] = dm(h6.begin[w6], 0, h6.strides[w6], I, C6, k7), h6.end[w6] = dm(h6.end[w6], 1, h6.strides[w6], I, C6, k7);
      const M6 = h6.strides[w6] === 1 && h6.begin[w6] === 0 && h6.end[w6] === I;
      p6 = p6 && M6, f = f && (w6 === 0 && h6.strides[w6] === 1 || M6);
    } else
      p6 = p6 && h6.strides[w6] === 1 && S, f = f && (w6 === 0 && h6.strides[w6] === 1 || S);
    let N, R = false;
    if (h6.beginValid && h6.endValid ? (N = h6.end[w6] - h6.begin[w6], R = true) : y6 ? (N = 1, R = true) : S && I >= 0 && (h6.strides[w6] < 0 ? N = -I : N = I, R = true), R) {
      let M6;
      N === 0 || N < 0 != h6.strides[w6] < 0 ? M6 = 0 : M6 = Math.trunc(N / h6.strides[w6]) + (N % h6.strides[w6] !== 0 ? 1 : 0), g6.push(M6);
    } else
      g6.push(-1);
  }
  for (let w6 = 0; w6 < h6.finalShapeGatherIndices.length; ++w6) {
    const y6 = h6.finalShapeGatherIndices[w6];
    y6 >= 0 ? b6.push(g6[y6]) : y6 === wd$1 && b6.push(1);
  }
  return {
    finalShapeSparse: b6.filter((w6, y6) => h6.finalShapeGatherIndices[y6] !== wd$1),
    finalShape: b6,
    isIdentity: p6,
    sliceDim0: f,
    isSimpleSlice: m,
    begin: h6.begin,
    end: h6.end,
    strides: h6.strides
  };
}
function nR(n, t) {
  t.beginMask = 0, t.endMask = 0, t.shrinkAxisMask = 0;
  let e = 0;
  t.beginValid = n.begin != null, t.endValid = n.end != null, t.begin = new Array(t.dims), t.end = new Array(t.dims), t.strides = new Array(t.dims), t.finalShapeGatherIndices = [], t.finalShapeGatherIndicesSparse = [], t.inputShapeGatherIndicesSparse = new Array(t.dims);
  for (let s = 0; s < n.dims; s++)
    if (1 << s & n.ellipsisMask) {
      const o = Math.min(t.dims - (n.dims - s) + 1 + n.numAddAxisAfterEllipsis, t.dims);
      for (; e < o; e++)
        t.begin[e] = 0, t.end[e] = 0, t.strides[e] = 1, t.beginMask |= 1 << e, t.endMask |= 1 << e, t.finalShapeGatherIndices.push(e), t.finalShapeGatherIndicesSparse.push(-1), t.inputShapeGatherIndicesSparse[e] = s;
    } else if (1 << s & n.newAxisMask)
      t.finalShapeGatherIndices.push(wd$1), t.finalShapeGatherIndicesSparse.push(-1);
    else {
      if (e === t.begin.length)
        throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);
      n.begin != null && (t.begin[e] = n.begin[s]), n.end != null && (t.end[e] = n.end[s]), t.strides[e] = n.strides[s], n.beginMask & 1 << s && (t.beginMask |= 1 << e), n.endMask & 1 << s && (t.endMask |= 1 << e), n.shrinkAxisMask & 1 << s ? (t.finalShapeGatherIndices.push(qN), t.finalShapeGatherIndicesSparse.push(-1), t.shrinkAxisMask |= 1 << e) : (t.finalShapeGatherIndices.push(e), t.finalShapeGatherIndicesSparse.push(s)), t.inputShapeGatherIndicesSparse[e] = s, e++;
    }
}
function dm(n, t, e, s, o, r) {
  if (o[t])
    return e > 0 ? r[t] : r[t + 1 & 1];
  {
    const i6 = n < 0 ? s + n : n;
    return i6 < r[0] ? r[0] : i6 > r[1] ? r[1] : i6;
  }
}
const sR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertParamsValid: Lp,
  computeFlatOffset: Dp,
  computeOutShape: Mp,
  getNormalizedAxes: eR,
  isSliceContinous: Wp,
  maskToAxes: tR,
  parseSliceParams: Hc,
  sliceInfo: Fp,
  startForAxis: S0,
  startIndicesWithElidedDims: I0,
  stopForAxis: k0,
  stopIndicesWithElidedDims: C0,
  stridesForAxis: v0,
  stridesWithElidedDims: x0
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class oR {
  /**
   * Constructs a `tf.SGDOptimizer` that uses stochastic gradient descent.
   *
   * ```js
   * // Fit a quadratic function by learning the coefficients a, b, c.
   * const xs = tf.tensor1d([0, 1, 2, 3]);
   * const ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);
   *
   * const a = tf.scalar(Math.random()).variable();
   * const b = tf.scalar(Math.random()).variable();
   * const c = tf.scalar(Math.random()).variable();
   *
   * // y = a * x^2 + b * x + c.
   * const f = x => a.mul(x.square()).add(b.mul(x)).add(c);
   * const loss = (pred, label) => pred.sub(label).square().mean();
   *
   * const learningRate = 0.01;
   * const optimizer = tf.train.sgd(learningRate);
   *
   * // Train the model.
   * for (let i = 0; i < 10; i++) {
   *   optimizer.minimize(() => loss(f(xs), ys));
   * }
   *
   * // Make predictions.
   * console.log(
   *     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);
   * const preds = f(xs).dataSync();
   * preds.forEach((pred, i) => {
   *   console.log(`x: ${i}, pred: ${pred}`);
   * });
   * ```
   *
   * @param learningRate The learning rate to use for the SGD algorithm.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static sgd(t) {
    return new Gp(t);
  }
  /**
   * Constructs a `tf.MomentumOptimizer` that uses momentum gradient
   * descent.
   *
   * See
   * [http://proceedings.mlr.press/v28/sutskever13.pdf](
   * http://proceedings.mlr.press/v28/sutskever13.pdf)
   *
   * @param learningRate The learning rate to use for the Momentum gradient
   * descent algorithm.
   * @param momentum The momentum to use for the momentum gradient descent
   * algorithm.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static momentum(t, e, s = false) {
    return new d0(t, e, s);
  }
  /**
   * Constructs a `tf.RMSPropOptimizer` that uses RMSProp gradient
   * descent. This implementation uses plain momentum and is not centered
   * version of RMSProp.
   *
   * See
   * [http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf](
   * http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)
   *
   * @param learningRate The learning rate to use for the RMSProp gradient
   * descent algorithm.
   * @param decay The discounting factor for the history/coming gradient.
   * @param momentum The momentum to use for the RMSProp gradient descent
   * algorithm.
   * @param epsilon Small value to avoid zero denominator.
   * @param centered If true, gradients are normalized by the estimated
   * variance of the gradient.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static rmsprop(t, e = 0.9, s = 0, o = null, r = false) {
    return new h0(t, e, s, o, r);
  }
  /**
   * Constructs a `tf.AdamOptimizer` that uses the Adam algorithm.
   * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
   *
   * @param learningRate The learning rate to use for the Adam gradient
   * descent algorithm.
   * @param beta1 The exponential decay rate for the 1st moment estimates.
   * @param beta2 The exponential decay rate for the 2nd moment estimates.
   * @param epsilon A small constant for numerical stability.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adam(t = 1e-3, e = 0.9, s = 0.999, o = null) {
    return new c0(t, e, s, o);
  }
  /**
   * Constructs a `tf.AdadeltaOptimizer` that uses the Adadelta algorithm.
   * See [https://arxiv.org/abs/1212.5701](https://arxiv.org/abs/1212.5701)
   *
   * @param learningRate The learning rate to use for the Adadelta gradient
   * descent algorithm.
   * @param rho The learning rate decay over each update.
   * @param epsilon A constant epsilon used to better condition the grad
   * update.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adadelta(t = 1e-3, e = 0.95, s = null) {
    return new a0(t, e, s);
  }
  /**
   * Constructs a `tf.AdamaxOptimizer` that uses the Adamax algorithm.
   * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
   *
   * @param learningRate The learning rate to use for the Adamax gradient
   * descent algorithm.
   * @param beta1 The exponential decay rate for the 1st moment estimates.
   * @param beta2 The exponential decay rate for the 2nd moment estimates.
   * @param epsilon A small constant for numerical stability.
   * @param decay The learning rate decay over each update.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adamax(t = 2e-3, e = 0.9, s = 0.999, o = null, r = 0) {
    return new u0(t, e, s, o, r);
  }
  /**
   * Constructs a `tf.AdagradOptimizer` that uses the Adagrad algorithm.
   * See
   * [http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf](
   * http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf)
   * or
   * [http://ruder.io/optimizing-gradient-descent/index.html#adagrad](
   * http://ruder.io/optimizing-gradient-descent/index.html#adagrad)
   *
   * @param learningRate The learning rate to use for the Adagrad gradient
   * descent algorithm.
   * @param initialAccumulatorValue Starting value for the accumulators, must be
   * positive.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adagrad(t, e = 0.1) {
    return new l0(t, e);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ko = oR;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rR = (() => typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : (n) => n())();
function _c() {
  return new Promise((n) => rR(() => n()));
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Vp(n, t) {
  const e = n[0].length;
  n.forEach((o, r) => {
    v(o.length === e, () => `Error in concat${e}D: rank of tensors[${r}] must be the same as the rank of the rest (${e})`);
  }), v(t >= 0 && t < e, () => `Error in concat${e}D: axis must be between 0 and ${e - 1}.`);
  const s = n[0];
  n.forEach((o, r) => {
    for (let i6 = 0; i6 < e; i6++)
      v(i6 === t || o[i6] === s[i6], () => `Error in concat${e}D: Shape of tensors[${r}] (${o}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`);
  });
}
function ts(n, t) {
  const e = n[0].slice();
  for (let s = 1; s < n.length; s++)
    e[t] += n[s][t];
  return e;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Fn$1;
(function(n) {
  n[n.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", n[n.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", n[n.ROW_LENGTHS = 2] = "ROW_LENGTHS", n[n.ROW_SPLITS = 3] = "ROW_SPLITS", n[n.ROW_LIMITS = 4] = "ROW_LIMITS", n[n.ROW_STARTS = 5] = "ROW_STARTS";
})(Fn$1 || (Fn$1 = {}));
function T0(n, t, e) {
  let s = new Array();
  if (e == null && t == null)
    return s;
  if (t == null)
    for (; s.length < n + e.length; )
      s.push(-1);
  else
    s = t.slice();
  if (e == null)
    return s;
  if (n + e.length !== s.length)
    throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n + e.length}, but shape.rank = ${s.length}`);
  for (let o = 1; o < e.length; ++o) {
    const r = e[o], i6 = s[s.length - e.length + o], a = s[i6];
    if (r >= 0)
      if (a >= 0) {
        if (a !== r)
          throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o + n}] = ${r} but shape[${o + n}] = ${a}`);
      } else
        s[i6] = r;
  }
  return s;
}
function N0(n) {
  const t = {
    FIRST_DIM_SIZE: Fn$1.FIRST_DIM_SIZE,
    VALUE_ROWIDS: Fn$1.VALUE_ROWIDS,
    ROW_LENGTHS: Fn$1.ROW_LENGTHS,
    ROW_SPLITS: Fn$1.ROW_SPLITS,
    ROW_LIMITS: Fn$1.ROW_LIMITS,
    ROW_STARTS: Fn$1.ROW_STARTS
  }, e = [];
  for (const s of n)
    if (s in t)
      e.push(t[s]);
    else
      break;
  return e;
}
function R0(n) {
  return n.length === 0 ? 0 : n[0] === Fn$1.FIRST_DIM_SIZE ? n.length - 1 : n.length;
}
function $0(n, t) {
  if (n == null || t == null)
    return;
  const e = n.length, s = t.length;
  if (e >= s)
    throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);
  for (let o = 0; o < Math.min(e, s - 1); ++o) {
    const r = n[o], i6 = t[o + 1];
    if (r >= 0 && i6 >= 0 && r !== 1 && r !== i6)
      throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o - n.length}] = ${r} but ragged tensor input.flatValues.shape[${o - n.length}] = ${i6}`);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zp = 30;
function Uc(n) {
  return n <= zp ? n : sl(n, Math.floor(Math.sqrt(n)));
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Xp(n, t, e) {
  const s = e * (typeof n == "number" ? n : n[0]), o = t * (typeof n == "number" ? n : n[1]);
  return [s, o];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fa(n, t, e, s = true) {
  let o = [];
  if (s)
    o = o.concat(t.slice(0)), o.push(n[0] / e), o = o.concat(n.slice(1));
  else {
    o = o.concat(n[0]);
    const r = t.length;
    for (let i6 = 0; i6 < r; ++i6)
      o = o.concat([n[i6 + 1] / t[i6], t[i6]]);
    o = o.concat(n.slice(r + 1));
  }
  return o;
}
function ma(n, t, e = true) {
  const s = [];
  if (e) {
    s.push(t);
    for (let o = t + 1; o < n; ++o)
      o <= 2 * t ? (s.push(o), s.push(o - (t + 1))) : s.push(o);
  } else {
    const o = [], r = [];
    for (let i6 = 1; i6 < n; ++i6)
      i6 >= t * 2 + 1 || i6 % 2 === 1 ? r.push(i6) : o.push(i6);
    s.push(...o), s.push(0), s.push(...r);
  }
  return s;
}
function ga(n, t, e, s = true) {
  const o = [];
  s ? o.push(n[0] / e) : o.push(n[0] * e);
  for (let r = 1; r < n.length; ++r)
    r <= t.length ? s ? o.push(t[r - 1] * n[r]) : o.push(n[r] / t[r - 1]) : o.push(n[r]);
  return o;
}
function Pp(n, t) {
  const e = [0];
  for (let s = 0; s < t; ++s)
    e.push(n[s][0]);
  return e;
}
function Ap(n, t, e) {
  const s = n.slice(0, 1);
  for (let o = 0; o < e; ++o)
    s.push(n[o + 1] - t[o][0] - t[o][1]);
  return s;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Yc = 1.7580993408473768, Qc = 1.0507009873554805;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Op = 0.3275911, Kp = 0.254829592, Zp = -0.284496736, Bp = 1.421413741, Hp = -1.453152027, _p = 1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ms(n, t) {
  if (n.length !== t.length)
    throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);
  const e = new Float32Array(n.length * 2);
  for (let s = 0; s < e.length; s += 2)
    e[s] = n[s / 2], e[s + 1] = t[s / 2];
  return e;
}
function G0(n) {
  const t = new Float32Array(n.length / 2), e = new Float32Array(n.length / 2);
  for (let s = 0; s < n.length; s += 2)
    t[s / 2] = n[s], e[s / 2] = n[s + 1];
  return { real: t, imag: e };
}
function E0(n) {
  const t = Math.ceil(n.length / 4), e = new Float32Array(t), s = new Float32Array(t);
  for (let o = 0; o < n.length; o += 4)
    e[Math.floor(o / 4)] = n[o], s[Math.floor(o / 4)] = n[o + 1];
  return { real: e, imag: s };
}
function L0(n) {
  const t = Math.floor(n.length / 4), e = new Float32Array(t), s = new Float32Array(t);
  for (let o = 2; o < n.length; o += 4)
    e[Math.floor(o / 4)] = n[o], s[Math.floor(o / 4)] = n[o + 1];
  return { real: e, imag: s };
}
function Up(n, t) {
  const e = n[t * 2], s = n[t * 2 + 1];
  return { real: e, imag: s };
}
function M0(n, t, e, s) {
  n[s * 2] = t, n[s * 2 + 1] = e;
}
function W0(n, t) {
  const e = new Float32Array(n / 2), s = new Float32Array(n / 2);
  for (let o = 0; o < Math.ceil(n / 2); o++) {
    const r = (t ? 2 : -2) * Math.PI * (o / n);
    e[o] = Math.cos(r), s[o] = Math.sin(r);
  }
  return { real: e, imag: s };
}
function D0(n, t, e) {
  const s = (e ? 2 : -2) * Math.PI * (n / t), o = Math.cos(s), r = Math.sin(s);
  return { real: o, imag: r };
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const vu = "->", iR = /->/g, hm = ",", pm = "...";
function Yp(n, t) {
  n = n.replace(/\s/g, "");
  const e = (n.length - n.replace(iR, "").length) / vu.length;
  if (e < 1)
    throw new Error("Equations without an arrow are not supported.");
  if (e > 1)
    throw new Error(`Equation must contain exactly one arrow ("${vu}").`);
  const [s, o] = n.split(vu);
  v(s.indexOf(pm) === -1, () => `The ellipsis notation ("${pm}") is not supported yet.`);
  const r = s.split(hm), i6 = r.length;
  if (t !== i6)
    throw new Error(`Expected ${i6} input tensors, received ${t}`);
  if (i6 > 2)
    throw new Error("Support for more than 2 input tensors is not implemented yet.");
  const a = [];
  for (let h6 = 0; h6 < o.length; ++h6) {
    const p6 = o[h6];
    if (!r.some((f) => f.indexOf(p6) !== -1))
      throw new Error(`Output subscripts contain the label ${p6} not present in the input subscripts.`);
    a.indexOf(p6) === -1 && a.push(p6);
  }
  for (let h6 = 0; h6 < s.length; ++h6) {
    const p6 = s[h6];
    a.indexOf(p6) === -1 && p6 !== hm && a.push(p6);
  }
  const l = new Array(r.length);
  for (let h6 = 0; h6 < i6; ++h6) {
    if (new Set(r[h6].split("")).size !== r[h6].length)
      throw new Error(`Found duplicate axes in input component ${r[h6]}. Support for duplicate axes in input is not implemented yet.`);
    l[h6] = [];
    for (let p6 = 0; p6 < r[h6].length; ++p6)
      l[h6].push(a.indexOf(r[h6][p6]));
  }
  const c = a.length, u = o.length, d = [];
  for (let h6 = u; h6 < c; ++h6)
    d.push(h6);
  return { allDims: a, summedDims: d, idDims: l };
}
function Qp(n, t) {
  let e = new Array(n);
  e.fill(-1);
  for (let o = 0; o < t.length; ++o)
    e[t[o]] = o;
  const s = [];
  for (let o = 0; o < n; ++o)
    e[o] === -1 && s.push(o);
  return e = e.filter((o) => o !== -1), { permutationIndices: e, expandDims: s };
}
function Jp(n, t, e) {
  const s = new Array(n);
  for (let o = 0; o < e.length; ++o) {
    const r = e[o].shape;
    for (let i6 = 0; i6 < t[o].length; ++i6)
      s[t[o][i6]] === void 0 ? s[t[o][i6]] = r[i6] : v(s[t[o][i6]] === r[i6], () => `Expected dimension ${s[t[o][i6]]} at axis ${i6} of input shaped ${JSON.stringify(r)}, but got dimension ${r[i6]}`);
  }
}
function jp(n, t) {
  const e = n, s = [];
  let o = 0;
  n.length === 0 && e.push(-1), o = n.length + 1;
  for (let i6 = 0; i6 < o; ++i6)
    s.push([]);
  const r = [];
  for (let i6 = 0; i6 < e.length; ++i6) {
    const a = e[i6], l = aR(t, a);
    for (const c of l)
      r.indexOf(c) === -1 && (s[i6].push(c), r.push(c));
  }
  return { path: e, steps: s };
}
function qp(n) {
  return n.every((t, e) => t === e);
}
function aR(n, t) {
  const e = [];
  for (let s = 0; s < n.length; ++s)
    (n[s].length === 0 || n[s].indexOf(t) !== -1 || t === -1) && e.push(s);
  return e;
}
function tf$1(n, t, e = 0) {
  let s = [];
  if (typeof t == "number")
    v(n.shape[e] % t === 0, () => "Number of splits must evenly divide the axis."), s = new Array(t).fill(n.shape[e] / t);
  else {
    const o = t.reduce((i6, a) => (a === -1 && (i6 += 1), i6), 0);
    v(o <= 1, () => "There should be only one negative value in split array.");
    const r = t.indexOf(-1);
    if (r !== -1) {
      const i6 = t.reduce((a, l) => l > 0 ? a + l : a);
      t[r] = n.shape[e] - i6;
    }
    v(n.shape[e] === t.reduce((i6, a) => i6 + a), () => "The sum of sizes must match the size of the axis dimension."), s = t;
  }
  return s;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function F0(n) {
  return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`;
}
function V0(n, t) {
  return `indices(${n}, 0) is invalid: ${t} < 0`;
}
function z0(n, t, e) {
  return `indices(${n}, 0) is invalid: ${t} >= ${e}`;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function X0(n, t) {
  return `only one output dimension may be -1, not both ${n} and ${t}`;
}
function P0(n, t) {
  return `size ${n} must be non-negative, not ${t}`;
}
function A0() {
  return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}
function O0(n, t) {
  const e = O(n), s = O(t);
  return `Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${t}`;
}
function K0(n, t) {
  const e = O(n), s = O(t);
  return `Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${t}`;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Id$1() {
  return "segment ids must be >= 0";
}
function Z0() {
  return "segment ids are not increasing";
}
function B0(n, t) {
  return `Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`;
}
function H0(n, t, e) {
  return `Bad: indices[${n}] == ${t} out of range [0, ${e})`;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _0(n, t) {
  let e = false, s;
  for (n <= zp ? (s = n, e = true) : s = sl(n, Math.floor(Math.sqrt(n))); !e; )
    s > t || s === n ? e = true : s = sl(n, s + 1);
  return s;
}
function U0(n, t, e) {
  const s = [], o = n.length;
  for (let r = 0; r < o; r++)
    r !== t ? s.push(n[r]) : s.push(e);
  return s;
}
function ef$1(n, t, e, s) {
  const o = t.shape.length, r = n.shape.length;
  if (s !== 0 && (s < -o || s > o))
    throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${s}`);
  if (s < 0 && (s += o), s > r)
    throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${r}).`);
  if (e < s)
    throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);
  for (let d = 0; d < s; ++d)
    if (n.shape[d] !== t.shape[d])
      throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);
  const i6 = n.shape[e], a = [];
  let l = 1, c = 1, u = 1;
  for (let d = 0; d < s; ++d)
    a.push(n.shape[d]), l *= n.shape[d];
  for (let d = s; d < e; d++)
    a.push(n.shape[d]), c *= n.shape[d];
  for (let d = s; d < o; d++)
    a.push(t.shape[d]);
  for (let d = e + 1; d < r; d++)
    a.push(n.shape[d]), u *= n.shape[d];
  return { batchSize: l, sliceSize: u, outerSize: c, dimSize: i6, outputShape: a };
}
const lR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  collectGatherOpShapeInfo: ef$1,
  computeOutShape: U0,
  segOpComputeOptimalWindowSize: _0
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function No(n) {
  try {
    return n.map((t) => ps(t));
  } catch (t) {
    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`);
  }
}
function Y0(n) {
  return n.map((t) => hs(t));
}
const cR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ERF_A1: Kp,
  ERF_A2: Zp,
  ERF_A3: Bp,
  ERF_A4: Hp,
  ERF_A5: _p,
  ERF_P: Op,
  PARALLELIZE_THRESHOLD: zp,
  get RowPartitionType() {
    return Fn$1;
  },
  SELU_SCALE: Qc,
  SELU_SCALEALPHA: Yc,
  applyActivation: Sp,
  assertAndGetBroadcastShape: bt$1,
  assertAxesAreInnerMostDims: Te,
  assertParamsConsistent: Vp,
  assignToTypedArray: M0,
  axesAreInnerMostDims: Jh$1,
  calculateShapes: Ir,
  checkEinsumDimSizes: Jp,
  checkPadOnDimRoundingMode: Be$1,
  combineLocations: Mb,
  combineRaggedTensorToTensorShapes: T0,
  complexWithEvenIndex: E0,
  complexWithOddIndex: L0,
  computeConv2DInfo: ke,
  computeConv3DInfo: Bs,
  computeDefaultPad: Zh$1,
  computeDilation2DInfo: ca,
  computeOptimalWindowSize: Uc,
  computeOutAndReduceShapes: ye$1,
  computeOutShape: ts,
  computePool2DInfo: $n$1,
  computePool3DInfo: xs,
  convertConv2DDataFormat: ys,
  decodeEinsumEquation: Yp,
  eitherStridesOrDilationsAreOne: Ee$1,
  expandShapeToKeepDim: re$1,
  exponent: D0,
  exponents: W0,
  fromStringArrayToUint8: Y0,
  fromUint8ToStringArray: No,
  getAxesPermutation: qt$1,
  getBroadcastDims: vo,
  getComplexWithIndex: Up,
  getEinsumComputePath: jp,
  getEinsumPermutation: Qp,
  getFusedBiasGradient: vp,
  getFusedDyActivation: Cp,
  getImageCenter: Xp,
  getInnerMostAxes: ie,
  getPermuted: ma,
  getRaggedRank: R0,
  getReductionAxes: le,
  getReshaped: fa,
  getReshapedPermuted: ga,
  getRowPartitionTypesHelper: N0,
  getSliceBeginCoords: Pp,
  getSliceSize: Ap,
  getSparseFillEmptyRowsIndicesDenseShapeMismatch: F0,
  getSparseFillEmptyRowsNegativeIndexErrorMessage: V0,
  getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: z0,
  getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: A0,
  getSparseReshapeInputOutputMismatchErrorMessage: K0,
  getSparseReshapeInputOutputMultipleErrorMessage: O0,
  getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: X0,
  getSparseReshapeNegativeOutputDimErrorMessage: P0,
  getSparseSegmentReductionIndicesOutOfRangeErrorMessage: H0,
  getSparseSegmentReductionNegativeSegmentIdsErrorMessage: Id$1,
  getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: Z0,
  getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: B0,
  getUndoAxesPermutation: Hs,
  isIdentityPermutation: qp,
  log: _I,
  mergeRealAndImagArrays: ms,
  prepareAndValidate: Bc,
  prepareSplitSize: tf$1,
  segment_util: lR,
  shouldFuse: kp,
  slice_util: sR,
  splitRealAndImagArrays: G0,
  stridesOrDilationsArePositive: Io,
  tupleValuesAreOne: wo,
  upcastType: je$1,
  validateDefaultValueShape: $0,
  validateInput: e0,
  validateUpdateShape: wp,
  warn: rn$1
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
PN();
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Q0 = {
  kernelName: Vl,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(n, pa(et(e, "float32"), -1)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uR = {
  kernelName: di,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return {
      x: () => {
        const s = At$1(et(e, "float32")), o = De$1(lt(gt$1(1), s));
        return jt$1(ut(n, o));
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dR = {
  kernelName: hi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return {
      x: () => {
        const s = De$1(lt(At$1(et(e, "float32")), 1));
        return ut(n, s);
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hR = {
  kernelName: br,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = bt$1(e.shape, s.shape);
    return { a: () => {
      let a = n;
      const l = le(e.shape, o);
      return l.length > 0 && (a = at(a, l)), W(a, e.shape);
    }, b: () => {
      let a = n;
      const l = le(s.shape, o);
      return l.length > 0 && (a = at(a, l)), W(a, s.shape);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pR = {
  kernelName: Bd$1,
  saveAllInputs: true,
  gradFunc: (n, t) => {
    const e = {};
    return t.forEach((s, o) => {
      e[o] = () => n.clone();
    }), e;
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fR = {
  kernelName: zl,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => Tt$1(e) };
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const mR = {
  kernelName: Xl,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => Tt$1(e) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const gR = {
  kernelName: pi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => ut(n, De$1(lt(gt$1(1), At$1(et(e, "float32"))))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bR = {
  kernelName: fi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return {
      x: () => {
        const s = De$1(U(gt$1(1), At$1(et(e, "float32"))));
        return ut(n, s);
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xR = {
  kernelName: bi,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = bt$1(e.shape, s.shape);
    return { a: () => {
      const a = U(At$1(e), At$1(s));
      let l = G(n, ut(s, a));
      const c = le(e.shape, o);
      return c.length > 0 && (l = at(l, c)), W(l, e.shape);
    }, b: () => {
      const a = U(At$1(e), At$1(s));
      let l = jt$1(G(n, ut(e, a)));
      const c = le(s.shape, o);
      return c.length > 0 && (l = at(l, c)), W(l, s.shape);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yR = {
  kernelName: mi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => ut(n, U(At$1(et(e, "float32")), 1)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wR = {
  kernelName: gi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => ut(n, lt(gt$1(1), At$1(et(e, "float32")))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IR(n, t, e, s, o, r) {
  const i6 = T(n, "dy", "avgPool3dGrad"), a = T(t, "input", "avgPool3dGrad");
  let l = i6, c = a, u = false;
  a.rank === 4 && (u = true, l = W(i6, [1, i6.shape[0], i6.shape[1], i6.shape[2], i6.shape[3]]), c = W(a, [
    1,
    a.shape[0],
    a.shape[1],
    a.shape[2],
    a.shape[3]
  ])), v(l.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`), v(c.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`), Be$1("avgPool3dGrad", o, r);
  const d = { dy: l, input: c }, h6 = { filterSize: e, strides: s, pad: o, dimRoundingMode: r }, p6 = $$1.runKernel(Yd$1, d, h6);
  return u ? W(p6, [p6.shape[1], p6.shape[2], p6.shape[3], p6.shape[4]]) : p6;
}
const CR = /* @__PURE__ */ L({ avgPool3dGrad_: IR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const vR = {
  kernelName: Al,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { filterSize: o, strides: r, pad: i6, dimRoundingMode: a } = e;
    return {
      x: () => CR(n, s, o, r, i6, a)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SR(n, t, e, s, o) {
  const r = T(n, "dy", "avgPoolGrad"), i6 = T(t, "input", "avgPoolGrad");
  v(i6.rank === r.rank, () => `Rank of input (${i6.rank}) does not match rank of dy (${r.rank})`);
  let a = i6, l = r, c = false;
  i6.rank === 3 && (c = true, a = W(i6, [1, i6.shape[0], i6.shape[1], i6.shape[2]]), l = W(r, [1, r.shape[0], r.shape[1], r.shape[2]])), v(l.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`), v(a.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);
  const u = { dy: l, input: a }, d = { filterSize: e, strides: s, pad: o }, h6 = $$1.runKernel(Ud$1, u, d);
  return c ? W(h6, [h6.shape[1], h6.shape[2], h6.shape[3]]) : h6;
}
const kR = /* @__PURE__ */ L({ avgPoolGrad_: SR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TR = {
  kernelName: Pl,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { filterSize: o, strides: r, pad: i6 } = e;
    return { x: () => kR(n, s, o, r, i6) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NR = {
  kernelName: Ol,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t, e) => {
    const [s, o] = t, { transposeA: r, transposeB: i6 } = e;
    return !r && !i6 ? {
      a: () => Gt(n, o, false, true),
      b: () => Gt(s, n, true, false)
    } : !r && i6 ? {
      a: () => Gt(n, o, false, false),
      b: () => Gt(n, s, true, false)
    } : r && !i6 ? {
      a: () => Gt(o, n, false, true),
      b: () => Gt(s, n, false, false)
    } : {
      a: () => Gt(o, n, true, true),
      b: () => Gt(n, s, true, true)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const RR = {
  kernelName: Kl,
  gradFunc: (n, t, e) => {
    const { blockShape: s, crops: o } = e;
    return { x: () => ip(n, s, o) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $R = {
  kernelName: BI,
  gradFunc: (n, t, e) => {
    const s = e, o = s.inputShape, r = s.shape, i6 = Array.from(r);
    for (let l = o.length - 1; l >= 0; l--)
      if (o[l] === r[l])
        i6[l] = 1;
      else if (o[l] !== 1)
        throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${r}].`);
    const a = [];
    for (let l = 0; l < i6.length; l++)
      i6[l] > 1 && a.push(l);
    return { x: () => at(
      n,
      a,
      true
      /* keepDims */
    ) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const GR = {
  kernelName: xi,
  gradFunc: (n) => ({ x: () => n.clone() })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ER = {
  kernelName: yi,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const LR = {
  kernelName: wi,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { clipValueMin: o, clipValueMax: r } = e;
    return {
      x: () => Oe(ss(Do(s, o), yr(s, r)), n, Tt$1(n))
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const MR = {
  kernelName: Zl,
  inputsToSave: ["x"],
  gradFunc: Q0.gradFunc
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WR = {
  kernelName: Bl,
  saveAllInputs: true,
  gradFunc: (n, t, e) => {
    const s = t.map((l) => l.shape), { axis: o } = e, r = Ct(o, t[0].shape)[0], i6 = s.map((l) => l[r]);
    return un$1(n, i6, r).map((l) => () => l);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const DR = {
  kernelName: Hl,
  inputsToSave: ["x", "filter"],
  gradFunc: (n, t, e) => {
    const [s, o] = t, { dilations: r, strides: i6, pad: a, dataFormat: l } = e;
    return v(wo(r), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`), {
      x: () => Uh$1(s.shape, n, o, i6, a, l),
      filter: () => Ip(s, n, o.shape, i6, a, l)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const FR = {
  kernelName: _l,
  inputsToSave: ["dy", "filter"],
  gradFunc: (n, t, e) => {
    const [s, o] = t, { strides: r, pad: i6, dataFormat: a, dimRoundingMode: l } = e;
    return {
      dy: () => Co(n, o, r, i6, a, 1, l),
      filter: () => Ip(n, s, o.shape, r, i6, a, l)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VR(n, t, e, s, o) {
  let r = n;
  n.rank === 4 && (r = W(n, [1, n.shape[0], n.shape[1], n.shape[2], n.shape[3]]));
  let i6 = t;
  i6.rank === 4 && (i6 = W(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), v(r.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`), v(i6.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${i6.shape}.`), v(e.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`), v(r.shape[4] === e[3], () => `Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${e[3]}.`), v(i6.shape[4] === e[4], () => `Error in conv3dDerFilter: depth of dy (${i6.shape[4]}) must match output depth for filter (${e[4]}).`);
  const a = { x: r, dy: i6 }, l = { strides: s, pad: o, filterShape: e };
  return $$1.runKernel(qd$1, a, l);
}
const zR = /* @__PURE__ */ L({ conv3DBackpropFilter_: VR });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const XR = {
  kernelName: Ul,
  inputsToSave: ["x", "filter"],
  gradFunc: (n, t, e) => {
    const { dilations: s, strides: o, pad: r } = e;
    v(wo(s), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);
    const [i6, a] = t;
    return {
      x: () => Gb(i6.shape, n, a, o, r),
      filter: () => zR(i6, n, a.shape, o, r)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PR = {
  kernelName: Ii,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(jt$1(_b(et(e, "float32"))), n) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const AR = {
  kernelName: Ci,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(Ub(et(e, "float32")), n) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OR = {
  kernelName: Yl,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { axis: o, exclusive: r, reverse: i6 } = e;
    return {
      x: () => {
        const a = qt$1([o], s.rank);
        let l = Lb(n, o, r, !i6);
        return a != null && (l = kt(l, a)), l;
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KR = {
  kernelName: Ql,
  inputsToSave: ["x", "filter"],
  gradFunc: (n, t, e) => {
    const { dilations: s, strides: o, pad: r, dimRoundingMode: i6 } = e, a = s ?? [1, 1];
    v(wo(a), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);
    const [l, c] = t;
    return v(l.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`), v(c.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`), v(l.shape[3] === c.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`), v(Ee$1(o, a), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`), Be$1("depthwiseConv2d", r, i6), {
      x: () => hT(l.shape, n, c, o, r, a, i6),
      filter: () => uT(l, n, c.shape, o, r, a, i6)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ZR = {
  kernelName: Jl,
  inputsToSave: ["x", "filter"],
  gradFunc: (n, t, e) => {
    const [s, o] = t, r = { x: s, filter: o, dy: n }, i6 = { x: s, filter: o, dy: n };
    return {
      x: () => $$1.runKernel(ed, r, e),
      filter: () => $$1.runKernel(nd, i6, e)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BR = {
  kernelName: Si,
  outputsToSave: [true],
  gradFunc: (n, t) => {
    const [e] = t, s = { dy: n, y: e };
    return { x: () => $$1.runKernel(ah$1, s) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const HR = {
  kernelName: ki,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t, s = G(Tn$1(jt$1(At$1(e))), 2 / Math.sqrt(Math.PI));
    return { x: () => G(n, s) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _R = {
  kernelName: Ti,
  outputsToSave: [true],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(n, e) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UR = {
  kernelName: ql,
  inputsToSave: ["input"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { input: () => W(n, e.shape) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YR = {
  kernelName: Ni,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(n, Tn$1(e)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const QR = {
  kernelName: Ri,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const JR = {
  kernelName: $i,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = bt$1(e.shape, s.shape);
    return { a: () => {
      const a = ut(n, et(s, "float32")), l = le(e.shape, o);
      return l.length > 0 ? W(at(a, l), e.shape) : a;
    }, b: () => {
      let a = G(n, et(e, "float32"));
      const l = le(s.shape, o);
      l.length > 0 && (a = W(at(a, l), s.shape));
      const c = At$1(s);
      return jt$1(ut(a, et(c, "float32")));
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jR = {
  kernelName: tc,
  inputsToSave: ["x", "mean", "variance", "scale"],
  gradFunc: (n, t, e) => {
    const { varianceEpsilon: s } = e, [o, r, i6, a] = t, l = a ?? gt$1(1), c = le(r.shape, o.shape), u = [];
    if (r.rank === 1) {
      for (let y6 = 0; y6 < o.shape.length - 1; ++y6)
        u.push(o.shape[y6]);
      u.push(1);
    }
    const d = lt(o, r), h6 = G(n, l), p6 = Zb(U(i6, gt$1(s))), f = G(G(G(p6, p6), p6), gt$1(-0.5));
    return {
      x: () => r.rank === 1 ? W(G(G(n, Vn$1(W(p6, [1, 1, 1, r.shape[0]]), u)), l), o.shape) : W(G(G(n, p6), l), o.shape),
      mean: () => {
        let y6 = G(G(p6, gt$1(-1)), h6);
        return r.rank === 1 && (y6 = at(y6, c)), W(y6, r.shape);
      },
      variance: () => {
        let y6 = G(G(f, d), h6);
        return r.rank === 1 && (y6 = at(y6, c)), W(y6, r.shape);
      },
      scale: () => {
        const y6 = G(d, p6);
        let I = G(n, y6);
        return r.rank === 1 && (I = at(I, c)), W(I, r.shape);
      },
      offset: () => {
        let y6 = n;
        return r.rank === 1 && (y6 = at(y6, c)), W(y6, r.shape);
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qR = {
  kernelName: ec,
  inputsToSave: ["x", "indices"],
  gradFunc: (n, t, e) => {
    const [s, o] = t, { axis: r } = e, i6 = Ct(r, s.shape)[0];
    return { x: () => {
      const l = s.shape, c = o.size, u = l.slice(0, i6), d = u.length, h6 = l.slice(r, l.length).slice(1), p6 = h6.length, f = fm(0, d), m = fm(d + 1, d + 1 + p6), g6 = mm([u, [c], h6]), b6 = W(n, g6), x6 = W(o, [c]), w6 = mm([[d], f, m]), y6 = kt(b6, w6);
      let I = qb(y6, x6, s.shape[i6]);
      const C6 = Hs(w6);
      return I = kt(I, C6), I;
    }, indices: () => o };
  }
};
function fm(n, t) {
  const e = [];
  for (let s = n; s < t; ++s)
    e.push(s);
  return e;
}
function mm(n) {
  const t = [];
  for (let e = 0; e < n.length; ++e)
    for (let s = 0; s < n[e].length; ++s)
      t.push(n[e][s]);
  return t;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const t$ = {
  kernelName: Gi,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t;
    return { a: () => Tt$1(e), b: () => Tt$1(s) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const e$ = {
  kernelName: Ei,
  gradFunc: (n) => ({ x: () => et(n, "float32") })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const n$ = {
  kernelName: Li,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const s$ = {
  kernelName: Mi,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const o$ = {
  kernelName: Wi,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const r$ = {
  kernelName: sc,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { alpha: o } = e, r = sn$1(s, 0);
    return { x: () => Oe(r, n, G(n, o)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i$ = {
  kernelName: Fi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => ut(n, U(e, 1)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const a$ = {
  kernelName: Di,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => ut(n, et(e, "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const l$ = {
  kernelName: HI,
  inputsToSave: [],
  outputsToSave: [true],
  gradFunc: (n, t, e) => {
    const [s] = t, { axis: o } = e;
    return {
      logits: () => {
        const i6 = Tn$1(s);
        return lt(n, G(at(n, o, true), i6));
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function c$(n, t, e, s = 5, o = 1, r = 1, i6 = 0.5) {
  const a = { x: n, y: t, dy: e }, l = { depthRadius: s, bias: o, alpha: r, beta: i6 };
  return $$1.runKernel(ph$1, a, l);
}
const u$ = L({ localResponseNormalizationBackprop_: c$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const d$ = {
  kernelName: cc,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (n, t, e) => {
    const [s, o] = t, { depthRadius: r, bias: i6, alpha: a, beta: l } = e;
    return {
      x: () => u$(s, o, n, r, i6, a, l)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J0(n, t, e, s) {
  return t.rank < e.rank && (t = W(t, re$1(t.shape, s))), n.rank < e.rank && (n = W(n, re$1(n.shape, s))), {
    x: () => G(n, et(kn$1(e, t), n.dtype))
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const gm = {
  kernelName: uc,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (n, t, e) => {
    const s = e, { reductionIndices: o } = s, r = t[0], i6 = t[1], a = Ct(o, r.shape), l = J0(n, i6, r, a);
    return {
      x: () => l.x()
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const h$ = {
  kernelName: Vi,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t;
    return { a: () => G(n, et(Do(e, s), "float32")), b: () => G(n, et(Fb(e, s), "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function p$(n, t, e, s, o, r, i6) {
  const a = T(n, "dy", "maxPool3dGrad"), l = T(t, "input", "maxPool3dGrad"), c = T(e, "output", "maxPool3dGrad");
  let u = a, d = l, h6 = c, p6 = false;
  l.rank === 4 && (p6 = true, u = W(a, [1, a.shape[0], a.shape[1], a.shape[2], a.shape[3]]), d = W(l, [
    1,
    l.shape[0],
    l.shape[1],
    l.shape[2],
    l.shape[3]
  ]), h6 = W(c, [
    1,
    c.shape[0],
    c.shape[1],
    c.shape[2],
    c.shape[3]
  ])), v(u.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`), v(d.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`), v(h6.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ${h6.rank}.`), Be$1("maxPool3dGrad", r, i6);
  const f = { dy: u, input: d, output: h6 }, m = { filterSize: s, strides: o, pad: r, dimRoundingMode: i6 }, g6 = $$1.runKernel(mh$1, f, m);
  return p6 ? W(g6, [g6.shape[1], g6.shape[2], g6.shape[3], g6.shape[4]]) : g6;
}
const f$ = /* @__PURE__ */ L({ maxPool3dGrad_: p$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const m$ = {
  kernelName: hc,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (n, t, e) => {
    const [s, o] = t, { filterSize: r, strides: i6, pad: a, dimRoundingMode: l } = e;
    return {
      x: () => f$(n, s, o, r, i6, a, l)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g$(n, t, e, s, o, r, i6) {
  const a = T(n, "dy", "maxPoolGrad"), l = T(t, "input", "maxPoolGrad"), c = T(e, "output", "maxPoolGrad");
  v(l.rank === a.rank, () => `Rank of input (${l.rank}) does not match rank of dy (${a.rank})`), v(a.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`), v(l.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`), Be$1("maxPoolGrad", r, i6);
  const u = { dy: a, input: l, output: c }, d = { filterSize: s, strides: o, pad: r, dimRoundingMode: i6 };
  return $$1.runKernel(fh$1, u, d);
}
const b$ = /* @__PURE__ */ L({ maxPoolGrad_: g$ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const x$ = {
  kernelName: dc,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (n, t, e) => {
    const [s, o] = t, { filterSize: r, strides: i6, pad: a } = e;
    return {
      x: () => b$(n, s, o, r, i6, a)
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const y$ = {
  kernelName: pc,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { axis: o } = e, r = Ct(o, s.shape), a = ye$1(s.shape, r)[1], l = O(a);
    return { x: () => {
      const u = s.shape.slice();
      r.forEach((p6) => {
        u[p6] = 1;
      });
      const d = W(n, u);
      return ut(G(d, Us(s.shape, "float32")), l);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const w$ = {
  kernelName: fc,
  inputsToSave: ["x"],
  outputsToSave: [true],
  gradFunc: (n, t, e) => {
    const s = e, { axis: o } = s, [r, i6] = t, a = Ct(o, r.shape), l = J0(n, i6, r, a);
    return {
      x: () => l.x()
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const I$ = {
  kernelName: zi,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t;
    return { a: () => G(n, et(yr(e, s), "float32")), b: () => G(n, et(sn$1(e, s), "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const C$ = {
  kernelName: mc,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const s = t[0], { paddings: o } = e, r = o.map((i6) => i6[0]);
    return { x: () => Dt(n, r, s.shape) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const v$ = {
  kernelName: Xi,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = bt$1(e.shape, s.shape);
    return { a: () => {
      const a = le(e.shape, o);
      return a.length > 0 ? W(at(n, a), e.shape) : n;
    }, b: () => {
      const a = G(n, jt$1(Ac(ut(e, s)))), l = le(s.shape, o);
      return l.length > 0 ? W(at(a, l), s.shape) : a;
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const S$ = {
  kernelName: Pi,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = bt$1(e.shape, s.shape);
    return { a: () => {
      const a = G(n, et(s, "float32")), l = le(e.shape, o);
      return l.length > 0 ? W(at(a, l), e.shape) : a;
    }, b: () => {
      const a = G(n, et(e, "float32")), l = le(s.shape, o);
      return l.length > 0 ? W(at(a, l), s.shape) : a;
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const k$ = {
  kernelName: gc,
  gradFunc: (n) => ({ x: () => jt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const T$ = {
  kernelName: yc,
  inputsToSave: ["indices"],
  gradFunc: (n, t) => {
    const e = t[0];
    return { indices: () => ge$1(e.shape, "float32") };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const N$ = {
  kernelName: xc,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const R$ = {
  kernelName: wc,
  saveAllInputs: true,
  gradFunc: (n, t, e) => {
    const { axis: s } = e;
    return To(n, s).map((r) => () => r);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bm = {
  kernelName: Ic,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const s = t[0], { paddings: o } = e, r = o.map((i6) => i6[0]);
    return { x: () => Dt(n, r, s.shape) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $$ = {
  kernelName: Ai,
  inputsToSave: ["a", "b"],
  outputsToSave: [true],
  gradFunc: (n, t) => {
    const [e, s, o] = t, r = e, i6 = s, a = bt$1(r.shape, i6.shape);
    return { a: () => {
      const u = et(i6, "float32");
      let d = G(n, G(u, ir(r, lt(u, gt$1(1)))));
      const h6 = le(r.shape, a);
      return h6.length > 0 && (d = at(d, h6)), W(d, r.shape);
    }, b: () => {
      const u = sn$1(r, 0), d = Oe(u, Nn$1(r), Tt$1(r));
      let h6 = G(n, G(o, d));
      const p6 = le(i6.shape, a);
      return p6.length > 0 && (h6 = at(h6, p6)), W(h6, i6.shape);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const G$ = {
  kernelName: Cc,
  inputsToSave: ["x", "alpha"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = sn$1(e, 0);
    return {
      x: () => Oe(o, n, G(n, s)),
      alpha: () => {
        let r = Oe(o, Tt$1(n), G(n, e));
        const i6 = le(s.shape, n.shape);
        return i6.length > 0 && (r = at(r, i6)), W(r, s.shape);
      }
    };
  }
};
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E$(n, t, e) {
  const s = n.shape.slice();
  s[e] = 1;
  const o = W(t, s), r = yd$1(n, e, true, false), i6 = yd$1(n, e, true, true), a = G(r, i6);
  return G(o, a);
}
function L$(n, t, e) {
  const s = n.shape.length, o = s - e.length, r = qt$1(e, s);
  let i6 = n;
  r != null && (i6 = kt(n, r));
  const a = i6.shape.slice(), c = a.splice(s - e.length, e.length).reduce((h6, p6) => h6 * p6, 1);
  a.push(c);
  const u = i6.reshape(a);
  let d = E$(u, t, o);
  if (d = d.reshape(i6.shape), r != null) {
    const h6 = Hs(r);
    d = kt(d, h6);
  }
  return d;
}
const M$ = {
  kernelName: vc,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { axis: o } = e;
    let r = [];
    return o == null ? r = s.shape.map((i6, a) => a) : typeof o == "number" ? r = [o] : r = o, { x: () => L$(s, n, r) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const W$ = {
  kernelName: vi,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = bt$1(e.shape, s.shape);
    return { a: () => {
      const a = ut(n, et(s, "float32")), l = le(e.shape, o);
      return l.length > 0 ? W(at(a, l), e.shape) : a;
    }, b: () => {
      let a = G(n, et(e, "float32"));
      const l = le(s.shape, o);
      l.length > 0 && (a = W(at(a, l), s.shape));
      const c = At$1(s);
      return jt$1(ut(a, et(c, "float32")));
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const D$ = {
  kernelName: Oi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => ut(n, jt$1(At$1(e))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F$ = {
  kernelName: Zi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t, s = G(yr(e, 6), pa(e));
    return { x: () => G(n, et(s, "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const V$ = {
  kernelName: Ki,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(n, et(pa(e), "float32")) };
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const z$ = {
  kernelName: Sc,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => W(n, e.shape) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const X$ = {
  kernelName: Tc,
  inputsToSave: ["images"],
  gradFunc: (n, t, e) => {
    const [s] = t, o = { dy: n, images: s };
    return { images: () => (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      $$1.runKernel(Ch$1, o, e)
    ) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const P$ = {
  kernelName: kc,
  inputsToSave: ["images"],
  gradFunc: (n, t, e) => {
    const [s] = t, o = { dy: n, images: s };
    return { images: () => (
      // tslint:disable-next-line: no-unnecessary-type-assertion
      $$1.runKernel(Ih$1, o, e)
    ) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const A$ = {
  kernelName: Nc,
  gradFunc: (n, t, e) => {
    const { dims: s } = e, o = Ct(s, n.shape);
    return { x: () => ko(n, o) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const O$ = {
  kernelName: Bi,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const K$ = {
  kernelName: Hi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => jt$1(ut(n, G(ir(e, 1.5), 2))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Z$ = {
  kernelName: Rc,
  inputsToSave: ["condition"],
  gradFunc: (n, t) => {
    const [e] = t;
    return {
      // TODO(julianoks): Return null for condition gradient
      // when backprop supports it.
      condition: () => et(Tt$1(e), "float32"),
      t: () => G(n, et(e, n.dtype)),
      e: () => G(n, et(np(e), n.dtype))
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const B$ = {
  kernelName: _i,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return {
      x: () => {
        const s = sn$1(e, gt$1(0)), o = gt$1(Yc), r = gt$1(Qc), i6 = G(n, r), a = G(G(n, o), Tn$1(et(e, "float32")));
        return Oe(s, i6, a);
      }
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const H$ = {
  kernelName: Ji,
  outputsToSave: [true],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(n, G(e, lt(gt$1(1), e))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _$ = {
  kernelName: Qi,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const U$ = {
  kernelName: Ui,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(Yh$1(et(e, "float32")), n) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Y$ = {
  kernelName: Yi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(Eb(et(e, "float32")), n) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Q$ = {
  kernelName: $c,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { begin: o, size: r } = e, i6 = s.shape, [a, l] = Hc(s, o, r), c = [];
    for (let u = 0; u < n.rank; u++)
      c.push([a[u], i6[u] - a[u] - l[u]]);
    return { x: () => rp(n, c) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const J$ = {
  kernelName: Mc,
  outputsToSave: [true],
  gradFunc: (n, t, e) => {
    const [s] = t, { dim: o } = e, r = true, i6 = G(n, s);
    return {
      logits: () => lt(i6, G(at(i6, [o], r), s))
    };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const j$ = {
  kernelName: ji,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(n, xr(e)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xm = {
  kernelName: Ec,
  gradFunc: (n, t, e) => {
    const { blockShape: s, paddings: o } = e;
    return { x: () => _h$1(n, s, o) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ym = {
  kernelName: Lc,
  gradFunc: (n, t, e) => {
    const { axis: s } = e;
    return { x: () => Ge$1(n, s) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const q$ = {
  kernelName: qi,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => ut(n, G(De$1(et(e, "float32")), 2)) };
  }
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tG = {
  kernelName: Nh$1,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(n, G(et(e, "float32"), 2)) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eG = {
  kernelName: ta,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = gt$1(2);
    return { a: () => G(n, G(o, lt(e, s))), b: () => G(n, G(o, lt(s, e))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nG = {
  kernelName: ra,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sG = {
  kernelName: ea,
  inputsToSave: ["a", "b"],
  gradFunc: (n, t) => {
    const [e, s] = t, o = bt$1(e.shape, s.shape);
    return { a: () => {
      let a = n;
      const l = le(e.shape, o);
      return l.length > 0 && (a = at(a, l)), W(a, e.shape);
    }, b: () => {
      let a = n;
      const l = le(s.shape, o);
      return l.length > 0 && (a = at(a, l)), W(jt$1(a), s.shape);
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oG = {
  kernelName: Gc,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, o = s.shape.slice(), { axis: r } = e;
    Ct(r, s.shape).forEach((c) => {
      o[c] = 1;
    });
    const a = W(n, o), l = G(a, Us(s.shape, "float32"));
    return { x: () => l };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rG = {
  kernelName: na,
  inputsToSave: ["x"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => ut(n, At$1(Yh$1(e))) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iG = {
  kernelName: sa,
  outputsToSave: [true],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => G(lt(gt$1(1), At$1(e)), n) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aG = {
  kernelName: oa,
  inputsToSave: ["x"],
  gradFunc: (n, t, e) => {
    const [s] = t, { reps: o } = e;
    return { x: () => {
      let i6 = Tt$1(s);
      if (s.rank === 1)
        for (let a = 0; a < o[0]; ++a)
          i6 = U(i6, Dt(n, [a * s.shape[0]], [s.shape[0]]));
      else if (s.rank === 2)
        for (let a = 0; a < o[0]; ++a)
          for (let l = 0; l < o[1]; ++l)
            i6 = U(i6, Dt(n, [a * s.shape[0], l * s.shape[1]], [
              s.shape[0],
              s.shape[1]
            ]));
      else if (s.rank === 3)
        for (let a = 0; a < o[0]; ++a)
          for (let l = 0; l < o[1]; ++l)
            for (let c = 0; c < o[2]; ++c)
              i6 = U(i6, Dt(n, [a * s.shape[0], l * s.shape[1], c * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]]));
      else if (s.rank === 4)
        for (let a = 0; a < o[0]; ++a)
          for (let l = 0; l < o[1]; ++l)
            for (let c = 0; c < o[2]; ++c)
              for (let u = 0; u < o[3]; ++u)
                i6 = U(i6, Dt(n, [
                  a * s.shape[0],
                  l * s.shape[1],
                  c * s.shape[2],
                  u * s.shape[3]
                ], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]]));
      else
        throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);
      return i6;
    } };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lG = {
  kernelName: Jo,
  gradFunc: (n, t, e) => {
    const s = e, { perm: o } = s, r = Hs(o);
    return { x: () => kt(n, r) };
  }
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cG = {
  kernelName: Wc,
  gradFunc: (n, t, e) => {
    const s = e, { axis: o } = s;
    return { value: () => os(n, o) };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uG = {
  kernelName: Dc,
  inputsToSave: ["segmentIds"],
  gradFunc: (n, t) => {
    const [e] = t;
    return { x: () => dG(n, e) };
  }
};
function dG(n, t) {
  const e = _s(t, Tt$1(t)), s = jh$1(n, e);
  let o = Do(t, gt$1(0, "int32"));
  const r = s.rank - o.rank;
  for (let a = 0; a < r; ++a)
    o = Ue$1(o, a + 1);
  o = ss(o, Us(s.shape, "bool"));
  const i6 = Tt$1(s);
  return Oe(o, s, i6);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hG = {
  kernelName: Fc,
  gradFunc: (n) => ({ x: () => Tt$1(n) })
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pG = [
  Q0,
  uR,
  dR,
  hR,
  pR,
  fR,
  mR,
  gR,
  bR,
  xR,
  yR,
  wR,
  vR,
  TR,
  NR,
  RR,
  $R,
  GR,
  ER,
  LR,
  MR,
  WR,
  FR,
  DR,
  XR,
  PR,
  AR,
  OR,
  KR,
  ZR,
  W$,
  BR,
  HR,
  _R,
  UR,
  YR,
  JR,
  QR,
  jR,
  qR,
  t$,
  e$,
  n$,
  s$,
  o$,
  r$,
  i$,
  a$,
  l$,
  d$,
  gm,
  gm,
  h$,
  m$,
  x$,
  y$,
  w$,
  I$,
  C$,
  v$,
  S$,
  k$,
  T$,
  N$,
  R$,
  bm,
  bm,
  $$,
  G$,
  M$,
  D$,
  F$,
  V$,
  z$,
  X$,
  P$,
  A$,
  O$,
  K$,
  Z$,
  B$,
  H$,
  _$,
  U$,
  Y$,
  Q$,
  J$,
  j$,
  xm,
  xm,
  ym,
  ym,
  q$,
  eG,
  tG,
  nG,
  sG,
  oG,
  rG,
  iG,
  aG,
  lG,
  cG,
  uG,
  hG
];
for (const n of pG)
  UI(n);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.abs = function() {
  return this.throwIfDisposed(), fe$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.acos = function() {
  return this.throwIfDisposed(), o2(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.acosh = function() {
  return this.throwIfDisposed(), i2(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.add = function(n) {
  return this.throwIfDisposed(), U(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.all = function(n, t) {
  return this.throwIfDisposed(), Nb$1(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.any = function(n, t) {
  return this.throwIfDisposed(), bd$1(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.argMax = function(n) {
  return this.throwIfDisposed(), Qr(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.argMin = function(n) {
  return this.throwIfDisposed(), d2(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.asScalar = function() {
  return this.throwIfDisposed(), v(this.size === 1, () => "The array must have only 1 element."), W(this, []);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.asType = function(n) {
  return this.throwIfDisposed(), et(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.as1D = function() {
  return this.throwIfDisposed(), W(this, [this.size]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.as2D = function(n, t) {
  return this.throwIfDisposed(), W(this, [n, t]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.as3D = function(n, t, e) {
  return this.throwIfDisposed(), W(this, [n, t, e]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.as4D = function(n, t, e, s) {
  return this.throwIfDisposed(), W(this, [n, t, e, s]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.as5D = function(n, t, e, s, o) {
  return this.throwIfDisposed(), W(this, [n, t, e, s, o]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.asin = function() {
  return this.throwIfDisposed(), p2(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.asinh = function() {
  return this.throwIfDisposed(), m2(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.atan = function() {
  return this.throwIfDisposed(), b2(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.atan2 = function(n) {
  return this.throwIfDisposed(), y2(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.atanh = function() {
  return this.throwIfDisposed(), I2(this);
};
K$1().prototype.avgPool = function(n, t, e, s) {
  return this.throwIfDisposed(), Bh$1(this, n, t, e, s);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.batchToSpaceND = function(n, t) {
  return this.throwIfDisposed(), _h$1(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.batchNorm = function(n, t, e, s, o) {
  return this.throwIfDisposed(), zc(this, n, t, e, s, o);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.broadcastTo = function(n) {
  return this.throwIfDisposed(), Br(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.cast = function(n) {
  return this.throwIfDisposed(), et(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.ceil = function() {
  return this.throwIfDisposed(), U2(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.clipByValue = function(n, t) {
  return this.throwIfDisposed(), pn$1(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.concat = function(n, t) {
  return this.throwIfDisposed(), n instanceof Lt$1 && (n = [n]), Ge$1([this, ...n], t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.conv1d = function(n, t, e, s, o, r) {
  return this.throwIfDisposed(), Rb(this, n, t, e, s, o, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.conv2dTranspose = function(n, t, e, s, o) {
  return this.throwIfDisposed(), $b(this, n, t, e, s, o);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.conv2d = function(n, t, e, s, o, r) {
  return this.throwIfDisposed(), Co(this, n, t, e, s, o, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.cos = function() {
  return this.throwIfDisposed(), Yh$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.cosh = function() {
  return this.throwIfDisposed(), Eb(this);
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.cumprod = function(n, t, e) {
  return this.throwIfDisposed(), yd$1(this, n, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.cumsum = function(n, t, e) {
  return this.throwIfDisposed(), Lb(this, n, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.depthToSpace = function(n, t) {
  return this.throwIfDisposed(), yv(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.depthwiseConv2d = function(n, t, e, s, o, r) {
  return this.throwIfDisposed(), Qh$1(this, n, t, e, s, o, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.dilation2d = function(n, t, e, s, o) {
  return this.throwIfDisposed(), Cv(this, n, t, e, s, o);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.divNoNan = function(n) {
  return this.throwIfDisposed(), Nv(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.div = function(n) {
  return this.throwIfDisposed(), ut(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.dot = function(n) {
  return this.throwIfDisposed(), $v(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.elu = function() {
  return this.throwIfDisposed(), Xc(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.equal = function(n) {
  return this.throwIfDisposed(), kn$1(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.erf = function() {
  return this.throwIfDisposed(), Lv(this);
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.euclideanNorm = function(n, t) {
  return this.throwIfDisposed(), Av(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.exp = function() {
  return this.throwIfDisposed(), Tn$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.expandDims = function(n) {
  return this.throwIfDisposed(), Ue$1(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.expm1 = function() {
  return this.throwIfDisposed(), Bv(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.fft = function() {
  return this.throwIfDisposed(), xp(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.flatten = function() {
  return this.throwIfDisposed(), W(this, [this.size]);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.floor = function() {
  return this.throwIfDisposed(), Ac(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.floorDiv = function(n) {
  return this.throwIfDisposed(), Tb$1(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.gather = function(n, t) {
  return this.throwIfDisposed(), jh$1(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.greaterEqual = function(n) {
  return this.throwIfDisposed(), Do(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.greater = function(n) {
  return this.throwIfDisposed(), sn$1(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.ifft = function() {
  return this.throwIfDisposed(), pl(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.irfft = function() {
  return this.throwIfDisposed(), Qb(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.isFinite = function() {
  return this.throwIfDisposed(), tS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.isInf = function() {
  return this.throwIfDisposed(), nS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.isNaN = function() {
  return this.throwIfDisposed(), oS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.leakyRelu = function(n) {
  return this.throwIfDisposed(), tp(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.lessEqual = function(n) {
  return this.throwIfDisposed(), yr(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.less = function(n) {
  return this.throwIfDisposed(), Fb(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.localResponseNormalization = function(n, t, e, s) {
  return this.throwIfDisposed(), cS(this, n, t, e, s);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.logSigmoid = function() {
  return this.throwIfDisposed(), gS(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.logSoftmax = function(n) {
  return this.throwIfDisposed(), Vb(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.logSumExp = function(n, t) {
  return this.throwIfDisposed(), zb(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.log = function() {
  return this.throwIfDisposed(), Nn$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.log1p = function() {
  return this.throwIfDisposed(), ep(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.logicalAnd = function(n) {
  return this.throwIfDisposed(), ss(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.logicalNot = function() {
  return this.throwIfDisposed(), np(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.logicalOr = function(n) {
  return this.throwIfDisposed(), Xb(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.logicalXor = function(n) {
  return this.throwIfDisposed(), SS(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.matMul = function(n, t, e) {
  return this.throwIfDisposed(), Gt(this, n, t, e);
};
K$1().prototype.maxPool = function(n, t, e, s) {
  return this.throwIfDisposed(), sp(this, n, t, e, s);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.max = function(n, t) {
  return this.throwIfDisposed(), Xn$1(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.maximum = function(n) {
  return this.throwIfDisposed(), _s(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.mean = function(n, t) {
  return this.throwIfDisposed(), se(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.min = function(n, t) {
  return this.throwIfDisposed(), ul(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.minimum = function(n) {
  return this.throwIfDisposed(), Kc(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.mirrorPad = function(n, t) {
  return this.throwIfDisposed(), LS(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.mod = function(n) {
  return this.throwIfDisposed(), WS(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.mul = function(n) {
  return this.throwIfDisposed(), G(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.neg = function() {
  return this.throwIfDisposed(), jt$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.norm = function(n, t, e) {
  return this.throwIfDisposed(), Pc(this, n, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.notEqual = function(n) {
  return this.throwIfDisposed(), qr(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.oneHot = function(n, t = 1, e = 0) {
  return this.throwIfDisposed(), Pb(this, n, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.onesLike = function() {
  return this.throwIfDisposed(), Rn$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.pad = function(n, t) {
  return this.throwIfDisposed(), rp(this, n, t);
};
K$1().prototype.pool = function(n, t, e, s, o, r) {
  return this.throwIfDisposed(), ZS(this, n, t, e, s, o, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.pow = function(n) {
  return this.throwIfDisposed(), ir(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.prelu = function(n) {
  return this.throwIfDisposed(), ap(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.prod = function(n, t) {
  return this.throwIfDisposed(), _S(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.reciprocal = function() {
  return this.throwIfDisposed(), gk(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.relu = function() {
  return this.throwIfDisposed(), ws(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.relu6 = function() {
  return this.throwIfDisposed(), Ob(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.reshapeAs = function(n) {
  return this.throwIfDisposed(), W(this, n.shape);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.reshape = function(n) {
  return this.throwIfDisposed(), W(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.resizeBilinear = function(n, t, e) {
  return this.throwIfDisposed(), r0(this, n, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.resizeNearestNeighbor = function(n, t, e) {
  return this.throwIfDisposed(), i0(this, n, t, e);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.reverse = function(n) {
  return this.throwIfDisposed(), ko(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.rfft = function() {
  return this.throwIfDisposed(), yp(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.round = function() {
  return this.throwIfDisposed(), Kb(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.rsqrt = function() {
  return this.throwIfDisposed(), Zb(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.selu = function() {
  return this.throwIfDisposed(), Bb(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.separableConv2d = function(n, t, e, s, o, r) {
  return this.throwIfDisposed(), Hb(this, n, t, e, s, o, r);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.sigmoid = function() {
  return this.throwIfDisposed(), xr(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.sign = function() {
  return this.throwIfDisposed(), kk(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.sin = function() {
  return this.throwIfDisposed(), _b(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.sinh = function() {
  return this.throwIfDisposed(), Ub(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.slice = function(n, t) {
  return this.throwIfDisposed(), Dt(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.softmax = function(n) {
  return this.throwIfDisposed(), bp(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.softplus = function() {
  return this.throwIfDisposed(), da(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.spaceToBatchND = function(n, t) {
  return this.throwIfDisposed(), ip(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.split = function(n, t) {
  return this.throwIfDisposed(), un$1(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.sqrt = function() {
  return this.throwIfDisposed(), De$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.square = function() {
  return this.throwIfDisposed(), At$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.squaredDifference = function(n) {
  return this.throwIfDisposed(), Jb(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.squeeze = function(n) {
  return this.throwIfDisposed(), ha(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.stack = function(n, t) {
  this.throwIfDisposed();
  const e = n instanceof Lt$1 ? [this, n] : [this, ...n];
  return os(e, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.step = function(n) {
  return this.throwIfDisposed(), pa(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.stridedSlice = function(n, t, e, s, o, r, i6, a) {
  return this.throwIfDisposed(), Kk(this, n, t, e, s, o, r, i6, a);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.sub = function(n) {
  return this.throwIfDisposed(), lt(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.sum = function(n, t) {
  return this.throwIfDisposed(), at(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.tan = function() {
  return this.throwIfDisposed(), Bk(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.tanh = function() {
  return this.throwIfDisposed(), Hh$1(this);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.tile = function(n) {
  return this.throwIfDisposed(), Vn$1(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.toBool = function() {
  return this.throwIfDisposed(), et(this, "bool");
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.toFloat = function() {
  return this.throwIfDisposed(), et(this, "float32");
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.toInt = function() {
  return this.throwIfDisposed(), et(this, "int32");
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.topk = function(n, t) {
  return this.throwIfDisposed(), Uk(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.transpose = function(n) {
  return this.throwIfDisposed(), kt(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.unique = function(n) {
  return this.throwIfDisposed(), Jk(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.unsortedSegmentSum = function(n, t) {
  return this.throwIfDisposed(), qb(this, n, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.unstack = function(n) {
  return this.throwIfDisposed(), To(this, n);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.where = function(n, t) {
  return this.throwIfDisposed(), Oe(n, this, t);
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
K$1().prototype.zerosLike = function() {
  return this.throwIfDisposed(), Tt$1(this);
};
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let Yn$1 = class Yn extends Error {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Yn.prototype);
  }
};
let Cn$1 = class Cn extends Error {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Cn.prototype);
  }
};
class E extends Error {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, E.prototype);
  }
}
let xt$1 = class xt extends Error {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, xt.prototype);
  }
};
let nf$1 = class nf extends Error {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, nf.prototype);
  }
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class j0 {
  constructor(t) {
    this.maxEntries = t || 100, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Get the entry for the key and mark it as used recently.
   */
  get(t) {
    let e;
    return this.cache.has(t) && (e = this.cache.get(t), this.cache.delete(t), this.cache.set(t, e)), e;
  }
  /**
   * Put the entry into the cache. If the key already existed, mark the key as
   * used recently.
   */
  put(t, e) {
    if (this.cache.has(t))
      this.cache.delete(t);
    else if (this.cache.size >= this.maxEntries) {
      const s = this.cache.keys().next().value;
      this.cache.delete(s);
    }
    this.cache.set(t, e);
  }
  /**
   * Get the MaxEntries of the cache.
   */
  getMaxEntries() {
    return this.maxEntries;
  }
  /**
   * Set the MaxEntries of the cache. If the maxEntries is decreased, reduce
   * entries in the cache.
   */
  setMaxEntries(t) {
    if (t < 0)
      throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);
    if (this.maxEntries > t)
      for (let e = 0; e < this.maxEntries - t; e++) {
        const s = this.cache.keys().next().value;
        this.cache.delete(s);
      }
    this.maxEntries = t;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Ro(n, t) {
  if (Array.isArray(n)) {
    let e = [];
    for (let s = 0; s < t; s++)
      e = e.concat(n);
    return e;
  } else {
    const e = new Array(t);
    return e.fill(n), e;
  }
}
function Qn$1(n, t) {
  if (!n)
    throw new nf$1(t);
}
function wm(n, t) {
  let e = 0;
  for (const s of n)
    s === t && e++;
  return e;
}
function Pe$1(n) {
  return n.length === 1 ? n[0] : n;
}
function Zt(n) {
  return Array.isArray(n) ? n : [n];
}
function cs(n) {
  const e = n.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  return e[0] !== "_" ? e : "private" + e;
}
function ro(n) {
  return n.length <= 1 || n.indexOf("_") === -1 ? n : n.replace(/[_]+(\w|$)/g, (t, e) => e.toUpperCase());
}
let mn$1 = {};
function sf$1(n) {
  if (n == null)
    return null;
  const t = {};
  return t.className = n.getClassName(), t.config = n.getConfig(), t;
}
function Cd$1(n) {
  if (!(n == null || typeof n != "object"))
    if (Array.isArray(n))
      n.forEach((t) => Cd$1(t));
    else {
      const t = Object.keys(n);
      for (const e of t) {
        const s = n[e];
        s != null && typeof s == "object" && (!Array.isArray(s) && s.type === "ndarray" && typeof s.value == "number" ? n[e] = s.value : Cd$1(s));
      }
    }
}
function ba(n, t = {}, e = {}, s = "object", o = false) {
  if (typeof n == "string") {
    const r = n;
    let i6;
    if (r in e)
      i6 = e[r];
    else if (r in mn$1)
      i6 = mn$1[r];
    else if (i6 = t[r], i6 == null)
      throw new E(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
    return i6;
  } else {
    const r = n;
    if (r.className == null || r.config == null)
      throw new E(`${s}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);
    const i6 = r.className;
    let a, l;
    if (i6 in e ? [a, l] = e[i6] : i6 in mn$1 ? [a, l] = mn$1.className : i6 in t && ([a, l] = t[i6]), a == null)
      throw new E(`Unknown ${s}: ${i6}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
    if (l != null) {
      const c = {};
      for (const p6 of Object.keys(mn$1))
        c[p6] = mn$1[p6];
      for (const p6 of Object.keys(e))
        c[p6] = e[p6];
      const u = r.config;
      u.customObjects = c;
      const d = Object.assign({}, mn$1);
      for (const p6 of Object.keys(e))
        mn$1[p6] = e[p6];
      Cd$1(r.config);
      const h6 = l(a, r.config, e, o);
      return mn$1 = Object.assign({}, d), h6;
    } else {
      const c = Object.assign({}, mn$1);
      for (const d of Object.keys(e))
        mn$1[d] = e[d];
      const u = new a(r.config);
      return mn$1 = Object.assign({}, c), u;
    }
  }
}
function fG(n, t) {
  return n < t ? -1 : n > t ? 1 : 0;
}
function Da(n, t) {
  return -1 * fG(n, t);
}
function Ws(n) {
  if (n == null)
    return n;
  const t = [];
  for (const e of n)
    t.indexOf(e) === -1 && t.push(e);
  return t;
}
function mG(n) {
  if (n == null)
    throw new E(`Invalid value in obj: ${JSON.stringify(n)}`);
  for (const t in n)
    if (n.hasOwnProperty(t))
      return false;
  return true;
}
function zo(n, t, e) {
  if (e != null && n.indexOf(e) < 0)
    throw new E(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`);
}
function of$1(n, t, e = 0, s = 1 / 0) {
  return Qn$1(e >= 0), Qn$1(s >= e), Array.isArray(n) && n.length >= e && n.length <= s && n.every((o) => typeof o === t);
}
function be$1(n, t) {
  Array.isArray(n) ? (v(n.length > 0, () => `${t} is unexpectedly an empty array.`), n.forEach((e, s) => be$1(e, `element ${s + 1} of ${t}`))) : v(Number.isInteger(n) && n > 0, () => `Expected ${t} to be a positive integer, but got ${q0(n)}.`);
}
function q0(n) {
  return n === null ? "null" : Array.isArray(n) ? "[" + n.map((t) => q0(t)).join(",") + "]" : typeof n == "string" ? `"${n}"` : `${n}`;
}
function gG(n, t, e) {
  let s = e != null ? e() : Ce$1(), o;
  return (...i6) => {
    const a = e != null ? e() : Ce$1();
    return a - s < t || (s = a, o = n(...i6)), o;
  };
}
function tx(n) {
  return n === "relu" ? "relu" : n === "linear" ? "linear" : n === "elu" ? "elu" : null;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let bG = 0;
function ex() {
  return bG++;
}
const Fa = {};
function Jc(n = "") {
  return n in Fa || (Fa[n] = 0), Fa[n] += 1, n + Fa[n].toString();
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const xG = ["channelsFirst", "channelsLast"], yG = ["nearest", "bilinear"], wG = ["valid", "same", "causal"], IG = ["max", "avg"], CG = ["sum", "mul", "concat", "ave"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const Zo = /* @__PURE__ */ new Map();
function ae(n) {
  zo(xG, "DataFormat", n);
}
function vG(n) {
  zo(yG, "InterpolationFormat", n);
}
function fn$1(n) {
  zo(wG, "PaddingMode", n);
}
function nx(n) {
  zo(IG, "PoolMode", n);
}
const Hr = [], Im = "/";
function fo(n, t) {
  Hr.push(n);
  try {
    const e = t();
    return Hr.pop(), e;
  } catch (e) {
    throw Hr.pop(), e;
  }
}
function SG() {
  return Hr.length === 0 ? "" : Hr.join(Im) + Im;
}
function sx(n) {
  if (!rx(n))
    throw new Error("Not a valid tensor name: '" + n + "'");
  return SG() + n;
}
function ox(n) {
  if (!rx(n))
    throw new Error("Not a valid tensor name: '" + n + "'");
  Zo.has(n) || Zo.set(n, 0);
  const t = Zo.get(n);
  if (Zo.set(n, Zo.get(n) + 1), t > 0) {
    const e = `${n}_${t}`;
    return Zo.set(e, 1), e;
  } else
    return n;
}
const kG = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
function rx(n) {
  return !!n.match(kG);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function TG(n) {
  return n === parseInt(n.toString(), 10);
}
function Ds(n, t, e) {
  t == null && (t = 0), e == null && (e = n.length);
  let s = 1;
  for (let o = t; o < e; ++o)
    s *= n[o];
  return s;
}
function ar(n) {
  if (n.length === 0)
    return Number.NaN;
  let t = Number.POSITIVE_INFINITY;
  for (let e = 0; e < n.length; e++) {
    const s = n[e];
    s < t && (t = s);
  }
  return t;
}
function Xs(n) {
  if (n.length === 0)
    return Number.NaN;
  let t = Number.NEGATIVE_INFINITY;
  for (let e = 0; e < n.length; e++) {
    const s = n[e];
    s > t && (t = s);
  }
  return t;
}
function On$1(n, t) {
  if (t < n)
    throw new E(`end (${t}) < begin (${n}) is forbidden.`);
  const e = [];
  for (let s = n; s < t; ++s)
    e.push(s);
  return e;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let Su;
function ue() {
  return Su == null && (Su = $s().epsilon()), Su;
}
function Kn$1() {
  return "channelsLast";
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function es(n, t) {
  return et(n, t);
}
function xa(n, t = -1) {
  const e = n.shape.slice();
  return t < 0 && (t = e.length + t + 1), e.splice(t, 0, 1), W(n, e);
}
function NG(n, t) {
  return D(() => {
    if (n.shape.length !== 2)
      throw new E(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);
    const e = xa(n, 1);
    return vd$1(e, [1, t, 1]);
  });
}
function RG(n) {
  const t = [Ds(n.shape)];
  return W(n, t);
}
function $G(n) {
  if (n.rank <= 1)
    throw new E(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);
  const t = [n.shape[0], Ds(n.shape, 1)];
  return W(n, t);
}
function mo(n, t, e) {
  return D(() => {
    switch (n.rank) {
      case 1:
        return mp(n, t, e);
      case 2:
        return Yb(n, [t, 0], [e, n.shape[1]]);
      case 3:
        return gp(n, [t, 0, 0], [e, n.shape[1], n.shape[2]]);
      case 4:
        return hl(n, [t, 0, 0, 0], [e, n.shape[1], n.shape[2], n.shape[3]]);
      case 5:
        return Dt(n, [t, 0, 0, 0, 0], [
          e,
          n.shape[1],
          n.shape[2],
          n.shape[3],
          n.shape[4]
        ]);
      case 6:
        return Dt(n, [t, 0, 0, 0, 0, 0], [
          e,
          n.shape[1],
          n.shape[2],
          n.shape[3],
          n.shape[4],
          n.shape[5]
        ]);
      default:
        throw new E(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`);
    }
  });
}
function ku(n, t, e) {
  return D(() => {
    switch (n.rank) {
      case 1:
        return mp(n, t, e);
      case 2:
        return Yb(n, [0, t], [n.shape[0], e]);
      case 3:
        return gp(n, [0, 0, t], [n.shape[0], n.shape[1], e]);
      case 4:
        return hl(n, [0, 0, 0, t], [n.shape[0], n.shape[1], n.shape[2], e]);
      default:
        throw new E(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`);
    }
  });
}
function Va(n, t, e, s) {
  return D(() => {
    switch (n.rank) {
      case 1:
        return mp(n, t, e);
      case 2:
        switch (s) {
          case 1:
            return mo(n, t, e);
          case 2:
            return ku(n, t, e);
          default:
            throw new E(`The axis is not within the rank of the tensor ${s}`);
        }
      case 3:
        switch (s) {
          case 1:
            return mo(n, t, e);
          case 2:
            return gp(n, [0, t, 0], [n.shape[0], e, n.shape[2]]);
          case 3:
            return ku(n, t, e);
          default:
            throw new E(`The axis is not within the rank of the tensor ${s}`);
        }
      case 4:
        switch (s) {
          case 1:
            return mo(n, t, e);
          case 2:
            return hl(n, [0, t, 0, 0], [n.shape[0], e, n.shape[2], n.shape[3]]);
          case 3:
            return hl(n, [0, 0, t, 0], [n.shape[0], n.shape[1], e, n.shape[3]]);
          case 4:
            return ku(n, t, e);
          default:
            throw new E(`The axis is not within the rank of the tensor ${s}`);
        }
      default:
        throw new E(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`);
    }
  });
}
function rf$1(n, t = -1) {
  let e;
  return t < 0 && (e = n[0].rank, e !== 0 ? t = e : t = 0), t === n[0].rank && (t = -1), Ge$1(n, t);
}
function Cm(n, t) {
  switch (n.rank) {
    case 1:
      return J2([n, t]);
    case 2:
      return q2([n, t], 0);
    case 3:
      return ev([n, t], 0);
    case 4:
      return sv([n, t], 0);
    default:
      throw new E(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`);
  }
}
function vd$1(n, t) {
  if (Array.isArray(t) || (t = [t]), n.rank !== t.length)
    throw new E(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);
  return Vn$1(n, t);
}
function jc(n, t = 0, e = 1, s, o) {
  return hk(n, t, e, s, o);
}
function ns(n, t, e, s) {
  if (n.rank < 2 || t.rank < 2)
    throw new xt$1(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);
  if (t.rank >= 3) {
    const o = n.shape.slice(-1)[0], r = t.shape.slice(-2)[0];
    if (o !== r)
      throw new xt$1(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);
  }
  if (n.rank === 2 && t.rank === 2)
    return im({
      a: n,
      b: t,
      transposeA: false,
      transposeB: false,
      bias: s ? Sd$1(n.rank, s, Kn$1()) : null,
      activation: e
    });
  {
    const o = n.shape.slice(), r = o.pop();
    n = W(n, [-1, r]);
    const i6 = t.shape.slice(), a = i6.pop(), l = i6.pop(), c = [...i6, a], u = Array.from({ length: t.rank }, (f, m) => m === 0 ? t.rank - 2 : m <= t.rank - 2 ? m - 1 : m);
    t = W(kt(t, u), [l, -1]);
    const d = [...o, ...c];
    return W(im({
      a: n,
      b: t,
      transposeA: false,
      transposeB: false,
      bias: s ? Sd$1(n.rank, s, Kn$1()) : null,
      activation: e
    }), d);
  }
}
function ix(n, t, e) {
  return D(() => (Array.isArray(t) ? t = Je$1(t, "int32") : t = et(t, "int32"), jh$1(n, t, e)));
}
function ya(n) {
  return G(n, n);
}
function Sd$1(n, t, e) {
  const s = t.shape;
  if (t.rank !== 1 && t.rank !== n)
    throw new E(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);
  if (n === 5) {
    if (e === "channelsFirst")
      return s.length === 1 ? W(t, [1, s[0], 1, 1, 1]) : W(t, [1, s[3], s[0], s[1], s[2]]);
    if (e === "channelsLast")
      return s.length === 1 ? W(t, [1, 1, 1, 1, s[0]]) : W(t, [1].concat(s));
  } else if (n === 4) {
    if (e === "channelsFirst")
      return s.length === 1 ? W(t, [1, s[0], 1, 1]) : W(t, [1, s[2], s[0], s[1]]);
    if (e === "channelsLast")
      return s.length === 1 ? W(t, [1, 1, 1, s[0]]) : W(t, [1].concat(s));
  } else if (n === 3) {
    if (e === "channelsFirst")
      return s.length === 1 ? W(t, [1, s[0], 1]) : W(t, [1, s[1], s[0]]);
    if (e === "channelsLast")
      return s.length === 1 ? W(t, [1, 1, s[0]]) : W(t, [1].concat(s));
  } else if (n < 3)
    return t;
  throw new E(`Unsupported input rank by biasAdd: ${t.rank}`);
}
function Hn$1(n, t, e) {
  return D(() => (e == null && (e = Kn$1()), ae(e), U(n, Sd$1(n.rank, t, e))));
}
function GG(n, t = 1) {
  if (t !== 1)
    throw new xt$1(`Support for alpha values other than 1 (${t}) is not implemented yet.`);
  return Xc(n);
}
function EG(n) {
  return D(() => ut(n, U(fe$1(n), 1)));
}
function ax(n, t, e, s) {
  return D(() => oT(n, t, e, s));
}
function LG(n) {
  return D(() => {
    const t = U(0.5, G(0.2, n));
    return pn$1(t, 0, 1);
  });
}
function wa(n, t, e = false) {
  return e ? n() : t();
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const MG = ["fanIn", "fanOut", "fanAvg"], WG = ["normal", "uniform", "truncatedNormal"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function DG(n) {
  zo(MG, "FanMode", n);
}
function FG(n) {
  zo(WG, "Distribution", n);
}
let Gn$1 = class Gn extends Vo {
  fromConfigUsesCustomObjects() {
    return false;
  }
  getConfig() {
    return {};
  }
};
class lx extends Gn$1 {
  apply(t, e) {
    return ge$1(t, e);
  }
}
lx.className = "Zeros";
_(lx);
let af$1 = class af extends Gn$1 {
  apply(t, e) {
    return Us(t, e);
  }
};
af$1.className = "Ones";
_(af$1);
class cx extends Gn$1 {
  constructor(t) {
    if (super(), typeof t != "object")
      throw new E(`Expected argument of type ConstantConfig but got ${t}`);
    if (t.value === void 0)
      throw new E(`config must have value set but got ${t}`);
    this.value = t.value;
  }
  apply(t, e) {
    return D(() => G(gt$1(this.value), Us(t, e)));
  }
  getConfig() {
    return {
      value: this.value
    };
  }
}
cx.className = "Constant";
_(cx);
class ux extends Gn$1 {
  constructor(t) {
    super(), this.DEFAULT_MINVAL = -0.05, this.DEFAULT_MAXVAL = 0.05, this.minval = t.minval || this.DEFAULT_MINVAL, this.maxval = t.maxval || this.DEFAULT_MAXVAL, this.seed = t.seed;
  }
  apply(t, e) {
    return Zc(t, this.minval, this.maxval, e, this.seed);
  }
  getConfig() {
    return { minval: this.minval, maxval: this.maxval, seed: this.seed };
  }
}
ux.className = "RandomUniform";
_(ux);
class dx extends Gn$1 {
  constructor(t) {
    super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = t.mean || this.DEFAULT_MEAN, this.stddev = t.stddev || this.DEFAULT_STDDEV, this.seed = t.seed;
  }
  apply(t, e) {
    if (e = e || "float32", e !== "float32" && e !== "int32")
      throw new xt$1(`randomNormal does not support dType ${e}.`);
    return jc(t, this.mean, this.stddev, e, this.seed);
  }
  getConfig() {
    return { mean: this.mean, stddev: this.stddev, seed: this.seed };
  }
}
dx.className = "RandomNormal";
_(dx);
class hx extends Gn$1 {
  constructor(t) {
    super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = t.mean || this.DEFAULT_MEAN, this.stddev = t.stddev || this.DEFAULT_STDDEV, this.seed = t.seed;
  }
  apply(t, e) {
    if (e = e || "float32", e !== "float32" && e !== "int32")
      throw new xt$1(`truncatedNormal does not support dType ${e}.`);
    return jb(t, this.mean, this.stddev, e, this.seed);
  }
  getConfig() {
    return { mean: this.mean, stddev: this.stddev, seed: this.seed };
  }
}
hx.className = "TruncatedNormal";
_(hx);
class px extends Gn$1 {
  constructor(t) {
    super(), this.gain = t.gain != null ? t.gain : 1;
  }
  apply(t, e) {
    return D(() => {
      if (t.length !== 2 || t[0] !== t[1])
        throw new E("Identity matrix initializer can only be used for 2D square matrices.");
      return G(this.gain, Db(t[0]));
    });
  }
  getConfig() {
    return { gain: this.gain };
  }
}
px.className = "Identity";
_(px);
function VG(n, t = "channelsLast") {
  let e, s;
  if (ae(t), n.length === 2)
    e = n[0], s = n[1];
  else if ([3, 4, 5].indexOf(n.length) !== -1) {
    if (t === "channelsFirst") {
      const o = Ds(n, 2);
      e = n[1] * o, s = n[0] * o;
    } else if (t === "channelsLast") {
      const o = Ds(n, 0, n.length - 2);
      e = n[n.length - 2] * o, s = n[n.length - 1] * o;
    }
  } else {
    const o = Ds(n);
    e = Math.sqrt(o), s = Math.sqrt(o);
  }
  return [e, s];
}
let qe$1 = class qe extends Gn$1 {
  /**
   * Constructor of VarianceScaling.
   * @throws ValueError for invalid value in scale.
   */
  constructor(t) {
    if (super(), t.scale < 0)
      throw new E(`scale must be a positive float. Got: ${t.scale}`);
    this.scale = t.scale == null ? 1 : t.scale, this.mode = t.mode == null ? "fanIn" : t.mode, DG(this.mode), this.distribution = t.distribution == null ? "normal" : t.distribution, FG(this.distribution), this.seed = t.seed;
  }
  apply(t, e) {
    const s = VG(t), o = s[0], r = s[1];
    let i6 = this.scale;
    if (this.mode === "fanIn" ? i6 /= Math.max(1, o) : this.mode === "fanOut" ? i6 /= Math.max(1, r) : i6 /= Math.max(1, (o + r) / 2), this.distribution === "normal") {
      const a = Math.sqrt(i6);
      if (e = e || "float32", e !== "float32" && e !== "int32")
        throw new xt$1(`${this.getClassName()} does not support dType ${e}.`);
      return jb(t, 0, a, e, this.seed);
    } else {
      const a = Math.sqrt(3 * i6);
      return Zc(t, -a, a, e, this.seed);
    }
  }
  getConfig() {
    return {
      scale: this.scale,
      mode: this.mode,
      distribution: this.distribution,
      seed: this.seed
    };
  }
};
qe$1.className = "VarianceScaling";
_(qe$1);
let lf$1 = class lf extends qe$1 {
  /**
   * Constructor of GlorotUniform
   * @param scale
   * @param mode
   * @param distribution
   * @param seed
   */
  constructor(t) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "uniform",
      seed: t == null ? null : t.seed
    });
  }
  getClassName() {
    return qe$1.className;
  }
};
lf$1.className = "GlorotUniform";
_(lf$1);
let cf$1 = class cf extends qe$1 {
  /**
   * Constructor of GlorotNormal.
   * @param scale
   * @param mode
   * @param distribution
   * @param seed
   */
  constructor(t) {
    super({
      scale: 1,
      mode: "fanAvg",
      distribution: "normal",
      seed: t == null ? null : t.seed
    });
  }
  getClassName() {
    return qe$1.className;
  }
};
cf$1.className = "GlorotNormal";
_(cf$1);
let uf$1 = class uf extends qe$1 {
  constructor(t) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "normal",
      seed: t == null ? null : t.seed
    });
  }
  getClassName() {
    return qe$1.className;
  }
};
uf$1.className = "HeNormal";
_(uf$1);
let df$1 = class df extends qe$1 {
  constructor(t) {
    super({
      scale: 2,
      mode: "fanIn",
      distribution: "uniform",
      seed: t == null ? null : t.seed
    });
  }
  getClassName() {
    return qe$1.className;
  }
};
df$1.className = "HeUniform";
_(df$1);
let hf$1 = class hf extends qe$1 {
  constructor(t) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "normal",
      seed: t == null ? null : t.seed
    });
  }
  getClassName() {
    return qe$1.className;
  }
};
hf$1.className = "LeCunNormal";
_(hf$1);
let pf$1 = class pf extends qe$1 {
  constructor(t) {
    super({
      scale: 1,
      mode: "fanIn",
      distribution: "uniform",
      seed: t == null ? null : t.seed
    });
  }
  getClassName() {
    return qe$1.className;
  }
};
pf$1.className = "LeCunUniform";
_(pf$1);
class fx extends Gn$1 {
  constructor(t) {
    if (super(), this.DEFAULT_GAIN = 1, this.gain = t.gain == null ? this.DEFAULT_GAIN : t.gain, this.seed = t.seed, this.seed != null)
      throw new xt$1("Random seed is not implemented for Orthogonal Initializer yet.");
  }
  apply(t, e) {
    return D(() => {
      if (t.length < 2)
        throw new xt$1("Shape must be at least 2D.");
      t[0] * t[1] > 2e3 && console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0] * t[1]}) elements: Slowness may result.`);
      const s = t[0] > t[1] ? [t[1], t[0]] : t, o = jc(s, 0, 1, "float32");
      let r = zN.gramSchmidt(o);
      return t[0] > t[1] && (r = kt(r)), G(this.gain, r);
    });
  }
  getConfig() {
    return {
      gain: this.gain,
      seed: this.seed
    };
  }
}
fx.className = "Orthogonal";
_(fx);
const vm = {
  constant: "Constant",
  glorotNormal: "GlorotNormal",
  glorotUniform: "GlorotUniform",
  heNormal: "HeNormal",
  heUniform: "HeUniform",
  identity: "Identity",
  leCunNormal: "LeCunNormal",
  leCunUniform: "LeCunUniform",
  ones: "Ones",
  orthogonal: "Orthogonal",
  randomNormal: "RandomNormal",
  randomUniform: "RandomUniform",
  truncatedNormal: "TruncatedNormal",
  varianceScaling: "VarianceScaling",
  zeros: "Zeros"
};
function Sm(n, t = {}) {
  return ba(n, an$1.getMap().classNameMap, t, "initializer");
}
function Jt(n) {
  return sf$1(n);
}
function Ut(n) {
  if (typeof n == "string") {
    const t = n in vm ? vm[n] : n;
    if (t === "GlorotNormal")
      return new cf$1();
    if (t === "GlorotUniform")
      return new lf$1();
    if (t === "HeNormal")
      return new uf$1();
    if (t === "HeUniform")
      return new df$1();
    if (t === "LeCunNormal")
      return new hf$1();
    if (t === "LeCunUniform")
      return new pf$1();
    {
      const e = {};
      return e.className = t, e.config = {}, Sm(e);
    }
  } else
    return n instanceof Gn$1 ? n : Sm(n);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function kd$1(n) {
  return Array.isArray(n) && Array.isArray(n[0]);
}
function fl(n) {
  return n.length === 0 ? [] : Array.isArray(n[0]) ? n : [n];
}
function mt(n) {
  let t;
  if (Array.isArray(n)) {
    if (n.length !== 1)
      throw new E(`Expected Tensor length to be 1; got ${n.length}`);
    t = n[0];
  } else
    t = n;
  return t;
}
function $t(n) {
  if (Array.isArray(n) && Array.isArray(n[0])) {
    if (n.length === 1)
      return n = n, n[0];
    throw new E(`Expected exactly 1 Shape; got ${n.length}`);
  } else
    return n;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function ml(n) {
  let t = 0;
  for (const e of n)
    e.shape.length === 0 ? t += 1 : t += e.shape.reduce((s, o) => s * o);
  return t;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const km = "Variable";
class zG {
  /**
   * Construct Variable from a `tf.Tensor`.
   *
   * If not explicitly named, the Variable will be given a name with the
   * prefix 'Variable'. Variable names are unique. In the case of name
   * collision, suffixies '_<num>' will be added to the name.
   *
   * @param val Initial value of the Variable.
   * @param name Name of the variable. If `null` or `undefined` is provided, it
   *   will default a name with the prefix 'Variable'.
   * @param constraint Optional, projection function to be applied to the
   * variable after optimize updates
   * @throws ValueError if `name` is `null` or `undefined`.
   */
  constructor(t, e = "float32", s = km, o = true, r = null) {
    this.dtype = e ?? "float32", this.shape = t.shape, this.id = ex(), s = s ?? km, this.originalName = sx(s), this.name = ox(this.originalName), this.trainable_ = o, this.constraint = r, this.val = tT(t, this.trainable_, this.name, this.dtype);
  }
  /**
   * Get a snapshot of the Variable's value.
   *
   * The returned value is a snapshot of the Variable's value at the time of
   * the invocation. Future mutations in the value of the tensor will only
   * be reflected by future calls to this method.
   */
  read() {
    return this.assertNotDisposed(), this.val;
  }
  /**
   * Update the value of the Variable.
   *
   * @param newVal: The new value to update to. Must be consistent with the
   *   dtype and shape of the Variable.
   * @return This Variable.
   */
  write(t) {
    return this.assertNotDisposed(), XG(this.val, t), this.val.id !== t.id && (this.val.assign(t), this.constraint != null && this.val.assign(this.constraint.apply(this.val))), this;
  }
  /**
   * Dispose this LayersVariable instance from memory.
   */
  dispose() {
    this.assertNotDisposed(), this.val.dispose();
  }
  assertNotDisposed() {
    if (this.val.isDisposed)
      throw new Error(`LayersVariable ${this.name} is already disposed.`);
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(t) {
    this.trainable_ = t, this.val.trainable = t;
  }
}
function XG(n, t) {
  if (n.shape.toString() !== t.shape.toString())
    throw new Error("Shape mismatch: " + JSON.stringify(n.shape) + " vs. " + JSON.stringify(t.shape));
}
function Td$1(n) {
  return n.map((t) => t.read());
}
function ff$1(n) {
  n.forEach((t) => {
    t[0].write(t[1]);
  });
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class de {
  constructor(t) {
    this.dtype = t.dtype, this.shape = t.shape, t.shape != null ? this.ndim = t.shape.length : this.ndim = t.ndim, this.maxNDim = t.maxNDim, this.minNDim = t.minNDim, this.axes = t.axes || {};
  }
}
let jn$1 = class jn {
  /**
   *
   * @param dtype
   * @param shape
   * @param sourceLayer The Layer that produced this symbolic tensor.
   * @param inputs The inputs passed to sourceLayer's __call__() method.
   * @param nodeIndex
   * @param tensorIndex
   * @param callArgs The keyword arguments passed to the __call__() method.
   * @param name
   * @param outputTensorIndex The index of this tensor in the list of outputs
   *   returned by apply().
   */
  constructor(t, e, s, o, r, i6, a) {
    this.dtype = t, this.shape = e, this.sourceLayer = s, this.inputs = o, this.callArgs = r, this.outputTensorIndex = a, this.id = ex(), i6 != null && (this.originalName = sx(i6), this.name = ox(this.originalName)), this.rank = e.length;
  }
};
let PG = 0;
class qc {
  constructor(t, e) {
    this.callArgs = e, this.id = PG++, this.outboundLayer = t.outboundLayer, this.inboundLayers = t.inboundLayers, this.nodeIndices = t.nodeIndices, this.tensorIndices = t.tensorIndices, this.inputTensors = t.inputTensors, this.outputTensors = t.outputTensors, this.inputMasks = t.inputMasks, this.outputMasks = t.outputMasks, this.inputShapes = t.inputShapes, this.outputShapes = t.outputShapes;
    for (const s of t.inboundLayers)
      s != null && s.outboundNodes.push(this);
    t.outboundLayer.inboundNodes.push(this);
  }
  getConfig() {
    const t = [];
    for (const e of this.inboundLayers)
      e != null ? t.push(e.name) : t.push(null);
    return {
      outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
      inboundLayers: t,
      nodeIndices: this.nodeIndices,
      tensorIndices: this.tensorIndices
    };
  }
}
let AG = 0;
let St$1 = class St extends Vo {
  constructor(t = {}) {
    super(), this._callHook = null, this._addedWeightNames = [], this._stateful = false, this.id = AG++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = false, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = false, this.inboundNodes = [], this.outboundNodes = [];
    let e = t.name;
    if (!e) {
      const s = this.getClassName();
      e = cs(s) + "_" + Jc(s);
    }
    if (this.name = e, this.trainable_ = t.trainable == null ? true : t.trainable, t.inputShape != null || t.batchInputShape != null) {
      let s;
      if (t.batchInputShape != null)
        s = t.batchInputShape;
      else if (t.inputShape != null) {
        let r = null;
        t.batchSize != null && (r = t.batchSize), s = [r].concat(t.inputShape);
      }
      this.batchInputShape = s;
      let o = t.dtype;
      o == null && (o = t.inputDType), o == null && (o = "float32"), this.dtype = o;
    }
    t.weights != null ? this.initialWeights = t.weights : this.initialWeights = null, this._refCount = null, this.fastWeightInitDuringBuild = false;
  }
  /**
   * Converts a layer and its index to a unique (immutable type) name.
   * This function is used internally with `this.containerNodes`.
   * @param layer The layer.
   * @param nodeIndex The layer's position (e.g. via enumerate) in a list of
   *   nodes.
   *
   * @returns The unique name.
   */
  static nodeKey(t, e) {
    return t.name + "_ib-" + e.toString();
  }
  /**
   * Returns this.inboundNode at index nodeIndex.
   *
   * Porting note: This is a replacement for _get_node_attribute_at_index()
   * @param nodeIndex
   * @param attrName The name of the attribute related to request for this node.
   */
  getNodeAtIndex(t, e) {
    if (this.inboundNodes.length === 0)
      throw new Cn$1(`The layer has never been called and thus has no defined ${e}.`);
    if (this.inboundNodes.length <= t)
      throw new E(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
    return this.inboundNodes[t];
  }
  /**
   * Retrieves the input tensor(s) of a layer at a given node.
   *
   * @param nodeIndex Integer, index of the node from which to retrieve the
   *   attribute. E.g. `nodeIndex=0` will correspond to the first time the layer
   *   was called.
   *
   * @return A tensor (or list of tensors if the layer has multiple inputs).
   */
  getInputAt(t) {
    return Pe$1(this.getNodeAtIndex(t, "input").inputTensors);
  }
  /**
   * Retrieves the output tensor(s) of a layer at a given node.
   *
   * @param nodeIndex Integer, index of the node from which to retrieve the
   *   attribute. E.g. `nodeIndex=0` will correspond to the first time the layer
   *   was called.
   *
   * @return A tensor (or list of tensors if the layer has multiple outputs).
   */
  getOutputAt(t) {
    return Pe$1(this.getNodeAtIndex(t, "output").outputTensors);
  }
  // Properties
  /**
   * Retrieves the input tensor(s) of a layer.
   *
   * Only applicable if the layer has exactly one inbound node,
   * i.e. if it is connected to one incoming layer.
   *
   * @return Input tensor or list of input tensors.
   *
   * @exception AttributeError if the layer is connected to more than one
   *   incoming layers.
   */
  get input() {
    if (this.inboundNodes.length > 1)
      throw new Yn$1(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
    if (this.inboundNodes.length === 0)
      throw new Yn$1(`Layer ${this.name} is not connected, no input to return.`);
    return Pe$1(this.getNodeAtIndex(0, "input").inputTensors);
  }
  /**
   * Retrieves the output tensor(s) of a layer.
   *
   * Only applicable if the layer has exactly one inbound node,
   * i.e. if it is connected to one incoming layer.
   *
   * @return Output tensor or list of output tensors.
   *
   * @exception AttributeError if the layer is connected to more than one
   *   incoming layers.
   */
  get output() {
    if (this.inboundNodes.length === 0)
      throw new Yn$1(`Layer ${this.name} has no inbound nodes.`);
    if (this.inboundNodes.length > 1)
      throw new Yn$1(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
    return Pe$1(this.getNodeAtIndex(0, "output").outputTensors);
  }
  get losses() {
    return this._losses;
  }
  /**
   * Retrieves the Layer's current loss values.
   *
   * Used for regularizers during training.
   */
  calculateLosses() {
    return this.losses.map((t) => t());
  }
  get updates() {
    return this._updates;
  }
  get built() {
    return this._built;
  }
  set built(t) {
    this._built = t;
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(t) {
    this._trainableWeights.forEach((e) => e.trainable = t), this.trainable_ = t;
  }
  get trainableWeights() {
    return this.trainable_ ? this._trainableWeights.filter((t) => t.trainable) : [];
  }
  set trainableWeights(t) {
    this._trainableWeights = t;
  }
  get nonTrainableWeights() {
    return this.trainable ? this._trainableWeights.filter((t) => !t.trainable).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
  }
  set nonTrainableWeights(t) {
    this._nonTrainableWeights = t;
  }
  /**
   * The concatenation of the lists trainableWeights and nonTrainableWeights
   * (in this order).
   */
  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }
  get stateful() {
    return this._stateful;
  }
  /**
   * Reset the states of the layer.
   *
   * This method of the base Layer class is essentially a no-op.
   * Subclasses that are stateful (e.g., stateful RNNs) should override this
   * method.
   */
  resetStates() {
    if (!this.stateful)
      throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
  }
  /**
   * Checks compatibility between the layer and provided inputs.
   *
   * This checks that the tensor(s) `input`
   * verify the input assumptions of the layer
   * (if any). If not, exceptions are raised.
   *
   * @param inputs Input tensor or list of input tensors.
   *
   * @exception ValueError in case of mismatch between
   *   the provided inputs and the expectations of the layer.
   */
  assertInputCompatibility(t) {
    if (t = Zt(t), this.inputSpec == null || this.inputSpec.length === 0)
      return;
    const e = Zt(this.inputSpec);
    if (t.length !== e.length)
      throw new E(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);
    for (let s = 0; s < t.length; s++) {
      const o = t[s], r = e[s];
      if (r == null)
        continue;
      const i6 = o.rank;
      if (r.ndim != null && i6 !== r.ndim)
        throw new E(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${i6}`);
      if (r.maxNDim != null && i6 > r.maxNDim)
        throw new E(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${i6}`);
      if (r.minNDim != null && i6 < r.minNDim)
        throw new E(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${i6}.`);
      if (r.dtype != null && o.dtype !== r.dtype)
        throw new E(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${o.dtype}.`);
      if (r.axes) {
        const a = o.shape;
        for (const l in r.axes) {
          const c = Number(l), u = r.axes[l], d = c >= 0 ? a[c] : a[a.length + c];
          if (u != null && [u, null].indexOf(d) === -1)
            throw new E(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${a}.`);
        }
      }
      if (r.shape != null)
        for (let a = 0; a < r.shape.length; ++a) {
          const l = r.shape[a], c = o.shape[a];
          if (l != null && c != null && l !== c)
            throw new E(`Input ${s} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${o.shape}.`);
        }
    }
  }
  /**
   * This is where the layer's logic lives.
   *
   * @param inputs Input tensor, or list/tuple of input tensors.
   * @param kwargs Additional keyword arguments.
   *
   * @return A tensor or list/tuple of tensors.
   */
  call(t, e) {
    return t;
  }
  invokeCallHook(t, e) {
    this._callHook != null && this._callHook(t, e);
  }
  /**
   * Set call hook.
   * This is currently used for testing only.
   * @param callHook
   */
  setCallHook(t) {
    this._callHook = t;
  }
  /**
   * Clear call hook.
   * This is currently used for testing only.
   */
  clearCallHook() {
    this._callHook = null;
  }
  /**
   * Builds or executes a `Layer`'s logic.
   *
   * When called with `tf.Tensor`(s), execute the `Layer`'s computation and
   * return Tensor(s). For example:
   *
   * ```js
   * const denseLayer = tf.layers.dense({
   *   units: 1,
   *   kernelInitializer: 'zeros',
   *   useBias: false
   * });
   *
   * // Invoke the layer's apply() method with a `tf.Tensor` (with concrete
   * // numeric values).
   * const input = tf.ones([2, 2]);
   * const output = denseLayer.apply(input);
   *
   * // The output's value is expected to be [[0], [0]], due to the fact that
   * // the dense layer has a kernel initialized to all-zeros and does not have
   * // a bias.
   * output.print();
   * ```
   *
   * When called with `tf.SymbolicTensor`(s), this will prepare the layer for
   * future execution.  This entails internal book-keeping on shapes of
   * expected Tensors, wiring layers together, and initializing weights.
   *
   * Calling `apply` with `tf.SymbolicTensor`s are typically used during the
   * building of non-`tf.Sequential` models. For example:
   *
   * ```js
   * const flattenLayer = tf.layers.flatten();
   * const denseLayer = tf.layers.dense({units: 1});
   *
   * // Use tf.layers.input() to obtain a SymbolicTensor as input to apply().
   * const input = tf.input({shape: [2, 2]});
   * const output1 = flattenLayer.apply(input);
   *
   * // output1.shape is [null, 4]. The first dimension is the undetermined
   * // batch size. The second dimension comes from flattening the [2, 2]
   * // shape.
   * console.log(JSON.stringify(output1.shape));
   *
   * // The output SymbolicTensor of the flatten layer can be used to call
   * // the apply() of the dense layer:
   * const output2 = denseLayer.apply(output1);
   *
   * // output2.shape is [null, 1]. The first dimension is the undetermined
   * // batch size. The second dimension matches the number of units of the
   * // dense layer.
   * console.log(JSON.stringify(output2.shape));
   *
   * // The input and output can be used to construct a model that consists
   * // of the flatten and dense layers.
   * const model = tf.model({inputs: input, outputs: output2});
   * ```
   *
   * @param inputs a `tf.Tensor` or `tf.SymbolicTensor` or an Array of them.
   * @param kwargs Additional keyword arguments to be passed to `call()`.
   *
   * @return Output of the layer's `call` method.
   *
   * @exception ValueError error in case the layer is missing shape information
   *   for its `build` call.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  // Porting Note: This is a replacement for __call__() in Python.
  apply(t, e) {
    e = e || {}, this.assertNotDisposed();
    const s = Zt(t);
    let o = true;
    for (const i6 of s)
      if (!(i6 instanceof jn$1)) {
        o = false;
        break;
      }
    let r = true;
    for (const i6 of s)
      if (i6 instanceof jn$1) {
        r = false;
        break;
      }
    if (o === r)
      throw new E("Arguments to apply() must be all SymbolicTensors or all Tensors");
    return fo(this.name, () => {
      if (!this.built) {
        this.assertInputCompatibility(t);
        const i6 = [];
        for (const a of Zt(t))
          i6.push(a.shape);
        this.build(Pe$1(i6)), this.built = true, this.initialWeights && this.setWeights(this.initialWeights), this._refCount === null && r && (this._refCount = 1);
      }
      if (this.assertInputCompatibility(t), r) {
        let i6 = this.call(t, e);
        const a = Zt(i6), l = [];
        for (let c of a)
          s.indexOf(c) !== -1 && (c = c.clone()), l.push(c);
        if (i6 = Pe$1(l), this.activityRegularizer != null)
          throw new xt$1("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return i6;
      } else {
        const i6 = OG(t), a = this.computeOutputShape(i6);
        let l;
        const c = KG(t);
        if (this.warnOnIncompatibleInputShape(Array.isArray(t) ? i6[0] : i6), a != null && a.length > 0 && Array.isArray(a[0]) ? l = a.map((u, d) => new jn$1(c, u, this, Zt(t), e, this.name, d)) : l = new jn$1(c, a, this, Zt(t), e, this.name), this.addInboundNode(t, l, null, null, i6, a, e), this._refCount++, this.activityRegularizer != null)
          throw new xt$1("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return l;
      }
    });
  }
  /**
   * Check compatibility between input shape and this layer's batchInputShape.
   *
   * Print warning if any incompatibility is found.
   *
   * @param inputShape Input shape to be checked.
   */
  warnOnIncompatibleInputShape(t) {
    if (this.batchInputShape != null)
      if (t.length !== this.batchInputShape.length)
        console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
      else {
        let e = false;
        this.batchInputShape.forEach((s, o) => {
          s != null && t[o] != null && t[o] !== s && (e = true);
        }), e && console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
      }
  }
  /**
   * Retrieves the output shape(s) of a layer.
   *
   * Only applicable if the layer has only one inbound node, or if all inbound
   * nodes have the same output shape.
   *
   * @returns Output shape or shapes.
   * @throws AttributeError: if the layer is connected to more than one incoming
   *   nodes.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  get outputShape() {
    if (this.inboundNodes == null || this.inboundNodes.length === 0)
      throw new Yn$1(`The layer ${this.name} has never been called and thus has no defined output shape.`);
    const t = [];
    for (const e of this.inboundNodes) {
      const s = JSON.stringify(e.outputShapes);
      t.indexOf(s) === -1 && t.push(s);
    }
    if (t.length === 1) {
      const e = this.inboundNodes[0].outputShapes;
      return Array.isArray(e) && Array.isArray(e[0]) && e.length === 1 ? e[0] : e;
    } else
      throw new Yn$1(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
  }
  /**
   * Counts the total number of numbers (e.g., float32, int32) in the
   * weights.
   *
   * @returns An integer count.
   * @throws RuntimeError: If the layer is not built yet (in which case its
   *   weights are not defined yet.)
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  countParams() {
    if (!this.built)
      throw new Cn$1(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
    return ml(this.weights);
  }
  /**
   * Creates the layer weights.
   *
   * Must be implemented on all layers that have weights.
   *
   * Called when apply() is called to construct the weights.
   *
   * @param inputShape A `Shape` or array of `Shape` (unused).
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  build(t) {
    this.built = true;
  }
  /**
   * Returns the current values of the weights of the layer.
   *
   * @param trainableOnly Whether to get the values of only trainable weights.
   * @returns Weight values as an `Array` of `tf.Tensor`s.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  getWeights(t = false) {
    return Td$1(t ? this.trainableWeights : this.weights);
  }
  /**
   * Sets the weights of the layer, from Tensors.
   *
   * @param weights a list of Tensors. The number of arrays and their shape
   *   must match number of the dimensions of the weights of the layer (i.e.
   *   it should match the output of `getWeights`).
   *
   * @exception ValueError If the provided weights list does not match the
   *   layer's specifications.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  setWeights(t) {
    D(() => {
      const e = this.weights;
      if (e.length !== t.length)
        throw new E(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);
      if (e.length === 0)
        return;
      const s = [], o = Td$1(e);
      for (let r = 0; r < o.length; ++r) {
        const i6 = o[r], a = e[r], l = t[r];
        if (!Rt$1(i6.shape, l.shape))
          throw new E(`Layer weight shape ${i6.shape} not compatible with provided weight shape ${l.shape}`);
        s.push([a, l]);
      }
      ff$1(s);
    });
  }
  /**
   * Adds a weight variable to the layer.
   *
   * @param name Name of the new weight variable.
   * @param shape The shape of the weight.
   * @param dtype The dtype of the weight.
   * @param initializer An initializer instance.
   * @param regularizer A regularizer instance.
   * @param trainable Whether the weight should be trained via backprop or not
   *   (assuming that the layer itself is also trainable).
   * @param constraint An optional trainable.
   * @return The created weight variable.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  addWeight(t, e, s, o, r, i6, a, l) {
    if (this._addedWeightNames.indexOf(t) !== -1)
      throw new E(`Duplicate weight name ${t} for layer ${this.name}`);
    this._addedWeightNames.push(t), s == null && (s = "float32"), this.fastWeightInitDuringBuild && (o = l != null ? l() : Ut("zeros"));
    const c = o.apply(e, s), u = new zG(c, s, t, i6, a);
    return c.dispose(), r != null && this.addLoss(() => r.apply(u.read())), i6 == null && (i6 = true), i6 ? this._trainableWeights.push(u) : this._nonTrainableWeights.push(u), u;
  }
  /**
   * Set the fast-weight-initialization flag.
   *
   * In cases where the initialized weight values will be immediately
   * overwritten by loaded weight values during model loading, setting
   * the flag to `true` saves unnecessary calls to potentially expensive
   * initializers and speeds up the loading process.
   *
   * @param value Target value of the flag.
   */
  setFastWeightInitDuringBuild(t) {
    this.fastWeightInitDuringBuild = t;
  }
  /**
   * Add losses to the layer.
   *
   * The loss may potentially be conditional on some inputs tensors,
   * for instance activity losses are conditional on the layer's inputs.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  addLoss(t) {
    t == null || Array.isArray(t) && t.length === 0 || (t = Zt(t), this._losses !== void 0 && this._losses !== null && this.losses.push(...t));
  }
  /**
   * Computes the output shape of the layer.
   *
   * Assumes that the layer will be built to match that input shape provided.
   *
   * @param inputShape A shape (tuple of integers) or a list of shape tuples
   *   (one per output tensor of the layer). Shape tuples can include null for
   *   free dimensions, instead of an integer.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  computeOutputShape(t) {
    return t;
  }
  /**
   * Computes an output mask tensor.
   *
   * @param inputs Tensor or list of tensors.
   * @param mask Tensor or list of tensors.
   *
   * @return null or a tensor (or list of tensors, one per output tensor of the
   * layer).
   */
  computeMask(t, e) {
    if (!this.supportsMasking) {
      if (e != null)
        if (Array.isArray(e))
          e.forEach((s) => {
            if (s != null)
              throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
          });
        else
          throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
      return null;
    }
    return e;
  }
  /**
   * Internal method to create an inbound node for the layer.
   *
   * @param inputTensors List of input tensors.
   * @param outputTensors List of output tensors.
   * @param inputMasks List of input masks (a mask can be a tensor, or null).
   * @param outputMasks List of output masks (a mask can be a tensor, or null).
   * @param inputShapes List of input shape tuples.
   * @param outputShapes List of output shape tuples.
   * @param kwargs Dictionary of keyword arguments that were passed to the
   *   `call` method of the layer at the call that created the node.
   */
  addInboundNode(t, e, s, o, r, i6, a = null) {
    const l = Zt(t);
    e = Zt(e), s = Zt(s), o = Zt(o), r = fl(r), i6 = fl(i6);
    const c = [], u = [], d = [];
    for (const h6 of l)
      c.push(h6.sourceLayer), u.push(h6.nodeIndex), d.push(h6.tensorIndex);
    new qc({
      outboundLayer: this,
      inboundLayers: c,
      nodeIndices: u,
      tensorIndices: d,
      inputTensors: l,
      outputTensors: e,
      inputMasks: s,
      outputMasks: o,
      inputShapes: r,
      outputShapes: i6
    }, a);
    for (let h6 = 0; h6 < e.length; h6++)
      e[h6].sourceLayer = this, e[h6].nodeIndex = this.inboundNodes.length - 1, e[h6].tensorIndex = h6;
  }
  /**
   * Returns the config of the layer.
   *
   * A layer config is a TS dictionary (serializable)
   * containing the configuration of a layer.
   * The same layer can be reinstantiated later
   * (without its trained weights) from this configuration.
   *
   * The config of a layer does not include connectivity
   * information, nor the layer class name.  These are handled
   * by 'Container' (one layer of abstraction above).
   *
   * Porting Note: The TS dictionary follows TS naming standards for
   * keys, and uses tfjs-layers type-safe Enums.  Serialization methods
   * should use a helper function to convert to the pythonic storage
   * standard. (see serialization_utils.convertTsToPythonic)
   *
   * @returns TS dictionary of configuration.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  getConfig() {
    const t = { name: this.name, trainable: this.trainable };
    return this.batchInputShape != null && (t.batchInputShape = this.batchInputShape), this.dtype != null && (t.dtype = this.dtype), t;
  }
  /**
   * Dispose the weight variables that this Layer instance holds.
   *
   * @returns {number} Number of disposed variables.
   */
  disposeWeights() {
    return this.weights.forEach((t) => t.dispose()), this.weights.length;
  }
  assertNotDisposed() {
    if (this._refCount === 0)
      throw new Error(`Layer '${this.name}' is already disposed.`);
  }
  /**
   * Attempt to dispose layer's weights.
   *
   * This method decreases the reference count of the Layer object by 1.
   *
   * A Layer is reference-counted. Its reference count is incremented by 1
   * the first item its `apply()` method is called and when it becomes a part
   * of a new `Node` (through calling the `apply()` method on a
   * `tf.SymbolicTensor`).
   *
   * If the reference count of a Layer becomes 0, all the weights will be
   * disposed and the underlying memory (e.g., the textures allocated in WebGL)
   * will be freed.
   *
   * Note: If the reference count is greater than 0 after the decrement, the
   * weights of the Layer will *not* be disposed.
   *
   * After a Layer is disposed, it cannot be used in calls such as `apply()`,
   * `getWeights()` or `setWeights()` anymore.
   *
   * @returns A DisposeResult Object with the following fields:
   *   - refCountAfterDispose: The reference count of the Container after this
   *     `dispose()` call.
   *   - numDisposedVariables: Number of `tf.Variable`s (i.e., weights) disposed
   *     during this `dispose()` call.
   * @throws {Error} If the layer is not built yet, or if the layer has already
   *   been disposed.
   *
   * @doc {heading: 'Models', 'subheading': 'Classes'}
   */
  dispose() {
    if (!this.built)
      throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
    if (this._refCount === null)
      throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
    this.assertNotDisposed();
    let t = 0;
    return --this._refCount === 0 && (t = this.disposeWeights()), { refCountAfterDispose: this._refCount, numDisposedVariables: t };
  }
};
function OG(n) {
  n = Zt(n);
  const t = [];
  for (const e of n)
    t.push(e.shape);
  return Pe$1(t);
}
function KG(n) {
  return "float32";
}
function mx(n, t, e) {
  if ((t == null || e != null && e > 0) && (t = n.sourceLayer, e = n.nodeIndex), t.inboundNodes.length === 0)
    return [n];
  {
    const s = t.inboundNodes[e];
    if (s.inboundLayers.length === 0)
      return s.inputTensors;
    {
      const o = [];
      for (let r = 0; r < s.inboundLayers.length; r++) {
        const i6 = s.inputTensors[r], a = s.inboundLayers[r], l = s.nodeIndices[r], c = mx(i6, a, l);
        for (const u of c)
          o.indexOf(u) === -1 && o.push(u);
      }
      return o;
    }
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Ia extends St$1 {
  constructor(t) {
    if (super({
      dtype: t.dtype,
      name: t.name != null ? t.name : Jc("input").toString()
    }), t.batchSize == null && (t.batchSize = null), t.sparse == null && (t.sparse = false), this.trainable = false, this.built = true, this.sparse = t.sparse, t.inputShape != null && t.batchInputShape != null)
      throw new E("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    let e = t.batchInputShape;
    if (e == null) {
      if (t.inputShape == null)
        throw new E("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      e = [t.batchSize].concat(t.inputShape);
    } else if (t.batchSize != null)
      throw new E("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
    const s = t.dtype || "float32";
    this.batchInputShape = e, this.dtype = s, this.inputSpec = [{ shape: e }];
    const o = new jn$1(this.dtype, this.batchInputShape, this, [], {}, this.name);
    o.nodeIndex = 0, o.tensorIndex = 0, new qc({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: [o],
      outputTensors: [o],
      inputMasks: [null],
      outputMasks: [null],
      inputShapes: [e],
      outputShapes: [e]
    });
  }
  apply(t, e) {
    throw new E(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
  }
  dispose() {
    return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
  }
  getConfig() {
    return {
      batchInputShape: this.batchInputShape,
      dtype: this.dtype,
      sparse: this.sparse,
      name: this.name
    };
  }
}
Ia.className = "InputLayer";
_(Ia);
function ZG(n) {
  if (n.batchShape == null && n.shape == null)
    throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
  if (n.batchShape != null && n.shape != null)
    throw new E("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
  let t = n.batchShape;
  n.shape != null && t == null && (t = [null].concat(n.shape));
  let e = n.dtype;
  return e == null && (e = "float32"), new Ia({
    batchInputShape: t,
    name: n.name,
    dtype: e,
    sparse: n.sparse
  }).inboundNodes[0].outputTensors[0];
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function BG(n, t) {
  if (n.dtype == null || n.dtype === t.dtype)
    return t;
  try {
    return et(t, n.dtype);
  } catch {
    throw new E(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`);
  }
}
class Gs {
  /**
   * Constructor, optionally does copy-construction.
   * @param feeds An Array of `Feed`s, or another `FeedDict`, in which case
   *   copy-construction will be performed.
   */
  constructor(t) {
    if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t instanceof Gs)
      for (const e in t.id2Value)
        this.id2Value[e] = t.id2Value[e], e in t.id2Mask && (this.id2Mask[e] = t.id2Mask[e]);
    else {
      if (t == null)
        return;
      for (const e of t)
        this.add(e.key, e.value);
    }
  }
  /**
   * Add a key-value pair to the FeedDict.
   *
   * @param key The key of the feed.
   * @param value The value of the tensor feed.
   * @param mask The value of the mask feed (optional).
   * @returns This `FeedDict`.
   * @throws ValueError: If the key `SymbolicTensor` already exists in the
   *   `FeedDict`.
   */
  add(t, e, s) {
    if (this.id2Value[t.id] == null)
      this.id2Value[t.id] = BG(t, e), this.name2Id[t.name] = t.id, s != null && (this.id2Mask[t.id] = s);
    else
      throw new E(`Duplicate key: name=${t.name}, id=${t.id}`);
    return this;
  }
  /**
   * Add a Feed to the FeedDict.
   * @param feed The new `Feed` to add.
   * @returns This `FeedDict`.
   */
  addFeed(t) {
    this.add(t.key, t.value);
  }
  /**
   * Probe whether a key already exists in the FeedDict.
   * @param key
   */
  hasKey(t) {
    return this.id2Value[t.id] != null;
  }
  /**
   * Get all the SymbolicTensor available in this FeedDict.
   */
  names() {
    return Object.keys(this.name2Id);
  }
  /**
   * Get the feed value for given key.
   * @param key The SymbolicTensor, or its name (as a string), of which the
   *     value is sought.
   * @returns If `key` exists, the corresponding feed value.
   * @throws ValueError: If `key` does not exist in this `FeedDict`.
   */
  getValue(t) {
    if (t instanceof jn$1) {
      if (this.id2Value[t.id] == null)
        throw new E(`Nonexistent key: ${t.name}`);
      return this.id2Value[t.id];
    } else {
      const e = this.name2Id[t];
      if (e == null)
        throw new E(`Feed dict has no SymbolicTensor name: ${t}`);
      return this.id2Value[e];
    }
  }
  /**
   * Get the feed mask for given key.
   * @param key The SymbolicTensor, or its name (as a string), of which the
   *     value is sought.
   * @returns If `key` exists, the corresponding feed mask.
   * @throws ValueError: If `key` does not exist in this `FeedDict`.
   */
  getMask(t) {
    if (t instanceof jn$1) {
      if (this.id2Value[t.id] == null)
        throw new E(`Nonexistent key: ${t.name}`);
      return this.id2Mask[t.id];
    } else {
      const e = this.name2Id[t];
      if (e == null)
        throw new E(`Feed dict has no SymbolicTensor name: ${t}`);
      return this.id2Mask[e];
    }
  }
  /** Dispose all mask Tensors held by this object. */
  disposeMasks() {
    this.id2Mask != null && yt$1(this.id2Mask);
  }
}
const gl = new j0(), bl = new j0();
function HG(n) {
  gl != null && gl.setMaxEntries(n), bl != null && bl.setMaxEntries(n);
}
function Ar(n, t, e, s) {
  const o = e == null ? false : e.training, r = Array.isArray(n), i6 = r ? n : [n], a = i6.map((f) => f.name), l = [], c = t.names();
  for (const f of a)
    c.indexOf(f) !== -1 ? l.push(t.getValue(f)) : l.push(null);
  s != null && (s.maxNumTensors = -1 / 0, s.minNumTensors = 1 / 0);
  const u = a.join(",") + "|" + t.names().sort().join(",");
  let d = gl.get(u), h6;
  if (d == null) {
    const f = _G(i6, t);
    d = f.sorted, h6 = f.recipientCounts, gl.put(u, d), bl.put(u, h6);
  }
  h6 = {}, o || Object.assign(h6, bl.get(u));
  const p6 = new Gs(t);
  for (let f = 0; f < d.length; ++f) {
    if (s != null) {
      const N = cl().numTensors;
      N > s.maxNumTensors && (s.maxNumTensors = N), N < s.minNumTensors && (s.minNumTensors = N);
    }
    const m = d[f], g6 = m.sourceLayer;
    if (g6 instanceof Ia)
      continue;
    const b6 = [], x6 = [], w6 = [];
    let y6 = false;
    for (const N of m.inputs) {
      const R = p6.getValue(N), M6 = p6.getMask(N);
      b6.push(R), x6.push(M6), M6 != null && (y6 = true), o || (h6[N.name]--, h6[N.name] === 0 && !t.hasKey(N) && a.indexOf(N.name) === -1 && !R.isDisposed && N.sourceLayer.stateful !== true && w6.push(R));
    }
    y6 && (e = e || {}, e.mask = x6[0]);
    const I = Zt(g6.apply(b6, e));
    let C6 = null;
    g6.supportsMasking && (C6 = g6.computeMask(b6, x6));
    const k7 = YG(m), S = Array.isArray(k7) ? k7 : [k7];
    for (let N = 0; N < S.length; ++N) {
      p6.hasKey(S[N]) || p6.add(S[N], I[N], Array.isArray(C6) ? C6[0] : C6);
      const R = a.indexOf(S[N].name);
      R !== -1 && (l[R] = I[N]);
    }
    o || yt$1(w6);
  }
  return p6.disposeMasks(), r ? l : l[0];
}
function _G(n, t) {
  v(n != null && n.length > 0, () => "Expected at least one fetch, got none");
  let e = [], s = {};
  if (n.length === 1) {
    const o = Tm(n[0], t);
    e = o.sorted, s = o.recipientMap;
  } else {
    const o = /* @__PURE__ */ new Set();
    for (const r of n) {
      const { sorted: i6, recipientMap: a } = Tm(r, t);
      for (const l of i6)
        o.has(l.name) || (e.push(l), o.add(l.name));
      for (const l in a)
        s[l] == null && (s[l] = /* @__PURE__ */ new Set()), a[l].forEach((c) => s[l].add(c));
    }
  }
  return {
    sorted: e,
    recipientCounts: UG(s)
  };
}
function UG(n) {
  const t = {};
  for (const e in n)
    t[e] = n[e].size;
  return t;
}
function Tm(n, t) {
  const e = /* @__PURE__ */ new Set(), s = [], o = {};
  for (const a of t.names())
    e.add(a);
  const r = [], i6 = [];
  for (r.push(n); r.length > 0; ) {
    const a = r[r.length - 1];
    if (e.has(a.name)) {
      r.pop();
      continue;
    }
    const l = i6[i6.length - 1] === r.length - 1;
    if (a.inputs.length === 0 || l)
      r.pop(), s.push(a), e.add(a.name), l && i6.pop();
    else {
      i6.push(r.length - 1);
      for (const c of a.inputs)
        o[c.name] == null && (o[c.name] = /* @__PURE__ */ new Set()), o[c.name].add(a.name), !e.has(c.name) && r.push(c);
    }
  }
  return { sorted: s, recipientMap: o };
}
function YG(n) {
  let t;
  if (n.sourceLayer.inboundNodes.length === 1)
    t = n.sourceLayer.output;
  else {
    let e = null;
    for (let s = 0; s < n.sourceLayer.inboundNodes.length; ++s)
      for (const o of n.sourceLayer.inboundNodes[s].outputTensors)
        if (o.id === n.id) {
          e = s;
          break;
        }
    t = n.sourceLayer.getOutputAt(e);
  }
  return t;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const QG = F();
QG.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", () => 100, HG);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function mf$1(n, t) {
  return D(() => De$1(at(G(n, n), t, true)));
}
class Ca extends Vo {
  getConfig() {
    return {};
  }
}
class gx extends Ca {
  constructor(t) {
    super(), this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = t.maxValue != null ? t.maxValue : this.defaultMaxValue, this.axis = t.axis != null ? t.axis : this.defaultAxis;
  }
  apply(t) {
    return D(() => {
      const e = mf$1(t, this.axis), s = pn$1(e, 0, this.maxValue);
      return G(t, ut(s, U(ue(), e)));
    });
  }
  getConfig() {
    return { maxValue: this.maxValue, axis: this.axis };
  }
}
gx.className = "MaxNorm";
_(gx);
class bx extends Ca {
  constructor(t) {
    super(), this.defaultAxis = 0, this.axis = t.axis != null ? t.axis : this.defaultAxis;
  }
  apply(t) {
    return D(() => ut(t, U(ue(), mf$1(t, this.axis))));
  }
  getConfig() {
    return { axis: this.axis };
  }
}
bx.className = "UnitNorm";
_(bx);
class xx extends Ca {
  apply(t) {
    return ws(t);
  }
}
xx.className = "NonNeg";
_(xx);
class yx extends Ca {
  constructor(t) {
    super(), this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = t.minValue != null ? t.minValue : this.defaultMinValue, this.maxValue = t.maxValue != null ? t.maxValue : this.defaultMaxValue, this.rate = t.rate != null ? t.rate : this.defaultRate, this.axis = t.axis != null ? t.axis : this.defaultAxis;
  }
  apply(t) {
    return D(() => {
      const e = mf$1(t, this.axis), s = U(G(this.rate, pn$1(e, this.minValue, this.maxValue)), G(1 - this.rate, e));
      return G(t, ut(s, U(ue(), e)));
    });
  }
  getConfig() {
    return {
      minValue: this.minValue,
      maxValue: this.maxValue,
      rate: this.rate,
      axis: this.axis
    };
  }
}
yx.className = "MinMaxNorm";
_(yx);
const Nm = {
  maxNorm: "MaxNorm",
  minMaxNorm: "MinMaxNorm",
  nonNeg: "NonNeg",
  unitNorm: "UnitNorm"
};
function he$1(n) {
  return sf$1(n);
}
function Rm(n, t = {}) {
  return ba(n, an$1.getMap().classNameMap, t, "constraint");
}
function pe(n) {
  if (n == null)
    return null;
  if (typeof n == "string") {
    const e = { className: n in Nm ? Nm[n] : n, config: {} };
    return Rm(e);
  } else
    return n instanceof Ca ? n : Rm(n);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
async function eo(n) {
  if (n == null)
    return;
  const t = [], e = [], s = [];
  for (const o in n) {
    const r = n[o];
    if (typeof r != "number") {
      const i6 = r;
      t.push(i6.data()), e.push(o), s.push(i6);
    }
  }
  if (t.length > 0) {
    const o = await Promise.all(t);
    for (let r = 0; r < o.length; ++r)
      n[e[r]] = o[r][0];
    yt$1(s);
  }
}
function wx(n) {
  if (n != null)
    for (const t in n) {
      const e = n[t];
      typeof e != "number" && e.dispose();
    }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
var $m;
(function(n) {
  n[n.SILENT = 0] = "SILENT", n[n.VERBOSE = 1] = "VERBOSE";
})($m || ($m = {}));
const JG = 125;
let ei$1 = class ei {
  constructor() {
    this.validationData = null;
  }
  setParams(t) {
    this.params = t;
  }
  async onEpochBegin(t, e) {
  }
  async onEpochEnd(t, e) {
  }
  async onBatchBegin(t, e) {
  }
  async onBatchEnd(t, e) {
  }
  async onTrainBegin(t) {
  }
  async onTrainEnd(t) {
  }
  // LayersModel needs to call Callback.setModel(), but cannot actually depend
  // on Callback because that creates a cyclic dependency.  Providing this no-op
  // method on BaseCallback breaks the cycle: this way LayersModel can depend on
  // BaseCallback but not on Callback.  The argument is typed as `Container`
  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback
  // overrides this method and enforces that the argument is really a
  // LayersModel.
  setModel(t) {
  }
};
class jG {
  // TODO(cais): When the need arises, uncomment the following lines and
  // implement the queue for time values.
  // private deltaTBatch: number;
  // private deltaTsBatchBegin: Array<number>;
  // private deltaTsBatchEnd: Array<number>;
  /**
   * Constructor of CallbackList.
   * @param callbacks Array of `Callback` instances.
   * @param queueLength Queue length for keeping running statistics over
   *   callback execution time.
   */
  constructor(t, e = 10) {
    t == null && (t = []), this.callbacks = t, this.queueLength = e;
  }
  append(t) {
    this.callbacks.push(t);
  }
  setParams(t) {
    for (const e of this.callbacks)
      e.setParams(t);
  }
  setModel(t) {
    for (const e of this.callbacks)
      e.setModel(t);
  }
  /**
   * Called at the start of an epoch.
   * @param epoch Index of epoch.
   * @param logs Dictionary of logs.
   */
  async onEpochBegin(t, e) {
    e == null && (e = {});
    for (const s of this.callbacks)
      await s.onEpochBegin(t, e);
  }
  /**
   * Called at the end of an epoch.
   * @param epoch Index of epoch.
   * @param logs Dictionary of logs.
   */
  async onEpochEnd(t, e) {
    e == null && (e = {});
    for (const s of this.callbacks)
      await s.onEpochEnd(t, e);
  }
  /**
   * Called  right before processing a batch.
   * @param batch Index of batch within the current epoch.
   * @param logs Dictionary of logs.
   */
  async onBatchBegin(t, e) {
    e == null && (e = {});
    for (const s of this.callbacks)
      await s.onBatchBegin(t, e);
  }
  /**
   * Called at the end of a batch.
   * @param batch Index of batch within the current epoch.
   * @param logs Dictionary of logs.
   */
  async onBatchEnd(t, e) {
    e == null && (e = {});
    for (const s of this.callbacks)
      await s.onBatchEnd(t, e);
  }
  /**
   * Called at the beginning of training.
   * @param logs Dictionary of logs.
   */
  async onTrainBegin(t) {
    t == null && (t = {});
    for (const e of this.callbacks)
      await e.onTrainBegin(t);
  }
  /**
   * Called at the end of training.
   * @param logs Dictionary of logs.
   */
  async onTrainEnd(t) {
    t == null && (t = {});
    for (const e of this.callbacks)
      await e.onTrainEnd(t);
  }
}
class qG extends ei$1 {
  constructor() {
    super();
  }
  async onEpochBegin(t) {
    this.seen = 0, this.totals = {};
  }
  async onBatchEnd(t, e) {
    e == null && (e = {});
    const s = e.size == null ? 0 : e.size;
    this.seen += s;
    for (const o in e) {
      const r = e[o];
      if (typeof r == "number")
        this.totals.hasOwnProperty(o) || (this.totals[o] = 0), this.totals[o] = this.totals[o] + r * s;
      else {
        let i6;
        o in this.totals ? i6 = this.totals[o] : this.totals[o] = 0;
        const a = D(() => U(this.totals[o], G(r, s)));
        this.totals[o] = a, i6 != null && i6.dispose();
      }
    }
  }
  async onEpochEnd(t, e) {
    if (e != null)
      for (const s of this.params.metrics)
        this.totals[s] != null && (typeof this.totals[s] == "number" ? e[s] = this.totals[s] / this.seen : D(() => {
          const o = G(ut(1, this.seen), this.totals[s]);
          e[s] = o, this.totals[s].dispose(), cn$1(e[s]);
        }));
  }
}
class tE extends ei$1 {
  async onTrainBegin(t) {
    this.epoch = [], this.history = {};
  }
  async onEpochEnd(t, e) {
    e == null && (e = {}), this.epoch.push(t);
    for (const s in e)
      this.history[s] == null && (this.history[s] = []), this.history[s].push(e[s]);
  }
  /**
   * Await the values of all losses and metrics.
   */
  async syncData() {
    const t = [], e = [], s = [];
    for (const r in this.history) {
      const i6 = this.history[r];
      for (let a = 0; a < i6.length; ++a)
        if (typeof i6[a] != "number") {
          const l = i6[a];
          t.push(l.data()), e.push(r), s.push(a);
        }
    }
    const o = await Promise.all(t);
    for (let r = 0; r < o.length; ++r)
      this.history[e[r]][s[r]].dispose(), this.history[e[r]][s[r]] = o[r][0];
  }
}
class eE extends ei$1 {
  constructor(t, e) {
    if (super(), this.currentEpoch = 0, this.nowFunc = t.nowFunc, this.nextFrameFunc = t.nextFrameFunc || _c, this.yieldEvery = e || "auto", this.yieldEvery === "auto" && (this.yieldEvery = JG), this.yieldEvery === "never" && t.onYield != null)
      throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    nl(this.yieldEvery) && (this.maybeWait = gG(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc)), this.trainBegin = t.onTrainBegin, this.trainEnd = t.onTrainEnd, this.epochBegin = t.onEpochBegin, this.epochEnd = t.onEpochEnd, this.batchBegin = t.onBatchBegin, this.batchEnd = t.onBatchEnd, this.yield = t.onYield;
  }
  async maybeWait(t, e, s) {
    const o = [];
    this.yield != null && (await eo(s), o.push(this.yield(t, e, s))), o.push(this.nextFrameFunc()), await Promise.all(o);
  }
  async onEpochBegin(t, e) {
    this.currentEpoch = t, this.epochBegin != null && (await eo(e), await this.epochBegin(t, e));
  }
  async onEpochEnd(t, e) {
    const s = [];
    this.epochEnd != null && (await eo(e), s.push(this.epochEnd(t, e))), this.yieldEvery === "epoch" && s.push(this.nextFrameFunc()), await Promise.all(s);
  }
  async onBatchBegin(t, e) {
    this.batchBegin != null && (await eo(e), await this.batchBegin(t, e));
  }
  async onBatchEnd(t, e) {
    const s = [];
    this.batchEnd != null && (await eo(e), s.push(this.batchEnd(t, e))), this.yieldEvery === "batch" ? s.push(this.nextFrameFunc()) : nl(this.yieldEvery) && s.push(this.maybeWait(this.currentEpoch, t, e)), await Promise.all(s);
  }
  async onTrainBegin(t) {
    this.trainBegin != null && (await eo(t), await this.trainBegin(t));
  }
  async onTrainEnd(t) {
    this.trainEnd != null && (await eo(t), await this.trainEnd(t));
  }
}
function Ix(n, t) {
  return n == null && (n = {}), n instanceof ei$1 ? [n] : Array.isArray(n) && n[0] instanceof ei$1 ? n : Zt(n).map((s) => new eE(s, t));
}
let xn$1 = class xn {
  /**
   * Blocks public access to constructor.
   */
  constructor() {
  }
  /**
   * Register a tf.LayersModel.fit() callback constructor.
   *
   * The registered callback constructor will be used to instantiate
   * callbacks for every tf.LayersModel.fit() call afterwards.
   *
   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`
   *   is to be reigstered.
   * @param callbackConstructor A no-arg constructor for `tf.Callback`.
   * @throws Error, if the same callbackConstructor has been registered before,
   *   either at the same or a different `verbosityLevel`.
   */
  static registerCallbackConstructor(t, e) {
    v(t >= 0 && Number.isInteger(t), () => `Verbosity level is expected to be an integer >= 0, but got ${t}`), xn.checkForDuplicate(e), xn.constructors[t] == null && (xn.constructors[t] = []), xn.constructors[t].push(e);
  }
  static checkForDuplicate(t) {
    for (const e in xn.constructors)
      xn.constructors[+e].forEach((o) => {
        if (o === t)
          throw new E("Duplicate callback constructor.");
      });
  }
  /**
   * Clear all registered callback constructors.
   */
  static clear() {
    xn.constructors = {};
  }
  /**
   * Create callbacks using the registered callback constructors.
   *
   * Given `verbosityLevel`, all constructors registered at that level or above
   * will be called and the instantiated callbacks will be used.
   *
   * @param verbosityLevel: Level of verbosity.
   */
  static createCallbacks(t) {
    const e = [];
    for (const s in xn.constructors) {
      const o = +s;
      t >= o && e.push(...xn.constructors[o]);
    }
    return e.map((s) => new s());
  }
};
xn$1.constructors = {};
function Cx(n, t, e, s, o, r, i6, a, l) {
  const c = new tE(), u = [
    new qG(),
    ...xn$1.createCallbacks(t)
  ];
  n != null && u.push(...n), u.push(c);
  const d = new jG(u);
  return d.setParams({
    epochs: e,
    initialEpoch: s,
    samples: o,
    steps: r,
    batchSize: i6,
    verbose: t,
    doValidation: a,
    metrics: l
  }), { callbackList: d, history: c };
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Pn$1(n, t = {}, e = false) {
  return ba(n, an$1.getMap().classNameMap, t, "layer", e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function xl(n, t) {
  return D(() => {
    n.dtype !== "float32" && (n = et(n, "float32"));
    const e = at(ya(n), t, true), s = ua(e.shape, ue()), o = De$1(_s(e, s));
    return ut(n, o);
  });
}
function tu(n, t) {
  return D(() => se(ya(lt(t, n)), -1));
}
function gf$1(n, t) {
  return D(() => se(fe$1(lt(t, n)), -1));
}
function bf$1(n, t) {
  return D(() => {
    const e = lt(n, t), s = pn$1(fe$1(n), ue(), Number.MAX_VALUE), o = fe$1(ut(e, s));
    return G(100, se(o, -1));
  });
}
function nE(n, t) {
  return D(() => {
    const e = pn$1(t, ue(), Number.MAX_VALUE), s = Nn$1(U(1, e)), o = pn$1(n, ue(), Number.MAX_VALUE), r = Nn$1(U(1, o));
    return se(ya(lt(s, r)), -1);
  });
}
function sE(n, t) {
  return D(() => {
    const e = _s(0, lt(1, G(n, t)));
    return se(ya(e), -1);
  });
}
function oE(n, t) {
  return D(() => {
    const e = _s(0, lt(1, G(n, t)));
    return se(e, -1);
  });
}
function rE(n, t) {
  return D(() => {
    const e = at(G(n, t), -1), s = Xn$1(G(lt(1, n), t), -1);
    return _s(0, U(1, lt(s, e)));
  });
}
function iE(n, t) {
  return D(() => {
    const e = Math.log(2), s = lt(t, n), o = lt(U(s, da(G(-2, s))), e);
    return se(o, -1);
  });
}
function ni$1(n, t, e = false) {
  return D(() => {
    if (e)
      t = bp(t);
    else {
      const s = at(t, t.shape.length - 1, true);
      t = ut(t, s);
    }
    return t = pn$1(t, ue(), 1 - ue()), jt$1(at(G(et(n, "float32"), Nn$1(t)), t.shape.length - 1));
  });
}
function yl(n, t, e = false) {
  return D(() => {
    const s = et(Ac(RG(n)), "int32");
    t = pn$1(t, ue(), 1 - ue());
    const o = t.shape, r = W(Pb(s, o[o.length - 1]), o);
    return ni$1(r, t, e);
  });
}
function aE(n, t) {
  if (!Rt$1(n.shape, t.shape))
    throw new E(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);
  return D(() => {
    const e = ws(t), s = jt$1(fe$1(t));
    return U(lt(e, G(t, n)), ep(Tn$1(s)));
  });
}
function eu(n, t) {
  return D(() => {
    let e;
    return e = pn$1(t, ue(), 1 - ue()), e = Nn$1(ut(e, lt(1, e))), se(aE(n, e), -1);
  });
}
function lE(n, t) {
  return D(() => {
    const e = pn$1(n, ue(), 1), s = pn$1(t, ue(), 1);
    return at(G(n, Nn$1(ut(e, s))), -1);
  });
}
function cE(n, t) {
  return D(() => {
    const e = Nn$1(U(ue(), t));
    return se(lt(t, G(n, e)), -1);
  });
}
function vx(n, t) {
  return D(() => {
    const e = xl(n, -1), s = xl(t, -1), o = G(e, s);
    return jt$1(at(o, -1));
  });
}
const wl = {
  meanSquaredError: tu,
  meanAbsoluteError: gf$1,
  meanAbsolutePercentageError: bf$1,
  meanSquaredLogarithmicError: nE,
  squaredHinge: sE,
  hinge: oE,
  categoricalHinge: rE,
  logcosh: iE,
  categoricalCrossentropy: ni$1,
  sparseCategoricalCrossentropy: yl,
  binaryCrossentropy: eu,
  kullbackLeiblerDivergence: lE,
  poisson: cE,
  cosineProximity: vx
};
function Tu(n) {
  if (typeof n == "string") {
    if (n in wl)
      return wl[n];
    let t = `Unknown loss ${n}`;
    throw n.toLowerCase().includes("softmaxcrossentropy") && (t = `Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`), new E(t);
  } else
    return n;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Sx(n, t) {
  return D(() => {
    const e = G(0.5, Rn$1(t)), s = es(sn$1(t, e), n.dtype);
    return se(kn$1(n, s), -1);
  });
}
function kx(n, t) {
  return D(() => es(kn$1(Qr(n, -1), Qr(t, -1)), "float32"));
}
function Tx(n, t) {
  return D(() => et(at(ss(kn$1(n, 1), kn$1(t, 1))), "float32"));
}
function uE(n, t) {
  return D(() => et(at(ss(kn$1(n, 1), kn$1(t, 0))), "float32"));
}
function dE(n, t) {
  return D(() => et(at(ss(kn$1(n, 0), kn$1(t, 1))), "float32"));
}
function hE(n, t) {
  return D(() => {
    const e = Tx(n, t), s = dE(n, t), o = U(e, s);
    return et(Oe(sn$1(o, 0), ut(e, o), 0), "float32");
  });
}
function IY(n, t) {
  return D(() => {
    const e = Tx(n, t), s = uE(n, t), o = U(e, s);
    return et(Oe(sn$1(o, 0), ut(e, o), 0), "float32");
  });
}
function pE(n, t) {
  return eu(n, t);
}
function fE(n, t) {
  return n.rank === t.rank && (n = ha(n, [n.rank - 1])), t = Qr(t, -1), t.dtype !== n.dtype && (t = et(t, n.dtype)), et(kn$1(n, t), "float32");
}
const mE = tu, gE = tu, bE = gf$1, xE = gf$1, yE = bf$1, wE = bf$1, Nx = ni$1, IE = vx, Rx = yl, Il = {
  binaryAccuracy: Sx,
  categoricalAccuracy: kx,
  precision: hE,
  categoricalCrossentropy: Nx,
  sparseCategoricalCrossentropy: Rx,
  mse: mE,
  MSE: gE,
  mae: bE,
  MAE: xE,
  mape: yE,
  MAPE: wE,
  cosine: IE
};
function CE(n) {
  if (typeof n == "string" && n in Il)
    return Il[n];
  if (typeof n != "string" && n != null)
    return n;
  throw new E(`Unknown metric ${n}`);
}
function za(n) {
  if (Qn$1(n !== null, `Unknown LossOrMetricFn ${n}`), typeof n == "string")
    return n;
  {
    let t;
    for (const e of Object.keys(wl))
      if (wl[e] === n) {
        t = e;
        break;
      }
    if (t !== void 0)
      return t;
    for (const e of Object.keys(Il))
      if (Il[e] === n) {
        t = e;
        break;
      }
    return t !== void 0 ? t : n.name;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function vE(n) {
  const t = {
    Adagrad: () => Ko.adagrad(0.01),
    Adadelta: () => Ko.adadelta(1, 0.95, ue()),
    Adam: () => Ko.adam(1e-3, 0.9, 0.999, ue()),
    Adamax: () => Ko.adamax(2e-3, 0.9, 0.999, ue(), 0),
    RMSProp: () => Ko.rmsprop(1e-3, 0.9, 0, ue()),
    SGD: () => Ko.sgd(0.01)
  };
  if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, n in t)
    return t[n]();
  throw new E(`Unknown Optimizer ${n}`);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const Gm = 1 * 1024 * 1024;
function Em(n, t, e = false) {
  if (n == null || typeof n != "object" || Object.getPrototypeOf(n) !== Object.prototype || !Nd$1(n))
    throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
  if (e) {
    const s = JSON.stringify(n);
    s.length > Gm && console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Gm}.`);
  }
}
function Nd$1(n) {
  if (n === null)
    return true;
  if (typeof n == "object")
    if (Object.getPrototypeOf(n) === Object.prototype) {
      const t = Object.keys(n);
      for (const e of t)
        if (typeof e != "string" || !Nd$1(n[e]))
          return false;
      return true;
    } else if (Array.isArray(n)) {
      for (const t of n)
        if (!Nd$1(t))
          return false;
      return true;
    } else
      return false;
  else {
    const t = typeof n;
    return t === "string" || t === "number" || t === "boolean";
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function SE(n, t, e, s = console.log) {
  const o = TE(n), r = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
  o ? (t = t || 90, e = e || [0.32, 0.61, 0.89, 1]) : (t = t || 115, e = e || [0.24, 0.48, 0.7, 0.8, 1]), e[e.length - 1] <= 1 && (e = e.map((u) => Math.floor(t * u)));
  let i6;
  if (!o) {
    r.push("Receives inputs"), i6 = [];
    for (const u in n.nodesByDepth)
      i6.push(...n.nodesByDepth[u]);
  }
  s("_".repeat(t)), Cl(r, e, s), s("=".repeat(t));
  const a = n.layers;
  for (let u = 0; u < a.length; ++u)
    o ? NE(a[u], e, s) : RE(a[u], e, i6, s), s((u === a.length - 1 ? "=" : "_").repeat(t));
  n.checkTrainableWeightsConsistency();
  const l = kE(n), c = ml(n.nonTrainableWeights);
  s(`Total params: ${l + c}`), s(`Trainable params: ${l}`), s(`Non-trainable params: ${c}`), s("_".repeat(t));
}
function kE(n) {
  let t;
  return n.collectedTrainableWeights != null ? t = ml(n.collectedTrainableWeights) : t = ml(n.trainableWeights), t;
}
function TE(n) {
  let t = true;
  const e = [], s = [];
  for (const o in n.nodesByDepth)
    e.push(n.nodesByDepth[o]);
  for (const o of e) {
    if (o.length > 1 || o.length === 1 && o[0].inboundLayers.length > 1) {
      t = false;
      break;
    }
    s.push(...o);
  }
  if (t)
    for (const o of n.layers) {
      let r = false;
      for (const i6 of o.inboundNodes)
        if (s.indexOf(i6) !== -1)
          if (r) {
            t = false;
            break;
          } else
            r = true;
      if (!t)
        break;
    }
  return t;
}
function Cl(n, t, e = console.log) {
  let s = "";
  for (let o = 0; o < n.length; ++o)
    o > 0 && (s = s.slice(0, s.length - 1) + " "), s += n[o], s = s.slice(0, t[o]), s += " ".repeat(t[o] - s.length);
  e(s);
}
function NE(n, t, e) {
  let s, o;
  try {
    o = n.inboundNodes.map((l) => JSON.stringify(l.inputShapes)).join(",");
  } catch {
    o = "multiple";
  }
  try {
    s = JSON.stringify(n.outputShape);
  } catch {
    s = "multiple";
  }
  const r = n.name, i6 = n.getClassName(), a = [
    `${r} (${i6})`,
    o,
    s,
    n.countParams().toString()
  ];
  Cl(a, t, e);
}
function RE(n, t, e, s) {
  let o, r;
  try {
    r = n.inboundNodes.map((d) => JSON.stringify(d.inputShapes)).join(",");
  } catch {
    r = "multiple";
  }
  try {
    o = JSON.stringify(n.outputShape);
  } catch {
    o = "multiple";
  }
  const i6 = [];
  for (const d of n.inboundNodes)
    if (!(e != null && e.length > 0 && e.indexOf(d) === -1))
      for (let h6 = 0; h6 < d.inboundLayers.length; ++h6) {
        const p6 = d.inboundLayers[h6].name, f = d.nodeIndices[h6], m = d.tensorIndices[h6];
        i6.push(`${p6}[${f}][${m}]`);
      }
  const a = n.name, l = n.getClassName(), c = i6.length === 0 ? "" : i6[0], u = [
    `${a} (${l})`,
    r,
    o,
    n.countParams().toString(),
    c
  ];
  Cl(u, t, s);
  for (let d = 1; d < i6.length; ++d)
    Cl(["", "", "", "", i6[d]], t, s);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function $x(n, t, e) {
  return (n === "inboundNodes" || n === "outputLayers" || n === "inputLayers") && t === 0 && typeof e == "string";
}
function si$1(n, t) {
  if (n === null)
    return null;
  if (typeof n == "string")
    return ro(n);
  if (typeof n == "number" || typeof n == "boolean")
    return n;
  if (n instanceof Array) {
    const e = [], s = n.length;
    for (let o = 0; o < s; ++o) {
      const r = n[o];
      $x(t, o, r) ? e.push(r) : e.push(si$1(r, t));
    }
    return e;
  } else {
    const e = {};
    for (const s of Object.keys(n)) {
      const o = n[s];
      if (s === "name" && typeof o == "string")
        e[s] = o;
      else {
        const r = ro(s);
        e[r] = si$1(o, r);
      }
    }
    return e;
  }
}
function Rd$1(n, t) {
  if (n == null)
    return null;
  if (typeof n == "string")
    return cs(n);
  if (typeof n == "number" || typeof n == "boolean")
    return n;
  if (n instanceof Array) {
    const e = [], s = n.length;
    for (let o = 0; o < s; ++o) {
      const r = n[o];
      $x(t, o, r) ? e.push(r) : e.push(Rd$1(r, t));
    }
    return e;
  } else {
    const e = {};
    for (const s of Object.keys(n)) {
      const o = n[s], r = cs(s);
      (s === "name" || s === "className") && typeof o == "string" ? e[r] = o : e[r] = Rd$1(o, s);
    }
    return e;
  }
}
/** @license See the LICENSE file. */
const Gx = "4.2.0";
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let Wn$1 = class Wn extends St$1 {
  constructor(t) {
    if (super({}), this.containerNodes = /* @__PURE__ */ new Set(), this.name = t.name, this.name == null) {
      const x6 = this.getClassName().toLowerCase();
      this.name = Jc(x6);
    }
    if (this.supportsMasking = false, this.trainable_ = true, Array.isArray(t.inputs) ? this.inputs = t.inputs.slice() : this.inputs = [t.inputs], Array.isArray(t.outputs) ? this.outputs = t.outputs.slice() : this.outputs = [t.outputs], Ws(this.inputs).length !== this.inputs.length)
      throw new E(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((x6) => x6.name)}`);
    Ws(this.outputs).length !== this.outputs.length && console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((x6) => x6.name)}`), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];
    for (const x6 of this.outputs) {
      const w6 = x6.sourceLayer, y6 = x6.nodeIndex, I = x6.tensorIndex;
      this.outputLayers.push(w6), this.outputLayersNodeIndices.push(y6), this.outputLayersTensorIndices.push(I);
    }
    for (const x6 of this.inputs) {
      const w6 = x6.sourceLayer, y6 = x6.nodeIndex, I = x6.tensorIndex;
      Qn$1(y6 === 0, "input layer has >1 nodes"), Qn$1(I === 0, "input layer has >1 tensors"), this.inputLayers.push(w6), this.inputLayersNodeIndices.push(y6), this.inputLayersTensorIndices.push(I);
    }
    this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];
    for (let x6 = 0; x6 < this.inputLayers.length; x6++) {
      const w6 = this.inputLayers[x6];
      if (!(w6 instanceof Ia))
        throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${x6} (0-based) originates from layer type ${w6.getClassName()}.`);
      this.inputNames.push(w6.name), this.feedInputShapes.push(w6.batchInputShape), this.feedInputNames.push(w6.name);
    }
    for (const x6 of this.outputLayers)
      this.outputNames.push(x6.name);
    this.internalInputShapes = this.inputs.map((x6) => x6.shape), this.internalOutputShapes = this.outputs.map((x6) => x6.shape);
    const e = {}, s = {}, o = {}, r = {}, i6 = {}, a = [], l = (x6, w6, y6, I, C6, k7) => {
      (I == null || C6 == null || k7 == null) && (I = x6.sourceLayer, C6 = x6.nodeIndex, k7 = x6.tensorIndex);
      const S = I.inboundNodes[C6];
      if (y6.indexOf(S) !== -1)
        throw new Cn$1(`The tensor ${x6.name} at layer "${I.name}" is part of a cycle.`);
      if (w6.indexOf(S) !== -1)
        return;
      this.containerNodes.add(Wn.nodeKey(I, C6)), I.id in i6 || (i6[I.id] = Object.keys(i6).length), y6.indexOf(S) === -1 && y6.push(S);
      const N = S.inboundLayers.length;
      for (let R = 0; R < N; R++) {
        const M6 = S.inputTensors[R], V = S.inboundLayers[R], z = S.nodeIndices[R], X = S.tensorIndices[R];
        l(M6, w6, y6, V, z, X);
      }
      for (w6.push(S); y6.indexOf(S) >= 0; )
        y6.splice(y6.indexOf(S), 1);
      a.push(S);
    }, c = [], u = [];
    for (const x6 of this.outputs)
      l(x6, c, u);
    const d = a.slice().reverse();
    for (const x6 of d) {
      s[x6.id] = x6, x6.id in e || (e[x6.id] = 0);
      let w6 = e[x6.id];
      const y6 = o[x6.outboundLayer.id] == null ? 0 : o[x6.outboundLayer.id];
      w6 = Math.max(w6, y6), o[x6.outboundLayer.id] = w6, r[x6.outboundLayer.id] = x6.outboundLayer, e[x6.id] = w6;
      for (let I = 0; I < x6.inboundLayers.length; I++) {
        const C6 = x6.inboundLayers[I], k7 = x6.nodeIndices[I], S = C6.inboundNodes[k7], N = e[S.id] == null ? 0 : e[S.id];
        e[S.id] = Math.max(w6 + 1, N), s[S.id] = S;
      }
    }
    const h6 = {};
    for (const x6 in e) {
      const w6 = e[x6];
      w6 in h6 || (h6[w6] = []), h6[w6].push(s[x6]);
    }
    const p6 = {};
    for (const x6 in o) {
      const w6 = o[x6];
      w6 in p6 || (p6[w6] = []), p6[w6].push(r[x6]);
    }
    let f = Object.keys(p6).map((x6) => parseInt(x6, 10)).sort(Da);
    this.layers = [];
    for (const x6 of f) {
      const w6 = p6[x6];
      w6.sort((y6, I) => {
        const C6 = i6[y6.id], k7 = i6[I.id];
        return C6 < k7 ? -1 : C6 > k7 ? 1 : 0;
      });
      for (const y6 of w6)
        y6 instanceof Wn && this.internalContainerRefs.push(y6), this.layers.push(y6);
    }
    this.layersByDepth = p6, f = Object.keys(h6).map((x6) => parseInt(x6, 10)).sort(Da);
    const m = this.inputs.slice(), g6 = [];
    for (const x6 of f)
      for (const w6 of h6[x6]) {
        const y6 = w6.outboundLayer;
        if (y6 != null) {
          for (const I of w6.inputTensors)
            if (m.indexOf(I) === -1)
              throw new Cn$1(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${y6.name}". The following previous layers were accessed without issue: ${g6}`);
          for (const I of w6.outputTensors)
            m.push(I);
          g6.push(y6.name);
        }
      }
    this.nodesByDepth = h6;
    const b6 = this.layers.map((x6) => x6.name);
    for (const x6 of b6) {
      const w6 = b6.filter((y6) => y6 === x6).length;
      if (w6 !== 1)
        throw new Cn$1(`The name "${x6}" is used ${w6} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(b6));
    }
    this.outboundNodes = [], this.inboundNodes = [], new qc({
      outboundLayer: this,
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: this.inputs,
      outputTensors: this.outputs,
      inputMasks: this.inputs.map((x6) => null),
      outputMasks: this.outputs.map((x6) => null),
      inputShapes: this.inputs.map((x6) => x6.shape),
      outputShapes: this.outputs.map((x6) => x6.shape)
    }), this.built = true, this._refCount = 1;
  }
  assertNotDisposed() {
    if (this._refCount === 0)
      throw new Error(`Container '${this.name}' is already disposed.`);
  }
  /**
   * Attempt to dispose a LayersModel's weights.
   *
   * This method decrease the reference count of the LayersModel object by 1.
   *
   * A LayersModel is reference-counted. Its reference count is incremented by 1
   * when it is first constructed and when it is used as a Layer of another
   * LayersModel.
   *
   * If the reference count of a LayersModel becomes 0, the `dispose` method of
   * all its constituent `Layer`s will be called.
   *
   * Note: If the reference count is greater than 0 after the decrement, the
   * `dispose` method of its constituent `Layer`s will *not* be called.
   *
   * After a LayersModel is disposed, it cannot be used in calls such as
   * 'predict`, `evaluate` or `fit` anymore.
   *
   * @returns A DisposeResult Object with the following fields:
   *   - refCountAfterDispose: The reference count of the LayersModel after this
   *     `dispose()` call.
   *   - numDisposedVariables: Number of `tf.Variable`s (i.e., weights) disposed
   *     during this `dispose()` call.
   * @throws {Error} If the layer is not built yet, or if the LayersModel has
   *   already been disposed.
   */
  dispose() {
    this.assertNotDisposed();
    const t = { refCountAfterDispose: null, numDisposedVariables: 0 };
    if (--this._refCount === 0) {
      for (const e of this.layers)
        t.numDisposedVariables += e.dispose().numDisposedVariables;
      for (const e of this.internalContainerRefs)
        t.numDisposedVariables += e.dispose().numDisposedVariables;
    }
    return t.refCountAfterDispose = this._refCount, t;
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(t) {
    this.layers.forEach((e) => {
      e._trainableWeights.forEach((s) => s.trainable = t);
    }), this.trainable_ = t;
  }
  get trainableWeights() {
    if (this._trainableWeights.length > 0)
      throw new E("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
    if (!this.trainable)
      return [];
    let t = [];
    for (const e of this.layers)
      t = t.concat(e.trainableWeights);
    return t;
  }
  get nonTrainableWeights() {
    const t = [];
    for (const e of this.layers)
      t.push(...e.nonTrainableWeights);
    if (!this.trainable) {
      const e = [];
      for (const s of this.layers)
        e.push(...s.trainableWeights);
      return e.concat(t);
    }
    return t;
  }
  get weights() {
    return this.trainableWeights.concat(this.nonTrainableWeights);
  }
  /**
   * Loads all layer weights from a JSON object.
   *
   * Porting Note: HDF5 weight files cannot be directly loaded in JavaScript /
   *   TypeScript. The utility script at `scripts/pykeras.py` offers means
   *   to convert them into JSON strings compatible with this method.
   * Porting Note: TensorFlow.js Layers supports only loading by name currently.
   *
   * @param weights A JSON mapping weight names to weight values as nested
   *   arrays of numbers, or a `NamedTensorMap`, i.e., a JSON mapping weight
   *   names to `tf.Tensor` objects.
   * @param strict Require that the provided weights exactly match those
   *   required by the container.  Default: `true`.  Passing `false` means that
   *   extra weights and missing weights will be silently ignored.
   */
  loadWeights(t, e = true) {
    const s = {};
    let o = 0;
    for (const i6 of this.layers)
      for (const a of i6.weights) {
        if (s[a.originalName] != null)
          throw new E(`Duplicate weight name: ${a.originalName}`);
        s[a.originalName] = a, o++;
      }
    const r = [];
    for (const i6 in t) {
      let a = i6;
      if (s[i6] == null) {
        const l = i6.split("/");
        a = l.slice(0, -2).concat([l[l.length - 1]]).join("/");
      }
      if (s[a] != null)
        r.push([s[a], t[i6]]);
      else if (e)
        throw new E(`Provided weight data has no target variable: ${i6}`);
      delete s[a];
    }
    if (e) {
      const i6 = [];
      for (const a in s)
        i6.push(a);
      if (i6.length > 0)
        throw new E(`${i6.length} of ${o} weights are not set: ${i6}`);
    }
    ff$1(r);
  }
  /**
   * Util shared between different serialization methods.
   * @returns LayersModel config with Keras version information added.
   */
  updatedConfig() {
    const t = this.getConfig(), e = {};
    return e.className = this.getClassName(), e.config = t, e.kerasVersion = `tfjs-layers ${Gx}`, e.backend = "TensorFlow.js", e;
  }
  /**
   * Returns a JSON string containing the network configuration.
   *
   * To load a network from a JSON save file, use
   * models.modelFromJSON(jsonString);
   * @param extraJsonArgs Unused in tfjs-layers, maintained for PyKeras
   * @param returnString Whether the return value should be stringified
   *    (default: `true`).
   * @returns a JSON string if `returnString` (default), or a JSON object if
   *   `!returnString`.
   */
  // tslint:disable-next-line:no-any
  toJSON(t, e = true) {
    const s = Rd$1(this.updatedConfig());
    return e ? JSON.stringify(s) : s;
  }
  /**
   * Call the model on new inputs.
   *
   * In this case `call` just reapplies all ops in the graph to the new inputs
   * (e.g. build a new computational graph from the provided inputs).
   *
   * @param inputs A tensor or list of tensors.
   * @param mask A mask or list of masks. A mask can be either a tensor or null
   *   (no mask).
   *
   * @return A tensor if there is a single output, or a list of tensors if there
   *   are more than one outputs.
   */
  call(t, e) {
    return D(() => {
      t = Zt(t);
      const s = new Gs();
      for (let o = 0; o < this.inputs.length; ++o)
        s.add(this.inputs[o], t[o]);
      return Ar(this.outputs, s, e);
    });
  }
  /**
   * Computes an output mask tensor.
   *
   * @param inputs Tensor or list of tensors.
   * @param mask Tensor or list of tensors.
   *
   * @return null or a tensor (or list of tensors, one per output tensor of the
   * layer).
   */
  computeMask(t, e) {
    return D(() => {
      t = Zt(t);
      let s;
      return e == null ? s = Ro(null, t.length) : s = Zt(e), this.runInternalGraph(t, s)[1];
    });
  }
  /**
   * Computes the output shape of the layer.
   *
   * Assumes that the layer will be built to match that input shape provided.
   *
   * @param inputShape A shape (tuple of integers) or a list of shape tuples
   *   (one per output tensor of the layer). Shape tuples can include null for
   *   free dimensions, instead of an integer.
   */
  computeOutputShape(t) {
    const e = fl(t);
    if (e.length !== this.inputLayers.length)
      throw new E(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);
    const s = {};
    for (let a = 0; a < e.length; a++) {
      const l = this.inputLayers[a], c = e[a], u = l.name + "_0_0";
      s[u] = c;
    }
    const o = Object.keys(this.nodesByDepth).map((a) => parseInt(a, 10)).sort(Da);
    if (o.length > 1)
      for (const a of o) {
        const l = this.nodesByDepth[a];
        for (const c of l) {
          const u = c.outboundLayer;
          if (this.inputLayers.map((m) => m.id).indexOf(u.id) !== -1)
            continue;
          const d = [];
          for (let m = 0; m < c.inboundLayers.length; m++) {
            const g6 = c.inboundLayers[m], b6 = c.nodeIndices[m], x6 = c.tensorIndices[m], w6 = `${g6.name}_${b6}_${x6}`, y6 = s[w6];
            d.push(y6);
          }
          const h6 = u.computeOutputShape(Pe$1(d)), p6 = fl(h6), f = u.inboundNodes.indexOf(c);
          for (let m = 0; m < p6.length; m++) {
            const g6 = `${u.name}_${f}_${m}`;
            s[g6] = p6[m];
          }
        }
      }
    const r = [], i6 = [];
    for (let a = 0; a < this.outputLayers.length; a++) {
      const l = this.outputLayers[a], c = this.outputLayersNodeIndices[a], u = this.outputLayersTensorIndices[a], d = `${l.name}_${c}_${u}`;
      i6.push(d);
    }
    for (let a = 0; a < i6.length; a++) {
      const l = i6[a];
      Qn$1(l in s), r.push(s[l]);
    }
    return Pe$1(r);
  }
  /**
   * Computes output tensors for new inputs.
   *
   * Note:
   *   - Expects `inputs` to be a list (potentially with 1 element).
   *
   * @param inputs List of tensors
   * @param masks List of masks (tensors or null).
   * @return Three lists: outputTensors, outputMasks, outputShapes
   */
  runInternalGraph(t, e) {
    e == null && (e = Ro(null, t.length));
    const s = {};
    for (let l = 0; l < this.inputs.length; ++l) {
      const c = this.inputs[l], u = t[l], d = e[l];
      s[c.id] = [u, d];
    }
    const o = Object.keys(this.nodesByDepth).map((l) => parseInt(l, 10)).sort(Da);
    for (const l of o) {
      const c = this.nodesByDepth[l];
      for (const u of c) {
        const d = u.outboundLayer, h6 = u.inputTensors, p6 = u.outputTensors, f = new Array();
        for (const m of h6)
          m.id in s && f.push(s[m.id]);
        if (f.length === h6.length) {
          let m = {}, g6, b6, x6, w6;
          if (u.callArgs != null && (m = u.callArgs), f.length === 1) {
            const [y6, I] = f[0];
            m.mask == null && (m.mask = I), x6 = Zt(d.call(y6, m)), w6 = Zt(d.computeMask(y6, I)), g6 = [y6], b6 = [I];
          } else
            g6 = f.map((y6) => y6[0]), b6 = f.map((y6) => y6[1]), m.mask == null && (m.mask = b6), x6 = Zt(d.call(g6, m)), w6 = Zt(d.computeMask(g6, b6));
          if (d.activityRegularizer)
            throw new xt$1("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
          for (let y6 = 0; y6 < p6.length; ++y6) {
            const I = p6[y6], C6 = x6[y6], k7 = w6[y6];
            s[I.id] = [C6, k7];
          }
        }
      }
    }
    const r = [], i6 = [], a = [];
    for (const l of this.outputs) {
      Qn$1(l.id in s, `Could not compute output ${l.name} : ${l.id}`);
      const [c, u] = s[l.id];
      a.push(c.shape), r.push(c), i6.push(u);
    }
    return [r, i6, a];
  }
  /**
   * Builds a map of internal node keys to node ordering.
   * Used in serializaion a node orderings may change as unused nodes are
   * dropped. Porting Note:  This helper method was pulled out of getConfig to
   * improve readability.
   * @param layers An array of Layers in the model.
   * @returns Map of Node Keys to index order within the layer.
   */
  buildNodeConversionMap(t) {
    const e = {};
    let s;
    for (const o of this.layers) {
      s = o instanceof Wn ? 1 : 0;
      for (let r = 0; r < o.inboundNodes.length; r++) {
        const i6 = Wn.nodeKey(o, r);
        this.containerNodes.has(i6) && (e[i6] = s, s += 1);
      }
    }
    return e;
  }
  /**
   * Retrieves a layer based on either its name (unique) or index.
   *
   * Indices are based on order of horizontal graph traversal (bottom-up).
   *
   * If both `name` and `index` are specified, `index` takes precedence.
   *
   * @param name Name of layer.
   * @param index Index of layer.
   * @returns A Layer instance.
   * @throws ValueError: In case of invalid layer name or index.
   *
   * @doc {
   *    heading: 'Layers',
   *    subheading: 'Classes',
   *    namespace: 'layers',
   *    subclasses: ['LayersModel']
   * }
   */
  getLayer(t, e) {
    if (e != null) {
      if (this.layers.length <= e)
        throw new E(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);
      return this.layers[e];
    } else if (t == null)
      throw new E("Provide either a layer name or layer index");
    for (const s of this.layers)
      if (s.name === t)
        return s;
    throw new E(`No such layer: ${t}`);
  }
  /**
   * Retrieves the Container's current loss values.
   *
   * Used for regularizers during training.
   */
  calculateLosses() {
    return D(() => {
      const t = [];
      for (const e of this.layers)
        for (let s = 0; s < e.inboundNodes.length; ++s) {
          const o = Wn.nodeKey(e, s);
          this.containerNodes.has(o) && t.push(...e.calculateLosses());
        }
      return t;
    });
  }
  getConfig() {
    const t = { name: this.name }, e = this.buildNodeConversionMap(this.layers), s = [];
    for (const i6 of this.layers) {
      const a = i6.getClassName(), l = i6.getConfig(), c = [];
      for (let d = 0; d < i6.inboundNodes.length; d++) {
        const h6 = i6.inboundNodes[d], p6 = Wn.nodeKey(i6, d);
        let f = {};
        if (this.containerNodes.has(p6)) {
          if (h6.callArgs)
            try {
              JSON.stringify(h6.callArgs), f = h6.callArgs;
            } catch {
              console.warn(`Layer ${i6.name} was passed non-serializable keyword arguments: ${h6.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`), f = {};
            }
          if (h6.inboundLayers.length > 0) {
            const m = [];
            for (let g6 = 0; g6 < h6.inboundLayers.length; g6++) {
              const b6 = h6.inboundLayers[g6], x6 = h6.nodeIndices[g6], w6 = h6.tensorIndices[g6], y6 = Wn.nodeKey(b6, x6);
              let I = e[y6];
              I == null && (I = 0), m.push([b6.name, I, w6, f]);
            }
            c.push(m);
          }
        }
      }
      const u = {};
      u.name = i6.name, u.className = a, u.config = l, u.inboundNodes = c, s.push(u);
    }
    t.layers = s;
    const o = [];
    for (let i6 = 0; i6 < this.inputLayers.length; i6++) {
      const a = this.inputLayers[i6], l = this.inputLayersNodeIndices[i6], c = Wn.nodeKey(a, l);
      if (!this.containerNodes.has(c))
        continue;
      let u = e[c];
      u == null && (u = 0);
      const d = this.inputLayersTensorIndices[i6];
      o.push([a.name, u, d]);
    }
    t.inputLayers = o;
    const r = [];
    for (let i6 = 0; i6 < this.outputLayers.length; i6++) {
      const a = this.outputLayers[i6], l = this.outputLayersNodeIndices[i6], c = Wn.nodeKey(a, l);
      if (!this.containerNodes.has(c))
        continue;
      let u = e[c];
      u == null && (u = 0);
      const d = this.outputLayersTensorIndices[i6];
      r.push([a.name, u, d]);
    }
    return t.outputLayers = r, t;
  }
  /**
   * Instantiates a LayersModel from its config (output of `get_config()`).
   * @param cls the class to create
   * @param config LayersModel config dictionary.
   * @param customObjects An optional dictionary of custom objects.
   * @param fastWeightInit Optional flag to use fast weight initialization
   *   during deserialization. This is applicable to cases in which
   *   the initialization will be immediately overwritten by loaded weight
   *   values. Default: `false`.
   * @returns A LayersModel instance.
   * @throws ValueError: In case of improperly formatted config dict.
   */
  /** @nocollapse */
  static fromConfig(t, e, s = {}, o = false) {
    const r = {}, i6 = {};
    function a(g6, b6) {
      g6.name in i6 ? i6[g6.name].push(b6) : i6[g6.name] = [b6];
    }
    function l(g6, b6) {
      const x6 = [];
      let w6;
      for (const y6 of b6) {
        const I = y6[0], C6 = y6[1], k7 = y6[2];
        if (w6 = y6[3] == null ? {} : y6[3], !(I in r)) {
          a(g6, b6);
          return;
        }
        const S = r[I];
        if (S.inboundNodes.length <= C6) {
          a(g6, b6);
          return;
        }
        const N = S.inboundNodes[C6];
        x6.push(N.outputTensors[k7]);
      }
      x6.length > 0 && g6.apply(Pe$1(x6), w6);
    }
    function c(g6) {
      const b6 = g6.name, x6 = Pn$1(g6, e.customObjects != null ? e.customObjects : {});
      x6.setFastWeightInitDuringBuild(o), r[b6] = x6, g6.inboundNodes.forEach((y6) => {
        if (!(y6 instanceof Array))
          throw new E(`Corrupted configuration, expected array for nodeData: ${y6}`);
        a(x6, y6);
      });
    }
    const u = e.name, d = e.layers;
    for (const g6 of d)
      c(g6);
    for (; !mG(i6); )
      for (const g6 of d) {
        const b6 = r[g6.name];
        if (b6.name in i6) {
          const x6 = i6[b6.name];
          delete i6[b6.name];
          for (const w6 of x6)
            l(b6, w6);
        }
      }
    const h6 = [], p6 = [], f = e.inputLayers;
    for (const g6 of f) {
      const b6 = g6[0], x6 = g6[1], w6 = g6[2];
      Qn$1(b6 in r);
      const I = r[b6].inboundNodes[x6].outputTensors;
      h6.push(I[w6]);
    }
    const m = e.outputLayers;
    for (const g6 of m) {
      const b6 = g6[0], x6 = g6[1], w6 = g6[2];
      Qn$1(b6 in r);
      const I = r[b6].inboundNodes[x6].outputTensors;
      p6.push(I[w6]);
    }
    return new t({ inputs: h6, outputs: p6, name: u });
  }
  /**
   * Determine whether the container is stateful.
   *
   * Porting Note: this is the equivalent of the stateful @property of
   *   the Container class in PyKeras.
   */
  get stateful() {
    if (this._stateful)
      throw new E("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
    for (const t of this.layers)
      if (t.stateful)
        return true;
    return false;
  }
  /**
   * Reset the state of all stateful constituent layers (if any).
   *
   * Examples of stateful layers include RNN layers whose `stateful` property
   * is set as `true`.
   */
  resetStates() {
    D(() => {
      this.layers.forEach((t) => {
        t.stateful && t.resetStates();
      });
    });
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function $E(n, t, e) {
  const s = t.length;
  if (n == null || Array.isArray(n) && n.length === 0)
    return t.map((o) => null);
  if (s === 1)
    return Array.isArray(n) && n.length === 1 ? n : typeof n == "object" && t[0] in n ? [n[t[0]]] : [n];
  if (Array.isArray(n)) {
    if (n.length !== s)
      throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);
    return n;
  } else if (typeof n == "object" && Object.keys(n).length > 0 && typeof n[Object.keys(n)[0]] == "object") {
    const o = [];
    return t.forEach((r) => {
      r in n ? o.push(n[r]) : o.push(null);
    }), o;
  } else
    throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`);
}
function Ex(n, t) {
  return $E(n, t, "classWeight");
}
async function Lx(n, t, e, s) {
  if (t != null || s != null)
    throw new Error("Support sampleWeight is not implemented yet");
  if (e != null) {
    const o = D(() => {
      if (n.shape.length === 1)
        return po(n);
      if (n.shape.length === 2) {
        if (n.shape[1] > 1)
          return Qr(n, 1);
        if (n.shape[1] === 1)
          return W(n, [n.shape[0]]);
        throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
      } else
        throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
    }), r = Array.from(await o.data());
    yt$1(o);
    const i6 = [];
    return r.forEach((a) => {
      if (e[a] == null)
        throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);
      i6.push(e[a]);
    }), Je$1(i6, "float32");
  } else
    return null;
}
function GE(n, t) {
  return G(n, t);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const EE = 32;
function Mx(n, t) {
  let e, s;
  const o = t;
  e = o.xs, s = o.ys, v(e != null && s != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);
  const r = Lm("input", n.inputNames, e), i6 = Lm("output", n.outputNames, s), a = r[0].shape[0];
  v(r.length === n.inputs.length, () => `LayersModel has ${n.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`), v(i6.length === n.outputs.length, () => `LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i6.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);
  for (let l = 0; l < r.length; l++)
    v(r[l].shape[0] === a, () => `Batch size mismatch: input ${n.inputNames[l]} has ${r[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);
  for (let l = 0; l < i6.length; l++)
    v(i6[l].shape[0] === a, () => `Batch size mismatch: output ${n.outputNames[l]} has ${i6[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);
  return { xs: r, ys: i6 };
}
function Lm(n, t, e) {
  if (e instanceof Lt$1)
    return [e];
  if (Array.isArray(e))
    return v(e.length === t.length, () => `Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`), e;
  {
    const s = [];
    for (const o of t) {
      if (e[o] == null)
        throw new E(`The feature data generated by the dataset lacks the required ${n} key '${o}'.`);
      s.push(e[o]);
    }
    return s;
  }
}
function LE(n) {
  if (n.length === 3)
    throw new xt$1("Validation with sample weights is not implemented yet.");
  return { xs: n[0], ys: n[1] };
}
async function ME(n, t, e) {
  const s = e.batchesPerEpoch != null;
  if (v(n.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."), v(e != null, () => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."), v(e.epochs != null && e.epochs > 0 && Number.isInteger(e.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`), v(!s || e.batchesPerEpoch > 0 && Number.isInteger(e.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`), v(
    // tslint:disable-next-line:no-any
    e.validationSplit == null,
    () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."
  ), n.isTraining)
    throw new Error("Cannot start training because another fit() call is ongoing.");
  n.isTraining = true;
  try {
    const o = e.validationData != null;
    let r, i6;
    if (o)
      if (Mm(e.validationData))
        v(e.validationBatches == null || e.validationBatches > 0 && Number.isInteger(e.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);
      else {
        const g6 = LE(e.validationData);
        r = g6.xs, i6 = g6.ys;
      }
    const a = n.makeTrainFunction(), l = n.getDedupedMetricsNames();
    let c;
    o ? c = l.slice().concat(l.map((g6) => "val_" + g6)) : c = l.slice();
    const u = Ix(e.callbacks, e.yieldEvery), d = e.verbose == null ? 1 : e.verbose, { callbackList: h6, history: p6 } = Cx(
      u,
      d,
      e.epochs,
      null,
      null,
      WE(t, e),
      null,
      // Batch size determined by the dataset itself.
      o,
      c
    );
    h6.setModel(n), n.history = p6, await h6.onTrainBegin(), n.stopTraining_ = false;
    let f = e.initialEpoch == null ? 0 : e.initialEpoch, m = await t.iterator();
    for (; f < e.epochs; ) {
      const g6 = {};
      await h6.onEpochBegin(f);
      let b6 = 0, x6 = 0;
      for (s || (m = await t.iterator()); !s || b6 < e.batchesPerEpoch; ) {
        const w6 = await m.next();
        if (s && w6.done) {
          console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${b6} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch * e.epochs} batches). You may need to use the repeat() function when building your dataset.`);
          break;
        }
        if (w6.value != null) {
          const { xs: y6, ys: I } = Mx(n, w6.value), C6 = {};
          C6.batch = x6, C6.size = y6[0].shape[0], await h6.onBatchBegin(x6, C6);
          const k7 = [];
          if (e.classWeight != null) {
            const R = Ex(e.classWeight, n.outputNames);
            for (let M6 = 0; M6 < R.length; ++M6)
              k7.push(await Lx(I[M6], null, R[M6]));
          }
          const S = y6.concat(I).concat(k7), N = a(S);
          yt$1(S);
          for (let R = 0; R < l.length; ++R) {
            const M6 = l[R], V = N[R];
            C6[M6] = V, cn$1(V);
          }
          await h6.onBatchEnd(x6, C6), wx(C6), x6++, b6++;
        }
        if (s ? b6 >= e.batchesPerEpoch : w6.done) {
          if (o) {
            let y6;
            Mm(e.validationData) ? y6 = Zt(await n.evaluateDataset(e.validationData, { batches: e.validationBatches })) : y6 = Zt(n.evaluate(r, i6, {
              batchSize: e.validationBatchSize == null ? EE : e.validationBatchSize,
              verbose: 0
            }));
            for (let I = 0; I < n.metricsNames.length; ++I)
              g6[`val_${n.metricsNames[I]}`] = y6[I];
          }
          break;
        }
        if (n.stopTraining_)
          break;
      }
      if (await h6.onEpochEnd(f, g6), f++, n.stopTraining_)
        break;
    }
    return await h6.onTrainEnd(), await n.history.syncData(), n.history;
  } finally {
    n.isTraining = false;
  }
}
function WE(n, t) {
  let e = null;
  return t.batchesPerEpoch != null ? e = t.batchesPerEpoch : Number.isFinite(n.size) && (e = n.size), e;
}
function Mm(n) {
  return typeof n.iterator == "function";
}
function DE(n) {
  return typeof n.next == "function";
}
async function FE(n, t, e) {
  e = e || {};
  const s = e.batches != null, o = n.testFunction;
  let r = [];
  if (e.verbose > 0)
    throw new xt$1("Verbose mode is not implemented yet.");
  v(!s || e.batches > 0 && Number.isInteger(e.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);
  const i6 = DE(t) ? t : await t.iterator();
  let a = 0, l = 0;
  for (; !s || l < e.batches; ) {
    const c = await i6.next();
    if (r = D(() => {
      if (c.value) {
        const { xs: u, ys: d } = Mx(n, c.value), h6 = u.concat(d), p6 = D(() => o(h6));
        if (yt$1(h6), l === 0)
          for (let m = 0; m < p6.length; ++m)
            r.push(gt$1(0));
        const f = h6[0].shape[0];
        for (let m = 0; m < p6.length; ++m) {
          const g6 = p6[m], b6 = r[m];
          r[m] = D(() => U(r[m], G(f, g6))), l > 0 && yt$1(b6);
        }
        yt$1(p6), a += f, ++l;
      }
      return r;
    }), c.done) {
      s && console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);
      break;
    }
  }
  for (let c = 0; c < r.length; ++c) {
    const u = r[c];
    r[c] = ut(r[c], a), yt$1(u);
  }
  return Pe$1(r);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Nu(n) {
  v(n > 0 && Number.isInteger(n), () => `batchSize is required to be a positive integer, but got ${n}`);
}
function Wr(n, t, e) {
  return n == null ? [null] : Array.isArray(n) ? n.map((s) => mo(s, t, e - t)) : mo(n, t, e - t);
}
function $d$1(n, t) {
  return D(() => n == null ? null : Array.isArray(n) ? n.map((e) => $d$1(e, t)) : ix(n, t.dtype === "int32" ? t : et(t, "int32")));
}
function Ru(n, t) {
  const e = [];
  let s = 0, o = null;
  for (; s < n; )
    o = s + t, o >= n && (o = n), e.push([s, o]), s = o;
  return e;
}
function Wx(n) {
  const t = [];
  n instanceof Lt$1 && (n = [n]);
  for (let e = 0; e < n.length; ++e) {
    const s = n[e];
    if (s.rank === 1)
      t.push(xa(s, 1));
    else {
      if (s.rank === 0)
        throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      t.push(s);
    }
  }
  return t;
}
function Mn$1(n, t) {
  if (n == null)
    return;
  const e = [];
  if (t instanceof Lt$1)
    e.push(t.id);
  else if (Array.isArray(t))
    t.forEach((o) => e.push(o.id));
  else if (t != null)
    for (const o in t) {
      const r = t[o];
      e.push(r.id);
    }
  const s = [];
  if (n instanceof Lt$1)
    e.indexOf(n.id) === -1 && s.push(n);
  else if (Array.isArray(n))
    n.forEach((o) => {
      e.indexOf(o.id) === -1 && s.push(o);
    });
  else if (n != null)
    for (const o in n) {
      const r = n[o];
      e.indexOf(r.id) === -1 && s.push(r);
    }
  s.forEach((o) => {
    o.isDisposed || o.dispose();
  });
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function VE(n) {
  return n instanceof Lt$1;
}
function Gd$1(n) {
  return Array.isArray(n);
}
function Wm(n) {
  return !VE(n) && !Gd$1(n);
}
function Dm(n, t, e, s = true, o = "") {
  if (t == null || t.length === 0) {
    if (n != null) {
      let i6 = false;
      if (Gd$1(n) && n.length > 0)
        i6 = true;
      else if (Wm(n)) {
        for (const a in n)
          if (n.hasOwnProperty(a)) {
            i6 = true;
            break;
          }
      } else
        i6 = true;
      if (i6)
        throw new E(`Error when checking model ${o} expected no data, but got ${n}`);
    }
    return [];
  }
  if (n == null)
    return t.map((i6) => null);
  let r;
  if (Wm(n)) {
    n = n, r = [];
    for (const i6 of t) {
      if (n[i6] == null)
        throw new E(`No data provided for "${i6}". Need data for each key in: ${t}`);
      r.push(n[i6]);
    }
  } else if (Gd$1(n)) {
    if (n = n, n.length !== t.length)
      throw new E(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);
    r = n;
  } else {
    if (n = n, t.length > 1)
      throw new E(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);
    r = [n];
  }
  if (r = Wx(r), e != null)
    for (let i6 = 0; i6 < t.length; ++i6) {
      if (e[i6] == null)
        continue;
      const a = r[i6];
      if (a.shape.length !== e[i6].length)
        throw new E(`Error when checking ${o}: expected ${t[i6]} to have ${e[i6].length} dimension(s). but got array with shape ${a.shape}`);
      for (let l = 0; l < e[i6].length; ++l) {
        if (l === 0 && !s)
          continue;
        const c = a.shape[l], u = e[i6][l];
        if (u != null && u >= 0 && c !== u)
          throw new E(`${o} expected a batch of elements where each example has shape [${e[i6].slice(1, e[i6].length)}] (i.e.,tensor shape [*,${e[i6].slice(1, e[i6].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1, a.shape.length)}] (tensor shape [${a.shape}])`);
      }
    }
  return r;
}
function zE(n, t, e) {
  const s = Ws(n.map((r) => r.shape[0]));
  s.sort();
  const o = Ws(t.map((r) => r.shape[0]));
  if (o.sort(), s.length > 1)
    throw new E(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map((r) => r.shape))}`);
  if (o.length > 1)
    throw new E(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((r) => r.shape))}`);
  if (s.length > 0 && o.length > 0 && !Rt$1(s, o))
    throw new E(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${o[0]} target sample(s).`);
}
function XE(n, t, e) {
  const s = [
    tu,
    eu,
    ni$1
  ];
  for (let o = 0; o < n.length; ++o) {
    const r = n[o], i6 = t[o], a = e[o];
    if (i6 != null) {
      if (i6 === ni$1 && r.shape[r.shape.length - 1] === 1)
        throw new E(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
      if (s.indexOf(i6) !== -1) {
        const l = r.shape.slice(1), c = a.slice(1);
        for (let u = 0; u < l.length; ++u) {
          const d = l[u], h6 = c[u];
          if (h6 != null && d !== h6)
            throw new E(`A target Tensor with shape ${r.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`);
        }
      }
    }
  }
}
function Fm(n, t, e, s = true, o = "") {
  let r;
  if (Array.isArray(n)) {
    if (n.length !== t.length)
      throw new E(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);
    r = n;
  } else {
    if (t.length > 1)
      throw new E(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);
    r = [n];
  }
  if (e != null)
    for (let i6 = 0; i6 < t.length; ++i6) {
      if (e[i6] == null)
        continue;
      const a = r[i6];
      if (a.shape.length !== e[i6].length)
        throw new E(`Error when checking ${o}: expected ${t[i6]} to have ${e[i6].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);
      for (let l = 0; l < e[i6].length; ++l) {
        if (l === 0 && !s)
          continue;
        const c = a.shape[l], u = e[i6][l];
        if (u != null && u !== c)
          throw new E(`Error when checking ${o}: expected ${t[i6]} to have shape ${JSON.stringify(e[i6])} but got array with shape ${JSON.stringify(a.shape)}.`);
      }
    }
}
function PE(n, t) {
  if (n == null || Array.isArray(n) && n.length === 0)
    return t.map((s) => []);
  let e;
  if (typeof n == "string" || typeof n == "function")
    e = [n];
  else if (Array.isArray(n) || typeof n == "object")
    e = n;
  else
    throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);
  if (Array.isArray(e))
    return t.map((s) => e);
  {
    const s = [];
    for (const o of t) {
      let r = e.hasOwnProperty(o) ? e[o] : [];
      Array.isArray(r) || (r = [r]), s.push(r);
    }
    return s;
  }
}
const AE = "layers-model";
class tr extends Wn$1 {
  constructor(t) {
    super(t), this.isTraining = false;
  }
  /**
   * Print a text summary of the model's layers.
   *
   * The summary includes
   * - Name and type of all layers that comprise the model.
   * - Output shape(s) of the layers
   * - Number of weight parameters of each layer
   * - If the model has non-sequential-like topology, the inputs each layer
   *   receives
   * - The total number of trainable and non-trainable parameters of the model.
   *
   * ```js
   * const input1 = tf.input({shape: [10]});
   * const input2 = tf.input({shape: [20]});
   * const dense1 = tf.layers.dense({units: 4}).apply(input1);
   * const dense2 = tf.layers.dense({units: 8}).apply(input2);
   * const concat = tf.layers.concatenate().apply([dense1, dense2]);
   * const output =
   *     tf.layers.dense({units: 3, activation: 'softmax'}).apply(concat);
   *
   * const model = tf.model({inputs: [input1, input2], outputs: output});
   * model.summary();
   * ```
   *
   * @param lineLength Custom line length, in number of characters.
   * @param positions Custom widths of each of the columns, as either
   *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number
   *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to
   *   right-most (i.e., ending) position of a column.
   * @param printFn Custom print function. Can be used to replace the default
   *   `console.log`. For example, you can use `x => {}` to mute the printed
   *   messages in the console.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  summary(t, e, s = console.log) {
    if (!this.built)
      throw new E("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
    SE(this, t, e, s);
  }
  /**
   * Configures and prepares the model for training and evaluation.  Compiling
   * outfits the model with an optimizer, loss, and/or metrics.  Calling `fit`
   * or `evaluate` on an un-compiled model will throw an error.
   *
   * @param args a `ModelCompileArgs` specifying the loss, optimizer, and
   * metrics to be used for fitting and evaluating this model.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  compile(t) {
    if (t.loss == null && (t.loss = []), this.loss = t.loss, typeof t.optimizer == "string")
      this.optimizer_ = vE(t.optimizer), this.isOptimizerOwned = true;
    else {
      if (!(t.optimizer instanceof Ys))
        throw new E("User-defined optimizer must be an instance of tf.Optimizer.");
      this.optimizer_ = t.optimizer, this.isOptimizerOwned = false;
    }
    let e = [];
    if (!Array.isArray(t.loss) && typeof t.loss != "string" && typeof t.loss != "function") {
      t.loss = t.loss;
      for (const i6 in t.loss)
        if (this.outputNames.indexOf(i6) === -1)
          throw new E(`Unknown entry in loss dictionary: "${i6}". Only expected the following keys: ${this.outputNames}`);
      for (const i6 of this.outputNames)
        t.loss[i6] == null && console.warn(`Output "${i6}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i6} during training`), e.push(Tu(t.loss[i6]));
    } else if (Array.isArray(t.loss)) {
      if (t.loss.length !== this.outputs.length)
        throw new E(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);
      e = t.loss.map((a) => Tu(a));
    } else {
      const i6 = Tu(t.loss);
      this.outputs.forEach((a) => {
        e.push(i6);
      });
    }
    this.lossFunctions = e, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
    for (let i6 = 0; i6 < this.outputs.length; ++i6) {
      const a = this.internalOutputShapes[i6], l = this.outputNames[i6];
      this.feedOutputNames.push(l), this.feedOutputShapes.push(a), this.feedLossFns.push(this.lossFunctions[i6]);
    }
    const s = [];
    this.metrics = t.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], fo("loss", () => {
      for (let i6 = 0; i6 < this.outputs.length; ++i6) {
        if (s.indexOf(i6) !== -1)
          continue;
        const a = this.lossFunctions[i6];
        this.outputs.length > 1 && (this.metricsTensors.push([a, i6]), this.metricsNames.push(this.outputNames[i6] + "_loss"));
      }
    });
    const o = PE(t.metrics, this.outputNames), r = (i6, a, l) => {
      this.outputNames.length > 1 && (a = this.outputNames[i6] + "_" + a), this.metricsNames.push(a), this.metricsTensors.push([l, i6]);
    };
    fo("metric", () => {
      for (let i6 = 0; i6 < this.outputs.length; ++i6) {
        if (s.indexOf(i6) !== -1)
          continue;
        const a = o[i6];
        ((c) => {
          const u = "";
          let d, h6, p6;
          for (const f of c) {
            if (typeof f == "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(f) !== -1) {
              const g6 = this.internalOutputShapes[i6];
              g6[g6.length - 1] === 1 || this.lossFunctions[i6] === eu ? ["accuracy", "acc"].indexOf(f) !== -1 ? h6 = Sx : ["crossentropy", "ce"].indexOf(f) !== -1 && (h6 = pE) : this.lossFunctions[i6] === yl ? ["accuracy", "acc"].indexOf(f) !== -1 ? h6 = fE : ["crossentropy", "ce"].indexOf(f) !== -1 && (h6 = Rx) : ["accuracy", "acc"].indexOf(f) !== -1 ? h6 = kx : ["crossentropy", "ce"].indexOf(f) !== -1 && (h6 = Nx);
              let b6;
              ["accuracy", "acc"].indexOf(f) !== -1 ? b6 = "acc" : ["crossentropy", "ce"].indexOf(f) !== -1 && (b6 = "ce"), p6 = h6, d = u + b6;
            } else
              p6 = CE(f), d = u + za(f);
            let m;
            fo(d, () => {
              m = p6;
            }), r(i6, d, m);
          }
        })(a);
      }
    }), this.collectedTrainableWeights = this.trainableWeights;
  }
  /**
   * Check trainable weights count consistency.
   *
   * This will raise a warning if `this.trainableWeights` and
   * `this.collectedTrainableWeights` are inconsistent (i.e., have different
   * numbers of parameters).
   * Inconsistency will typically arise when one modifies `model.trainable`
   * without calling `model.compile()` again.
   */
  checkTrainableWeightsConsistency() {
    this.collectedTrainableWeights != null && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
  }
  /**
   * Returns the loss value & metrics values for the model in test mode.
   *
   * Loss and metrics are specified during `compile()`, which needs to happen
   * before calls to `evaluate()`.
   *
   * Computation is done in batches.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * const result = model.evaluate(
   *     tf.ones([8, 10]), tf.ones([8, 1]), {batchSize: 4});
   * result.print();
   * ```
   *
   * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the
   * model has multiple inputs.
   * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the
   * model has multiple outputs.
   * @param args A `ModelEvaluateArgs`, containing optional fields.
   *
   * @return `Scalar` test loss (if the model has a single output and no
   *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs
   *   and/or metrics). The attribute `model.metricsNames`
   *   will give you the display labels for the scalar outputs.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  evaluate(t, e, s = {}) {
    const o = s.batchSize == null ? 32 : s.batchSize;
    Nu(o);
    const r = true, i6 = this.standardizeUserDataXY(t, e, r, o);
    try {
      const a = i6[0].concat(i6[1]);
      this.makeTestFunction();
      const l = this.testFunction, c = this.testLoop(l, a, o, s.verbose, s.steps);
      return Pe$1(c);
    } finally {
      Mn$1(i6[0], t), Mn$1(i6[1], e);
    }
  }
  // TODO(cais): Add code snippet below once real dataset objects are
  //   available.
  /**
   * Evaluate model using a dataset object.
   *
   * Note: Unlike `evaluate()`, this method is asynchronous (`async`).
   *
   * @param dataset A dataset object. Its `iterator()` method is expected
   *   to generate a dataset iterator object, the `next()` method of which
   *   is expected to produce data batches for evaluation. The return value
   *   of the `next()` call ought to contain a boolean `done` field and a
   *   `value` field. The `value` field is expected to be an array of two
   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former
   *   case is for models with exactly one input and one output (e.g.
   *   a sequential model). The latter case is for models with multiple
   *   inputs and/or multiple outputs. Of the two items in the array, the
   *   first is the input feature(s) and the second is the output target(s).
   * @param args A configuration object for the dataset-based evaluation.
   * @returns Loss and metric values as an Array of `Scalar` objects.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async evaluateDataset(t, e) {
    return this.makeTestFunction(), FE(this, t, e);
  }
  /**
   * Get number of samples provided for training, evaluation or prediction.
   *
   * @param ins Input `tf.Tensor`.
   * @param batchSize Integer batch size, optional.
   * @param steps Total number of steps (batches of samples) before
   * declaring loop finished. Optional.
   * @param stepsName The public API's parameter name for `steps`.
   * @returns Number of samples provided.
   */
  checkNumSamples(t, e, s, o = "steps") {
    let r;
    if (s != null) {
      if (r = null, e != null)
        throw new E(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${e}`);
    } else if (t != null)
      Array.isArray(t) ? r = t[0].shape[0] : r = t.shape[0];
    else
      throw new E(`Either the input data should have a defined shape, or ${o} shoud be specified.`);
    return r;
  }
  /**
   * Execute internal tensors of the model with input data feed.
   * @param inputs Input data feed. Must match the inputs of the model.
   * @param outputs Names of the output tensors to be fetched. Must match
   *   names of the SymbolicTensors that belong to the graph.
   * @returns Fetched values for `outputs`.
   */
  execute(t, e) {
    if (Array.isArray(e) && e.length === 0)
      throw new E("`outputs` is an empty Array, which is not allowed.");
    const s = Array.isArray(e), o = s ? e : [e], r = this.retrieveSymbolicTensors(o), i6 = new Gs();
    if (t instanceof Lt$1 && (t = [t]), Array.isArray(t)) {
      if (t.length !== this.inputs.length)
        throw new E(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
      for (let l = 0; l < this.inputs.length; ++l)
        i6.add(this.inputs[l], t[l]);
    } else
      for (const l of this.inputs) {
        const c = t[l.name];
        if (c == null)
          throw new E(`No value is provided for the model's input ${l.name}`);
        i6.add(l, c);
      }
    const a = Ar(r, i6);
    return s ? a : a[0];
  }
  /**
   * Retrieve the model's internal symbolic tensors from symbolic-tensor names.
   */
  retrieveSymbolicTensors(t) {
    const e = Ro(null, t.length);
    let s = t.length;
    for (const o of this.layers) {
      const r = Array.isArray(o.output) ? o.output : [o.output], i6 = r.map((a) => a.name);
      for (let a = 0; a < t.length; ++a) {
        const l = i6.indexOf(t[a]);
        if (l !== -1 && (e[a] = r[l], s--), s === 0)
          break;
      }
      if (s === 0)
        break;
    }
    if (s > 0) {
      const o = [];
      throw e.forEach((r, i6) => {
        r == null && o.push(t[i6]);
      }), new E(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`);
    }
    return e;
  }
  /**
   * Helper method to loop over some data in batches.
   *
   * Porting Note: Not using the functional approach in the Python equivalent
   *   due to the imperative backend.
   * Porting Note: Does not support step mode currently.
   *
   * @param ins: input data
   * @param batchSize: integer batch size.
   * @param verbose: verbosity model
   * @returns: Predictions as `tf.Tensor` (if a single output) or an `Array` of
   *   `tf.Tensor` (if multipe outputs).
   */
  predictLoop(t, e = 32, s = false) {
    return D(() => {
      const o = this.checkNumSamples(t);
      if (s)
        throw new xt$1("Verbose predictLoop() is not implemented yet.");
      const r = Ru(o, e), i6 = this.outputs.map((a) => []);
      for (let a = 0; a < r.length; ++a)
        D(() => {
          const c = r[a][0], u = r[a][1], d = Wr(t, c, u), h6 = [];
          if (Array.isArray(d))
            for (let f = 0; f < d.length; ++f)
              h6.push({ key: this.inputs[f], value: d[f] });
          else
            h6.push({ key: this.inputs[0], value: d });
          const p6 = new Gs(h6);
          return Ar(this.outputs, p6);
        }).forEach((c, u) => i6[u].push(c));
      return Pe$1(i6.map((a) => Ge$1(a, 0)));
    });
  }
  /**
   * Generates output predictions for the input samples.
   *
   * Computation is done in batches.
   *
   * Note: the "step" mode of predict() is currently not supported.
   *   This is because the TensorFlow.js core backend is imperative only.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.predict(tf.ones([8, 10]), {batchSize: 4}).print();
   * ```
   *
   * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if
   *   the model has multiple inputs.
   * @param args A `ModelPredictArgs` object containing optional fields.
   *
   * @return Prediction results as a `tf.Tensor`(s).
   *
   * @exception ValueError In case of mismatch between the provided input data
   *   and the model's expectations, or in case a stateful model receives a
   *   number of samples that is not a multiple of the batch size.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predict(t, e = {}) {
    const s = Wx(t);
    Fm(s, this.inputNames, this.feedInputShapes, false);
    try {
      const o = e.batchSize == null ? 32 : e.batchSize;
      return Nu(o), this.predictLoop(s, o);
    } finally {
      Mn$1(s, t);
    }
  }
  /**
   * Returns predictions for a single batch of samples.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.predictOnBatch(tf.ones([8, 10])).print();
   * ```
   * @param x: Input samples, as a Tensor (for models with exactly one
   *   input) or an array of Tensors (for models with more than one input).
   * @return Tensor(s) of predictions
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predictOnBatch(t) {
    Fm(t, this.inputNames, this.feedInputShapes, true);
    const e = (Array.isArray(t) ? t[0] : t).shape[0];
    return this.predictLoop(t, e);
  }
  standardizeUserDataXY(t, e, s = true, o) {
    if (this.optimizer_ == null)
      throw new Cn$1("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
    const r = [];
    for (let i6 = 0; i6 < this.feedOutputShapes.length; ++i6) {
      const a = this.feedOutputShapes[i6];
      this.feedLossFns[i6] === yl ? r.push(a.slice(0, a.length - 1).concat([1])) : r.push(a);
    }
    if (t = Dm(t, this.feedInputNames, this.feedInputShapes, false, "input"), e = Dm(e, this.feedOutputNames, r, false, "target"), zE(t, e), XE(e, this.feedLossFns, this.feedOutputShapes), this.stateful && o != null && o > 0 && t[0].shape[0] % o !== 0)
      throw new E(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);
    return [t, e];
  }
  async standardizeUserData(t, e, s, o, r = true, i6) {
    const [a, l] = this.standardizeUserDataXY(t, e, r, i6);
    if (s != null)
      throw new Error("sample weight is not supported yet.");
    let c = null;
    if (o != null) {
      const u = Ex(o, this.outputNames);
      c = [];
      for (let d = 0; d < u.length; ++d)
        c.push(await Lx(l[d], null, u[d]));
    }
    return [a, l, c];
  }
  /**
   * Loop over some test data in batches.
   * @param f A Function returning a list of tensors.
   * @param ins Array of tensors to be fed to `f`.
   * @param batchSize Integer batch size or `null` / `undefined`.
   * @param verbose verbosity mode.
   * @param steps Total number of steps (batches of samples) before
   * declaring test finished. Ignored with the default value of `null` /
   * `undefined`.
   * @returns Array of Scalars.
   */
  testLoop(t, e, s, o = 0, r) {
    return D(() => {
      const i6 = this.checkNumSamples(e, s, r, "steps"), a = [];
      if (o > 0)
        throw new xt$1("Verbose mode is not implemented yet.");
      if (r != null)
        throw new xt$1("steps mode in testLoop() is not implemented yet");
      {
        const l = Ru(i6, s), c = Je$1(On$1(0, i6));
        for (let u = 0; u < l.length; ++u) {
          const d = l[u][0], h6 = l[u][1], p6 = mo(c, d, h6 - d), f = $d$1(e, p6), m = t(f);
          if (u === 0)
            for (let g6 = 0; g6 < m.length; ++g6)
              a.push(gt$1(0));
          for (let g6 = 0; g6 < m.length; ++g6) {
            const b6 = m[g6];
            a[g6] = U(a[g6], G(h6 - d, b6));
          }
        }
        for (let u = 0; u < a.length; ++u)
          a[u] = ut(a[u], i6);
      }
      return a;
    });
  }
  getDedupedMetricsNames() {
    const t = this.metricsNames, e = [];
    for (let s = 0; s < t.length; ++s) {
      const o = t[s];
      let r = o;
      if (wm(t, o) > 1) {
        const i6 = wm(t.slice(0, s), o);
        r += `_${i6}`;
      }
      e.push(r);
    }
    return e;
  }
  /**
   * Creates a function that performs the following actions:
   *
   * 1. computes the losses
   * 2. sums them to get the total loss
   * 3. call the optimizer computes the gradients of the LayersModel's
   *    trainable weights w.r.t. the total loss and update the variables
   * 4. calculates the metrics
   * 5. returns the values of the losses and metrics.
   */
  makeTrainFunction() {
    return (t) => {
      const e = [], s = t.slice(0, this.inputs.length), o = t.slice(this.inputs.length, this.inputs.length + this.outputs.length), r = t.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2), i6 = [], a = () => {
        const d = [];
        for (let m = 0; m < this.inputs.length; ++m)
          d.push({ key: this.inputs[m], value: s[m] });
        const h6 = new Gs(d), p6 = Ar(this.outputs, h6, { training: true });
        let f;
        for (let m = 0; m < this.lossFunctions.length; ++m) {
          const g6 = this.lossFunctions[m];
          let b6 = g6(o[m], p6[m]);
          r[m] != null && (b6 = GE(b6, r[m]));
          const x6 = se(b6);
          e.push(x6), m === 0 ? f = b6 : f = U(f, b6);
        }
        for (let m = 0; m < this.metricsTensors.length; ++m) {
          let g6;
          if (this.outputs.length > 1 && m < this.outputs.length)
            g6 = e[m];
          else {
            const b6 = this.metricsTensors[m][0], x6 = this.metricsTensors[m][1];
            g6 = se(b6(o[x6], p6[x6]));
          }
          cn$1(g6), i6.push(g6);
        }
        return f = se(f), this.calculateLosses().forEach((m) => {
          f = U(f, m);
        }), f;
      }, l = this.collectedTrainableWeights.map((d) => d.read()), c = true;
      return [this.optimizer_.minimize(a, c, l)].concat(i6);
    };
  }
  /**
   * Create a function which, when invoked with an array of `tf.Tensor`s as a
   * batch of inputs, returns the prespecified loss and metrics of the model
   * under the batch of input data.
   */
  makeTestFunction() {
    this.testFunction = (t) => D(() => {
      const e = [];
      let s;
      const o = t.slice(0, this.inputs.length), r = t.slice(this.inputs.length, this.inputs.length + this.outputs.length), i6 = [];
      for (let c = 0; c < this.inputs.length; ++c)
        i6.push({ key: this.inputs[c], value: o[c] });
      const a = new Gs(i6), l = Ar(this.outputs, a);
      for (let c = 0; c < this.lossFunctions.length; ++c) {
        const u = this.lossFunctions[c], d = se(u(r[c], l[c]));
        c === 0 ? s = d : s = U(s, d), e.push(s);
      }
      for (let c = 0; c < this.metricsTensors.length; ++c) {
        const u = this.metricsTensors[c][0], d = this.metricsTensors[c][1], h6 = se(u(r[d], l[d]));
        e.push(h6);
      }
      return e;
    });
  }
  /**
   * Trains the model for a fixed number of epochs (iterations on a
   * dataset).
   *
   * ```js
   * const model = tf.sequential({
   *     layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * for (let i = 1; i < 5 ; ++i) {
   *   const h = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {
   *       batchSize: 4,
   *       epochs: 3
   *   });
   *   console.log("Loss after Epoch " + i + " : " + h.history.loss[0]);
   * }
   * ```
   *
   * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the
   * model has multiple inputs. If all inputs in the model are named, you
   * can also pass a dictionary mapping input names to `tf.Tensor`s.
   * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if
   * the model has multiple outputs. If all outputs in the model are named,
   * you can also pass a dictionary mapping output names to `tf.Tensor`s.
   * @param args A `ModelFitArgs`, containing optional fields.
   *
   * @return A `History` instance. Its `history` attribute contains all
   *   information collected during training.
   *
   * @exception ValueError In case of mismatch between the provided input
   * data and what the model expects.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async fit(t, e, s = {}) {
    if (this.isTraining)
      throw new Error("Cannot start training because another fit() call is ongoing.");
    this.isTraining = true;
    let o, r, i6, a, l, c, u, d, h6;
    try {
      const p6 = s.batchSize == null ? 32 : s.batchSize;
      Nu(p6);
      const f = false, m = await this.standardizeUserData(t, e, s.sampleWeight, s.classWeight, f, p6);
      o = m[0], r = m[1], h6 = m[2];
      let g6 = false, b6;
      if (s.validationData != null && s.validationData.length > 0) {
        if (g6 = true, s.validationData.length === 2)
          l = s.validationData[0], c = s.validationData[1];
        else
          throw s.validationData.length === 3 ? new xt$1("validationData including sample weights is not supported yet.") : new E(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);
        const N = true, R = await this.standardizeUserData(
          l,
          c,
          null,
          /** Unused sample weights. */
          null,
          /** Unused class weights. */
          N,
          p6
        );
        u = R[0], d = R[1], b6 = u.concat(d);
      } else if (s.validationSplit != null && s.validationSplit > 0 && s.validationSplit < 1) {
        g6 = true;
        const N = Math.floor(o[0].shape[0] * (1 - s.validationSplit)), R = o[0].shape[0];
        u = Wr(o, N, R), i6 = o, o = Wr(o, 0, N), d = Wr(r, N, R), a = r, r = Wr(r, 0, N), b6 = u.concat(d);
      } else
        s.validationSteps != null && (g6 = true);
      const x6 = o.concat(r).concat(h6);
      this.checkTrainableWeightsConsistency();
      const w6 = this.makeTrainFunction(), y6 = this.getDedupedMetricsNames();
      let I, C6;
      g6 ? (this.makeTestFunction(), I = this.testFunction, C6 = y6.slice().concat(y6.map((N) => "val_" + N))) : (I = null, b6 = [], C6 = y6.slice());
      const k7 = Ix(s.callbacks, s.yieldEvery);
      return await this.fitLoop(w6, x6, y6, p6, s.epochs, s.verbose, k7, I, b6, s.shuffle, C6, s.initialEpoch, null, null);
    } finally {
      this.isTraining = false, Mn$1(o, t), Mn$1(r, e), Mn$1(i6, t), Mn$1(a, e), Mn$1(u, l), Mn$1(d, c), h6 != null && yt$1(h6);
    }
  }
  /**
   * Abstract fit function for `f(ins)`.
   * @param f A Function returning a list of tensors. For training, this
   *   function is expected to perform the updates to the variables.
   * @param ins List of tensors to be fed to `f`.
   * @param outLabels List of strings, display names of the outputs of `f`.
   * @param batchSize Integer batch size or `== null` if unknown. Default : 32.
   * @param epochs Number of times to iterate over the data. Default : 1.
   * @param verbose Verbosity mode: 0, 1, or 2. Default: 1.
   * @param callbacks List of callbacks to be called during training.
   * @param valF Function to call for validation.
   * @param valIns List of tensors to be fed to `valF`.
   * @param shuffle Whether to shuffle the data at the beginning of every
   * epoch. Default : true.
   * @param callbackMetrics List of strings, the display names of the metrics
   *   passed to the callbacks. They should be the concatenation of the
   *   display names of the outputs of `f` and the list of display names
   *   of the outputs of `valF`.
   * @param initialEpoch Epoch at which to start training (useful for
   *   resuming a previous training run). Default : 0.
   * @param stepsPerEpoch Total number of steps (batches on samples) before
   *   declaring one epoch finished and starting the next epoch. Ignored with
   *   the default value of `undefined` or `null`.
   * @param validationSteps Number of steps to run validation for (only if
   *   doing validation from data tensors). Not applicable for tfjs-layers.
   * @returns A `History` object.
   */
  async fitLoop(t, e, s, o, r, i6, a, l, c, u, d, h6, p6, f) {
    o == null && (o = 32), r == null && (r = 1), u == null && (u = true), h6 == null && (h6 = 0);
    let m = false;
    if (l != null && c != null && (m = true), f != null && (m = true, p6 == null))
      throw new E("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
    const g6 = this.checkNumSamples(e, o, p6, "steps_per_epoch");
    let b6;
    g6 != null && (b6 = On$1(0, g6)), i6 == null && (i6 = 1);
    const { callbackList: x6, history: w6 } = Cx(a, i6, r, h6, g6, p6, o, m, d);
    x6.setModel(this), this.history = w6, await x6.onTrainBegin(), this.stopTraining_ = false;
    for (let y6 = h6; y6 < r; ++y6) {
      await x6.onEpochBegin(y6);
      const I = {};
      if (p6 != null)
        throw new xt$1("stepsPerEpoch mode is not implemented yet.");
      {
        if (u === "batch")
          throw new xt$1("batch shuffling is not implemneted yet");
        u && Pd$1(b6);
        const C6 = Je$1(b6), k7 = Ru(g6, o);
        for (let S = 0; S < k7.length; ++S) {
          const N = {};
          if (await x6.onBatchBegin(S, N), D(() => {
            const R = k7[S][0], M6 = k7[S][1], V = mo(C6, R, M6 - R);
            N.batch = S, N.size = M6 - R;
            const z = $d$1(e, V), X = t(z);
            for (let P6 = 0; P6 < s.length; ++P6) {
              const A6 = s[P6], B6 = X[P6];
              N[A6] = B6, cn$1(B6);
            }
            if (S === k7.length - 1 && m) {
              const P6 = this.testLoop(l, c, o);
              for (let A6 = 0; A6 < s.length; ++A6) {
                const B6 = s[A6], Z = P6[A6];
                cn$1(Z), I["val_" + B6] = Z;
              }
            }
          }), await x6.onBatchEnd(S, N), wx(N), this.stopTraining_)
            break;
        }
        C6.dispose();
      }
      if (await x6.onEpochEnd(y6, I), this.stopTraining_)
        break;
    }
    return await x6.onTrainEnd(), await this.history.syncData(), this.history;
  }
  // TODO(cais): Add code snippet below when it's possible to instantiate
  //   actual dataset objects.
  /**
   * Trains the model using a dataset object.
   *
   * @param dataset A dataset object. Its `iterator()` method is expected
   *   to generate a dataset iterator object, the `next()` method of which
   *   is expected to produce data batches for training. The return value
   *   of the `next()` call ought to contain a boolean `done` field and a
   *   `value` field. The `value` field is expected to be an array of two
   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former
   *   case is for models with exactly one input and one output (e.g.
   *   a sequential model). The latter case is for models with multiple
   *   inputs and/or multiple outputs.
   *   Of the two items in the array, the first is the input feature(s) and
   *   the second is the output target(s).
   * @param args A `ModelFitDatasetArgs`, containing optional fields.
   *
   * @return A `History` instance. Its `history` attribute contains all
   *   information collected during training.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async fitDataset(t, e) {
    return ME(this, t, e);
  }
  /**
   * Runs a single gradient update on a single batch of data.
   *
   * This method differs from `fit()` and `fitDataset()` in the following
   * regards:
   *   - It operates on exactly one batch of data.
   *   - It returns only the loss and metric values, instead of
   *     returning the batch-by-batch loss and metric values.
   *   - It doesn't support fine-grained options such as verbosity and
   *     callbacks.
   *
   * @param x Input data. It could be one of the following:
   *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has
   *     multiple inputs).
   *   - An Object mapping input names to corresponding `tf.Tensor` (if the
   *     model has named inputs).
   * @param y Target data. It could be either a `tf.Tensor` or multiple
   *   `tf.Tensor`s. It should be consistent with `x`.
   * @returns Training loss or losses (in case the model has
   *   multiple outputs), along with metrics (if any), as numbers.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async trainOnBatch(t, e) {
    const s = await this.standardizeUserData(t, e), o = s[0], r = s[1], a = this.makeTrainFunction()(o.concat(r)), l = [];
    for (const c of a) {
      const u = await c.data();
      l.push(u[0]);
    }
    return yt$1(a), Mn$1(s[0], t), Mn$1(s[1], e), Pe$1(l);
  }
  /**
   * Extract weight values of the model.
   *
   * @param config: An instance of `io.SaveConfig`, which specifies
   * model-saving options such as whether only trainable weights are to be
   * saved.
   * @returns A `NamedTensorMap` mapping original weight names (i.e.,
   *   non-uniqueified weight names) to their values.
   */
  getNamedWeights(t) {
    const e = [], s = t != null && t.trainableOnly, o = s ? this.trainableWeights : this.weights, r = this.getWeights(s);
    for (let i6 = 0; i6 < o.length; ++i6)
      s && !o[i6].trainable || e.push({ name: o[i6].originalName, tensor: r[i6] });
    return e;
  }
  /**
   * Setter used for force stopping of LayersModel.fit() (i.e., training).
   *
   * Example:
   *
   * ```js
   * const input = tf.input({shape: [10]});
   * const output = tf.layers.dense({units: 1}).apply(input);
   * const model = tf.model({inputs: [input], outputs: [output]});
   * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});
   * const xs = tf.ones([8, 10]);
   * const ys = tf.zeros([8, 1]);
   *
   * const history = await model.fit(xs, ys, {
   *   epochs: 10,
   *   callbacks: {
   *     onEpochEnd: async (epoch, logs) => {
   *       if (epoch === 2) {
   *         model.stopTraining = true;
   *       }
   *     }
   *   }
   * });
   *
   * // There should be only 3 values in the loss array, instead of 10
   * values,
   * // due to the stopping after 3 epochs.
   * console.log(history.history.loss);
   * ```
   */
  set stopTraining(t) {
    this.stopTraining_ = t;
  }
  get stopTraining() {
    return this.stopTraining_;
  }
  get optimizer() {
    return this.optimizer_;
  }
  set optimizer(t) {
    this.optimizer_ !== t && (this.optimizer_ = t, this.isOptimizerOwned = false);
  }
  dispose() {
    const t = super.dispose();
    if (t.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
      const e = cl().numTensors;
      this.optimizer_.dispose(), t.numDisposedVariables += e - cl().numTensors;
    }
    return t;
  }
  getLossIdentifiers() {
    let t;
    if (typeof this.loss == "string")
      t = cs(this.loss);
    else if (Array.isArray(this.loss)) {
      for (const e of this.loss)
        if (typeof e != "string")
          throw new Error("Serialization of non-string loss is not supported.");
      t = this.loss.map((e) => cs(e));
    } else {
      const e = Object.keys(this.loss);
      t = {};
      const s = this.loss;
      for (const o of e)
        if (typeof s[o] == "string")
          t[o] = cs(s[o]);
        else
          throw new Error("Serialization of non-string loss is not supported.");
    }
    return t;
  }
  getMetricIdentifiers() {
    if (typeof this.metrics == "string" || typeof this.metrics == "function")
      return [cs(za(this.metrics))];
    if (Array.isArray(this.metrics))
      return this.metrics.map((t) => cs(za(t)));
    {
      const t = {};
      for (const e in this.metrics)
        t[e] = cs(za(this.metrics[e]));
      return t;
    }
  }
  getTrainingConfig() {
    return {
      loss: this.getLossIdentifiers(),
      metrics: this.getMetricIdentifiers(),
      optimizer_config: {
        class_name: this.optimizer.getClassName(),
        config: this.optimizer.getConfig()
      }
    };
  }
  loadTrainingConfig(t) {
    if (t.weighted_metrics != null)
      throw new Error("Loading weight_metrics is not supported yet.");
    if (t.loss_weights != null)
      throw new Error("Loading loss_weights is not supported yet.");
    if (t.sample_weight_mode != null)
      throw new Error("Loading sample_weight_mode is not supported yet.");
    const e = si$1(t.optimizer_config), s = Pn$1(e);
    let o;
    if (typeof t.loss == "string")
      o = ro(t.loss);
    else if (Array.isArray(t.loss))
      o = t.loss.map((i6) => ro(i6));
    else if (t.loss != null) {
      o = {};
      for (const i6 in t.loss)
        o[i6] = ro(t.loss[i6]);
    }
    let r;
    if (Array.isArray(t.metrics))
      r = t.metrics.map((i6) => ro(i6));
    else if (t.metrics != null) {
      r = {};
      for (const i6 in t.metrics)
        r[i6] = ro(t.metrics[i6]);
    }
    this.compile({ loss: o, metrics: r, optimizer: s });
  }
  /**
   * Save the configuration and/or weights of the LayersModel.
   *
   * An `IOHandler` is an object that has a `save` method of the proper
   * signature defined. The `save` method manages the storing or
   * transmission of serialized data ("artifacts") that represent the
   * model's topology and weights onto or via a specific medium, such as
   * file downloads, local storage, IndexedDB in the web browser and HTTP
   * requests to a server. TensorFlow.js provides `IOHandler`
   * implementations for a number of frequently used saving mediums, such as
   * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
   * for more details.
   *
   * This method also allows you to refer to certain types of `IOHandler`s
   * as URL-like string shortcuts, such as 'localstorage://' and
   * 'indexeddb://'.
   *
   * Example 1: Save `model`'s topology and weights to browser [local
   * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
   * then load it back.
   *
   * ```js
   * const model = tf.sequential(
   *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
   * console.log('Prediction from original model:');
   * model.predict(tf.ones([1, 3])).print();
   *
   * const saveResults = await model.save('localstorage://my-model-1');
   *
   * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');
   * console.log('Prediction from loaded model:');
   * loadedModel.predict(tf.ones([1, 3])).print();
   * ```
   *
   * Example 2. Saving `model`'s topology and weights to browser
   * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);
   * then load it back.
   *
   * ```js
   * const model = tf.sequential(
   *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
   * console.log('Prediction from original model:');
   * model.predict(tf.ones([1, 3])).print();
   *
   * const saveResults = await model.save('indexeddb://my-model-1');
   *
   * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');
   * console.log('Prediction from loaded model:');
   * loadedModel.predict(tf.ones([1, 3])).print();
   * ```
   *
   * Example 3. Saving `model`'s topology and weights as two files
   * (`my-model-1.json` and `my-model-1.weights.bin`) downloaded from
   * browser.
   *
   * ```js
   * const model = tf.sequential(
   *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
   * const saveResults = await model.save('downloads://my-model-1');
   * ```
   *
   * Example 4. Send  `model`'s topology and weights to an HTTP server.
   * See the documentation of `tf.io.http` for more details
   * including specifying request parameters and implementation of the
   * server.
   *
   * ```js
   * const model = tf.sequential(
   *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});
   * const saveResults = await model.save('http://my-server/model/upload');
   * ```
   *
   * @param handlerOrURL An instance of `IOHandler` or a URL-like,
   * scheme-based string shortcut for `IOHandler`.
   * @param config Options for saving the model.
   * @returns A `Promise` of `SaveResult`, which summarizes the result of
   * the saving, such as byte sizes of the saved artifacts for the model's
   *   topology and weight values.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  async save(t, e) {
    if (typeof t == "string") {
      const c = LC(t);
      if (c.length === 0)
        throw new E(`Cannot find any save handlers for URL '${t}'`);
      if (c.length > 1)
        throw new E(`Found more than one (${c.length}) save handlers for URL '${t}'`);
      t = c[0];
    }
    if (t.save == null)
      throw new E("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    const s = await sm(this.getNamedWeights(e)), o = false, r = null, a = {
      modelTopology: this.toJSON(r, o),
      format: AE,
      generatedBy: `TensorFlow.js tfjs-layers v${Gx}`,
      convertedBy: null
    };
    if ((e == null ? false : e.includeOptimizer) && this.optimizer != null) {
      a.trainingConfig = this.getTrainingConfig();
      const c = "optimizer", { data: u, specs: d } = await sm(await this.optimizer.getWeights(), c);
      s.specs.push(...d), s.data = bb$1([s.data, u]);
    }
    return this.userDefinedMetadata != null && (Em(this.userDefinedMetadata, this.name, true), a.userDefinedMetadata = this.userDefinedMetadata), a.weightData = s.data, a.weightSpecs = s.specs, t.save(a);
  }
  /**
   * Set user-defined metadata.
   *
   * The set metadata will be serialized together with the topology
   * and weights of the model during `save()` calls.
   *
   * @param setUserDefinedMetadata
   */
  setUserDefinedMetadata(t) {
    Em(t, this.name), this.userDefinedMetadata = t;
  }
  /**
   * Get user-defined metadata.
   *
   * The metadata is supplied via one of the two routes:
   *   1. By calling `setUserDefinedMetadata()`.
   *   2. Loaded during model loading (if the model is constructed
   *      via `tf.loadLayersModel()`.)
   *
   * If no user-defined metadata is available from either of the
   * two routes, this function will return `undefined`.
   */
  getUserDefinedMetadata() {
    return this.userDefinedMetadata;
  }
}
tr.className = "Model";
_(tr);
class Dx extends tr {
}
Dx.className = "Functional";
_(Dx);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
async function CY(n, t) {
  "modelTopology" in n || (n = { modelTopology: n }), n = n;
  let e = n.modelTopology;
  e.model_config != null && (e = e.model_config);
  const s = si$1(e), o = Pn$1(s, t);
  if (n.weightsManifest != null) {
    const r = await AN(n.weightsManifest, n.pathPrefix, o.weights.map((a) => a.originalName)), i6 = {};
    for (const a of o.weights)
      i6[a.originalName] = r[a.originalName];
    o.loadWeights(i6), yt$1(r);
  }
  return o;
}
async function vY(n, t) {
  if (t == null && (t = {}), typeof n == "string") {
    const e = MC(n, t);
    if (e.length === 0)
      e.push(HN(n, t));
    else if (e.length > 1)
      throw new E(`Found more than one (${e.length}) load handlers for URL '${n}'`);
    n = e[0];
  }
  return OE(n, void 0, t);
}
async function OE(n, t, e) {
  if (e == null && (e = {}), n.load == null)
    throw new E("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
  const s = await n.load();
  let o = s.modelTopology;
  o.model_config != null && (o = o.model_config);
  const r = e.strict == null ? true : e.strict, i6 = s.weightData != null && s.weightSpecs != null && r, a = Pn$1(si$1(o), t, i6), l = s.trainingConfig;
  if (l != null && a.loadTrainingConfig(l), s.userDefinedMetadata != null && a.setUserDefinedMetadata(s.userDefinedMetadata), s.weightData != null) {
    if (s.weightSpecs == null)
      throw new E("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
    const { modelWeights: c, optimizerWeights: u } = KE(s.weightData, s.weightSpecs);
    a.loadWeights(c, r), a.optimizer != null && u.length > 0 && await a.optimizer.setWeights(u), yt$1(c), yt$1(u.map((d) => d.tensor));
  }
  return a;
}
function KE(n, t) {
  const e = gb$1(n, t), s = {}, o = [];
  return t.forEach((r) => {
    r.group === "optimizer" ? o.push({ name: r.name, tensor: e[r.name] }) : s[r.name] = e[r.name];
  }), { modelWeights: s, optimizerWeights: o };
}
let oi$1 = class oi extends tr {
  constructor(t) {
    if (super({ inputs: [], outputs: [] }), t = t || {}, this.trainable = true, this.built = false, this.name = t.name != null ? t.name : Jc("sequential_"), t.layers != null)
      for (const e of t.layers)
        this.add(e);
  }
  // Helper function to Sequential.add  Throws if the new output shape will be
  // invalid.
  checkShape(t) {
    if (t.inboundNodes[0].outputTensors[0].shape.some((s) => s < 0))
      throw new E(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`);
  }
  /**
   * Adds a layer instance on top of the layer stack.
   *
   * ```js
   *  const model = tf.sequential();
   *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));
   *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));
   *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));
   *  // Note that the untrained model is random at this point.
   *  model.predict(tf.randomNormal([10, 1])).print();
   * ```
   * @param layer Layer instance.
   *
   * @exception ValueError In case the `layer` argument does not know its
   * input shape.
   * @exception ValueError In case the `layer` argument has multiple output
   *   tensors, or is already connected somewhere else (forbidden in
   *   `Sequential` models).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  add(t) {
    const e = t instanceof oi || t instanceof tr;
    let s;
    if (e) {
      if (s = t, s.outputs.length !== 1)
        throw new E("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      if (s.inputs.length !== 1)
        throw new E("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
    }
    if (this.outputs.length === 0) {
      if (t.inboundNodes.length === 0) {
        if (t.batchInputShape == null)
          throw new E("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
        const o = ZG({
          batchShape: t.batchInputShape,
          dtype: t.dtype,
          name: t.name + "_input"
        });
        t.apply(o);
      }
      if (e)
        this.outputs = s.outputs, this.inputs = s.inputs;
      else {
        if (t.inboundNodes.length !== 1)
          throw new E(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);
        if (t.inboundNodes[0].outputTensors.length !== 1)
          throw new E("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(t), this.outputs = [t.inboundNodes[0].outputTensors[0]], this.inputs = mx(this.outputs[0]);
      }
      this.inboundNodes = [], new qc({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        // no model-level masking for now
        inputMasks: Ro(null, this.inputs.length),
        outputMasks: [null],
        inputShapes: this.inputs.map((o) => o.shape),
        outputShapes: this.outputs[0].shape
      });
    } else {
      const o = t.apply(this.outputs[0]);
      if (Array.isArray(o))
        throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
      this.checkShape(t), this.outputs = [o], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
    this.layers.push(t), this.built = false;
  }
  /**
   * Removes the last layer in the model.
   *
   * @exception TypeError if there are no layers in the model.
   */
  pop() {
    if (this.layers.length === 0)
      throw new TypeError("There are no layers in the model.");
    if (this.layers.pop(), this.layers.length === 0)
      this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
    else {
      const t = this.layers.length - 1;
      this.layers[t].outboundNodes = [], this.outputs = [this.layers[t].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
    }
  }
  call(t, e) {
    return this.model == null && this.build(), this.model.call(t, e);
  }
  build(t) {
    if ($t(t), this.inputs.length === 0 || this.outputs.length === 0)
      throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
    this.model = new tr({
      inputs: this.inputs,
      outputs: this.outputs[0],
      name: this.name + "_model"
    }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = true;
  }
  countParams() {
    return this.built || this.build(), super.countParams();
  }
  /**
   * Print a text summary of the Sequential model's layers.
   *
   * The summary includes
   * - Name and type of all layers that comprise the model.
   * - Output shape(s) of the layers
   * - Number of weight parameters of each layer
   * - The total number of trainable and non-trainable parameters of the
   * model.
   *
   * ```js
   * const model = tf.sequential();
   * model.add(
   *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));
   * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
   *
   * model.summary();
   * ```
   *
   * @param lineLength Custom line length, in number of characters.
   * @param positions Custom widths of each of the columns, as either
   *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number
   *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to
   *   right-most (i.e., ending) position of a column.
   * @param printFn Custom print function. Can be used to replace the default
   *   `console.log`. For example, you can use `x => {}` to mute the printed
   *   messages in the console.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  summary(t, e, s = console.log) {
    this.built || this.build(), super.summary(t, e, s);
  }
  /**
   * Sets the weights of the model.
   *
   * @param weights Should be a list of Tensors with shapes and types matching
   *   the output of `model.getWeights()`.
   */
  setWeights(t) {
    this.model == null && this.build(), this.model.setWeights(t);
  }
  /**
   * Returns the loss value & metrics values for the model in test mode.
   *
   * Loss and metrics are specified during `compile()`, which needs to happen
   * before calls to `evaluate()`.
   *
   * Computation is done in batches.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {
   *   batchSize: 4,
   * });
   * result.print();
   * ```
   *
   * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the
   * model has multiple inputs.
   * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the
   * model has multiple outputs.
   * @param args A `ModelEvaluateConfig`, containing optional fields.
   *
   * @return `Scalar` test loss (if the model has a single output and no
   *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs
   *   and/or metrics). The attribute `model.metricsNames`
   *   will give you the display labels for the scalar outputs.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  evaluate(t, e, s = {}) {
    if (!this.built)
      throw new Cn$1("The model needs to be compiled before being used.");
    return this.model.evaluate(t, e, s);
  }
  // TODO(cais): Add code snippet below once real dataset objects are
  //   available.
  /**
   * Evaluate model using a dataset object.
   *
   * Note: Unlike `evaluate()`, this method is asynchronous (`async`).
   *
   * @param dataset A dataset object. Its `iterator()` method is expected
   *   to generate a dataset iterator object, the `next()` method of which
   *   is expected to produce data batches for evaluation. The return value
   *   of the `next()` call ought to contain a boolean `done` field and a
   *   `value` field. The `value` field is expected to be an array of two
   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former
   *   case is for models with exactly one input and one output (e.g.
   *   a sequential model). The latter case is for models with multiple
   *   inputs and/or multiple outputs. Of the two items in the array, the
   *   first is the input feature(s) and the second is the output target(s).
   * @param args A configuration object for the dataset-based evaluation.
   * @returns Loss and metric values as an Array of `Scalar` objects.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async evaluateDataset(t, e) {
    if (!this.built)
      throw new Cn$1("The model needs to be compiled before being used.");
    return this.model.evaluateDataset(t, e);
  }
  /**
   * Generates output predictions for the input samples.
   *
   * Computation is done in batches.
   *
   * Note: the "step" mode of predict() is currently not supported.
   *   This is because the TensorFlow.js core backend is imperative only.
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.predict(tf.ones([2, 10])).print();
   * ```
   *
   * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if
   *   the model has multiple inputs.
   * @param conifg A `ModelPredictConfig` object containing optional fields.
   *
   * @return `tf.Tensor`(s) of predictions.
   *
   * @exception ValueError In case of mismatch between the provided input data
   *   and the model's expectations, or in case a stateful model receives a
   *   number of samples that is not a multiple of the batch size.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predict(t, e = {}) {
    return this.model == null && this.build(), this.model.predict(t, e);
  }
  /**
   * Returns predictions for a single batch of samples.
   *
   * @param x: Input samples, as a Tensor, or list of Tensors (if the model
   *   has multiple inputs).
   * @return Tensor(s) of predictions
   */
  predictOnBatch(t) {
    return this.model == null && this.build(), this.model.predictOnBatch(t);
  }
  /**
   * See `LayersModel.compile`.
   *
   * @param args
   */
  compile(t) {
    this.build(), this.model.compile(t), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
  }
  get optimizer() {
    return this.model == null ? void 0 : this.model.optimizer;
  }
  set optimizer(t) {
    this.model.optimizer = t;
  }
  /**
   * Trains the model for a fixed number of epochs (iterations on a dataset).
   *
   * ```js
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {
   *   batchSize: 4,
   *   epochs: 3
   * });
   * console.log(history.history.loss[0]);
   * ```
   *
   * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the
   * model has multiple inputs. If all inputs in the model are named, you can
   * also pass a dictionary mapping input names to `tf.Tensor`s.
   * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if
   * the model has multiple outputs. If all outputs in the model are named, you
   *  can also pass a dictionary mapping output names to `tf.Tensor`s.
   * @param args  A `ModelFitConfig`, containing optional fields.
   *
   * @return A `History` instance. Its `history` attribute contains all
   *   information collected during training.
   *
   * @exception ValueError In case of mismatch between the provided input data
   *   and what the model expects.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async fit(t, e, s = {}) {
    if (!this.built)
      throw new Cn$1("The model needs to be compiled before being used.");
    return this.model.fit(t, e, s);
  }
  /**
   * Trains the model using a dataset object.
   *
   * ```js
   * const xArray = [
   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],
   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],
   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],
   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],
   * ];
   * const yArray = [1, 1, 1, 1];
   * // Create a dataset from the JavaScript array.
   * const xDataset = tf.data.array(xArray);
   * const yDataset = tf.data.array(yArray);
   * // Zip combines the `x` and `y` Datasets into a single Dataset, the
   * // iterator of which will return an object containing of two tensors,
   * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle
   * // four such samples into a single object, with the same keys now pointing
   * // to tensors that hold 4 examples, organized along the batch dimension.
   * // The call to `shuffle(4)` causes each iteration through the dataset to
   * // happen in a different order.  The size of the shuffle window is 4.
   * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})
   *     .batch(4)
   *     .shuffle(4);
   * const model = tf.sequential({
   *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]
   * });
   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});
   * const history = await model.fitDataset(xyDataset, {
   *   epochs: 4,
   *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}
   * });
   * ```
   *
   * @param dataset A dataset object. Its `iterator()` method is expected to
   *   generate a dataset iterator object, the `next()` method of which is
   *   expected to produce data batches for evaluation. The return value of the
   *   `next()` call ought to contain a boolean `done` field and a `value`
   *   field.
   *
   *   The `value` field is expected to be an object of with fields
   *   `xs` and `ys`, which point to the feature tensor and the target tensor,
   *   respectively. This case is for models with exactly one input and one
   *   output (e.g. a sequential model). For example:
   *   ```js
   *   {value: {xs: xsTensor, ys: ysTensor}, done: false}
   *   ```
   *
   *   If the model has multiple inputs, the `xs` field of `value` should
   *   be an object mapping input names to their respective feature tensors.
   *   For example:
   *   ```js
   *   {
   *     value: {
   *       xs: {
   *         input_1: xsTensor1,
   *         input_2: xsTensor2
   *       },
   *       ys: ysTensor
   *     },
   *     done: false
   *   }
   *   ```
   *   If the model has multiple outputs, the `ys` field of `value` should
   *   be an object mapping output names to their respective target tensors.
   *   For example:
   *   ```js
   *   {
   *     value: {
   *       xs: xsTensor,
   *       ys: {
   *         output_1: ysTensor1,
   *         output_2: ysTensor2
   *       },
   *     },
   *     done: false
   *   }
   *   ```
   * @param args A `ModelFitDatasetArgs`, containing optional fields.
   *
   * @return A `History` instance. Its `history` attribute contains all
   *   information collected during training.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  async fitDataset(t, e) {
    if (!this.built)
      throw new Cn$1("The model needs to be compiled before being used.");
    return this.model.fitDataset(t, e);
  }
  /**
   * Runs a single gradient update on a single batch of data.
   *
   * This method differs from `fit()` and `fitDataset()` in the following
   * regards:
   *   - It operates on exactly one batch of data.
   *   - It returns only the loss and metric values, instead of
   *     returning the batch-by-batch loss and metric values.
   *   - It doesn't support fine-grained options such as verbosity and
   *     callbacks.
   *
   * @param x Input data. It could be one of the following:
   *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has
   *     multiple inputs).
   *   - An Object mapping input names to corresponding `tf.Tensor` (if the
   *     model has named inputs).
   * @param y Target data. It could be either a `tf.Tensor` or multiple
   *   `tf.Tensor`s. It should be consistent with `x`.
   * @returns Training loss or losses (in case the model has
   *   multiple outputs), along with metrics (if any), as numbers.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async trainOnBatch(t, e) {
    return this.model.trainOnBatch(t, e);
  }
  /* See parent class for JsDoc */
  /** @nocollapse */
  static fromConfig(t, e, s = {}, o = false) {
    let r, i6 = {};
    if (e instanceof Array) {
      if (e[0].className == null || e[0].className === "Merge")
        throw new E("Legacy serialization format not supported yet.");
      r = e;
    } else
      v(e.layers != null, () => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."), r = e.layers, delete e.layers, i6 = e;
    const a = new t(i6);
    if (!(a instanceof oi))
      throw new xt$1(`Sequential.fromConfig called on non-Sequential input: ${a}`);
    for (const l of r) {
      const u = Pn$1(l, void 0, o);
      o && u.setFastWeightInitDuringBuild(true), a.add(u);
    }
    return a;
  }
  /**
   * Setter used for force stopping of LayersModel.fit() (i.e., training).
   *
   * Example:
   *
   * ```js
   * const model = tf.sequential();
   * model.add(tf.layers.dense({units: 1, inputShape: [10]}));
   * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});
   * const xs = tf.ones([8, 10]);
   * const ys = tf.zeros([8, 1]);
   *
   * const history = await model.fit(xs, ys, {
   *   epochs: 10,
   *   callbacks: {
   *     onEpochEnd: async (epoch, logs) => {
   *       if (epoch === 2) {
   *         model.stopTraining = true;
   *       }
   *     }
   *   }
   * });
   *
   * // There should be only 3 values in the loss array, instead of 10 values,
   * // due to the stopping after 3 epochs.
   * console.log(history.history.loss);
   * ```
   */
  set stopTraining(t) {
    if (this.model == null)
      throw new E("Cannot set the stopTraining property of a sequential model before it is compiled.");
    this.model.stopTraining = t;
  }
  get stopTraining() {
    if (this.model == null)
      throw new E("Cannot get the stopTraining property of a sequential model before it is compiled.");
    return this.model.stopTraining;
  }
  // TODO(cais): Override get trainableWeights() here
  // tslint:disable-next-line:no-any
  getConfig() {
    const t = [];
    for (const e of this.layers) {
      const s = {};
      s.className = e.getClassName(), s.config = e.getConfig(), t.push(s);
    }
    return { name: this.name, layers: t };
  }
};
oi$1.className = "Sequential";
_(oi$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let He$1 = class He extends Vo {
  getConfig() {
    return {};
  }
};
class Fx extends He$1 {
  /**
   * Calculate the activation function.
   *
   * @param x: Input.
   * @param alpha: Scaling factor the negative section.
   * @return Output of the ELU activation.
   */
  apply(t, e = 1) {
    return GG(t, e);
  }
}
Fx.className = "elu";
_(Fx);
class Vx extends He$1 {
  apply(t) {
    return Bb(t);
  }
}
Vx.className = "selu";
_(Vx);
class zx extends He$1 {
  apply(t) {
    return ws(t);
  }
}
zx.className = "relu";
_(zx);
class Xx extends He$1 {
  apply(t) {
    return D(() => Kc(6, ws(t)));
  }
}
Xx.className = "relu6";
_(Xx);
class Px extends He$1 {
  apply(t) {
    return t;
  }
}
Px.className = "linear";
_(Px);
class Ax extends He$1 {
  apply(t) {
    return xr(t);
  }
}
Ax.className = "sigmoid";
_(Ax);
class Ox extends He$1 {
  apply(t) {
    return LG(t);
  }
}
Ox.className = "hardSigmoid";
_(Ox);
class Kx extends He$1 {
  apply(t) {
    return da(t);
  }
}
Kx.className = "softplus";
_(Kx);
class Zx extends He$1 {
  apply(t) {
    return EG(t);
  }
}
Zx.className = "softsign";
_(Zx);
class Bx extends He$1 {
  apply(t) {
    return Hh$1(t);
  }
}
Bx.className = "tanh";
_(Bx);
let xf$1 = class xf extends He$1 {
  /**
   * Calculate the activation function.
   *
   * @param x Tensor.
   * @param axis Integer, axis along which the softmax normalization is applied.
   * Invalid if < 2, as softmax across 1 (the batch dimension) is assumed to be
   * an error.
   *
   * @returns a Tensor of the same shape as x
   *
   * @throws ValueError: In case `dim(x) < 2`.
   */
  apply(t, e = -1) {
    return bp(t, e);
  }
};
xf$1.className = "softmax";
_(xf$1);
class Hx extends He$1 {
  /**
   * Calculate the activation function of log softmax:
   * log( exp(x_i) / sum(exp(x)) )
   *
   * @param x Tensor.
   * @param axis Integer, axis along which the softmax normalization is applied.
   * Invalid if < 2, as softmax across 1 (the batch dimension) is assumed to be
   * an error.
   *
   * @returns a Tensor of the same shape as x
   *
   * @throws ValueError: In case `dim(x) < 2`.
   */
  apply(t, e = -1) {
    return Vb(t, e);
  }
}
Hx.className = "logSoftmax";
_(Hx);
class _x extends He$1 {
  /**
   * Calculate the activation function.
   *
   * @param x Tensor.
   * @param alpha Scaling factor for the sigmoid function.
   * @returns a Tensor of the same shape as x
   */
  apply(t, e = 1) {
    return D(() => G(xr(G(t, e)), t));
  }
}
_x.className = "swish";
_(_x);
class Ux extends He$1 {
  /**
   * Calculate the activation function.
   *
   * @param x Tensor.
   * @returns a Tensor of the same shape as x
   */
  apply(t) {
    return D(() => G(t, Hh$1(da(t))));
  }
}
Ux.className = "mish";
_(Ux);
function Ps(n) {
  return n.getClassName();
}
function $u(n, t = {}) {
  return ba(n, an$1.getMap().classNameMap, t, "activation");
}
function As(n) {
  if (n == null) {
    const t = {};
    return t.className = "linear", t.config = {}, $u(t);
  }
  if (typeof n == "string") {
    const t = {};
    return t.className = n, t.config = {}, $u(t);
  } else
    return n instanceof He$1 ? n : $u(n);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function yf$1(n) {
  if (n != null && typeof n != "object")
    throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`);
}
class Yx extends Vo {
}
class nu extends Yx {
  constructor(t) {
    super(), yf$1(t), this.l1 = t == null || t.l1 == null ? 0.01 : t.l1, this.l2 = t == null || t.l2 == null ? 0.01 : t.l2, this.hasL1 = this.l1 !== 0, this.hasL2 = this.l2 !== 0;
  }
  /**
   * Porting note: Renamed from __call__.
   * @param x Variable of which to calculate the regularization score.
   */
  apply(t) {
    return D(() => {
      let e = ge$1([1]);
      return this.hasL1 && (e = U(e, at(G(this.l1, fe$1(t))))), this.hasL2 && (e = U(e, at(G(this.l2, ya(t))))), W(e, []);
    });
  }
  getConfig() {
    return { l1: this.l1, l2: this.l2 };
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t({ l1: e.l1, l2: e.l2 });
  }
}
nu.className = "L1L2";
_(nu);
function TY(n) {
  return yf$1(n), new nu({ l1: n != null ? n.l1 : null, l2: 0 });
}
function NY(n) {
  return yf$1(n), new nu({ l2: n != null ? n.l2 : null, l1: 0 });
}
const Vm = {
  l1l2: "L1L2"
};
function Ft$1(n) {
  return sf$1(n);
}
function zm(n, t = {}) {
  return ba(n, an$1.getMap().classNameMap, t, "regularizer");
}
function Yt(n) {
  if (n == null)
    return null;
  if (typeof n == "string") {
    const e = { className: n in Vm ? Vm[n] : n, config: {} };
    return zm(e);
  } else
    return n instanceof Yx ? n : zm(n);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Qx extends St$1 {
  constructor(t) {
    super(t ?? {}), this.supportsMasking = true, t != null && (this.maxValue = t.maxValue);
  }
  call(t, e) {
    t = mt(t);
    let s = ws(t);
    return this.maxValue != null && (s = pn$1(s, 0, this.maxValue)), s;
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = { maxValue: this.maxValue }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
}
Qx.className = "ReLU";
_(Qx);
class Jx extends St$1 {
  constructor(t) {
    super(t ?? {}), this.DEFAULT_ALPHA = 0.3, t == null && (t = {}), this.alpha = t.alpha == null ? this.DEFAULT_ALPHA : t.alpha;
  }
  call(t, e) {
    const s = mt(t);
    return tp(s, this.alpha);
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = { alpha: this.alpha }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
}
Jx.className = "LeakyReLU";
_(Jx);
class jx extends St$1 {
  constructor(t) {
    if (super(t ?? {}), this.DEFAULT_ALPHA_INITIALIZER = "zeros", t == null && (t = {}), this.supportsMasking = true, this.alphaInitializer = Ut(t.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = Yt(t.alphaRegularizer), this.alphaConstraint = pe(t.alphaConstraint), t.sharedAxes == null)
      this.sharedAxes = null;
    else if (Array.isArray(t.sharedAxes))
      this.sharedAxes = t.sharedAxes;
    else if (typeof t.sharedAxes == "number")
      this.sharedAxes = [t.sharedAxes];
    else
      throw new E(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);
  }
  build(t) {
    t = $t(t);
    const e = t.slice(1);
    if (this.sharedAxes != null)
      for (const o of this.sharedAxes)
        e[o - 1] = 1;
    this.alpha = this.addWeight("alpha", e, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
    const s = {};
    if (this.sharedAxes != null)
      for (let o = 1; o < t.length; ++o)
        s[o] = t[o];
    this.inputSpec = [new de({
      ndim: t.length,
      axes: s
    })], this.built = true;
  }
  call(t, e) {
    return t = mt(t), ap(t, this.alpha.read());
  }
  getConfig() {
    const t = {
      alphaInitializer: Jt(this.alphaInitializer),
      alphaRegularizer: Ft$1(this.alphaRegularizer),
      alphaConstraint: he$1(this.alphaConstraint),
      sharedAxes: this.sharedAxes
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
}
jx.className = "PReLU";
_(jx);
let qx = class extends St$1 {
  constructor(t) {
    if (super(t ?? {}), this.DEFAULT_ALPHA = 1, t == null && (t = {}), t.alpha != null && t.alpha !== this.DEFAULT_ALPHA)
      throw new xt$1(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);
    this.alpha = t.alpha == null ? this.DEFAULT_ALPHA : t.alpha;
  }
  call(t, e) {
    const s = mt(t);
    return Xc(s);
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = { alpha: this.alpha }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
qx.className = "ELU";
_(qx);
let ty$1 = class ty extends St$1 {
  constructor(t) {
    super(t ?? {}), this.DEFAULT_THETA = 1, t == null && (t = {}), this.theta = t.theta == null ? this.DEFAULT_THETA : t.theta;
  }
  call(t, e) {
    const s = mt(t);
    return G(s, et(sn$1(s, this.theta), "float32"));
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = { theta: this.theta }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
ty$1.className = "ThresholdedReLU";
_(ty$1);
let ey$1 = class ey extends St$1 {
  constructor(t) {
    super(t ?? {}), this.DEFAULT_AXIS = 1, t == null && (t = {}), this.softmax = new xf$1().apply, this.axis = t.axis == null ? this.DEFAULT_AXIS : t.axis;
  }
  call(t, e) {
    const s = mt(t);
    return this.softmax(s, this.axis);
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = { axis: this.axis }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
ey$1.className = "Softmax";
_(ey$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function er(n, t, e) {
  if (typeof n == "number")
    return Ro(n, t);
  if (n.length !== t)
    throw new E(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);
  for (let s = 0; s < t; ++s) {
    const o = n[s];
    if (!TG(o))
      throw new E(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${o}`);
  }
  return n;
}
function An$1(n, t, e, s, o = 1) {
  if (n == null)
    return n;
  const r = t + (t - 1) * (o - 1);
  let i6;
  return e === "same" ? i6 = n : i6 = n - r + 1, Math.floor((i6 + s - 1) / s);
}
function Jn$1(n, t, e, s) {
  if (n == null)
    return null;
  if (s === "valid")
    n = n * t + Xs([e - t, 0]);
  else if (s === "same")
    n = n * t;
  else
    throw new E(`Unsupport padding mode: ${s}.`);
  return n;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function wf$1(n, t) {
  return D(() => (ae(t), t === "channelsFirst" ? kt(n, [0, 2, 3, 1]) : n));
}
function ny$1(n, t) {
  return D(() => (ae(t), t === "channelsFirst" ? kt(n, [0, 2, 3, 4, 1]) : n));
}
function ZE(n, t, e, s = 1, o = "valid", r, i6 = 1) {
  return D(() => {
    if (r == null && (r = Kn$1()), ae(r), n.shape.length !== 3)
      throw new E(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);
    if (t.shape.length !== 3)
      throw new E(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);
    if (e != null && e.shape.length !== 1)
      throw new E(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);
    if (r === "channelsFirst" && (n = kt(n, [0, 2, 1])), o === "causal")
      throw new xt$1("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    let a = Rb(n, t, s, o === "same" ? "same" : "valid", "NWC", i6);
    return e != null && (a = Hn$1(a, e)), a;
  });
}
function Xm(n, t, e, s = [1, 1], o = "valid", r, i6, a = null) {
  return D(() => {
    if (r == null && (r = Kn$1()), ae(r), n.rank !== 3 && n.rank !== 4)
      throw new E(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);
    if (t.rank !== 3 && t.rank !== 4)
      throw new E(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);
    let l = wf$1(n, r);
    if (o === "causal")
      throw new xt$1("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    return l = lT({
      x: l,
      filter: t,
      strides: s,
      pad: o === "same" ? "same" : "valid",
      dilations: i6,
      dataFormat: "NHWC",
      bias: e,
      activation: a
    }), r === "channelsFirst" && (l = kt(l, [0, 3, 1, 2])), l;
  });
}
function BE(n, t, e, s = [1, 1, 1], o = "valid", r, i6) {
  return D(() => {
    if (r == null && (r = Kn$1()), ae(r), n.rank !== 4 && n.rank !== 5)
      throw new E(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);
    if (t.rank !== 4 && t.rank !== 5)
      throw new E(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);
    let a = ny$1(n, r);
    if (o === "causal")
      throw new xt$1("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
    return a = cv(a, t, s, o === "same" ? "same" : "valid", "NDHWC", i6), e != null && (a = Hn$1(a, e)), r === "channelsFirst" && (a = kt(a, [0, 4, 1, 2, 3])), a;
  });
}
class su extends St$1 {
  constructor(t, e) {
    if (super(e), this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", su.verifyArgs(e), this.rank = t, be$1(this.rank, "rank"), this.rank !== 1 && this.rank !== 2 && this.rank !== 3)
      throw new xt$1(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
    if (this.kernelSize = er(e.kernelSize, t, "kernelSize"), this.strides = er(e.strides == null ? 1 : e.strides, t, "strides"), this.padding = e.padding == null ? "valid" : e.padding, fn$1(this.padding), this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, ae(this.dataFormat), this.activation = As(e.activation), this.useBias = e.useBias == null ? true : e.useBias, this.biasInitializer = Ut(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = pe(e.biasConstraint), this.biasRegularizer = Yt(e.biasRegularizer), this.activityRegularizer = Yt(e.activityRegularizer), this.dilationRate = er(e.dilationRate == null ? 1 : e.dilationRate, t, "dilationRate"), this.rank === 1 && Array.isArray(this.dilationRate) && this.dilationRate.length !== 1)
      throw new E(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    if (this.rank === 2) {
      if (typeof this.dilationRate == "number")
        this.dilationRate = [this.dilationRate, this.dilationRate];
      else if (this.dilationRate.length !== 2)
        throw new E(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    } else if (this.rank === 3) {
      if (typeof this.dilationRate == "number")
        this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
      else if (this.dilationRate.length !== 3)
        throw new E(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
    }
  }
  static verifyArgs(t) {
    if (Qn$1("kernelSize" in t, "required key 'kernelSize' not in config"), typeof t.kernelSize != "number" && !of$1(t.kernelSize, "number", 1, 3))
      throw new E(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`);
  }
  getConfig() {
    const t = {
      kernelSize: this.kernelSize,
      strides: this.strides,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      activation: Ps(this.activation),
      useBias: this.useBias,
      biasInitializer: Jt(this.biasInitializer),
      biasRegularizer: Ft$1(this.biasRegularizer),
      activityRegularizer: Ft$1(this.activityRegularizer),
      biasConstraint: he$1(this.biasConstraint)
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
}
class vr extends su {
  constructor(t, e) {
    super(t, e), this.kernel = null, vr.verifyArgs(e), this.filters = e.filters, be$1(this.filters, "filters"), this.kernelInitializer = Ut(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = pe(e.kernelConstraint), this.kernelRegularizer = Yt(e.kernelRegularizer);
  }
  build(t) {
    t = $t(t);
    const e = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
    if (t[e] == null)
      throw new E(`The channel dimension of the input should be defined. Found ${t[e]}`);
    const s = t[e], o = this.kernelSize.concat([s, this.filters]);
    this.kernel = this.addWeight("kernel", o, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [{ ndim: this.rank + 2, axes: { [e]: s } }], this.built = true;
  }
  call(t, e) {
    return D(() => {
      t = mt(t);
      let s;
      const o = this.bias == null ? null : this.bias.read(), r = tx(this.activation.getClassName());
      if (r != null && this.rank === 2)
        s = Xm(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate, r);
      else {
        if (this.rank === 1)
          s = ZE(t, this.kernel.read(), o, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
        else if (this.rank === 2)
          s = Xm(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate);
        else if (this.rank === 3)
          s = BE(t, this.kernel.read(), o, this.strides, this.padding, this.dataFormat, this.dilationRate);
        else
          throw new xt$1("convolutions greater than 3D are not implemented yet.");
        this.activation != null && (s = this.activation.apply(s));
      }
      return s;
    });
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = [], s = this.dataFormat === "channelsLast" ? t.slice(1, t.length - 1) : t.slice(2);
    for (let r = 0; r < s.length; ++r) {
      const i6 = An$1(s[r], this.kernelSize[r], this.padding, this.strides[r], typeof this.dilationRate == "number" ? this.dilationRate : this.dilationRate[r]);
      e.push(i6);
    }
    let o = [t[0]];
    return this.dataFormat === "channelsLast" ? (o = o.concat(e), o.push(this.filters)) : (o.push(this.filters), o = o.concat(e)), o;
  }
  getConfig() {
    const t = {
      filters: this.filters,
      kernelInitializer: Jt(this.kernelInitializer),
      kernelRegularizer: Ft$1(this.kernelRegularizer),
      kernelConstraint: he$1(this.kernelConstraint)
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
  static verifyArgs(t) {
    if (!("filters" in t) || typeof t.filters != "number" || t.filters < 1)
      throw new E(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`);
  }
}
class va extends vr {
  constructor(t) {
    super(2, t), va.verifyArgs(t);
  }
  getConfig() {
    const t = super.getConfig();
    return delete t.rank, t;
  }
  static verifyArgs(t) {
    if (typeof t.kernelSize != "number" && !of$1(t.kernelSize, "number", 1, 2))
      throw new E(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`);
  }
}
va.className = "Conv2D";
_(va);
class Sa extends vr {
  constructor(t) {
    super(3, t), Sa.verifyArgs(t);
  }
  getConfig() {
    const t = super.getConfig();
    return delete t.rank, t;
  }
  static verifyArgs(t) {
    if (typeof t.kernelSize != "number" && !(Array.isArray(t.kernelSize) && (t.kernelSize.length === 1 || t.kernelSize.length === 3)))
      throw new E(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`);
  }
}
Sa.className = "Conv3D";
_(Sa);
let sy$1 = class sy extends va {
  constructor(t) {
    if (super(t), this.inputSpec = [new de({ ndim: 4 })], this.padding !== "same" && this.padding !== "valid")
      throw new E(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
  }
  build(t) {
    if (t = $t(t), t.length !== 4)
      throw new E("Input should have rank 4; Received input shape: " + JSON.stringify(t));
    const e = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
    if (t[e] == null)
      throw new E("The channel dimension of the inputs should be defined. Found `None`.");
    const s = t[e], o = this.kernelSize.concat([this.filters, s]);
    this.kernel = this.addWeight("kernel", o, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new de({ ndim: 4, axes: { [e]: s } })], this.built = true;
  }
  call(t, e) {
    return D(() => {
      let s = mt(t);
      if (s.shape.length !== 4)
        throw new E(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);
      const o = s.shape, r = o[0];
      let i6, a;
      this.dataFormat === "channelsFirst" ? (i6 = 2, a = 3) : (i6 = 1, a = 2);
      const l = o[i6], c = o[a], u = this.kernelSize[0], d = this.kernelSize[1], h6 = this.strides[0], p6 = this.strides[1], f = Jn$1(l, h6, u, this.padding), m = Jn$1(c, p6, d, this.padding), g6 = [r, f, m, this.filters];
      this.dataFormat !== "channelsLast" && (s = kt(s, [0, 2, 3, 1]));
      let b6 = $b(s, this.kernel.read(), g6, this.strides, this.padding);
      return this.dataFormat !== "channelsLast" && (b6 = kt(b6, [0, 3, 1, 2])), this.bias != null && (b6 = Hn$1(b6, this.bias.read(), this.dataFormat)), this.activation != null && (b6 = this.activation.apply(b6)), b6;
    });
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = t.slice();
    let s, o, r;
    this.dataFormat === "channelsFirst" ? (s = 1, o = 2, r = 3) : (s = 3, o = 1, r = 2);
    const i6 = this.kernelSize[0], a = this.kernelSize[1], l = this.strides[0], c = this.strides[1];
    return e[s] = this.filters, e[o] = Jn$1(e[o], l, i6, this.padding), e[r] = Jn$1(e[r], c, a, this.padding), e;
  }
  getConfig() {
    const t = super.getConfig();
    return delete t.dilationRate, t;
  }
};
sy$1.className = "Conv2DTranspose";
_(sy$1);
let oy$1 = class oy extends Sa {
  constructor(t) {
    if (super(t), this.inputSpec = [new de({ ndim: 5 })], this.padding !== "same" && this.padding !== "valid")
      throw new E(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
  }
  build(t) {
    if (t = $t(t), t.length !== 5)
      throw new E("Input should have rank 5; Received input shape: " + JSON.stringify(t));
    const e = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
    if (t[e] == null)
      throw new E("The channel dimension of the inputs should be defined. Found `None`.");
    const s = t[e], o = this.kernelSize.concat([this.filters, s]);
    this.kernel = this.addWeight("kernel", o, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [new de({ ndim: 5, axes: { [e]: s } })], this.built = true;
  }
  call(t, e) {
    return D(() => {
      let s = mt(t);
      if (s.shape.length !== 5)
        throw new E(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);
      const o = s.shape, r = o[0];
      let i6, a, l;
      this.dataFormat === "channelsFirst" ? (l = 2, i6 = 3, a = 4) : (l = 1, i6 = 2, a = 3);
      const c = o[l], u = o[i6], d = o[a], h6 = this.kernelSize[0], p6 = this.kernelSize[1], f = this.kernelSize[2], m = this.strides[0], g6 = this.strides[1], b6 = this.strides[2], x6 = Jn$1(c, m, h6, this.padding), w6 = Jn$1(u, g6, p6, this.padding), y6 = Jn$1(d, b6, f, this.padding), I = [r, x6, w6, y6, this.filters];
      this.dataFormat !== "channelsLast" && (s = kt(s, [0, 2, 3, 4, 1]));
      let C6 = hv(s, this.kernel.read(), I, this.strides, this.padding);
      return this.dataFormat !== "channelsLast" && (C6 = kt(C6, [0, 4, 1, 2, 3])), this.bias !== null && (C6 = Hn$1(C6, this.bias.read(), this.dataFormat)), this.activation !== null && (C6 = this.activation.apply(C6)), C6;
    });
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = t.slice();
    let s, o, r, i6;
    this.dataFormat === "channelsFirst" ? (s = 1, o = 2, r = 3, i6 = 4) : (s = 4, o = 1, r = 2, i6 = 3);
    const a = this.kernelSize[0], l = this.kernelSize[1], c = this.kernelSize[2], u = this.strides[0], d = this.strides[1], h6 = this.strides[2];
    return e[s] = this.filters, e[o] = Jn$1(e[o], u, a, this.padding), e[r] = Jn$1(e[r], d, l, this.padding), e[i6] = Jn$1(e[i6], h6, c, this.padding), e;
  }
  getConfig() {
    const t = super.getConfig();
    return delete t.dilationRate, t;
  }
};
oy$1.className = "Conv3DTranspose";
_(oy$1);
let ry$1 = class ry extends vr {
  constructor(t, e) {
    if (super(t, e), this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, e.filters == null)
      throw new E("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    if (e.kernelInitializer != null || e.kernelRegularizer != null || e.kernelConstraint != null)
      throw new E("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    if (e.padding != null && e.padding !== "same" && e.padding !== "valid")
      throw new E(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);
    this.depthMultiplier = e.depthMultiplier == null ? 1 : e.depthMultiplier, this.depthwiseInitializer = Ut(e.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = Yt(e.depthwiseRegularizer), this.depthwiseConstraint = pe(e.depthwiseConstraint), this.pointwiseInitializer = Ut(e.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = Yt(e.pointwiseRegularizer), this.pointwiseConstraint = pe(e.pointwiseConstraint);
  }
  build(t) {
    if (t = $t(t), t.length < this.rank + 2)
      throw new E(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(t)}`);
    const e = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
    if (t[e] == null || t[e] < 0)
      throw new E(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);
    const s = t[e], o = this.kernelSize.concat([s, this.depthMultiplier]), r = [];
    for (let a = 0; a < this.rank; ++a)
      r.push(1);
    r.push(s * this.depthMultiplier, this.filters);
    const i6 = true;
    this.depthwiseKernel = this.addWeight("depthwise_kernel", o, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, i6, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", r, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, i6, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, i6, this.biasConstraint) : this.bias = null, this.inputSpec = [new de({ ndim: this.rank + 2, axes: { [e]: s } })], this.built = true;
  }
  call(t, e) {
    return D(() => {
      t = mt(t);
      let s;
      if (this.rank === 1)
        throw new xt$1("1D separable convolution is not implemented yet.");
      return this.rank === 2 && (this.dataFormat === "channelsFirst" && (t = kt(t, [0, 2, 3, 1])), s = Hb(t, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (s = Hn$1(s, this.bias.read(), this.dataFormat)), this.activation != null && (s = this.activation.apply(s)), this.dataFormat === "channelsFirst" && (s = kt(s, [0, 3, 1, 2])), s;
    });
  }
  getConfig() {
    const t = super.getConfig();
    return delete t.rank, delete t.kernelInitializer, delete t.kernelRegularizer, delete t.kernelConstraint, t.depthwiseInitializer = Jt(this.depthwiseInitializer), t.pointwiseInitializer = Jt(this.pointwiseInitializer), t.depthwiseRegularizer = Ft$1(this.depthwiseRegularizer), t.pointwiseRegularizer = Ft$1(this.pointwiseRegularizer), t.depthwiseConstraint = he$1(this.depthwiseConstraint), t.pointwiseConstraint = he$1(this.pointwiseConstraint), t;
  }
};
ry$1.className = "SeparableConv";
let iy$1 = class iy extends ry$1 {
  constructor(t) {
    super(2, t);
  }
};
iy$1.className = "SeparableConv2D";
_(iy$1);
class ou extends vr {
  constructor(t) {
    super(1, t), ou.verifyArgs(t), this.inputSpec = [{ ndim: 3 }];
  }
  getConfig() {
    const t = super.getConfig();
    return delete t.rank, delete t.dataFormat, t;
  }
  static verifyArgs(t) {
    if (typeof t.kernelSize != "number" && !of$1(t.kernelSize, "number", 1, 1))
      throw new E(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`);
  }
}
ou.className = "Conv1D";
_(ou);
let ay$1 = class ay extends St$1 {
  constructor(t) {
    super(t), typeof t.cropping == "number" ? this.cropping = [[t.cropping, t.cropping], [t.cropping, t.cropping]] : typeof t.cropping[0] == "number" ? this.cropping = [
      [t.cropping[0], t.cropping[0]],
      [t.cropping[1], t.cropping[1]]
    ] : this.cropping = t.cropping, this.dataFormat = t.dataFormat === void 0 ? "channelsLast" : t.dataFormat, this.inputSpec = [{ ndim: 4 }];
  }
  computeOutputShape(t) {
    return this.dataFormat === "channelsFirst" ? [
      t[0],
      t[1],
      t[2] - this.cropping[0][0] - this.cropping[0][1],
      t[3] - this.cropping[1][0] - this.cropping[1][1]
    ] : [
      t[0],
      t[1] - this.cropping[0][0] - this.cropping[0][1],
      t[2] - this.cropping[1][0] - this.cropping[1][1],
      t[3]
    ];
  }
  call(t, e) {
    return D(() => {
      if (t = mt(t), this.dataFormat === "channelsLast") {
        const s = Va(t, this.cropping[0][0], t.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
        return Va(s, this.cropping[1][0], t.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
      } else {
        const s = Va(t, this.cropping[0][0], t.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
        return Va(s, this.cropping[1][0], t.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
      }
    });
  }
  getConfig() {
    const t = { cropping: this.cropping, dataFormat: this.dataFormat }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
ay$1.className = "Cropping2D";
_(ay$1);
let ly$1 = class ly extends St$1 {
  constructor(t) {
    super(t), this.DEFAULT_SIZE = [2, 2], this.inputSpec = [{ ndim: 4 }], this.size = t.size == null ? this.DEFAULT_SIZE : t.size, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, ae(this.dataFormat), this.interpolation = t.interpolation == null ? "nearest" : t.interpolation, vG(this.interpolation);
  }
  computeOutputShape(t) {
    if (this.dataFormat === "channelsFirst") {
      const e = t[2] == null ? null : this.size[0] * t[2], s = t[3] == null ? null : this.size[1] * t[3];
      return [t[0], t[1], e, s];
    } else {
      const e = t[1] == null ? null : this.size[0] * t[1], s = t[2] == null ? null : this.size[1] * t[2];
      return [t[0], e, s, t[3]];
    }
  }
  call(t, e) {
    return D(() => {
      let s = mt(t);
      const o = s.shape;
      if (this.dataFormat === "channelsFirst") {
        s = kt(s, [0, 2, 3, 1]);
        const r = this.size[0] * o[2], i6 = this.size[1] * o[3], a = this.interpolation === "nearest" ? uo.resizeNearestNeighbor(s, [r, i6]) : uo.resizeBilinear(s, [r, i6]);
        return kt(a, [0, 3, 1, 2]);
      } else {
        const r = this.size[0] * o[1], i6 = this.size[1] * o[2];
        return this.interpolation === "nearest" ? uo.resizeNearestNeighbor(s, [r, i6]) : uo.resizeBilinear(s, [r, i6]);
      }
    });
  }
  getConfig() {
    const t = {
      size: this.size,
      dataFormat: this.dataFormat,
      interpolation: this.interpolation
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
ly$1.className = "UpSampling2D";
_(ly$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function HE(n, t, e = [1, 1], s = "valid", o, r) {
  return D(() => {
    o == null && (o = Kn$1()), ae(o);
    let i6 = wf$1(n, o);
    if (n.rank !== 4)
      throw new E(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);
    if (t.rank !== 4)
      throw new E(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);
    return i6 = Qh$1(i6, t, e, s === "same" ? "same" : "valid", "NHWC", r), o === "channelsFirst" && (i6 = kt(i6, [0, 3, 1, 2])), i6;
  });
}
let cy$1 = class cy extends su {
  constructor(t) {
    super(2, t), this.depthwiseKernel = null, this.depthMultiplier = t.depthMultiplier == null ? 1 : t.depthMultiplier, this.depthwiseInitializer = Ut(t.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = pe(t.depthwiseConstraint), this.depthwiseRegularizer = Yt(t.depthwiseRegularizer);
  }
  build(t) {
    if (t = $t(t), t.length < 4)
      throw new E(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);
    const e = this.dataFormat === "channelsFirst" ? 1 : 3;
    if (t[e] == null || t[e] < 0)
      throw new E(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);
    const s = t[e], o = [
      this.kernelSize[0],
      this.kernelSize[1],
      s,
      this.depthMultiplier
    ];
    this.depthwiseKernel = this.addWeight("depthwise_kernel", o, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [s * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
  }
  call(t, e) {
    return D(() => {
      t = mt(t);
      let s = HE(t, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
      return this.useBias && (s = Hn$1(s, this.bias.read(), this.dataFormat)), this.activation != null && (s = this.activation.apply(s)), s;
    });
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = this.dataFormat === "channelsFirst" ? t[2] : t[1], s = this.dataFormat === "channelsFirst" ? t[3] : t[2], o = this.dataFormat === "channelsFirst" ? t[1] * this.depthMultiplier : t[3] * this.depthMultiplier, r = An$1(e, this.kernelSize[0], this.padding, this.strides[0]), i6 = An$1(s, this.kernelSize[1], this.padding, this.strides[1]);
    return this.dataFormat === "channelsFirst" ? [t[0], o, r, i6] : [t[0], r, i6, o];
  }
  getConfig() {
    const t = super.getConfig();
    return t.depthMultiplier = this.depthMultiplier, t.depthwiseInitializer = Jt(this.depthwiseInitializer), t.depthwiseRegularizer = Ft$1(this.depthwiseRegularizer), t.depthwiseConstraint = he$1(this.depthwiseRegularizer), t;
  }
};
cy$1.className = "DepthwiseConv2D";
_(cy$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function uy$1(n, t, e, s) {
  if (Array.isArray(n)) {
    if (t != null || e != null)
      throw new E("When inputs is an array, neither initialState or constants should be provided");
    s != null && (e = n.slice(n.length - s, n.length), n = n.slice(0, n.length - s)), n.length > 1 && (t = n.slice(1, n.length)), n = n[0];
  }
  function o(r) {
    return r == null || Array.isArray(r) ? r : [r];
  }
  return t = o(t), e = o(e), { inputs: n, initialState: t, constants: e };
}
function dy$1(n, t, e, s = false, o, r, i6 = false, a = false) {
  return D(() => {
    const l = t.shape.length;
    if (l < 3)
      throw new E(`Input should be at least 3D, but is ${l}D.`);
    const c = [1, 0].concat(On$1(2, l));
    if (t = kt(t, c), r != null)
      throw new xt$1("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    i6 && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), o != null && (o = et(et(o, "bool"), "float32"), o.rank === l - 1 && (o = Ue$1(o, -1)), o = kt(o, c)), s && (t = ko(t, 0), o != null && (o = ko(o, 0)));
    const u = [];
    let d, h6 = e;
    const p6 = t.shape[0], f = To(t);
    let m;
    o != null && (m = To(o));
    for (let b6 = 0; b6 < p6; ++b6) {
      const x6 = f[b6], w6 = D(() => n(x6, h6));
      if (o == null)
        d = w6[0], h6 = w6[1];
      else {
        const y6 = D(() => {
          const I = m[b6], C6 = lt(Rn$1(I), I), k7 = U(G(w6[0], I), G(h6[0], C6)), S = h6.map((N, R) => U(G(w6[1][R], I), G(N, C6)));
          return { output: k7, newStates: S };
        });
        d = y6.output, h6 = y6.newStates;
      }
      a && u.push(d);
    }
    let g6;
    return a && (g6 = os(u, 1)), [d, g6, h6];
  });
}
class Qs extends St$1 {
  constructor(t) {
    super(t);
    let e;
    if (t.cell == null)
      throw new E("cell property is missing for the constructor of RNN.");
    if (Array.isArray(t.cell) ? e = new vf$1({ cells: t.cell }) : e = t.cell, e.stateSize == null)
      throw new E("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    this.cell = e, this.returnSequences = t.returnSequences == null ? false : t.returnSequences, this.returnState = t.returnState == null ? false : t.returnState, this.goBackwards = t.goBackwards == null ? false : t.goBackwards, this._stateful = t.stateful == null ? false : t.stateful, this.unroll = t.unroll == null ? false : t.unroll, this.supportsMasking = true, this.inputSpec = [new de({ ndim: 3 })], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = [];
  }
  // Porting Note: This is the equivalent of `RNN.states` property getter in
  //   PyKeras.
  getStates() {
    if (this.states_ == null) {
      const t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      return On$1(0, t).map((e) => null);
    } else
      return this.states_;
  }
  // Porting Note: This is the equivalent of the `RNN.states` property setter in
  //   PyKeras.
  setStates(t) {
    this.states_ = t;
  }
  computeOutputShape(t) {
    kd$1(t) && (t = t[0]), t = t;
    let e = this.cell.stateSize;
    Array.isArray(e) || (e = [e]);
    const s = e[0];
    let o;
    if (this.returnSequences ? o = [t[0], t[1], s] : o = [t[0], s], this.returnState) {
      const r = [];
      for (const i6 of e)
        r.push([t[0], i6]);
      return [o].concat(r);
    } else
      return o;
  }
  computeMask(t, e) {
    return D(() => {
      Array.isArray(e) && (e = e[0]);
      const s = this.returnSequences ? e : null;
      if (this.returnState) {
        const o = this.states.map((r) => null);
        return [s].concat(o);
      } else
        return s;
    });
  }
  /**
   * Get the current state tensors of the RNN.
   *
   * If the state hasn't been set, return an array of `null`s of the correct
   * length.
   */
  get states() {
    if (this.states_ == null) {
      const t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, e = [];
      for (let s = 0; s < t; ++s)
        e.push(null);
      return e;
    } else
      return this.states_;
  }
  set states(t) {
    this.states_ = t;
  }
  build(t) {
    if (this.numConstants != null)
      throw new xt$1("Constants support is not implemented in RNN yet.");
    kd$1(t) && (t = t[0]), t = t;
    const e = this.stateful ? t[0] : null, s = t.slice(2);
    this.inputSpec[0] = new de({ shape: [e, null, ...s] });
    const o = [t[0]].concat(t.slice(2));
    this.cell.build(o);
    let r;
    if (Array.isArray(this.cell.stateSize) ? r = this.cell.stateSize : r = [this.cell.stateSize], this.stateSpec != null) {
      if (!Rt$1(this.stateSpec.map((i6) => i6.shape[i6.shape.length - 1]), r))
        throw new E(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
    } else
      this.stateSpec = r.map((i6) => new de({ shape: [null, i6] }));
    this.stateful && this.resetStates();
  }
  /**
   * Reset the state tensors of the RNN.
   *
   * If the `states` argument is `undefined` or `null`, will set the
   * state tensor(s) of the RNN to all-zero tensors of the appropriate
   * shape(s).
   *
   * If `states` is provided, will set the state tensors of the RNN to its
   * value.
   *
   * @param states Optional externally-provided initial states.
   * @param training Whether this call is done during training. For stateful
   *   RNNs, this affects whether the old states are kept or discarded. In
   *   particular, if `training` is `true`, the old states will be kept so
   *   that subsequent backpropgataion through time (BPTT) may work properly.
   *   Else, the old states will be discarded.
   */
  resetStates(t, e = false) {
    D(() => {
      if (!this.stateful)
        throw new Yn$1("Cannot call resetStates() on an RNN Layer that is not stateful.");
      const s = this.inputSpec[0].shape[0];
      if (s == null)
        throw new E("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (this.states_ == null)
        Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((o) => ge$1([s, o])) : this.states_ = [ge$1([s, this.cell.stateSize])];
      else if (t == null)
        yt$1(this.states_), this.keptStates != null && (yt$1(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((o) => ge$1([s, o])) : this.states_[0] = ge$1([s, this.cell.stateSize]);
      else {
        if (Array.isArray(t) || (t = [t]), t.length !== this.states_.length)
          throw new E(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);
        e === true ? this.keptStates.push(this.states_.slice()) : yt$1(this.states_);
        for (let o = 0; o < this.states_.length; ++o) {
          const r = t[o], i6 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[o] : this.cell.stateSize, a = [s, i6];
          if (!Rt$1(r.shape, a))
            throw new E(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);
          this.states_[o] = r;
        }
      }
      this.states_ = this.states_.map((o) => cn$1(o.clone()));
    });
  }
  apply(t, e) {
    let s = e == null ? null : e.initialState, o = e == null ? null : e.constants;
    e == null && (e = {});
    const r = uy$1(t, s, o, this.numConstants);
    t = r.inputs, s = r.initialState, o = r.constants;
    let i6 = [], a = [];
    if (s != null) {
      e.initialState = s, i6 = i6.concat(s), this.stateSpec = [];
      for (const c of s)
        this.stateSpec.push(new de({ shape: c.shape }));
      a = a.concat(this.stateSpec);
    }
    if (o != null && (e.constants = o, i6 = i6.concat(o), this.numConstants = o.length), i6[0] instanceof jn$1) {
      const c = [t].concat(i6), u = this.inputSpec.concat(a), d = this.inputSpec;
      this.inputSpec = u;
      const h6 = super.apply(c, e);
      return this.inputSpec = d, h6;
    } else
      return super.apply(t, e);
  }
  // tslint:disable-next-line:no-any
  call(t, e) {
    return D(() => {
      const s = e == null ? null : e.mask, o = e == null ? null : e.training;
      let r = e == null ? null : e.initialState;
      t = mt(t), r == null && (this.stateful ? r = this.states_ : r = this.getInitialState(t));
      const i6 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
      if (r.length !== i6)
        throw new E(`RNN Layer has ${i6} state(s) but was passed ${r.length} initial state(s).`);
      this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
      const a = { training: o }, c = dy$1((f, m) => {
        const g6 = this.cell.call([f].concat(m), a);
        return [g6[0], g6.slice(1)];
      }, t, r, this.goBackwards, s, null, this.unroll, this.returnSequences), u = c[0], d = c[1], h6 = c[2];
      this.stateful && this.resetStates(h6, o);
      const p6 = this.returnSequences ? d : u;
      return this.returnState ? [p6].concat(h6) : p6;
    });
  }
  getInitialState(t) {
    return D(() => {
      let e = ge$1(t.shape);
      return e = at(e, [1, 2]), e = xa(e), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map((s) => s > 1 ? vd$1(e, [1, s]) : e) : this.cell.stateSize > 1 ? [vd$1(e, [1, this.cell.stateSize])] : [e];
    });
  }
  get trainableWeights() {
    return this.trainable ? this.cell.trainableWeights : [];
  }
  get nonTrainableWeights() {
    return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
  }
  setFastWeightInitDuringBuild(t) {
    super.setFastWeightInitDuringBuild(t), this.cell != null && this.cell.setFastWeightInitDuringBuild(t);
  }
  getConfig() {
    const t = super.getConfig(), e = {
      returnSequences: this.returnSequences,
      returnState: this.returnState,
      goBackwards: this.goBackwards,
      stateful: this.stateful,
      unroll: this.unroll
    };
    this.numConstants != null && (e.numConstants = this.numConstants);
    const s = this.cell.getConfig();
    return this.getClassName() === Qs.className && (e.cell = {
      className: this.cell.getClassName(),
      config: s
    }), Object.assign(Object.assign(Object.assign({}, s), t), e);
  }
  /** @nocollapse */
  static fromConfig(t, e, s = {}) {
    const o = e.cell, r = Pn$1(o, s);
    return new t(Object.assign(e, { cell: r }));
  }
}
Qs.className = "RNN";
_(Qs);
class ru extends St$1 {
}
let If$1 = class If extends ru {
  constructor(t) {
    super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = t.units, be$1(this.units, "units"), this.activation = As(t.activation == null ? this.DEFAULT_ACTIVATION : t.activation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = Ut(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Ut(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Ut(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = Yt(t.kernelRegularizer), this.recurrentRegularizer = Yt(t.recurrentRegularizer), this.biasRegularizer = Yt(t.biasRegularizer), this.kernelConstraint = pe(t.kernelConstraint), this.recurrentConstraint = pe(t.recurrentConstraint), this.biasConstraint = pe(t.biasConstraint), this.dropout = ar([1, Xs([0, t.dropout == null ? 0 : t.dropout])]), this.recurrentDropout = ar([
      1,
      Xs([0, t.recurrentDropout == null ? 0 : t.recurrentDropout])
    ]), this.dropoutFunc = t.dropoutFunc, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(t) {
    t = $t(t), this.kernel = this.addWeight("kernel", [t[t.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
  }
  // Porting Note: PyKeras' equivalent of this method takes two tensor inputs:
  //   `inputs` and `states`. Here, the two tensors are combined into an
  //   `Tensor[]` Array as the first input argument.
  //   Similarly, PyKeras' equivalent of this method returns two values:
  //    `output` and `[output]`. Here the two are combined into one length-2
  //    `Tensor[]`, consisting of `output` repeated.
  call(t, e) {
    return D(() => {
      if (t = t, t.length !== 2)
        throw new E(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);
      let s = t[1];
      t = t[0];
      const o = e.training == null ? false : e.training;
      0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = Os({
        ones: () => Rn$1(t),
        rate: this.dropout,
        training: o,
        dropoutFunc: this.dropoutFunc
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = Os({
        ones: () => Rn$1(s),
        rate: this.recurrentDropout,
        training: o,
        dropoutFunc: this.dropoutFunc
      }));
      let r;
      const i6 = this.dropoutMask, a = this.recurrentDropoutMask;
      i6 != null ? r = ns(G(t, i6), this.kernel.read()) : r = ns(t, this.kernel.read()), this.bias != null && (r = Hn$1(r, this.bias.read())), a != null && (s = G(s, a));
      let l = U(r, ns(s, this.recurrentKernel.read()));
      return this.activation != null && (l = this.activation.apply(l)), [l, l];
    });
  }
  getConfig() {
    const t = super.getConfig(), e = {
      units: this.units,
      activation: Ps(this.activation),
      useBias: this.useBias,
      kernelInitializer: Jt(this.kernelInitializer),
      recurrentInitializer: Jt(this.recurrentInitializer),
      biasInitializer: Jt(this.biasInitializer),
      kernelRegularizer: Ft$1(this.kernelRegularizer),
      recurrentRegularizer: Ft$1(this.recurrentRegularizer),
      biasRegularizer: Ft$1(this.biasRegularizer),
      activityRegularizer: Ft$1(this.activityRegularizer),
      kernelConstraint: he$1(this.kernelConstraint),
      recurrentConstraint: he$1(this.recurrentConstraint),
      biasConstraint: he$1(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout
    };
    return Object.assign(Object.assign({}, t), e);
  }
};
If$1.className = "SimpleRNNCell";
_(If$1);
let hy$1 = class hy extends Qs {
  constructor(t) {
    t.cell = new If$1(t), super(t);
  }
  call(t, e) {
    return D(() => {
      this.cell.dropoutMask != null && (yt$1(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (yt$1(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      const s = e == null ? null : e.mask, o = e == null ? null : e.training, r = e == null ? null : e.initialState;
      return super.call(t, { mask: s, training: o, initialState: r });
    });
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e);
  }
};
hy$1.className = "SimpleRNN";
_(hy$1);
let Cf$1 = class Cf extends ru {
  constructor(t) {
    if (super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", t.resetAfter)
      throw new E("GRUCell does not support reset_after parameter set to true.");
    this.units = t.units, be$1(this.units, "units"), this.activation = As(t.activation === void 0 ? this.DEFAULT_ACTIVATION : t.activation), this.recurrentActivation = As(t.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = Ut(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Ut(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Ut(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = Yt(t.kernelRegularizer), this.recurrentRegularizer = Yt(t.recurrentRegularizer), this.biasRegularizer = Yt(t.biasRegularizer), this.kernelConstraint = pe(t.kernelConstraint), this.recurrentConstraint = pe(t.recurrentConstraint), this.biasConstraint = pe(t.biasConstraint), this.dropout = ar([1, Xs([0, t.dropout == null ? 0 : t.dropout])]), this.recurrentDropout = ar([
      1,
      Xs([0, t.recurrentDropout == null ? 0 : t.recurrentDropout])
    ]), this.dropoutFunc = t.dropoutFunc, this.implementation = t.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(t) {
    t = $t(t);
    const e = t[t.length - 1];
    this.kernel = this.addWeight("kernel", [e, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
  }
  call(t, e) {
    return D(() => {
      if (t = t, t.length !== 2)
        throw new E(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);
      const s = e.training == null ? false : e.training;
      let o = t[1];
      t = t[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = Os({
        ones: () => Rn$1(t),
        rate: this.dropout,
        training: s,
        count: 3,
        dropoutFunc: this.dropoutFunc
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = Os({
        ones: () => Rn$1(o),
        rate: this.recurrentDropout,
        training: s,
        count: 3,
        dropoutFunc: this.dropoutFunc
      }));
      const r = this.dropoutMask, i6 = this.recurrentDropoutMask;
      let a, l, c;
      0 < this.dropout && this.dropout < 1 && (t = G(t, r[0]));
      let u = ns(t, this.kernel.read());
      this.useBias && (u = Hn$1(u, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (o = G(o, i6[0]));
      const d = this.recurrentKernel.read(), [h6, p6] = un$1(d, [2 * this.units, this.units], d.rank - 1), f = ns(o, h6), [m, g6, b6] = un$1(u, 3, u.rank - 1), [x6, w6] = un$1(f, 2, f.rank - 1);
      a = this.recurrentActivation.apply(U(m, x6)), l = this.recurrentActivation.apply(U(g6, w6));
      const y6 = ns(G(l, o), p6);
      c = this.activation.apply(U(b6, y6));
      const I = U(G(a, o), G(U(1, jt$1(a)), c));
      return [I, I];
    });
  }
  getConfig() {
    const t = super.getConfig(), e = {
      units: this.units,
      activation: Ps(this.activation),
      recurrentActivation: Ps(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: Jt(this.kernelInitializer),
      recurrentInitializer: Jt(this.recurrentInitializer),
      biasInitializer: Jt(this.biasInitializer),
      kernelRegularizer: Ft$1(this.kernelRegularizer),
      recurrentRegularizer: Ft$1(this.recurrentRegularizer),
      biasRegularizer: Ft$1(this.biasRegularizer),
      activityRegularizer: Ft$1(this.activityRegularizer),
      kernelConstraint: he$1(this.kernelConstraint),
      recurrentConstraint: he$1(this.recurrentConstraint),
      biasConstraint: he$1(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation,
      resetAfter: false
    };
    return Object.assign(Object.assign({}, t), e);
  }
};
Cf$1.className = "GRUCell";
_(Cf$1);
let py$1 = class py extends Qs {
  constructor(t) {
    t.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new Cf$1(t), super(t);
  }
  call(t, e) {
    return D(() => {
      this.cell.dropoutMask != null && (yt$1(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (yt$1(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      const s = e == null ? null : e.mask, o = e == null ? null : e.training, r = e == null ? null : e.initialState;
      return super.call(t, { mask: s, training: o, initialState: r });
    });
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return e.implmentation === 0 && (e.implementation = 1), new t(e);
  }
};
py$1.className = "GRU";
_(py$1);
class iu extends ru {
  constructor(t) {
    super(t), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = t.units, be$1(this.units, "units"), this.activation = As(t.activation === void 0 ? this.DEFAULT_ACTIVATION : t.activation), this.recurrentActivation = As(t.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), this.useBias = t.useBias == null ? true : t.useBias, this.kernelInitializer = Ut(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Ut(t.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Ut(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = t.unitForgetBias, this.kernelRegularizer = Yt(t.kernelRegularizer), this.recurrentRegularizer = Yt(t.recurrentRegularizer), this.biasRegularizer = Yt(t.biasRegularizer), this.kernelConstraint = pe(t.kernelConstraint), this.recurrentConstraint = pe(t.recurrentConstraint), this.biasConstraint = pe(t.biasConstraint), this.dropout = ar([1, Xs([0, t.dropout == null ? 0 : t.dropout])]), this.recurrentDropout = ar([
      1,
      Xs([0, t.recurrentDropout == null ? 0 : t.recurrentDropout])
    ]), this.dropoutFunc = t.dropoutFunc, this.implementation = t.implementation, this.stateSize = [this.units, this.units], this.dropoutMask = null, this.recurrentDropoutMask = null;
  }
  build(t) {
    var e;
    t = $t(t);
    const s = t[t.length - 1];
    this.kernel = this.addWeight("kernel", [s, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
    let o;
    if (this.useBias) {
      if (this.unitForgetBias) {
        const r = this.biasInitializer, i6 = this.units;
        o = new (e = class extends Gn$1 {
          apply(l, c) {
            const u = r.apply([i6]), d = new af$1().apply([i6]), h6 = r.apply([i6 * 2]);
            return Cm(Cm(u, d), h6);
          }
        }, /** @nocollapse */
        e.className = "CustomInit", e)();
      } else
        o = this.biasInitializer;
      this.bias = this.addWeight("bias", [this.units * 4], null, o, this.biasRegularizer, true, this.biasConstraint);
    } else
      this.bias = null;
    this.built = true;
  }
  call(t, e) {
    return D(() => {
      const s = e.training == null ? false : e.training;
      if (t = t, t.length !== 3)
        throw new E(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);
      let o = t[1];
      const r = t[2];
      t = t[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = Os({
        ones: () => Rn$1(t),
        rate: this.dropout,
        training: s,
        count: 4,
        dropoutFunc: this.dropoutFunc
      })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = Os({
        ones: () => Rn$1(o),
        rate: this.recurrentDropout,
        training: s,
        count: 4,
        dropoutFunc: this.dropoutFunc
      }));
      const i6 = this.dropoutMask, a = this.recurrentDropoutMask;
      let l, c, u, d;
      0 < this.dropout && this.dropout < 1 && (t = G(t, i6[0]));
      let h6 = ns(t, this.kernel.read());
      0 < this.recurrentDropout && this.recurrentDropout < 1 && (o = G(o, a[0])), h6 = U(h6, ns(o, this.recurrentKernel.read())), this.useBias && (h6 = Hn$1(h6, this.bias.read()));
      const [p6, f, m, g6] = un$1(h6, 4, h6.rank - 1);
      l = this.recurrentActivation.apply(p6), c = this.recurrentActivation.apply(f), u = U(G(c, r), G(l, this.activation.apply(m))), d = this.recurrentActivation.apply(g6);
      const b6 = G(d, this.activation.apply(u));
      return [b6, b6, u];
    });
  }
  getConfig() {
    const t = super.getConfig(), e = {
      units: this.units,
      activation: Ps(this.activation),
      recurrentActivation: Ps(this.recurrentActivation),
      useBias: this.useBias,
      kernelInitializer: Jt(this.kernelInitializer),
      recurrentInitializer: Jt(this.recurrentInitializer),
      biasInitializer: Jt(this.biasInitializer),
      unitForgetBias: this.unitForgetBias,
      kernelRegularizer: Ft$1(this.kernelRegularizer),
      recurrentRegularizer: Ft$1(this.recurrentRegularizer),
      biasRegularizer: Ft$1(this.biasRegularizer),
      activityRegularizer: Ft$1(this.activityRegularizer),
      kernelConstraint: he$1(this.kernelConstraint),
      recurrentConstraint: he$1(this.recurrentConstraint),
      biasConstraint: he$1(this.biasConstraint),
      dropout: this.dropout,
      recurrentDropout: this.recurrentDropout,
      implementation: this.implementation
    };
    return Object.assign(Object.assign({}, t), e);
  }
}
iu.className = "LSTMCell";
_(iu);
let fy$1 = class fy extends Qs {
  constructor(t) {
    t.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new iu(t), super(t);
  }
  call(t, e) {
    return D(() => {
      this.cell.dropoutMask != null && (yt$1(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (yt$1(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
      const s = e == null ? null : e.mask, o = e == null ? null : e.training, r = e == null ? null : e.initialState;
      return super.call(t, { mask: s, training: o, initialState: r });
    });
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return e.implmentation === 0 && (e.implementation = 1), new t(e);
  }
};
fy$1.className = "LSTM";
_(fy$1);
let vf$1 = class vf extends ru {
  constructor(t) {
    super(t), this.cells = t.cells;
  }
  get stateSize() {
    const t = [];
    for (const e of this.cells.slice().reverse())
      Array.isArray(e.stateSize) ? t.push(...e.stateSize) : t.push(e.stateSize);
    return t;
  }
  call(t, e) {
    return D(() => {
      t = t;
      let s = t.slice(1);
      const o = [];
      for (const a of this.cells.slice().reverse())
        Array.isArray(a.stateSize) ? o.push(s.splice(0, a.stateSize.length)) : o.push(s.splice(0, 1));
      o.reverse();
      const r = [];
      let i6;
      for (let a = 0; a < this.cells.length; ++a) {
        const l = this.cells[a];
        s = o[a], a === 0 ? i6 = [t[0]].concat(s) : i6 = [i6[0]].concat(s), i6 = l.call(i6, e), r.push(i6.slice(1));
      }
      s = [];
      for (const a of r.slice().reverse())
        s.push(...a);
      return [i6[0]].concat(s);
    });
  }
  build(t) {
    kd$1(t) && (t = t[0]), t = t;
    let e;
    this.cells.forEach((s, o) => {
      fo(`RNNCell_${o}`, () => {
        s.build(t), Array.isArray(s.stateSize) ? e = s.stateSize[0] : e = s.stateSize, t = [t[0], e];
      });
    }), this.built = true;
  }
  getConfig() {
    const t = super.getConfig(), e = (r) => ({
      className: r.getClassName(),
      config: r.getConfig()
    }), o = { cells: this.cells.map(e) };
    return Object.assign(Object.assign({}, t), o);
  }
  /** @nocollapse */
  static fromConfig(t, e, s = {}) {
    const o = [];
    for (const r of e.cells)
      o.push(Pn$1(r, s));
    return new t({ cells: o });
  }
  get trainableWeights() {
    if (!this.trainable)
      return [];
    const t = [];
    for (const e of this.cells)
      t.push(...e.trainableWeights);
    return t;
  }
  get nonTrainableWeights() {
    const t = [];
    for (const e of this.cells)
      t.push(...e.nonTrainableWeights);
    if (!this.trainable) {
      const e = [];
      for (const s of this.cells)
        e.push(...s.trainableWeights);
      return e.concat(t);
    }
    return t;
  }
  /**
   * Retrieve the weights of a the model.
   *
   * @returns A flat `Array` of `tf.Tensor`s.
   */
  getWeights() {
    const t = [];
    for (const e of this.cells)
      t.push(...e.weights);
    return Td$1(t);
  }
  /**
   * Set the weights of the model.
   *
   * @param weights An `Array` of `tf.Tensor`s with shapes and types matching
   *     the output of `getWeights()`.
   */
  setWeights(t) {
    const e = [];
    for (const s of this.cells) {
      const o = s.weights.length, r = t.splice(o);
      for (let i6 = 0; i6 < s.weights.length; ++i6)
        e.push([s.weights[i6], r[i6]]);
    }
    ff$1(e);
  }
};
vf$1.className = "StackedRNNCells";
_(vf$1);
function Os(n) {
  const { ones: t, rate: e, training: s = false, count: o = 1, dropoutFunc: r } = n, i6 = () => r != null ? r(t(), e) : ax(t(), e), a = () => wa(i6, t, s);
  return !o || o <= 1 ? cn$1(a().clone()) : Array(o).fill(void 0).map(a).map((c) => cn$1(c.clone()));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
var _E = globalThis && globalThis.__rest || function(n, t) {
  var e = {};
  for (var s in n)
    Object.prototype.hasOwnProperty.call(n, s) && t.indexOf(s) < 0 && (e[s] = n[s]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, s = Object.getOwnPropertySymbols(n); o < s.length; o++)
      t.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(n, s[o]) && (e[s[o]] = n[s[o]]);
  return e;
};
let my$1 = class my extends Qs {
  constructor(t) {
    if (t.unroll)
      throw new xt$1("Unrolling is not possible with convolutional RNNs.");
    if (Array.isArray(t.cell))
      throw new xt$1("It is not possible at the moment to stack convolutional cells.");
    super(t), this.inputSpec = [new de({ ndim: 5 })];
  }
  call(t, e) {
    return D(() => {
      if (this.cell.dropoutMask != null && (yt$1(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (yt$1(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), e && e.constants)
        throw new E("ConvRNN2D cell does not support constants");
      const s = e == null ? null : e.mask, o = e == null ? null : e.training, r = e == null ? null : e.initialState;
      return super.call(t, { mask: s, training: o, initialState: r });
    });
  }
  computeOutputShape(t) {
    let e = this.computeSingleOutputShape(t);
    return this.returnSequences || (e = [e[0], ...e.slice(2)]), this.returnState && (e = [e, ...Array(2).fill([t[0], ...e.slice(-3)])]), e;
  }
  getInitialState(t) {
    return D(() => {
      const { stateSize: e } = this.cell, s = t.shape, o = this.computeSingleOutputShape(s), r = [o[0], ...o.slice(2)], i6 = ge$1(r);
      return Array.isArray(e) ? Array(e.length).fill(i6) : [i6];
    });
  }
  resetStates(t, e = false) {
    D(() => {
      if (!this.stateful)
        throw new Yn$1("Cannot call resetStates() on an RNN Layer that is not stateful.");
      const s = this.inputSpec[0].shape, o = this.computeSingleOutputShape(s), r = [o[0], ...o.slice(2)];
      if (s[0] == null)
        throw new E("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
      if (this.getStates() == null)
        Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => ge$1(r)) : this.states_ = [ge$1(r)];
      else if (t == null)
        yt$1(this.states_), this.keptStates != null && (yt$1(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => ge$1(r)) : this.states_[0] = ge$1(r);
      else {
        if (Array.isArray(t) || (t = [t]), t.length !== this.states_.length)
          throw new E(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);
        e ? this.keptStates.push(this.states_.slice()) : yt$1(this.states_);
        for (let a = 0; a < this.states_.length; ++a) {
          const l = t[a], c = r;
          if (!Rt$1(l.shape, c))
            throw new E(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);
          this.states_[a] = l;
        }
      }
      this.states_ = this.states_.map((a) => cn$1(a.clone()));
    });
  }
  computeSingleOutputShape(t) {
    const { dataFormat: e, filters: s, kernelSize: o, padding: r, strides: i6, dilationRate: a } = this.cell, l = e === "channelsFirst", c = t[l ? 3 : 2], u = t[l ? 4 : 3], d = An$1(c, o[0], r, i6[0], a[0]), h6 = An$1(u, o[1], r, i6[1], a[1]);
    return [
      ...t.slice(0, 2),
      ...l ? [s, d, h6] : [d, h6, s]
    ];
  }
};
my$1.className = "ConvRNN2D";
let Sf$1 = class Sf extends iu {
  constructor(t) {
    const { filters: e, kernelSize: s, strides: o, padding: r, dataFormat: i6, dilationRate: a } = t;
    super(Object.assign(Object.assign({}, t), { units: e })), this.filters = e, be$1(this.filters, "filters"), this.kernelSize = er(s, 2, "kernelSize"), this.kernelSize.forEach((l) => be$1(l, "kernelSize")), this.strides = er(o || 1, 2, "strides"), this.strides.forEach((l) => be$1(l, "strides")), this.padding = r || "valid", fn$1(this.padding), this.dataFormat = i6 || "channelsLast", ae(this.dataFormat), this.dilationRate = er(a || 1, 2, "dilationRate"), this.dilationRate.forEach((l) => be$1(l, "dilationRate"));
  }
  build(t) {
    var e;
    t = $t(t);
    const s = this.dataFormat === "channelsFirst" ? 1 : t.length - 1;
    if (t[s] == null)
      throw new E(`The channel dimension of the input should be defined. Found ${t[s]}`);
    const o = t[s], r = 4, i6 = this.kernelSize.concat([o, this.filters * r]);
    this.kernel = this.addWeight("kernel", i6, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
    const a = this.kernelSize.concat([this.filters, this.filters * r]);
    if (this.recurrentKernel = this.addWeight("recurrent_kernel", a, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias) {
      let l;
      if (this.unitForgetBias) {
        const c = this.biasInitializer, u = this.filters;
        l = new (e = class extends Gn$1 {
          apply(h6, p6) {
            const f = c.apply([u]), m = Us([u]), g6 = c.apply([u * 2]);
            return rf$1([f, m, g6]);
          }
        }, /** @nocollapse */
        e.className = "CustomInit", e)();
      } else
        l = this.biasInitializer;
      this.bias = this.addWeight("bias", [this.filters * r], null, l, this.biasRegularizer, true, this.biasConstraint);
    }
    this.built = true;
  }
  call(t, e) {
    return D(() => {
      if (t.length !== 3)
        throw new E(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);
      const s = e.training || false, o = t[0], r = t[1], i6 = t[2], a = 4;
      0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = Os({
        ones: () => Rn$1(o),
        rate: this.dropout,
        training: s,
        count: a,
        dropoutFunc: this.dropoutFunc
      }));
      const l = this.dropoutMask, c = (Y, Q, j) => !Q || !Q[j] ? Y : G(Q[j], Y);
      let u = c(o, l, 0), d = c(o, l, 1), h6 = c(o, l, 2), p6 = c(o, l, 3);
      0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = Os({
        ones: () => Rn$1(r),
        rate: this.recurrentDropout,
        training: s,
        count: a,
        dropoutFunc: this.dropoutFunc
      }));
      const f = this.recurrentDropoutMask;
      let m = c(r, f, 0), g6 = c(r, f, 1), b6 = c(r, f, 2), x6 = c(r, f, 3);
      const w6 = 3, [y6, I, C6, k7] = un$1(this.kernel.read(), a, w6), [S, N, R, M6] = this.useBias ? un$1(this.bias.read(), a) : [null, null, null, null];
      u = this.inputConv(u, y6, S, this.padding), d = this.inputConv(d, I, N, this.padding), h6 = this.inputConv(h6, C6, R, this.padding), p6 = this.inputConv(p6, k7, M6, this.padding);
      const [V, z, X, P6] = un$1(this.recurrentKernel.read(), a, w6);
      m = this.recurrentConv(m, V), g6 = this.recurrentConv(g6, z), b6 = this.recurrentConv(b6, X), x6 = this.recurrentConv(x6, P6);
      const A6 = this.recurrentActivation.apply(U(u, m)), B6 = this.recurrentActivation.apply(U(d, g6)), Z = U(G(B6, i6), G(A6, this.activation.apply(U(h6, b6)))), H6 = G(this.recurrentActivation.apply(U(p6, x6)), this.activation.apply(Z));
      return [H6, H6, Z];
    });
  }
  getConfig() {
    const t = super.getConfig(), e = _E(t, ["units"]), s = {
      filters: this.filters,
      kernelSize: this.kernelSize,
      padding: this.padding,
      dataFormat: this.dataFormat,
      dilationRate: this.dilationRate,
      strides: this.strides
    };
    return Object.assign(Object.assign({}, e), s);
  }
  inputConv(t, e, s, o) {
    const r = Co(t, e, this.strides, o || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
    return s ? Hn$1(r, s, this.dataFormat) : r;
  }
  recurrentConv(t, e) {
    return Co(t, e, 1, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
  }
};
Sf$1.className = "ConvLSTM2DCell";
_(Sf$1);
let gy$1 = class gy extends my$1 {
  constructor(t) {
    const e = new Sf$1(t);
    super(Object.assign(Object.assign({}, t), { cell: e }));
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    return new t(e);
  }
};
gy$1.className = "ConvLSTM2D";
_(gy$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let kf$1 = class kf extends St$1 {
  constructor(t) {
    super(t), this.rate = Math.max(Math.min(t.rate, 1), 0), this.noiseShape = t.noiseShape, this.seed = t.seed, this.supportsMasking = true;
  }
  getNoiseShape(t) {
    if (this.noiseShape == null)
      return this.noiseShape;
    const e = t.shape, s = [];
    for (let o = 0; o < this.noiseShape.length; ++o)
      s.push(this.noiseShape[o] == null ? e[o] : this.noiseShape[o]);
    return s;
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      const s = mt(t);
      if (0 < this.rate && this.rate < 1) {
        const o = e.training == null ? false : e.training, r = this.getNoiseShape(s);
        return wa(() => ax(s, this.rate, r, this.seed), () => s, o);
      }
      return t;
    });
  }
  getConfig() {
    const t = {
      rate: this.rate,
      noiseShape: this.noiseShape,
      seed: this.seed
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
  dispose() {
    return super.dispose();
  }
};
kf$1.className = "Dropout";
_(kf$1);
let by$1 = class by extends kf$1 {
  constructor(t) {
    super(t), this.inputSpec = [{ ndim: 3 }];
  }
  getNoiseShape(t) {
    const e = t.shape;
    return [e[0], 1, e[2]];
  }
};
by$1.className = "SpatialDropout1D";
_(by$1);
let xy$1 = class xy extends St$1 {
  constructor(t) {
    if (super(t), this.activation = null, this.useBias = true, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", t.batchInputShape == null && t.inputShape == null && t.inputDim != null) {
      let e = null;
      t.batchSize != null && (e = t.batchSize), this.batchInputShape = [e, t.inputDim];
    }
    this.units = t.units, be$1(this.units, "units"), this.activation = As(t.activation), t.useBias != null && (this.useBias = t.useBias), this.kernelInitializer = Ut(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = Ut(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = pe(t.kernelConstraint), this.biasConstraint = pe(t.biasConstraint), this.kernelRegularizer = Yt(t.kernelRegularizer), this.biasRegularizer = Yt(t.biasRegularizer), this.activityRegularizer = Yt(t.activityRegularizer), this.supportsMasking = true, this.inputSpec = [{ minNDim: 2 }];
  }
  build(t) {
    t = $t(t);
    const e = t[t.length - 1];
    this.kernel == null && (this.kernel = this.addWeight("kernel", [e, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint))), this.inputSpec = [{ minNDim: 2, axes: { [-1]: e } }], this.built = true;
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = t.slice();
    return e[e.length - 1] = this.units, e;
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      const s = mt(t), o = tx(this.activation.getClassName());
      let r;
      return o != null ? r = ns(s, this.kernel.read(), o, this.bias ? this.bias.read() : null) : (r = ns(s, this.kernel.read()), this.bias != null && (r = Hn$1(r, this.bias.read())), this.activation != null && (r = this.activation.apply(r))), r;
    });
  }
  getConfig() {
    const t = {
      units: this.units,
      activation: Ps(this.activation),
      useBias: this.useBias,
      kernelInitializer: Jt(this.kernelInitializer),
      biasInitializer: Jt(this.biasInitializer),
      kernelRegularizer: Ft$1(this.kernelRegularizer),
      biasRegularizer: Ft$1(this.biasRegularizer),
      activityRegularizer: Ft$1(this.activityRegularizer),
      kernelConstraint: he$1(this.kernelConstraint),
      biasConstraint: he$1(this.biasConstraint)
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
xy$1.className = "Dense";
_(xy$1);
let yy$1 = class yy extends St$1 {
  constructor(t) {
    t = t || {}, super(t), this.inputSpec = [{ minNDim: 3 }], this.dataFormat = t.dataFormat;
  }
  computeOutputShape(t) {
    t = $t(t);
    for (const e of t.slice(1))
      if (e == null)
        throw new E(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
    return [t[0], Ds(t, 1)];
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      let s = mt(t);
      if (this.dataFormat === "channelsFirst" && s.rank > 1) {
        const o = [0];
        for (let r = 2; r < s.rank; ++r)
          o.push(r);
        o.push(1), s = kt(s, o);
      }
      return $G(s);
    });
  }
  getConfig() {
    const t = {};
    this.dataFormat != null && (t.dataFormat = this.dataFormat);
    const e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
yy$1.className = "Flatten";
_(yy$1);
let wy$1 = class wy extends St$1 {
  constructor(t) {
    super(t), this.supportsMasking = true, this.activation = As(t.activation);
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      const s = mt(t);
      return this.activation.apply(s);
    });
  }
  getConfig() {
    const t = { activation: Ps(this.activation) }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
wy$1.className = "Activation";
_(wy$1);
let Iy$1 = class Iy extends St$1 {
  constructor(t) {
    super(t), this.n = t.n, this.inputSpec = [{ ndim: 2 }];
  }
  computeOutputShape(t) {
    return [t[0], this.n, t[1]];
  }
  call(t, e) {
    return D(() => (t = mt(t), NG(t, this.n)));
  }
  getConfig() {
    const t = {
      n: this.n
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
Iy$1.className = "RepeatVector";
_(Iy$1);
let Cy$1 = class Cy extends St$1 {
  constructor(t) {
    super(t), this.targetShape = t.targetShape;
    for (let e = 0; e < this.targetShape.length; ++e)
      this.isUnknown(this.targetShape[e]) && (this.targetShape[e] = null);
  }
  isUnknown(t) {
    return t < 0 || t == null;
  }
  /**
   * Finds and replaces a missing dimension in output shape.
   *
   * This is a near direct port of the internal Numpy function
   * `_fix_unknown_dimension` in `numpy/core/src/multiarray/shape.c`.
   *
   * @param inputShape: Original shape of array begin reshape.
   * @param outputShape: Target shape of the array, with at most a single
   * `null` or negative number, which indicates an underdetermined dimension
   * that should be derived from `inputShape` and the known dimensions of
   *   `outputShape`.
   * @returns: The output shape with `null` replaced with its computed value.
   * @throws: ValueError: If `inputShape` and `outputShape` do not match.
   */
  fixUnknownDimension(t, e) {
    const s = "Total size of new array must be unchanged.", o = e.slice();
    let r = 1, i6 = null;
    for (let l = 0; l < o.length; ++l) {
      const c = o[l];
      if (this.isUnknown(c))
        if (i6 === null)
          i6 = l;
        else
          throw new E("Can only specifiy one unknown dimension.");
      else
        r *= c;
    }
    const a = Ds(t);
    if (i6 !== null) {
      if (r === 0 || a % r !== 0)
        throw new E(s);
      o[i6] = a / r;
    } else if (a !== r)
      throw new E(s);
    return o;
  }
  computeOutputShape(t) {
    let e = false;
    for (let s = 0; s < t.length; ++s)
      if (this.isUnknown(t[s])) {
        e = true;
        break;
      }
    return e ? t.slice(0, 1).concat(this.targetShape) : t.slice(0, 1).concat(this.fixUnknownDimension(t.slice(1), this.targetShape));
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      const s = mt(t), o = s.shape, r = o.slice(0, 1).concat(this.fixUnknownDimension(o.slice(1), this.targetShape));
      return W(s, r);
    });
  }
  getConfig() {
    const t = {
      targetShape: this.targetShape
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
Cy$1.className = "Reshape";
_(Cy$1);
let vy$1 = class vy extends St$1 {
  constructor(t) {
    if (super(t), t.dims == null)
      throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    if (!Array.isArray(t.dims))
      throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);
    const e = On$1(1, t.dims.length + 1);
    if (!Rt$1(t.dims.slice().sort(), e))
      throw new Error("Invalid permutation `dims`: " + JSON.stringify(t.dims) + " `dims` must contain consecutive integers starting from 1.");
    this.dims = t.dims, this.dimsIncludingBatch = [0].concat(this.dims), this.inputSpec = [new de({ ndim: this.dims.length + 1 })];
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = t.slice();
    return this.dims.forEach((s, o) => {
      e[o + 1] = t[s];
    }), e;
  }
  call(t, e) {
    return kt(mt(t), this.dimsIncludingBatch);
  }
  getConfig() {
    const t = {
      dims: this.dims
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
vy$1.className = "Permute";
_(vy$1);
let Sy$1 = class Sy extends St$1 {
  constructor(t) {
    super(t ?? {}), this.supportsMasking = true, t != null ? this.maskValue = t.maskValue == null ? 0 : t.maskValue : this.maskValue = 0;
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = super.getConfig(), e = { maskValue: this.maskValue };
    return Object.assign(e, t), e;
  }
  computeMask(t, e) {
    const s = mt(t), o = -1;
    return bd$1(qr(s, this.maskValue), o);
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      const s = mt(t), o = -1, r = true, i6 = bd$1(qr(s, this.maskValue), o, r);
      return G(s, et(i6, s.dtype));
    });
  }
};
Sy$1.className = "Masking";
_(Sy$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let ky$1 = class ky extends St$1 {
  constructor(t) {
    if (super(t), this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", t.batchInputShape == null && t.inputShape == null) {
      let e = null;
      t.batchSize != null && (e = t.batchSize), t.inputLength == null ? this.batchInputShape = [e, null] : this.batchInputShape = [e].concat(Zt(t.inputLength));
    }
    this.inputDim = t.inputDim, be$1(this.inputDim, "inputDim"), this.outputDim = t.outputDim, be$1(this.outputDim, "outputDim"), this.embeddingsInitializer = Ut(t.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = Yt(t.embeddingsRegularizer), this.activityRegularizer = Yt(t.activityRegularizer), this.embeddingsConstraint = pe(t.embeddingsConstraint), this.maskZero = t.maskZero, this.supportsMasking = t.maskZero, this.inputLength = t.inputLength;
  }
  build(t) {
    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint), this.built = true;
  }
  // Override warnOnIncompatibleInputShape because an embedding layer allows
  // the input to have varying ranks.
  warnOnIncompatibleInputShape(t) {
  }
  computeMask(t, e) {
    return D(() => this.maskZero ? (t = mt(t), qr(t, Tt$1(t))) : null);
  }
  computeOutputShape(t) {
    if (t = $t(t), this.inputLength == null)
      return [...t, this.outputDim];
    const e = Zt(this.inputLength);
    if (e.length !== t.length - 1)
      throw new E(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);
    {
      let s = 0;
      for (let o = 0; o < e.length; ++o) {
        const r = e[o], i6 = t[o + 1];
        if (r != null && i6 != null && r !== i6)
          throw new E(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);
        r == null && (e[s] = i6), s++;
      }
    }
    return [t[0], ...e, this.outputDim];
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      let s = mt(t);
      s.dtype !== "int32" && (s = es(s, "int32"));
      const o = ix(this.embeddings.read(), W(s, [s.size]));
      return W(o, $t(this.computeOutputShape(s.shape)));
    });
  }
  getConfig() {
    const t = {
      inputDim: this.inputDim,
      outputDim: this.outputDim,
      embeddingsInitializer: Jt(this.embeddingsInitializer),
      embeddingsRegularizer: Ft$1(this.embeddingsRegularizer),
      activityRegularizer: Ft$1(this.activityRegularizer),
      embeddingsConstraint: he$1(this.embeddingsConstraint),
      maskZero: this.maskZero,
      inputLength: this.inputLength
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
ky$1.className = "Embedding";
_(ky$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Xo extends St$1 {
  constructor(t) {
    super(t || {}), this.supportsMasking = true;
  }
  /**
   * Logic for merging multiple tensors, to be overridden by subclasses.
   * @param inputs
   */
  mergeFunction(t) {
    throw new xt$1();
  }
  /**
   * Computes the shape of the result of an elementwise operation.
   *
   * @param shape1: Shape of the first tensor.
   * @param shape2: Shape of the second tensor.
   * @returns Expected output shape when an elementwise operation is carried
   *   out on 2 tensors with shapes `shape1` and `shape2`.
   * @throws ValueError: If `shape1` and `shape2` are not compatible for
   *   element-wise operations.
   */
  computeElementwiseOpOutputShape(t, e) {
    if (t == null || e == null)
      return null;
    if (t.length < e.length)
      return this.computeElementwiseOpOutputShape(e, t);
    if (e.length === 0)
      return t;
    const s = t.slice(0, t.length - e.length);
    for (let o = 0; o < e.length; ++o) {
      const r = t[t.length - e.length + o], i6 = e[o];
      if (r == null || i6 == null || r < 0 || i6 < 0)
        s.push(null);
      else if (r === 1)
        s.push(i6);
      else if (i6 === 1)
        s.push(r);
      else {
        if (r !== i6)
          throw new E("Operands could not be broadcast together with shapes " + JSON.stringify(t) + " " + JSON.stringify(e));
        s.push(r);
      }
    }
    return s;
  }
  build(t) {
    if (Array.isArray(t) && !Array.isArray(t[0]) && (t = [$t(t)]), t = t, t.length < 2)
      throw new E(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);
    let e = [];
    for (const r of t)
      r != null && r[0] !== null && e.push(r[0]);
    if (e = Ws(e), e.length > 1)
      throw new E(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);
    let s = t[0] == null ? null : t[0].slice(1);
    for (let r = 1; r < t.length; ++r) {
      const i6 = t[r] == null ? null : t[r].slice(1);
      s = this.computeElementwiseOpOutputShape(s, i6);
    }
    const o = t.map((r) => r.length);
    t.indexOf(null) === -1 && Ws(o).length === 1 ? this.reshapeRequired = false : this.reshapeRequired = true;
  }
  call(t, e) {
    return D(() => {
      if (t = t, this.reshapeRequired) {
        const s = [], o = t.map((r) => r.rank);
        if (o.indexOf(null) === -1) {
          const r = Xs(o);
          for (let i6 of t) {
            const a = i6.rank;
            for (let l = 0; l < r - a; ++l)
              i6 = xa(i6, 1);
            s.push(i6);
          }
          return this.mergeFunction(s);
        } else {
          let r = false;
          for (const l of t) {
            const c = l.rank;
            if (c == null) {
              const u = l.shape, d = u[0], h6 = u.slice(1).concat([d]);
              let p6 = W(l, [d].concat(Ds(u.slice(1))));
              p6 = kt(p6, [1, 0]), p6 = W(p6, h6), s.push(p6), r = true;
            } else if (c > 1) {
              const u = On$1(1, c).concat([0]);
              s.push(kt(l, u)), r = true;
            } else
              s.push(l);
          }
          let i6 = this.mergeFunction(s);
          const a = i6.rank;
          if (r) {
            if (a == null) {
              const l = i6.shape, c = l.length, u = l[c - 1], d = [u].concat(l.slice(0, l.length - 1));
              i6 = W(kt(W(i6, [-1, u]), [1, 0]), d);
            } else if (a > 1) {
              const l = [a - 1].concat(On$1(0, a - 1));
              i6 = kt(i6, l);
            }
          }
          return i6;
        }
      } else
        return this.mergeFunction(t);
    });
  }
  computeOutputShape(t) {
    t = t;
    let e;
    t[0] == null ? e = null : e = t[0].slice(1);
    for (let o = 1; o < t.length; ++o) {
      const r = t[o] == null ? null : t[o].slice(1);
      e = this.computeElementwiseOpOutputShape(e, r);
    }
    let s = [];
    for (const o of t)
      o != null && o[0] !== null && s.push(o[0]);
    return s = Ws(s), s.length === 1 ? e = s.concat(e) : e = [null].concat(e), e;
  }
  computeMask(t, e) {
    return D(() => {
      if (e == null)
        return null;
      if (!Array.isArray(e))
        throw new E("`mask` should be an Array");
      if (!Array.isArray(t))
        throw new E("`inputs` should be an Array");
      if (e.length !== t.length)
        throw new E(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);
      if (e.every((o) => o == null))
        return null;
      e = e.map((o) => o == null ? o : Ue$1(o, 0));
      let s = e[0];
      for (let o = 1; o < e.length - 1; ++o)
        s = ss(s, e[o]);
      return s;
    });
  }
}
let Ty$1 = class Ty extends Xo {
  constructor(t) {
    super(t);
  }
  mergeFunction(t) {
    return D(() => {
      let e = t[0].clone();
      for (let s = 1; s < t.length; ++s)
        e = U(e, t[s]);
      return e;
    });
  }
};
Ty$1.className = "Add";
_(Ty$1);
let Ny$1 = class Ny extends Xo {
  constructor(t) {
    super(t);
  }
  mergeFunction(t) {
    return D(() => {
      let e = t[0].clone();
      for (let s = 1; s < t.length; ++s)
        e = G(e, t[s]);
      return e;
    });
  }
};
Ny$1.className = "Multiply";
_(Ny$1);
let Ry$1 = class Ry extends Xo {
  constructor(t) {
    super(t);
  }
  mergeFunction(t) {
    return D(() => {
      let e = t[0].clone();
      for (let s = 1; s < t.length; ++s)
        e = U(e, t[s]);
      return G(1 / t.length, e);
    });
  }
};
Ry$1.className = "Average";
_(Ry$1);
let $y$1 = class $y extends Xo {
  constructor(t) {
    super(t);
  }
  mergeFunction(t) {
    return D(() => {
      let e = t[0];
      for (let s = 1; s < t.length; ++s)
        e = _s(e, t[s]);
      return e;
    });
  }
};
$y$1.className = "Maximum";
_($y$1);
let Gy$1 = class Gy extends Xo {
  constructor(t) {
    super(t);
  }
  mergeFunction(t) {
    return D(() => {
      let e = t[0];
      for (let s = 1; s < t.length; ++s)
        e = Kc(e, t[s]);
      return e;
    });
  }
};
Gy$1.className = "Minimum";
_(Gy$1);
let Ey$1 = class Ey extends Xo {
  constructor(t) {
    super(t), this.DEFAULT_AXIS = -1, t == null && (t = {}), this.axis = t.axis == null ? this.DEFAULT_AXIS : t.axis, this.supportsMasking = true, this.reshapeRequired = false;
  }
  build(t) {
    if (!(Array.isArray(t) && Array.isArray(t[0])) || t.length === 1)
      throw new E("A `Concatenate` layer should be called on a list of at least 2 inputs");
    t = t;
    let e = true;
    for (const o of t)
      if (o != null) {
        e = false;
        break;
      }
    if (e)
      return;
    const s = [];
    for (let o = 0; o < t.length; ++o) {
      const r = t[o].slice();
      r.splice(this.axis, 1);
      let i6 = false;
      for (const a of s)
        if (Rt$1(a, r)) {
          i6 = true;
          break;
        }
      i6 || s.push(r);
    }
    if (s.length > 1)
      throw new E("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(t));
  }
  mergeFunction(t) {
    return D(() => rf$1(t, this.axis));
  }
  computeOutputShape(t) {
    if (!(Array.isArray(t) && Array.isArray(t[0])))
      throw new E("A `Concatenate` layer should be called on a list of inputs.");
    const e = t, s = e[0].slice(), o = this.axis < 0 ? s.length + this.axis : this.axis;
    for (const r of e.slice(1)) {
      if (s[o] == null || r[o] == null) {
        s[o] = null;
        break;
      }
      s[o] += r[o];
    }
    return s;
  }
  computeMask(t, e) {
    if (e == null)
      return null;
    if (!Array.isArray(e))
      throw new E("`mask` should be an array for Concatenate");
    if (!Array.isArray(t))
      throw new E("`inputs` should be an array for Concatenate");
    if (e.length !== t.length)
      throw new E(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);
    return D(() => {
      let s = true;
      if (e.forEach((i6) => {
        if (i6 != null) {
          s = false;
          return;
        }
      }), s)
        return null;
      const o = [];
      for (let i6 = 0; i6 < t.length; ++i6)
        e[i6] == null ? o.push(et(Rn$1(t[i6]), "bool")) : e[i6].rank < t[i6].rank ? o.push(Ue$1(e[i6], -1)) : o.push(e[i6]);
      const r = Ge$1(o, this.axis);
      return Nb$1(r, -1, false);
    });
  }
  getConfig() {
    const t = {
      axis: this.axis
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
Ey$1.className = "Concatenate";
_(Ey$1);
function Dr(n, t) {
  for (; n < 0; )
    n += t;
  return n;
}
function UE(n, t, e) {
  if (n.shape.length > 3 || t.shape.length > 3)
    throw new xt$1("batchDot is not implemented for tensors of 4D or higher rank yet");
  if (v(n.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`), v(n.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`), typeof e == "number" && (e = [e, e]), n.dtype === "complex64" || t.dtype === "complex64")
    throw new xt$1("batchDot is not implemented for complex64-type Tensors yet.");
  const s = n.shape.length, o = t.shape.length;
  e == null && (e = [s - 1, o - 2]);
  const r = e;
  return D(() => {
    let i6;
    if (s > o) {
      i6 = s - o;
      const l = [];
      for (let c = 0; c < i6; ++c)
        l.push(1);
      t = W(t, t.shape.concat(l));
    } else if (o > s) {
      i6 = o - s;
      const l = [];
      for (let c = 0; c < i6; ++c)
        l.push(1);
      n = W(n, n.shape.concat(l));
    } else
      i6 = 0;
    let a;
    if (n.shape.length === 2 && t.shape.length === 2)
      r[0] === r[1] ? a = at(G(n, t), r[0]) : a = at(G(kt(n, [1, 0]), t), r[1]);
    else {
      const l = r[0] !== n.shape.length - 1, c = r[1] === t.shape.length - 1;
      a = Gt(n, t, l, c);
    }
    if (i6 > 0) {
      let l;
      s > o ? l = s + o - 3 : l = s - 1;
      const c = [];
      for (let u = l; u < l + i6; ++u)
        c.push(u);
      a = ha(a, c);
    }
    return a.shape.length === 1 && (a = Ue$1(a, 1)), a;
  });
}
let Ly$1 = class Ly extends Xo {
  constructor(t) {
    super(t), this.axes = t.axes, this.normalize = t.normalize == null ? false : t.normalize, this.supportsMasking = true, this.reshapeRequired = false;
  }
  build(t) {
    v(Array.isArray(t) && t.length === 2 && Array.isArray(t[0]) && Array.isArray(t[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    const e = t[0], s = t[1];
    if (e.length > 3 || s.length > 3)
      throw new xt$1("Dot layer does not support tensors of 4D or higher rank yet.");
    const o = this.interpretAxes(e, s);
    if (e[o[0]] !== s[o[1]])
      throw new E(`Dimension incompatibility: ${e[o[0]]} !== ${s[o[1]]}`);
  }
  mergeFunction(t) {
    if (t.length !== 2)
      throw new E(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);
    let e = t[0], s = t[1], o;
    return Array.isArray(this.axes) ? o = this.axes.map((r, i6) => Dr(r, t[i6].shape.length)) : o = [
      Dr(this.axes, e.shape.length),
      Dr(this.axes, s.shape.length)
    ], this.normalize && (e = xl(e, o[0]), s = xl(s, o[1])), UE(e, s, o);
  }
  interpretAxes(t, e) {
    let s;
    return Array.isArray(this.axes) ? s = this.axes : s = [
      Dr(this.axes, t.length),
      Dr(this.axes, e.length)
    ], s;
  }
  computeOutputShape(t) {
    v(Array.isArray(t) && t.length === 2 && Array.isArray(t[0]) && Array.isArray(t[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
    const e = t[0].slice(), s = t[1].slice();
    if (e.length > 3 || s.length > 3)
      throw new xt$1("Dot layer does not support tensors of 4D or higher rank yet.");
    const o = this.interpretAxes(e, s);
    e.splice(o[0], 1), s.splice(o[1], 1), s.splice(0, 1);
    const r = e.concat(s);
    return r.length === 1 && r.push(1), r;
  }
  computeMask(t, e) {
    return null;
  }
  getConfig() {
    const t = {
      axes: this.axes,
      normalize: this.normalize
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
Ly$1.className = "Dot";
_(Ly$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
let My$1 = class My extends St$1 {
  constructor(t) {
    super(t), this.supportsMasking = true, this.stddev = t.stddev;
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = super.getConfig(), e = { stddev: this.stddev };
    return Object.assign(e, t), e;
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      const s = mt(t);
      return wa(() => U(jc(s.shape, 0, this.stddev), s), () => s, e.training || false);
    });
  }
};
My$1.className = "GaussianNoise";
_(My$1);
let Wy$1 = class Wy extends St$1 {
  constructor(t) {
    super(t), this.supportsMasking = true, this.rate = t.rate;
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = super.getConfig(), e = { rate: this.rate };
    return Object.assign(e, t), e;
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e);
      const s = mt(t);
      return this.rate > 0 && this.rate < 1 ? wa(() => {
        const r = Math.sqrt(this.rate / (1 - this.rate));
        return G(s, jc(s.shape, 1, r));
      }, () => s, e.training || false) : s;
    });
  }
};
Wy$1.className = "GaussianDropout";
_(Wy$1);
let Dy$1 = class Dy extends St$1 {
  constructor(t) {
    super(t), this.supportsMasking = true, this.rate = t.rate, this.noiseShape = t.noiseShape;
  }
  _getNoiseShape(t) {
    return this.noiseShape || mt(t).shape;
  }
  computeOutputShape(t) {
    return t;
  }
  getConfig() {
    const t = super.getConfig(), e = { rate: this.rate };
    return Object.assign(e, t), e;
  }
  call(t, e) {
    return D(() => {
      if (this.rate < 1 && this.rate > 0) {
        const s = this._getNoiseShape(t);
        return wa(() => {
          const r = mt(t), i6 = 1.6732632423543772, a = 1.0507009873554805, l = -i6 * a;
          let c = Do(Zc(s), this.rate);
          c = es(c, "float32");
          const u = ((1 - this.rate) * (1 + this.rate * l ** 2)) ** -0.5, d = -u * l * this.rate, h6 = U(G(r, c), G(U(c, -1), l));
          return U(G(h6, u), d);
        }, () => mt(t), e.training || false);
      }
      return t;
    });
  }
};
Dy$1.className = "AlphaDropout";
_(Dy$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function ri$1(n, t, e, s, o, r = 1e-3) {
  let i6;
  if (n.rank === 2)
    i6 = X2(n, t, e, s, o, r);
  else if (n.rank === 3)
    i6 = A2(n, t, e, s, o, r);
  else if (n.rank === 4)
    i6 = K2(n, t, e, s, o, r);
  else
    throw new xt$1(`batchNormalization is not implemented for array of rank ${n.rank} yet`);
  return i6;
}
function YE(n, t, e, s, o = 1e-3) {
  return D(() => {
    const r = op(n, s), i6 = r.mean, a = r.variance;
    return [ri$1(n, i6, a, e, t, o), i6, a];
  });
}
function QE(n, t, e, s, o = 1e-3) {
  return D(() => {
    const r = op(n, s), i6 = r.mean, a = r.variance, l = [];
    for (const f of On$1(0, n.rank))
      s.indexOf(f) !== -1 ? l.push(1) : l.push(n.shape[f]);
    const c = W(i6, l), u = W(a, l), d = t == null ? null : W(t, l), h6 = e == null ? null : W(e, l);
    return [ri$1(n, c, u, h6, d, o), i6, a];
  });
}
function JE(n, t, e, s, o = 1e-3) {
  return Rt$1(s.slice().sort(), On$1(0, n.rank - 1)) ? YE(n, t, e, s, o) : QE(n, t, e, s, o);
}
let Fy$1 = class Fy extends St$1 {
  constructor(t) {
    t == null && (t = {}), super(t), this.supportsMasking = true, this.axis = t.axis == null ? -1 : t.axis, this.momentum = t.momentum == null ? 0.99 : t.momentum, this.epsilon = t.epsilon == null ? 1e-3 : t.epsilon, this.center = t.center == null ? true : t.center, this.scale = t.scale == null ? true : t.scale, this.betaInitializer = Ut(t.betaInitializer || "zeros"), this.gammaInitializer = Ut(t.gammaInitializer || "ones"), this.movingMeanInitializer = Ut(t.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = Ut(t.movingVarianceInitializer || "ones"), this.betaConstraint = pe(t.betaConstraint), this.gammaConstraint = pe(t.gammaConstraint), this.betaRegularizer = Yt(t.betaRegularizer), this.gammaRegularizer = Yt(t.gammaRegularizer);
  }
  build(t) {
    t = $t(t);
    const e = this.axis >= 0 ? this.axis : this.axis + t.length, s = t[e];
    if (s == null)
      throw new E(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);
    this.inputSpec = [new de({ ndim: t.length, axes: { [e]: s } })];
    const o = [s];
    this.scale && (this.gamma = this.addWeight("gamma", o, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", o, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", o, null, this.movingMeanInitializer, null, false), this.movingVariance = this.addWeight("moving_variance", o, null, this.movingVarianceInitializer, null, false), this.built = true;
  }
  call(t, e) {
    return D(() => {
      const s = e.training == null ? false : e.training, o = mt(t), r = o.shape, i6 = r.length, a = On$1(0, i6), l = this.axis >= 0 ? this.axis : this.axis + i6;
      a.splice(l, 1);
      const c = Ro(1, i6);
      c[l] = r[l];
      const u = a.slice();
      u.sort();
      const d = !Rt$1(u, On$1(0, i6).slice(0, i6 - 1)), h6 = () => {
        if (d) {
          const x6 = W(this.movingMean.read(), c), w6 = W(this.movingVariance.read(), c), y6 = this.center ? W(this.beta.read(), c) : null, I = this.scale ? W(this.gamma.read(), c) : null;
          return ri$1(o, x6, w6, y6, I, this.epsilon);
        } else
          return ri$1(o, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
      };
      if (!s)
        return h6();
      const [p6, f, m] = JE(o, this.gamma.read(), this.beta.read(), a, this.epsilon), g6 = (x6, w6, y6) => {
        D(() => {
          const I = 1 - y6, C6 = x6.read(), k7 = G(lt(C6, w6), I);
          x6.write(lt(C6, k7));
        });
      };
      return (() => {
        g6(this.movingMean, f, this.momentum), g6(this.movingVariance, m, this.momentum);
      })(), p6;
    });
  }
  getConfig() {
    const t = {
      axis: this.axis,
      momentum: this.momentum,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: Jt(this.betaInitializer),
      gammaInitializer: Jt(this.gammaInitializer),
      movingMeanInitializer: Jt(this.movingMeanInitializer),
      movingVarianceInitializer: Jt(this.movingVarianceInitializer),
      betaRegularizer: Ft$1(this.betaRegularizer),
      gammaRegularizer: Ft$1(this.gammaRegularizer),
      betaConstraint: he$1(this.betaConstraint),
      gammaConstraint: he$1(this.gammaConstraint)
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
Fy$1.className = "BatchNormalization";
_(Fy$1);
let Vy$1 = class Vy extends St$1 {
  constructor(t) {
    if (t == null && (t = {}), super(t), this.axis = t.axis == null ? -1 : t.axis, typeof this.axis == "number") {
      if (!Number.isInteger(this.axis))
        throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
    } else if (Array.isArray(this.axis)) {
      for (const e of this.axis)
        if (!Number.isInteger(e))
          throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
    } else
      throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
    this.epsilon = t.epsilon == null ? 1e-3 : t.epsilon, this.center = t.center == null ? true : t.center, this.scale = t.scale == null ? true : t.scale, this.betaInitializer = Ut(t.betaInitializer || "zeros"), this.gammaInitializer = Ut(t.gammaInitializer || "ones"), this.betaRegularizer = Yt(t.betaRegularizer), this.gammaRegularizer = Yt(t.gammaRegularizer), this.supportsMasking = true;
  }
  build(t) {
    t = $t(t);
    const e = t.length;
    typeof this.axis == "number" && (this.axis = [this.axis]);
    for (let r = 0; r < this.axis.length; ++r)
      this.axis[r] < 0 && (this.axis[r] += e);
    for (const r of this.axis)
      if (r < 0 || r >= e)
        throw new Error(`Invalid axis: ${r}`);
    if (this.axis.length !== Ws(this.axis).length)
      throw new Error(`Found duplicate axes in: ${this.axis}`);
    const s = this.axis.map((r) => t[r]), o = true;
    this.scale ? this.gamma = this.addWeight("gamma", s, "float32", this.gammaInitializer, this.gammaRegularizer, o) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", s, "float32", this.betaInitializer, this.betaRegularizer, o) : this.beta = null, this.built = true;
  }
  call(t, e) {
    const s = mt(t), o = s.shape, r = o.length;
    return D(() => {
      let { mean: a, variance: l } = op(s, this.axis, true);
      const c = Ro(1, r);
      for (const m of this.axis)
        c[m] = o[m];
      const u = (m) => m != null && m.shape.length !== r ? W(m, c) : m;
      let d = this.scale ? u(this.gamma.read()) : null, h6 = this.center ? u(this.beta.read()) : null;
      const p6 = [], f = [];
      for (let m = 0; m < r; ++m)
        this.axis.indexOf(m) !== -1 ? (p6.push(o[m]), f.push(1)) : (p6.push(1), f.push(o[m]));
      return a = Vn$1(a, p6), l = Vn$1(l, p6), d != null && (d = Vn$1(d, f)), h6 != null && (h6 = Vn$1(h6, f)), ri$1(s, a, l, h6, d, this.epsilon);
    });
  }
  getConfig() {
    const t = {
      axis: this.axis,
      epsilon: this.epsilon,
      center: this.center,
      scale: this.scale,
      betaInitializer: Jt(this.betaInitializer),
      gammaInitializer: Jt(this.gammaInitializer),
      betaRegularizer: Ft$1(this.betaRegularizer),
      gammaRegularizer: Ft$1(this.gammaRegularizer)
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
Vy$1.className = "LayerNormalization";
_(Vy$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function jE(n, t, e) {
  return D(() => {
    if (n.rank !== 4)
      throw new E(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);
    if (t == null && (t = [[1, 1], [1, 1]]), t.length !== 2 || t[0].length !== 2 || t[1].length !== 2)
      throw new E("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
    if (e == null && (e = Kn$1()), e !== "channelsLast" && e !== "channelsFirst")
      throw new E(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
    let s;
    return e === "channelsFirst" ? s = [[0, 0], [0, 0], t[0], t[1]] : s = [[0, 0], t[0], t[1], [0, 0]], rp(n, s);
  });
}
let zy$1 = class zy extends St$1 {
  constructor(t) {
    if (t == null && (t = {}), super(t), this.dataFormat = t.dataFormat == null ? Kn$1() : t.dataFormat, t.padding == null)
      this.padding = [[1, 1], [1, 1]];
    else if (typeof t.padding == "number")
      this.padding = [[t.padding, t.padding], [t.padding, t.padding]];
    else {
      if (t.padding = t.padding, t.padding.length !== 2)
        throw new E(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);
      let e, s;
      if (typeof t.padding[0] == "number")
        e = [t.padding[0], t.padding[0]], s = [t.padding[1], t.padding[1]];
      else {
        if (t.padding = t.padding, t.padding[0].length !== 2)
          throw new E(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);
        if (e = t.padding[0], t.padding[1].length !== 2)
          throw new E(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);
        s = t.padding[1];
      }
      this.padding = [e, s];
    }
    this.inputSpec = [new de({ ndim: 4 })];
  }
  computeOutputShape(t) {
    t = $t(t);
    let e, s;
    return this.dataFormat === "channelsFirst" ? (t[2] != null && t[2] >= 0 ? e = t[2] + this.padding[0][0] + this.padding[0][1] : e = null, t[3] != null && t[3] >= 0 ? s = t[3] + this.padding[1][0] + this.padding[1][1] : s = null, [t[0], t[1], e, s]) : (t[1] != null && t[1] >= 0 ? e = t[1] + this.padding[0][0] + this.padding[0][1] : e = null, t[2] != null && t[2] >= 0 ? s = t[2] + this.padding[1][0] + this.padding[1][1] : s = null, [t[0], e, s, t[3]]);
  }
  call(t, e) {
    return D(() => jE(mt(t), this.padding, this.dataFormat));
  }
  getConfig() {
    const t = {
      padding: this.padding,
      dataFormat: this.dataFormat
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
zy$1.className = "ZeroPadding2D";
_(zy$1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function au(n, t, e, s, o, r) {
  return D(() => {
    ae(o), nx(r), fn$1(s), e == null && (e = [1, 1]), s == null && (s = "valid"), o == null && (o = Kn$1()), r == null && (r = "max"), n = wf$1(n, o);
    let i6;
    const a = s === "same" ? "same" : "valid";
    return r === "max" ? i6 = sp(n, t, e, a) : i6 = Bh$1(
      // TODO(cais): Rank check?
      n,
      t,
      e,
      a
    ), o === "channelsFirst" && (i6 = kt(i6, [0, 3, 1, 2])), i6;
  });
}
function Xy$1(n, t, e, s, o, r) {
  return D(() => {
    ae(o), nx(r), fn$1(s), e == null && (e = [1, 1, 1]), s == null && (s = "valid"), o == null && (o = Kn$1()), r == null && (r = "max"), n = ny$1(n, o);
    let i6;
    const a = s === "same" ? "same" : "valid";
    return r === "max" ? i6 = NS(n, t, e, a) : i6 = $2(n, t, e, a), o === "channelsFirst" && (i6 = kt(i6, [0, 4, 1, 2, 3])), i6;
  });
}
let Py$1 = class Py extends St$1 {
  /**
   *
   * @param args Parameters for the Pooling layer.
   *
   * config.poolSize defaults to 2.
   */
  constructor(t) {
    if (t.poolSize == null && (t.poolSize = 2), super(t), typeof t.poolSize == "number")
      this.poolSize = [t.poolSize];
    else if (Array.isArray(t.poolSize) && t.poolSize.length === 1 && typeof t.poolSize[0] == "number")
      this.poolSize = t.poolSize;
    else
      throw new E(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);
    if (be$1(this.poolSize, "poolSize"), t.strides == null)
      this.strides = this.poolSize;
    else if (typeof t.strides == "number")
      this.strides = [t.strides];
    else if (Array.isArray(t.strides) && t.strides.length === 1 && typeof t.strides[0] == "number")
      this.strides = t.strides;
    else
      throw new E(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);
    be$1(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, fn$1(this.padding), this.inputSpec = [new de({ ndim: 3 })];
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = An$1(t[1], this.poolSize[0], this.padding, this.strides[0]);
    return [t[0], e, t[2]];
  }
  call(t, e) {
    return D(() => {
      this.invokeCallHook(t, e), t = xa(mt(t), 2);
      const s = this.poolingFunction(mt(t), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
      return ha(s, [2]);
    });
  }
  getConfig() {
    const t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
let Ay$1 = class Ay extends Py$1 {
  constructor(t) {
    super(t);
  }
  poolingFunction(t, e, s, o, r) {
    return ae(r), fn$1(o), au(t, e, s, o, r, "max");
  }
};
Ay$1.className = "MaxPooling1D";
_(Ay$1);
let Oy$1 = class Oy extends Py$1 {
  constructor(t) {
    super(t);
  }
  poolingFunction(t, e, s, o, r) {
    return ae(r), fn$1(o), au(t, e, s, o, r, "avg");
  }
};
Oy$1.className = "AveragePooling1D";
_(Oy$1);
let Ky$1 = class Ky extends St$1 {
  constructor(t) {
    if (t.poolSize == null && (t.poolSize = [2, 2]), super(t), this.poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize], t.strides == null)
      this.strides = this.poolSize;
    else if (Array.isArray(t.strides)) {
      if (t.strides.length !== 2)
        throw new E(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);
      this.strides = t.strides;
    } else
      this.strides = [t.strides, t.strides];
    be$1(this.poolSize, "poolSize"), be$1(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, ae(this.dataFormat), fn$1(this.padding), this.inputSpec = [new de({ ndim: 4 })];
  }
  computeOutputShape(t) {
    t = $t(t);
    let e = this.dataFormat === "channelsFirst" ? t[2] : t[1], s = this.dataFormat === "channelsFirst" ? t[3] : t[2];
    return e = An$1(e, this.poolSize[0], this.padding, this.strides[0]), s = An$1(s, this.poolSize[1], this.padding, this.strides[1]), this.dataFormat === "channelsFirst" ? [t[0], t[1], e, s] : [t[0], e, s, t[3]];
  }
  call(t, e) {
    return D(() => (this.invokeCallHook(t, e), this.poolingFunction(mt(t), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }
  getConfig() {
    const t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
let Zy$1 = class Zy extends Ky$1 {
  constructor(t) {
    super(t);
  }
  poolingFunction(t, e, s, o, r) {
    return ae(r), fn$1(o), au(t, e, s, o, r, "max");
  }
};
Zy$1.className = "MaxPooling2D";
_(Zy$1);
let By$1 = class By extends Ky$1 {
  constructor(t) {
    super(t);
  }
  poolingFunction(t, e, s, o, r) {
    return ae(r), fn$1(o), au(t, e, s, o, r, "avg");
  }
};
By$1.className = "AveragePooling2D";
_(By$1);
let Hy$1 = class Hy extends St$1 {
  constructor(t) {
    if (t.poolSize == null && (t.poolSize = [2, 2, 2]), super(t), this.poolSize = Array.isArray(t.poolSize) ? t.poolSize : [t.poolSize, t.poolSize, t.poolSize], t.strides == null)
      this.strides = this.poolSize;
    else if (Array.isArray(t.strides)) {
      if (t.strides.length !== 3)
        throw new E(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);
      this.strides = t.strides;
    } else
      this.strides = [t.strides, t.strides, t.strides];
    be$1(this.poolSize, "poolSize"), be$1(this.strides, "strides"), this.padding = t.padding == null ? "valid" : t.padding, this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, ae(this.dataFormat), fn$1(this.padding), this.inputSpec = [new de({ ndim: 5 })];
  }
  computeOutputShape(t) {
    t = $t(t);
    let e = this.dataFormat === "channelsFirst" ? t[2] : t[1], s = this.dataFormat === "channelsFirst" ? t[3] : t[2], o = this.dataFormat === "channelsFirst" ? t[4] : t[3];
    return e = An$1(e, this.poolSize[0], this.padding, this.strides[0]), s = An$1(s, this.poolSize[1], this.padding, this.strides[1]), o = An$1(o, this.poolSize[2], this.padding, this.strides[2]), this.dataFormat === "channelsFirst" ? [t[0], t[1], e, s, o] : [t[0], e, s, o, t[4]];
  }
  call(t, e) {
    return D(() => (this.invokeCallHook(t, e), this.poolingFunction(mt(t), this.poolSize, this.strides, this.padding, this.dataFormat)));
  }
  getConfig() {
    const t = {
      poolSize: this.poolSize,
      padding: this.padding,
      strides: this.strides,
      dataFormat: this.dataFormat
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
let _y$1 = class _y extends Hy$1 {
  constructor(t) {
    super(t);
  }
  poolingFunction(t, e, s, o, r) {
    return ae(r), fn$1(o), Xy$1(t, e, s, o, r, "max");
  }
};
_y$1.className = "MaxPooling3D";
_(_y$1);
let Uy$1 = class Uy extends Hy$1 {
  constructor(t) {
    super(t);
  }
  poolingFunction(t, e, s, o, r) {
    return ae(r), fn$1(o), Xy$1(t, e, s, o, r, "avg");
  }
};
Uy$1.className = "AveragePooling3D";
_(Uy$1);
let Yy$1 = class Yy extends St$1 {
  constructor(t) {
    super(t), this.inputSpec = [new de({ ndim: 3 })];
  }
  computeOutputShape(t) {
    return [t[0], t[2]];
  }
  call(t, e) {
    throw new xt$1();
  }
};
let Qy$1 = class Qy extends Yy$1 {
  constructor(t) {
    super(t || {});
  }
  call(t, e) {
    return D(() => {
      const s = mt(t);
      return se(s, 1);
    });
  }
};
Qy$1.className = "GlobalAveragePooling1D";
_(Qy$1);
let Jy$1 = class Jy extends Yy$1 {
  constructor(t) {
    super(t || {});
  }
  call(t, e) {
    return D(() => {
      const s = mt(t);
      return Xn$1(s, 1);
    });
  }
};
Jy$1.className = "GlobalMaxPooling1D";
_(Jy$1);
let jy$1 = class jy extends St$1 {
  constructor(t) {
    super(t), this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, ae(this.dataFormat), this.inputSpec = [new de({ ndim: 4 })];
  }
  computeOutputShape(t) {
    return t = t, this.dataFormat === "channelsLast" ? [t[0], t[3]] : [t[0], t[1]];
  }
  call(t, e) {
    throw new xt$1();
  }
  getConfig() {
    const t = { dataFormat: this.dataFormat }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
};
let qy$1 = class qy extends jy$1 {
  call(t, e) {
    return D(() => {
      const s = mt(t);
      return this.dataFormat === "channelsLast" ? se(s, [1, 2]) : se(s, [2, 3]);
    });
  }
};
qy$1.className = "GlobalAveragePooling2D";
_(qy$1);
class t1 extends jy$1 {
  call(t, e) {
    return D(() => {
      const s = mt(t);
      return this.dataFormat === "channelsLast" ? Xn$1(s, [1, 2]) : Xn$1(s, [2, 3]);
    });
  }
}
t1.className = "GlobalMaxPooling2D";
_(t1);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class e1 extends St$1 {
  constructor(t) {
    super(t), this.layer = t.layer;
  }
  build(t) {
    this.built = true;
  }
  // TODO(cais): Implement activityRegularizer getter.
  get trainable() {
    return this.layer != null ? this.layer.trainable : false;
  }
  set trainable(t) {
    this.layer != null && (this.layer.trainable = t);
  }
  get trainableWeights() {
    return this.layer.trainableWeights;
  }
  // TODO(cais): Implement setter for trainableWeights.
  get nonTrainableWeights() {
    return this.layer.nonTrainableWeights;
  }
  // TODO(cais): Implement setter for nonTrainableWeights.
  get updates() {
    return this.layer._updates;
  }
  // TODO(cais): Implement getUpdatesFor().
  get losses() {
    return this.layer.losses;
  }
  // TODO(cais): Implement getLossesFor().
  getWeights() {
    return this.layer.getWeights();
  }
  setWeights(t) {
    this.layer.setWeights(t);
  }
  getConfig() {
    const t = {
      layer: {
        className: this.layer.getClassName(),
        config: this.layer.getConfig()
      }
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
  setFastWeightInitDuringBuild(t) {
    super.setFastWeightInitDuringBuild(t), this.layer != null && this.layer.setFastWeightInitDuringBuild(t);
  }
  /** @nocollapse */
  static fromConfig(t, e, s = {}) {
    const o = e.layer, r = Pn$1(o, s);
    delete e.layer;
    const i6 = { layer: r };
    return Object.assign(i6, e), new t(i6);
  }
}
class n1 extends e1 {
  constructor(t) {
    super(t), this.supportsMasking = true;
  }
  build(t) {
    if (t = $t(t), t.length < 3)
      throw new E(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);
    this.inputSpec = [{ shape: t }];
    const e = [t[0]].concat(t.slice(2));
    this.layer.built || (this.layer.build(e), this.layer.built = true), super.build(t);
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = [t[0]].concat(t.slice(2)), s = this.layer.computeOutputShape(e), o = t[1];
    return [s[0], o].concat(s.slice(1));
  }
  call(t, e) {
    return D(() => (t = mt(t), dy$1(
      (i6, a) => [mt(this.layer.call(i6, e)), []],
      t,
      [],
      false,
      null,
      null,
      false,
      true
      /* needPerStepOutputs */
    )[1]));
  }
}
n1.className = "TimeDistributed";
_(n1);
function qE(n) {
  zo(CG, "BidirectionalMergeMode", n);
}
const tL = "concat";
class s1 extends e1 {
  constructor(t) {
    super(t);
    const e = t.layer.getConfig(), s = {};
    s.className = t.layer.getClassName(), s.config = e, this.forwardLayer = Pn$1(s), e.goBackwards = e.goBackwards !== true;
    const o = {};
    if (o.className = t.layer.getClassName(), o.config = e, this.backwardLayer = Pn$1(o), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = t.mergeMode === void 0 ? tL : t.mergeMode, qE(this.mergeMode), t.weights)
      throw new xt$1("weights support is not implemented for Bidirectional layer yet.");
    this._stateful = t.layer.stateful, this.returnSequences = t.layer.returnSequences, this.returnState = t.layer.returnState, this.supportsMasking = true, this._trainable = true, this.inputSpec = t.layer.inputSpec, this.numConstants = null;
  }
  get trainable() {
    return this._trainable;
  }
  set trainable(t) {
    this._trainable = t, this.forwardLayer != null && (this.forwardLayer.trainable = t), this.backwardLayer != null && (this.backwardLayer.trainable = t);
  }
  getWeights() {
    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
  }
  setWeights(t) {
    const e = t.length, s = Math.floor(e / 2);
    this.forwardLayer.setWeights(t.slice(0, s)), this.backwardLayer.setWeights(t.slice(s));
  }
  computeOutputShape(t) {
    let e = this.forwardLayer.computeOutputShape(t);
    Array.isArray(e) && Array.isArray(e[0]) || (e = [e]), e = e;
    let s, o, r;
    return this.returnState && (r = e.slice(1)), s = e[0], s = s, this.mergeMode === "concat" ? (s[s.length - 1] *= 2, o = [s]) : this.mergeMode == null ? o = [s, s.slice()] : o = [s], this.returnState ? this.mergeMode == null ? o.concat(r).concat(r.slice()) : [s].concat(r).concat(r.slice()) : Pe$1(o);
  }
  apply(t, e) {
    let s = e == null ? null : e.initialState, o = e == null ? null : e.constants;
    e == null && (e = {});
    const r = uy$1(t, s, o, this.numConstants);
    if (t = r.inputs, s = r.initialState, o = r.constants, Array.isArray(t) && (s = t.slice(1), t = t[0]), (s == null || s.length === 0) && o == null)
      return super.apply(t, e);
    const i6 = [], a = [];
    if (s != null) {
      const c = s.length;
      if (c % 2 > 0)
        throw new E("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
      e.initialState = s, i6.push(...s);
      const u = s.map((d) => new de({ shape: d.shape }));
      this.forwardLayer.stateSpec = u.slice(0, c / 2), this.backwardLayer.stateSpec = u.slice(c / 2), a.push(...u);
    }
    if (o != null)
      throw new xt$1("Support for constants in Bidirectional layers is not implemented yet.");
    const l = i6[0] instanceof jn$1;
    for (const c of i6)
      if (c instanceof jn$1 !== l)
        throw new E("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
    if (l) {
      const c = [t].concat(i6), u = this.inputSpec.concat(a), d = this.inputSpec;
      this.inputSpec = u;
      const h6 = super.apply(c, e);
      return this.inputSpec = d, h6;
    } else
      return super.apply(t, e);
  }
  call(t, e) {
    return D(() => {
      const s = e.initialState;
      let o, r;
      if (s == null)
        o = this.forwardLayer.call(t, e), r = this.backwardLayer.call(t, e);
      else {
        const l = s.slice(0, s.length / 2), c = s.slice(s.length / 2);
        o = this.forwardLayer.call(t, Object.assign(e, { initialState: l })), r = this.backwardLayer.call(t, Object.assign(e, { initialState: c }));
      }
      let i6;
      this.returnState && (Array.isArray(o) && (i6 = o.slice(1).concat(r.slice(1))), o = o[0], r = r[0]), this.returnSequences && (r = ko(r, 1));
      let a;
      return this.mergeMode === "concat" ? a = rf$1([o, r]) : this.mergeMode === "sum" ? a = U(o, r) : this.mergeMode === "ave" ? a = G(0.5, U(o, r)) : this.mergeMode === "mul" ? a = G(o, r) : this.mergeMode == null && (a = [o, r]), this.returnState ? this.mergeMode == null ? a.concat(i6) : [a].concat(i6) : a;
    });
  }
  resetStates(t) {
    this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
  }
  build(t) {
    fo(this.forwardLayer.name, () => {
      this.forwardLayer.build(t);
    }), fo(this.backwardLayer.name, () => {
      this.backwardLayer.build(t);
    }), this.built = true;
  }
  computeMask(t, e) {
    Array.isArray(e) && (e = e[0]);
    let s;
    if (this.returnSequences ? this.mergeMode == null ? s = [e, e] : s = e : this.mergeMode == null ? s = [null, null] : s = null, this.returnState) {
      const r = this.forwardLayer.states.map((i6) => null);
      return Array.isArray(s) ? s.concat(r).concat(r) : [s].concat(r).concat(r);
    } else
      return s;
  }
  get trainableWeights() {
    return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
  }
  get nonTrainableWeights() {
    return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
  }
  // TODO(cais): Implement constraints().
  setFastWeightInitDuringBuild(t) {
    super.setFastWeightInitDuringBuild(t), this.forwardLayer != null && this.forwardLayer.setFastWeightInitDuringBuild(t), this.backwardLayer != null && this.backwardLayer.setFastWeightInitDuringBuild(t);
  }
  getConfig() {
    const t = {
      mergeMode: this.mergeMode
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
  /** @nocollapse */
  static fromConfig(t, e) {
    const s = Pn$1(e.layer);
    if (delete e.layer, e.numConstants != null)
      throw new xt$1("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
    const o = e;
    return o.layer = s, new t(o);
  }
}
s1.className = "Bidirectional";
_(s1);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class o1 extends St$1 {
  constructor(t) {
    super(t), this.scale = t.scale, t.offset ? this.offset = t.offset : this.offset = 0;
  }
  getConfig() {
    const t = {
      scale: this.scale,
      offset: this.offset
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
  call(t, e) {
    return D(() => (t = mt(t), t.dtype !== "float32" && (t = es(t, "float32")), U(G(t, this.scale), this.offset)));
  }
}
o1.className = "Rescaling";
_(o1);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const { resizeBilinear: eL, cropAndResize: nL } = uo;
class r1 extends St$1 {
  constructor(t) {
    super(t), this.height = t.height, this.width = t.width;
  }
  centerCrop(t, e, s, o, r, i6, a, l) {
    return D(() => {
      let c, u = false;
      const d = e / i6, h6 = s / a, p6 = (o + e) / i6, f = (r + s) / a, m = [d, h6, p6, f], g6 = [];
      t.rank === 3 ? (u = true, c = os([t])) : c = t;
      for (let I = 0; I < c.shape[0]; I++)
        g6.push(m);
      const b6 = Re$1(g6, [g6.length, 4]), x6 = ti$1(0, g6.length, 1, "int32"), y6 = nL(c, b6, x6, [o, r], "nearest");
      return es(u ? mt(To(y6)) : y6, l);
    });
  }
  upsize(t, e, s, o) {
    return D(() => {
      const r = eL(t, [e, s]);
      return es(r, o);
    });
  }
  call(t, e) {
    return D(() => {
      const s = mt(t), o = s.dtype, r = s.shape, i6 = r[r.length - 3], a = r[r.length - 2];
      let l = 0;
      i6 !== this.height && (l = Math.floor((i6 - this.height) / 2));
      let c = 0;
      return a !== this.width && (c = Math.floor((a - this.width) / 2), c === 0 && (c = 1)), l >= 0 && c >= 0 ? this.centerCrop(s, l, c, this.height, this.width, i6, a, o) : this.upsize(t, this.height, this.width, o);
    });
  }
  getConfig() {
    const t = {
      height: this.height,
      width: this.width
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = t.length - 3, s = t.length - 2;
    return t[e] = this.height, t[s] = this.width, t;
  }
}
r1.className = "CenterCrop";
_(r1);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function sL(n, t, e, s) {
  let o = mt(n);
  if (o.dtype !== "int32" && (o = es(o, "int32")), t === "int")
    return o;
  const r = o.shape;
  if (o.rank === 0 && (o = Ue$1(o, -1)), t === "oneHot" && o.shape[o.shape.length - 1] !== 1 && (o = Ue$1(o, -1)), o.rank > 2)
    throw new E(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${r} which would result in output rank ${o.rank}.`);
  const i6 = ["multiHot", "oneHot"].includes(t), a = o;
  let l;
  if (typeof s < "u" && t === "count" ? l = rm(a, s, e, i6) : l = rm(a, [], e, i6), t !== "tfIdf")
    return l;
  if (s)
    return G(l, s);
  throw new E("When outputMode is 'tfIdf', weights must be provided.");
}
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class i1 extends St$1 {
  constructor(t) {
    super(t), this.numTokens = t.numTokens, t.outputMode ? this.outputMode = t.outputMode : this.outputMode = "multiHot";
  }
  getConfig() {
    const t = {
      numTokens: this.numTokens,
      outputMode: this.outputMode
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
  computeOutputShape(t) {
    return t = $t(t), t == null ? [this.numTokens] : this.outputMode === "oneHot" && t[t.length - 1] !== 1 ? (t.push(this.numTokens), t) : (t[t.length - 1] = this.numTokens, t);
  }
  call(t, e) {
    return D(() => {
      t = mt(t), t.dtype !== "int32" && (t = es(t, "int32"));
      let s;
      if (typeof e.countWeights < "u") {
        if (this.outputMode !== "count")
          throw new E(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);
        s = mt(e.countWeights);
      }
      const o = Xn$1(t), r = ul(t), i6 = sn$1(this.numTokens, o).bufferSync().get(0), a = Do(r, 0).bufferSync().get(0);
      if (!(i6 && a))
        throw new E(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);
      return sL(t, this.outputMode, this.numTokens, s);
    });
  }
}
i1.className = "CategoryEncoding";
_(i1);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const oL = ["bilinear", "nearest"], Pm = new Set(oL);
class a1 extends St$1 {
  constructor(t) {
    if (super(t), this.height = t.height, this.width = t.width, t.interpolation)
      if (Pm.has(t.interpolation))
        this.interpolation = t.interpolation;
      else
        throw new E(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);
    else
      this.interpolation = "bilinear";
    this.cropToAspectRatio = !!t.cropToAspectRatio;
  }
  computeOutputShape(t) {
    t = $t(t);
    const e = t[2];
    return [this.height, this.width, e];
  }
  getConfig() {
    const t = {
      height: this.height,
      width: this.width,
      interpolation: this.interpolation,
      cropToAspectRatio: this.cropToAspectRatio
    }, e = super.getConfig();
    return Object.assign(t, e), t;
  }
  call(t, e) {
    return D(() => {
      const s = [this.height, this.width];
      if (this.interpolation === "bilinear")
        return uo.resizeBilinear(t, s, !this.cropToAspectRatio);
      if (this.interpolation === "nearest")
        return uo.resizeNearestNeighbor(t, s, !this.cropToAspectRatio);
      throw new Error(`Interpolation is ${this.interpolation} but only ${[...Pm]} are supported`);
    });
  }
}
a1.className = "Resizing";
_(a1);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rL = F();
rL.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (n) => {
  n && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var Am;
(function(n) {
  n[n.DT_INVALID = 0] = "DT_INVALID", n[n.DT_FLOAT = 1] = "DT_FLOAT", n[n.DT_DOUBLE = 2] = "DT_DOUBLE", n[n.DT_INT32 = 3] = "DT_INT32", n[n.DT_UINT8 = 4] = "DT_UINT8", n[n.DT_INT16 = 5] = "DT_INT16", n[n.DT_INT8 = 6] = "DT_INT8", n[n.DT_STRING = 7] = "DT_STRING", n[n.DT_COMPLEX64 = 8] = "DT_COMPLEX64", n[n.DT_INT64 = 9] = "DT_INT64", n[n.DT_BOOL = 10] = "DT_BOOL", n[n.DT_QINT8 = 11] = "DT_QINT8", n[n.DT_QUINT8 = 12] = "DT_QUINT8", n[n.DT_QINT32 = 13] = "DT_QINT32", n[n.DT_BFLOAT16 = 14] = "DT_BFLOAT16", n[n.DT_QINT16 = 15] = "DT_QINT16", n[n.DT_QUINT16 = 16] = "DT_QUINT16", n[n.DT_UINT16 = 17] = "DT_UINT16", n[n.DT_COMPLEX128 = 18] = "DT_COMPLEX128", n[n.DT_HALF = 19] = "DT_HALF", n[n.DT_RESOURCE = 20] = "DT_RESOURCE", n[n.DT_VARIANT = 21] = "DT_VARIANT", n[n.DT_UINT32 = 22] = "DT_UINT32", n[n.DT_UINT64 = 23] = "DT_UINT64", n[n.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", n[n.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", n[n.DT_INT32_REF = 103] = "DT_INT32_REF", n[n.DT_UINT8_REF = 104] = "DT_UINT8_REF", n[n.DT_INT16_REF = 105] = "DT_INT16_REF", n[n.DT_INT8_REF = 106] = "DT_INT8_REF", n[n.DT_STRING_REF = 107] = "DT_STRING_REF", n[n.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", n[n.DT_INT64_REF = 109] = "DT_INT64_REF", n[n.DT_BOOL_REF = 110] = "DT_BOOL_REF", n[n.DT_QINT8_REF = 111] = "DT_QINT8_REF", n[n.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", n[n.DT_QINT32_REF = 113] = "DT_QINT32_REF", n[n.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", n[n.DT_QINT16_REF = 115] = "DT_QINT16_REF", n[n.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", n[n.DT_UINT16_REF = 117] = "DT_UINT16_REF", n[n.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", n[n.DT_HALF_REF = 119] = "DT_HALF_REF", n[n.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", n[n.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", n[n.DT_UINT32_REF = 122] = "DT_UINT32_REF", n[n.DT_UINT64_REF = 123] = "DT_UINT64_REF";
})(Am || (Am = {}));
var Om;
(function(n) {
  (function(t) {
    t[t.LEGACY = 0] = "LEGACY", t[t.V1 = 1] = "V1", t[t.V2 = 2] = "V2";
  })(n.CheckpointFormatVersion || (n.CheckpointFormatVersion = {}));
})(Om || (Om = {}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function iL(n, t) {
  return vl(n, t);
}
function vl(n, t, e = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set()) {
  if (n == null)
    return null;
  if (typeof Blob == "function" && n instanceof Blob)
    return n.slice();
  if (s.has(n))
    throw new Error("Circular references are not supported.");
  if (e.has(n))
    return e.get(n);
  const o = t(n);
  if (o.recurse && o.value !== null)
    throw new Error("A deep map function may not return both a value and recurse=true.");
  if (o.recurse)
    if (lr(n)) {
      const r = Array.isArray(n) ? [] : {};
      s.add(n);
      for (const i6 in n) {
        const a = n[i6], l = vl(a, t, e, s);
        r[i6] = l;
      }
      return s.delete(n), n.__proto__ && (r.__proto__ = n.__proto__), r;
    } else
      throw new Error(`Can't recurse into non-iterable type: ${n}`);
  else
    return e.set(n, o.value), o.value;
}
function aL(n, t = c1) {
  return l1(n, t);
}
function l1(n, t, e = /* @__PURE__ */ new Set()) {
  const s = n[0];
  if (e.has(s))
    throw new Error("Circular references are not supported.");
  const o = t(n);
  if (o.recurse && o.value !== null)
    throw new Error("A deep zip function may not return both a value and recurse=true.");
  if (o.recurse)
    if (lr(s)) {
      const r = Array.isArray(s) ? [] : {};
      e.add(s);
      for (const i6 in s) {
        const a = n.map((c) => c[i6]), l = l1(a, t, e);
        r[i6] = l;
      }
      return e.delete(s), r;
    } else
      throw new Error(`Can't recurse into non-iterable type: ${s}`);
  else
    return o.value;
}
function c1(n) {
  return n === null ? null : lr(n[0]) ? { value: null, recurse: true } : { value: n, recurse: false };
}
async function u1(n, t) {
  const e = /* @__PURE__ */ new Map();
  vl(n, t, e);
  for (const o of Array.from(e.keys())) {
    const r = e.get(o);
    if (ui$1(r)) {
      const i6 = await r;
      e.set(o, i6);
    }
  }
  return vl(n, t, e);
}
function lr(n) {
  let t = false;
  if (F().get("IS_BROWSER"))
    t = n instanceof TextDecoder;
  else {
    const { StringDecoder: e } = require("string_decoder");
    t = n instanceof e;
  }
  return n != null && !ArrayBuffer.isView(n) && (Array.isArray(n) || typeof n == "object" && !(n instanceof Lt$1) && !(n instanceof Promise) && !t);
}
function lL(n) {
  return n == null || cL(n) || Array.isArray(n) || typeof n == "object" && n instanceof Lt$1 || dn$1(n);
}
function cL(n) {
  return n === null || typeof n != "object" && typeof n != "function";
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function uL(n) {
  return iL(n, dL);
}
function dL(n) {
  return n instanceof Lt$1 ? { value: n.clone(), recurse: false } : lr(n) ? { value: null, recurse: true } : { value: n, recurse: false };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class d1 {
  /**
   * Constructs a `RingBuffer`.
   * @param capacity The number of items that the buffer can accomodate.
   */
  constructor(t) {
    if (this.capacity = t, this.begin = 0, this.end = 0, t == null)
      throw new RangeError("Can't create a ring buffer of unknown capacity.");
    if (t < 1)
      throw new RangeError("Can't create ring buffer of capacity < 1.");
    this.data = new Array(t), this.doubledCapacity = 2 * t;
  }
  /**
   * Map any index into the range 0 <= index < 2*capacity.
   */
  wrap(t) {
    for (; t < 0; )
      t += this.doubledCapacity;
    return t % this.doubledCapacity;
  }
  get(t) {
    if (t < 0)
      throw new RangeError("Can't get item at a negative index.");
    return this.data[t % this.capacity];
  }
  set(t, e) {
    if (t < 0)
      throw new RangeError("Can't set item at a negative index.");
    this.data[t % this.capacity] = e;
  }
  /**
   * Returns the current number of items in the buffer.
   */
  length() {
    let t = this.end - this.begin;
    return t < 0 && (t = this.doubledCapacity + t), t;
  }
  /**
   * Reports whether the buffer is full.
   * @returns true if the number of items in the buffer equals its capacity, and
   *   false otherwise.
   */
  isFull() {
    return this.length() === this.capacity;
  }
  /**
   * Reports whether the buffer is empty.
   * @returns true if the number of items in the buffer equals zero, and
   *   false otherwise.
   */
  isEmpty() {
    return this.length() === 0;
  }
  /**
   * Adds an item to the end of the buffer.
   */
  push(t) {
    if (this.isFull())
      throw new RangeError("Ring buffer is full.");
    this.set(this.end, t), this.end = this.wrap(this.end + 1);
  }
  /**
   * Adds many items to the end of the buffer, in order.
   */
  pushAll(t) {
    for (const e of t)
      this.push(e);
  }
  /**
   * Removes and returns the last item in the buffer.
   */
  pop() {
    if (this.isEmpty())
      throw new RangeError("Ring buffer is empty.");
    this.end = this.wrap(this.end - 1);
    const t = this.get(this.end);
    return this.set(this.end, void 0), t;
  }
  /**
   * Adds an item to the beginning of the buffer.
   */
  unshift(t) {
    if (this.isFull())
      throw new RangeError("Ring buffer is full.");
    this.begin = this.wrap(this.begin - 1), this.set(this.begin, t);
  }
  /**
   * Removes and returns the first item in the buffer.
   */
  shift() {
    if (this.isEmpty())
      throw new RangeError("Ring buffer is empty.");
    const t = this.get(this.begin);
    return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), t;
  }
  /**
   * Removes and returns a specific item in the buffer, and moves the last item
   * to the vacated slot.  This is useful for implementing a shuffling stream.
   * Note that this operation necessarily scrambles the original order.
   *
   * @param relativeIndex: the index of the item to remove, relative to the
   *   first item in the buffer (e.g., hiding the ring nature of the underlying
   *   storage).
   */
  shuffleExcise(t) {
    if (this.isEmpty())
      throw new RangeError("Ring buffer is empty.");
    const e = this.wrap(this.begin + t), s = this.get(e);
    return this.set(e, this.pop()), s;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class lu extends d1 {
  /**
   * Constructs a `GrowingRingBuffer`.
   */
  constructor() {
    super(lu.INITIAL_CAPACITY);
  }
  isFull() {
    return false;
  }
  push(t) {
    super.isFull() && this.expand(), super.push(t);
  }
  unshift(t) {
    super.isFull() && this.expand(), super.unshift(t);
  }
  /**
   * Doubles the capacity of the buffer.
   */
  expand() {
    const t = this.capacity * 2, e = new Array(t), s = this.length();
    for (let o = 0; o < s; o++)
      e[o] = this.get(this.wrap(this.begin + o));
    this.data = e, this.capacity = t, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = s;
  }
}
lu.INITIAL_CAPACITY = 32;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function h1(n) {
  return new mL(n);
}
function hL(n) {
  return new gL(n);
}
function pL(n, t) {
  return new p1(n, t);
}
function fL(n, t = Es.FAIL) {
  return new TL(n, t);
}
let Ke$1 = class Ke {
  /**
   * Collect all remaining elements of a bounded stream into an array.
   * Obviously this will succeed only for small streams that fit in memory.
   * Useful for testing.
   *
   * @returns A Promise for an array of stream elements, which will resolve
   *   when the stream is exhausted.
   */
  async toArray() {
    const t = [];
    let e = await this.next();
    for (; !e.done; )
      t.push(e.value), e = await this.next();
    return t;
  }
  /**
   * Collect all elements of this dataset into an array with prefetching 100
   * elements. This is useful for testing, because the prefetch changes the
   * order in which the Promises are resolved along the processing pipeline.
   * This may help expose bugs where results are dependent on the order of
   * Promise resolution rather than on the logical order of the stream (i.e.,
   * due to hidden mutable state).
   *
   * @returns A Promise for an array of stream elements, which will resolve
   *   when the stream is exhausted.
   */
  async toArrayForTest() {
    const t = this.prefetch(100), e = [];
    let s = await t.next();
    for (; !s.done; )
      e.push(s.value), s = await t.next();
    return e;
  }
  /**
   * Draw items from the stream until it is exhausted.
   *
   * This can be useful when the stream has side effects but no output.  In
   * that case, calling this function guarantees that the stream will be
   * fully processed.
   */
  async resolveFully() {
    let t = await this.next();
    for (; !t.done; )
      t = await this.next();
  }
  /**
   * Draw items from the stream until it is exhausted, or a predicate fails.
   *
   * This can be useful when the stream has side effects but no output.  In
   * that case, calling this function guarantees that the stream will be
   * fully processed.
   */
  async resolveWhile(t) {
    let e = await this.next(), s = t(e.value);
    for (; !e.done && s; )
      e = await this.next(), s = t(e.value);
  }
  /**
   * Handles errors thrown on this stream using a provided handler function.
   *
   * @param handler A function that handles any `Error` thrown during a `next()`
   *   call and returns true if the stream should continue (dropping the failed
   *   call) or false if the stream should quietly terminate.  If the handler
   *   itself throws (or rethrows) an `Error`, that will be propagated.
   *
   * @returns A `LazyIterator` of elements passed through from upstream,
   *   possibly filtering or terminating on upstream `next()` calls that
   *   throw an `Error`.
   */
  handleErrors(t) {
    return new vL(this, t);
  }
  // TODO(soergel): Implement reduce() etc.
  /**
   * Filters this stream according to `predicate`.
   *
   * @param predicate A function mapping a stream element to a boolean or a
   * `Promise` for one.
   *
   * @returns A `LazyIterator` of elements for which the predicate was true.
   */
  filter(t) {
    return new IL(this, t);
  }
  /**
   * Maps this stream through a 1-to-1 transform.
   *
   * @param transform A function mapping a stream element to a transformed
   *   element.
   *
   * @returns A `LazyIterator` of transformed elements.
   */
  map(t) {
    return new CL(this, t);
  }
  /**
   * Maps this stream through an async 1-to-1 transform.
   *
   * @param transform A function mapping a stream element to a `Promise` for a
   *   transformed stream element.
   *
   * @returns A `LazyIterator` of transformed elements.
   */
  mapAsync(t) {
    return new Km(this, t);
  }
  /**
   * Maps this stream through a 1-to-1 transform, forcing serial execution.
   *
   * @param transform A function mapping a stream element to a transformed
   *   element.
   *
   * @returns A `LazyIterator` of transformed elements.
   */
  serialMapAsync(t) {
    return new Km(this, t).serial();
  }
  /**
   * Maps this stream through a 1-to-many transform.
   *
   * @param transform A function mapping a stream element to an array of
   *   transformed elements.
   *
   * @returns A `DataStream` of transformed elements.
   */
  flatmap(t) {
    return new kL(this, t);
  }
  /**
   * Apply a function to every element of the stream.
   *
   * @param f A function to apply to each stream element.
   */
  async forEachAsync(t) {
    return this.map(t).resolveFully();
  }
  /**
   * Apply a function to every element of the stream, forcing serial execution.
   *
   * @param f A function to apply to each stream element.  Should return 'true'
   *   to indicate that the stream should continue, or 'false' to cause it to
   *   terminate.
   */
  async serialForEach(t) {
    return this.serialMapAsync(t).resolveWhile((e) => e === true);
  }
  /**
   * Groups elements into batches, represented as arrays of elements.
   *
   * We can think of the elements of this iterator as 'rows' (even if they are
   * nested structures).  By the same token, consecutive values for a given
   * key within the elements form a 'column'.  This matches the usual sense of
   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).
   *
   * Thus, "Row-major" means that the resulting batch is simply a collection of
   * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major
   * form, which is needed for vectorized computation.
   *
   * @param batchSize The number of elements desired per batch.
   * @param smallLastBatch Whether to emit the final batch when it has fewer
   *   than batchSize elements. Default true.
   * @returns A `LazyIterator` of batches of elements, represented as arrays
   *   of the original element type.
   */
  rowMajorBatch(t, e = true) {
    return new wL(this, t, e);
  }
  /**
   * Groups elements into batches, represented in column-major form.
   *
   * We can think of the elements of this iterator as 'rows' (even if they are
   * nested structures).  By the same token, consecutive values for a given
   * key within the elements form a 'column'.  This matches the usual sense of
   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).
   *
   * Thus, "column-major" means that the resulting batch is a (potentially
   * nested) structure representing the columns.  Each column entry, then,
   * contains a collection of the values found in that column for a range of
   * input elements.  This representation allows for vectorized computation, in
   * contrast to the row-major form.
   *
   * The inputs should all have the same nested structure (i.e., of arrays and
   * dicts).  The result is a single object with the same nested structure,
   * where the leaves are arrays collecting the values of the inputs at that
   * location (or, optionally, the result of a custom function applied to those
   * arrays).
   *
   * @param batchSize The number of elements desired per batch.
   * @param smallLastBatch Whether to emit the final batch when it has fewer
   *   than batchSize elements. Default true.
   * @param zipFn: (optional) A function that expects an array of elements at a
   *   single node of the object tree, and returns a `DeepMapResult`.  The
   *   `DeepMapResult` either provides a result value for that node (i.e.,
   *   representing the subtree), or indicates that the node should be processed
   *   recursively.  The default zipFn recurses as far as possible and places
   *   arrays at the leaves.
   * @returns A `LazyIterator` of batches of elements, represented as an object
   *   with collections at the leaves.
   */
  columnMajorBatch(t, e = true, s = c1) {
    return this.rowMajorBatch(t, e).map((r) => aL(r, s));
  }
  /**
   * Concatenate this `LazyIterator` with another.
   *
   * @param iterator A `LazyIterator` to be concatenated onto this one.
   * @param baseErrorHandler An optional function that can intercept `Error`s
   *   raised during a `next()` call on the base stream.  This function can
   *   decide whether the error should be propagated, whether the error should
   *   be ignored, or whether the base stream should be terminated.
   * @returns A `LazyIterator`.
   */
  concatenate(t, e) {
    return new p1(h1([this, t]), e);
  }
  /**
   * Limits this stream to return at most `count` items.
   *
   * @param count The maximum number of items to provide from the stream. If
   * a negative or undefined value is given, the entire stream is returned
   *   unaltered.
   */
  take(t) {
    return t < 0 || t == null ? this : new yL(this, t);
  }
  /**
   * Skips the first `count` items in this stream.
   *
   * @param count The number of items to skip.  If a negative or undefined
   * value is given, the entire stream is returned unaltered.
   */
  skip(t) {
    return t < 0 || t == null ? this : new xL(this, t);
  }
  /**
   * Prefetch the first `bufferSize` items in this stream.
   *
   * Note this prefetches Promises, but makes no guarantees about when those
   * Promises resolve.
   *
   * @param bufferSize: An integer specifying the number of elements to be
   *   prefetched.
   */
  prefetch(t) {
    return new f1(this, t);
  }
  // TODO(soergel): deep sharded shuffle, where supported
  /**
   * Randomly shuffles the elements of this stream.
   *
   * @param bufferSize: An integer specifying the number of elements from
   * this stream from which the new stream will sample.
   * @param seed: (Optional.) An integer specifying the random seed that
   * will be used to create the distribution.
   */
  shuffle(t, e) {
    return new NL(this, t, e);
  }
  /**
   * Force an iterator to execute serially: each next() call will await the
   * prior one, so that they cannot execute concurrently.
   */
  serial() {
    return new bL(this);
  }
};
class mL extends Ke$1 {
  constructor(t) {
    super(), this.items = t, this.trav = 0;
  }
  summary() {
    return `Array of ${this.items.length} items`;
  }
  async next() {
    if (this.trav >= this.items.length)
      return { value: null, done: true };
    const t = this.items[this.trav];
    return this.trav++, { value: uL(t), done: false };
  }
}
class gL extends Ke$1 {
  constructor(t) {
    super(), this.nextFn = t;
  }
  summary() {
    return "Function call";
  }
  async next() {
    try {
      return this.nextFn();
    } catch (t) {
      throw t.message = `Error thrown while iterating through a dataset: ${t.message}`, t;
    }
  }
}
class bL extends Ke$1 {
  constructor(t) {
    super(), this.upstream = t, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Serial`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    return this.upstream.next();
  }
}
class xL extends Ke$1 {
  constructor(t, e) {
    super(), this.upstream = t, this.maxCount = e, this.count = 0, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Skip`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    for (; this.count++ < this.maxCount; ) {
      const t = await this.upstream.next();
      if (t.done)
        return t;
      yt$1(t.value);
    }
    return this.upstream.next();
  }
}
class yL extends Ke$1 {
  constructor(t, e) {
    super(), this.upstream = t, this.maxCount = e, this.count = 0;
  }
  summary() {
    return `${this.upstream.summary()} -> Take`;
  }
  async next() {
    return this.count++ >= this.maxCount ? { value: null, done: true } : this.upstream.next();
  }
}
class wL extends Ke$1 {
  constructor(t, e, s = true) {
    super(), this.upstream = t, this.batchSize = e, this.enableSmallLastBatch = s, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> RowMajorBatch`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    const t = [];
    for (; t.length < this.batchSize; ) {
      const e = await this.upstream.next();
      if (e.done)
        return this.enableSmallLastBatch && t.length > 0 ? { value: t, done: false } : { value: null, done: true };
      t.push(e.value);
    }
    return { value: t, done: false };
  }
}
class IL extends Ke$1 {
  constructor(t, e) {
    super(), this.upstream = t, this.predicate = e, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> Filter`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    for (; ; ) {
      const t = await this.upstream.next();
      if (t.done || this.predicate(t.value))
        return t;
      yt$1(t.value);
    }
  }
}
class CL extends Ke$1 {
  constructor(t, e) {
    super(), this.upstream = t, this.transform = e;
  }
  summary() {
    return `${this.upstream.summary()} -> Map`;
  }
  async next() {
    const t = await this.upstream.next();
    if (t.done)
      return { value: null, done: true };
    const e = fs(t.value), s = this.transform(t.value), o = fs(s);
    for (const r of e)
      Vc(r, o) || r.dispose();
    return { value: s, done: false };
  }
}
class vL extends Ke$1 {
  constructor(t, e) {
    super(), this.upstream = t, this.handler = e, this.count = 0, this.lastRead = Promise.resolve({ value: null, done: false });
  }
  summary() {
    return `${this.upstream.summary()} -> handleErrors`;
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    for (; ; )
      try {
        return await this.upstream.next();
      } catch (t) {
        if (!this.handler(t))
          return { value: null, done: true };
      }
  }
}
class Km extends Ke$1 {
  constructor(t, e) {
    super(), this.upstream = t, this.transform = e;
  }
  summary() {
    return `${this.upstream.summary()} -> AsyncMap`;
  }
  async next() {
    const t = await this.upstream.next();
    if (t.done)
      return { value: null, done: true };
    const e = fs(t.value), s = await this.transform(t.value), o = fs(s);
    for (const r of e)
      Vc(r, o) || r.dispose();
    return { value: s, done: false };
  }
}
class SL extends Ke$1 {
  constructor() {
    super(), this.outputQueue = new lu(), this.lastRead = Promise.resolve({ value: null, done: false });
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  async serialNext() {
    for (; this.outputQueue.length() === 0; )
      if (!await this.pump())
        return { value: null, done: true };
    return { value: this.outputQueue.shift(), done: false };
  }
}
class kL extends SL {
  constructor(t, e) {
    super(), this.upstream = t, this.transform = e;
  }
  summary() {
    return `${this.upstream.summary()} -> Flatmap`;
  }
  async pump() {
    const t = await this.upstream.next();
    if (t.done)
      return false;
    const e = fs(t.value), s = this.transform(t.value), o = fs(s);
    this.outputQueue.pushAll(s);
    for (const r of e)
      Vc(r, o) || r.dispose();
    return true;
  }
}
class p1 extends Ke$1 {
  constructor(t, e) {
    super(), this.baseErrorHandler = e, this.lastRead = null, this.iterator = null, this.moreIterators = t;
  }
  summary() {
    return "TODO: fill in upstream of chained summaries -> Chained";
  }
  async next() {
    return this.lastRead = this.readFromChain(this.lastRead), this.lastRead;
  }
  async readFromChain(t) {
    if (await t, this.iterator == null) {
      const s = await this.moreIterators.next();
      if (s.done)
        return { value: null, done: true };
      this.iterator = s.value, this.baseErrorHandler != null && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler));
    }
    const e = await this.iterator.next();
    return e.done ? (this.iterator = null, this.readFromChain(t)) : e;
  }
}
var Es;
(function(n) {
  n[n.FAIL = 0] = "FAIL", n[n.SHORTEST = 1] = "SHORTEST", n[n.LONGEST = 2] = "LONGEST";
})(Es || (Es = {}));
class TL extends Ke$1 {
  constructor(t, e = Es.FAIL) {
    super(), this.iterators = t, this.mismatchMode = e, this.count = 0, this.currentPromise = null;
  }
  summary() {
    return "{TODO: fill in upstream of zip summaries} -> Zip";
  }
  async nextState(t) {
    await t;
    let e = 0, s = 0;
    function o(i6) {
      return i6 instanceof Ke$1 ? {
        value: i6.next().then((l) => (e++, l.done && s++, l.value)),
        recurse: false
      } : { value: null, recurse: true };
    }
    const r = await u1(this.iterators, o);
    if (e === s)
      return { value: null, done: true };
    if (s > 0)
      switch (this.mismatchMode) {
        case Es.FAIL:
          throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);
        case Es.SHORTEST:
          return { value: null, done: true };
        case Es.LONGEST:
      }
    return this.count++, { value: r, done: false };
  }
  async next() {
    return this.currentPromise = this.nextState(this.currentPromise), this.currentPromise;
  }
}
class f1 extends Ke$1 {
  constructor(t, e) {
    super(), this.upstream = t, this.bufferSize = e, this.buffer = new d1(e);
  }
  summary() {
    return `${this.upstream.summary()} -> Prefetch`;
  }
  /**
   * Refill the prefetch buffer.  Returns only after the buffer is full, or
   * the upstream source is exhausted.
   */
  refill() {
    for (; !this.buffer.isFull(); ) {
      const t = this.upstream.next();
      this.buffer.push(t);
    }
  }
  next() {
    return this.refill(), this.buffer.shift();
  }
}
class NL extends f1 {
  constructor(t, e, s) {
    super(t, e), this.upstream = t, this.windowSize = e, this.upstreamExhausted = false, this.random = wr.alea(s || Ce$1().toString()), this.lastRead = Promise.resolve({ value: null, done: false });
  }
  async next() {
    return this.lastRead = this.lastRead.then(() => this.serialNext()), this.lastRead;
  }
  randomInt(t) {
    return Math.floor(this.random() * t);
  }
  chooseIndex() {
    return this.randomInt(this.buffer.length());
  }
  async serialNext() {
    for (this.upstreamExhausted || this.refill(); !this.buffer.isEmpty(); ) {
      const t = this.chooseIndex(), e = await this.buffer.shuffleExcise(t);
      if (e.done)
        this.upstreamExhausted = true;
      else
        return this.refill(), e;
    }
    return { value: null, done: true };
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
let Tf$1 = class Tf {
  constructor() {
    this.size = null;
  }
  // TODO(soergel): Make Datasets report whether repeated iterator() calls
  // produce the same result (e.g., reading from a file) or different results
  // (e.g., from the webcam).  Currently we don't make this distinction but it
  // could be important for the user to know.
  // abstract isDeterministic(): boolean;
  /**
   * Groups elements into batches.
   *
   * It is assumed that each of the incoming dataset elements has the same
   * structure -- i.e. the same set of keys at each location in an object
   * hierarchy.  For each key, the resulting `Dataset` provides a batched
   * element collecting all of the incoming values for that key.
   *
   *  * Incoming primitives are grouped into a 1-D Tensor.
   *  * Incoming Tensors are grouped into a new Tensor where the 0th axis is
   *    the batch dimension.
   *  * Incoming arrays are converted to Tensor and then batched.
   *  * A nested array is interpreted as an n-D Tensor, so the batched result
   *    has n+1 dimensions.
   *  * An array that cannot be converted to Tensor produces an error.
   *
   * If an array should not be batched as a unit, it should first be converted
   * to an object with integer keys.
   *
   * Here are a few examples:
   *
   * Batch a dataset of numbers:
   * ```js
   * const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8]).batch(4);
   * await a.forEachAsync(e => e.print());
   * ```
   *
   * Batch a dataset of arrays:
   * ```js
   * const b = tf.data.array([[1], [2], [3], [4], [5], [6], [7], [8]]).batch(4);
   * await b.forEachAsync(e => e.print());
   * ```
   *
   * Batch a dataset of objects:
   * ```js
   * const c = tf.data.array([{a: 1, b: 11}, {a: 2, b: 12}, {a: 3, b: 13},
   *   {a: 4, b: 14}, {a: 5, b: 15}, {a: 6, b: 16}, {a: 7, b: 17},
   *   {a: 8, b: 18}]).batch(4);
   * await c.forEachAsync(e => {
   *   console.log('{');
   *   for(var key in e) {
   *     console.log(key+':');
   *     e[key].print();
   *   }
   *   console.log('}');
   * })
   * ```
   *
   * @param batchSize The number of elements desired per batch.
   * @param smallLastBatch Whether to emit the final batch when it has fewer
   *   than batchSize elements. Default true.
   * @returns A `Dataset`, from which a stream of batches can be obtained.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  batch(t, e = true) {
    const s = this;
    v(t > 0, () => `batchSize needs to be positive, but it is
      ${t}`);
    let o;
    return this.size === 1 / 0 || this.size == null ? o = this.size : e ? o = Math.ceil(this.size / t) : o = Math.floor(this.size / t), bn$1(async () => (await s.iterator()).columnMajorBatch(t, e, RL), o);
  }
  /**
   * Concatenates this `Dataset` with another.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3]);
   * const b = tf.data.array([4, 5, 6]);
   * const c = a.concatenate(b);
   * await c.forEachAsync(e => console.log(e));
   * ```
   *
   * @param dataset A `Dataset` to be concatenated onto this one.
   * @returns A `Dataset`.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  concatenate(t) {
    const e = this;
    let s;
    return this.size === 1 / 0 || t.size === 1 / 0 ? s = 1 / 0 : this.size != null && t.size != null ? s = this.size + t.size : s = null, bn$1(async () => (await e.iterator()).concatenate(await t.iterator()), s);
  }
  /**
   * Filters this dataset according to `predicate`.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
   *   .filter(x => x%2 === 0);
   * await a.forEachAsync(e => console.log(e));
   * ```
   *
   * @param predicate A function mapping a dataset element to a boolean or a
   * `Promise` for one.
   *
   * @returns A `Dataset` of elements for which the predicate was true.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  filter(t) {
    const e = this;
    let s;
    return this.size === 1 / 0 ? s = 1 / 0 : s = null, bn$1(async () => (await e.iterator()).filter((o) => D(() => t(o))), s);
  }
  /**
   * Apply a function to every element of the dataset.
   *
   * After the function is applied to a dataset element, any Tensors contained
   * within that element are disposed.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3]);
   * await a.forEachAsync(e => console.log(e));
   * ```
   *
   * @param f A function to apply to each dataset element.
   * @returns A `Promise` that resolves after all elements have been processed.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  async forEachAsync(t) {
    return (await this.iterator()).forEachAsync(t);
  }
  /**
   * Maps this dataset through a 1-to-1 transform.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3]).map(x => x*x);
   * await a.forEachAsync(e => console.log(e));
   * ```
   *
   * @param transform A function mapping a dataset element to a transformed
   *   dataset element.
   *
   * @returns A `Dataset` of transformed elements.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  map(t) {
    const e = this;
    return bn$1(async () => (await e.iterator()).map((s) => D(() => t(s))), this.size);
  }
  /**
   * Maps this dataset through an async 1-to-1 transform.
   *
   * ```js
   * const a =
   *  tf.data.array([1, 2, 3]).mapAsync(x => new Promise(function(resolve){
   *    setTimeout(() => {
   *      resolve(x * x);
   *    }, Math.random()*1000 + 500);
   *  }));
   * console.log(await a.toArray());
   * ```
   *
   * @param transform A function mapping a dataset element to a `Promise` for a
   *   transformed dataset element.  This transform is responsible for disposing
   *   any intermediate `Tensor`s, i.e. by wrapping its computation in
   *   `tf.tidy()`; that cannot be automated here (as it is in the synchronous
   *   `map()` case).
   *
   * @returns A `Dataset` of transformed elements.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  mapAsync(t) {
    const e = this;
    return bn$1(async () => (await e.iterator()).mapAsync(t), this.size);
  }
  /**
   *  Creates a `Dataset` that prefetches elements from this dataset.
   *
   * @param bufferSize: An integer specifying the number of elements to be
   *   prefetched.
   * @returns A `Dataset`.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  prefetch(t) {
    if (t == null)
      throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
    const e = this;
    return bn$1(async () => (await e.iterator()).prefetch(t), this.size);
  }
  /**
   * Repeats this dataset `count` times.
   *
   * NOTE: If this dataset is a function of global state (e.g. a random number
   * generator), then different repetitions may produce different elements.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3]).repeat(3);
   * await a.forEachAsync(e => console.log(e));
   * ```
   *
   * @param count: (Optional) An integer, representing the number of times
   *   the dataset should be repeated. The default behavior (if `count` is
   *   `undefined` or negative) is for the dataset be repeated indefinitely.
   * @returns A `Dataset`.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  repeat(t) {
    const e = this;
    let s;
    return this.size != null && t > 0 ? s = this.size * t : t === 0 ? s = 0 : this.size != null && (t === void 0 || t < 0) ? s = 1 / 0 : s = null, bn$1(async () => {
      const o = hL(async () => ({ value: await e.iterator(), done: false }));
      return pL(o.take(t));
    }, s);
  }
  /**
   * Creates a `Dataset` that skips `count` initial elements from this dataset.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3, 4, 5, 6]).skip(3);
   * await a.forEachAsync(e => console.log(e));
   * ```
   *
   * @param count: The number of elements of this dataset that should be skipped
   *   to form the new dataset.  If `count` is greater than the size of this
   *   dataset, the new dataset will contain no elements.  If `count`
   *   is `undefined` or negative, skips the entire dataset.
   *
   * @returns A `Dataset`.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  skip(t) {
    const e = this;
    let s;
    return this.size != null && t >= 0 && this.size >= t ? s = this.size - t : this.size != null && (this.size < t || t === void 0 || t < 0) ? s = 0 : s = null, bn$1(async () => (await e.iterator()).skip(t), s);
  }
  /**
   * Pseudorandomly shuffles the elements of this dataset. This is done in a
   * streaming manner, by sampling from a given number of prefetched elements.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3, 4, 5, 6]).shuffle(3);
   * await a.forEachAsync(e => console.log(e));
   * ```
   *
   * @param bufferSize: An integer specifying the number of elements from this
   *   dataset from which the new dataset will sample.
   * @param seed: (Optional) An integer specifying the random seed that will
   *   be used to create the distribution.
   * @param reshuffleEachIteration: (Optional) A boolean, which if true
   *   indicates that the dataset should be pseudorandomly reshuffled each time
   *   it is iterated over. If false, elements will be returned in the same
   *   shuffled order on each iteration. (Defaults to `true`.)
   * @returns A `Dataset`.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  shuffle(t, e, s = true) {
    if (t == null || t < 0)
      throw this.size == null ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);
    const o = this, r = wr.alea(e || Ce$1().toString());
    return bn$1(async () => {
      let i6 = r.int32();
      return s && (i6 += r.int32()), (await o.iterator()).shuffle(t, i6.toString());
    }, this.size);
  }
  /**
   * Creates a `Dataset` with at most `count` initial elements from this
   * dataset.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3, 4, 5, 6]).take(3);
   * await a.forEachAsync(e => console.log(e));
   * ```
   *
   * @param count: The number of elements of this dataset that should be taken
   *   to form the new dataset.  If `count` is `undefined` or negative, or if
   *   `count` is greater than the size of this dataset, the new dataset will
   *   contain all elements of this dataset.
   * @returns A `Dataset`.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  take(t) {
    const e = this;
    let s;
    return this.size != null && this.size > t ? s = t : this.size != null && this.size <= t ? s = this.size : s = null, bn$1(async () => (await e.iterator()).take(t), s);
  }
  /**
   * Collect all elements of this dataset into an array.
   *
   * Obviously this will succeed only for small datasets that fit in memory.
   * Useful for testing and generally should be avoided if possible.
   *
   * ```js
   * const a = tf.data.array([1, 2, 3, 4, 5, 6]);
   * console.log(await a.toArray());
   * ```
   *
   * @returns A Promise for an array of elements, which will resolve
   *   when a new stream has been obtained and fully consumed.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  async toArray() {
    if (this.size === 1 / 0)
      throw new Error("Can not convert infinite data stream to array.");
    return (await this.iterator()).toArray();
  }
  /**
   * Collect all elements of this dataset into an array with prefetching 100
   * elements. This is useful for testing, because the prefetch changes the
   * order in which the Promises are resolved along the processing pipeline.
   * This may help expose bugs where results are dependent on the order of
   * Promise resolution rather than on the logical order of the stream (i.e.,
   * due to hidden mutable state).
   *
   * @returns A Promise for an array of elements, which will resolve
   *   when a new stream has been obtained and fully consumed.
   */
  async toArrayForTest() {
    if (this.size === 1 / 0)
      throw new Error("Can not convert infinite data stream to array.");
    return (await this.iterator()).toArrayForTest();
  }
};
Tf$1.MAX_BUFFER_SIZE = 1e4;
function bn$1(n, t = null) {
  return new class extends Tf$1 {
    constructor() {
      super(...arguments), this.size = t;
    }
    /*
     * Provide a new stream of elements.  Note this will also start new streams
     * from any underlying `Dataset`s.
     */
    async iterator() {
      return n();
    }
  }();
}
function EY(n) {
  return bn$1(async () => h1(n), n.length);
}
function LY(n) {
  if (!lr(n))
    throw new Error("The argument to zip() must be an object or array.");
  let t;
  if (Array.isArray(n))
    for (let e = 0; e < n.length; e++)
      t = t == null ? n[e].size : Math.min(t, n[e].size);
  else if (n instanceof Object)
    for (const e in n)
      t = t == null ? n[e].size : Math.min(t, n[e].size);
  return bn$1(async () => {
    const e = await u1(n, (s) => {
      if (s instanceof Tf$1)
        return { value: s.iterator(), recurse: false };
      if (lr(s))
        return { value: null, recurse: true };
      throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
    });
    return fL(e, Es.SHORTEST);
  }, t);
}
function RL(n) {
  if (n === null)
    return null;
  const t = n[0];
  return lL(t) ? { value: $L(n), recurse: false } : { value: null, recurse: true };
}
function $L(n) {
  if (n.length === 0)
    throw new Error("Can't make a batch of zero elements.");
  return n[0] instanceof Lt$1 ? os(n) : Re$1(n);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function it(n, t) {
  Array.isArray(n) || (n = [n]), n.forEach((e) => {
    e != null && v(e.dtype !== "complex64", () => `${t} does not support complex64 tensors in the CPU backend.`);
  });
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const GL = t0;
class cu extends Xd$1 {
  constructor() {
    super(), this.blockSize = 48, this.firstUse = true, this.data = new Mg$1(this, Xt());
  }
  nextDataId() {
    return cu.nextDataId++;
  }
  write(t, e, s) {
    this.firstUse && (this.firstUse = false, F().get("IS_NODE") && rn$1(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));
    const o = { id: this.nextDataId() };
    return this.data.set(o, { values: t, dtype: s, refCount: 1 }), o;
  }
  /**
   * Create a data bucket in cpu backend.
   * @param shape Shape of the `TensorInfo`.
   * @param dtype DType of the `TensorInfo`.
   * @param values The value of the `TensorInfo` stored as a flattened array.
   */
  makeTensorInfo(t, e, s) {
    let o;
    if (e === "string" && s != null && s.length > 0 && mr(s[0])) {
      const r = s.map((i6) => hs(i6));
      o = this.write(r, t, e);
    } else
      o = this.write(s, t, e);
    return { dataId: o, shape: t, dtype: e };
  }
  /** Return refCount of a `TensorData`. */
  refCount(t) {
    return this.data.has(t) ? this.data.get(t).refCount : 0;
  }
  /** Increase refCount of a `TensorData`. */
  incRef(t) {
    const e = this.data.get(t);
    e.refCount++;
  }
  /** Decrease refCount of a `TensorData`. */
  decRef(t) {
    if (this.data.has(t)) {
      const e = this.data.get(t);
      e.refCount--;
    }
  }
  move(t, e, s, o, r) {
    this.data.set(t, { values: e, dtype: o, refCount: r });
  }
  numDataIds() {
    return this.data.numDataIds();
  }
  async read(t) {
    return this.readSync(t);
  }
  readSync(t) {
    const { dtype: e, complexTensorInfos: s } = this.data.get(t);
    if (e === "complex64") {
      const o = this.readSync(s.real.dataId), r = this.readSync(s.imag.dataId);
      return ms(o, r);
    }
    return Pg$1(this.data.get(t).values, e);
  }
  bufferSync(t) {
    const e = this.readSync(t.dataId);
    if (t.dtype === "string")
      try {
        const s = e.map((o) => ps(o));
        return vt$1(t.shape, t.dtype, s);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return vt$1(t.shape, t.dtype, e);
  }
  makeOutput(t, e, s) {
    return Xt().makeTensorFromTensorInfo(this.makeTensorInfo(e, s, t), this);
  }
  /**
   * Dispose the memory if the dataId has 0 refCount. Return true if the memory
   * is released or memory is not managed in this backend, false if memory is
   * not cleared.
   * @param dataId
   * @oaram force Optional, remove the data regardless of refCount
   */
  disposeData(t, e = false) {
    if (this.data.has(t)) {
      if (this.data.get(t).refCount--, !e && this.data.get(t).refCount > 0)
        return false;
      const { complexTensorInfos: s } = this.data.get(t);
      s != null && (this.disposeData(s.real.dataId, true), this.disposeData(s.imag.dataId, true)), this.data.delete(t);
    }
    return true;
  }
  disposeIntermediateTensorInfo(t) {
    this.disposeData(t.dataId);
  }
  async time(t) {
    const e = Ce$1();
    return t(), { kernelMs: Ce$1() - e };
  }
  memory() {
    return {
      // Unreliable due to automatic gc. The numbers above are cumulative.
      unreliable: true,
      reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
    };
  }
  where(t) {
    it([t], "where");
    const e = this.readSync(t.dataId);
    return GL(t.shape, e);
  }
  dispose() {
  }
  floatPrecision() {
    return 32;
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return super.epsilon();
  }
}
cu.nextDataId = 0;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function m1(n) {
  const t = new Float32Array(n.length);
  for (let e = 0; e < n.length; ++e)
    t[e] = Math.abs(n[e]);
  return t;
}
const EL = (n) => {
  const { x: t } = n.inputs, e = n.backend;
  it(t, "abs");
  let s = new Float32Array(O(t.shape));
  const o = e.data.get(t.dataId).values;
  return s = m1(o), e.makeOutput(s, t.shape, t.dtype);
}, LL = {
  kernelName: Vl,
  backendName: "cpu",
  kernelFunc: EL
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ce(n) {
  return (t, e, s, o, r) => {
    const i6 = bt$1(t, e), a = i6.length, l = dt(i6), c = O(i6), u = xe$1(r, c), d = t.length, h6 = e.length, p6 = dt(t), f = dt(e), m = vo(t, i6), g6 = vo(e, i6);
    if (m.length + g6.length === 0)
      for (let b6 = 0; b6 < u.length; ++b6)
        u[b6] = n(s[b6 % s.length], o[b6 % o.length]);
    else
      for (let b6 = 0; b6 < u.length; ++b6) {
        const x6 = Mo(b6, a, l), w6 = x6.slice(-d);
        m.forEach((k7) => w6[k7] = 0);
        const y6 = zn$1(w6, d, p6), I = x6.slice(-h6);
        g6.forEach((k7) => I[k7] = 0);
        const C6 = zn$1(I, h6, f);
        u[b6] = n(s[y6], o[C6]);
      }
    return [u, i6];
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ye(n) {
  const { inputs: t, backend: e } = n, { real: s, imag: o } = t, r = e.data.get(s.dataId).values, i6 = e.data.get(o.dataId).values, a = e.makeTensorInfo(s.shape, "complex64"), l = e.data.get(a.dataId);
  return l.complexTensorInfos = {
    real: e.makeTensorInfo(s.shape, "float32", r),
    imag: e.makeTensorInfo(o.shape, "float32", i6)
  }, a;
}
const ML = {
  kernelName: Jd$1,
  backendName: "cpu",
  kernelFunc: Ye
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sl(n, t, e = "float32") {
  if (e === "complex64") {
    const o = Sl(n, t, "float32"), r = Sl(n, t, "float32");
    return Ye({ inputs: { real: o, imag: r }, backend: n });
  }
  const s = Se(O(t), e);
  return n.makeTensorInfo(t, e, s);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rs(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  return e.incRef(s.dataId), { dataId: s.dataId, shape: s.shape, dtype: s.dtype };
}
const WL = {
  kernelName: Ei,
  backendName: "cpu",
  kernelFunc: rs
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $o(n) {
  const { inputs: t, backend: e } = n, { input: s } = t, o = e.data.get(s.dataId).complexTensorInfos.real, r = e.data.get(o.dataId).values;
  return e.makeTensorInfo(o.shape, o.dtype, r);
}
const DL = {
  kernelName: wh$1,
  backendName: "cpu",
  kernelFunc: $o
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g1(n, t, e, s) {
  if (s === "int32") {
    const o = Int32Array.from(n);
    return [t, "int32", o];
  }
  if (s === "bool") {
    const o = Zs([0], e), [r, i6] = ce((a, l) => a !== l ? 1 : 0)(t, [], n, o, "bool");
    return [i6, "bool", r];
  }
  throw new Error(`Error in Cast: failed to cast ${e} to ${s}`);
}
function Ks(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { dtype: r } = s;
  if (r === "complex64") {
    if (o.dtype === "complex64")
      return rs({ inputs: { x: o }, backend: e });
    const u = Sl(e, o.shape, o.dtype), d = Ks({ inputs: { x: o }, backend: e, attrs: { dtype: "float32" } }), h6 = Ye({ inputs: { real: d, imag: u }, backend: e });
    return e.disposeIntermediateTensorInfo(u), e.disposeIntermediateTensorInfo(d), h6;
  }
  if (o.dtype === "complex64") {
    const u = $o({ inputs: { input: o }, backend: e }), d = Ks({ inputs: { x: u }, backend: e, attrs: { dtype: r } });
    return e.disposeIntermediateTensorInfo(u), d;
  }
  if (!Od$1(o.dtype, r)) {
    const u = rs({ inputs: { x: o }, backend: e });
    return { dataId: u.dataId, shape: u.shape, dtype: r };
  }
  const i6 = e.data.get(o.dataId).values, [a, l, c] = g1(i6, o.shape, o.dtype, r);
  return e.makeTensorInfo(a, l, c);
}
const FL = {
  kernelName: xi,
  backendName: "cpu",
  kernelFunc: Ks
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function we(n, t, e, s) {
  return e == null ? ({ inputs: o, backend: r }) => {
    const { a: i6, b: a } = o, l = r;
    it([i6, a], n);
    const c = l.data.get(i6.dataId).values, u = l.data.get(a.dataId).values, d = i6.dtype === "string" ? (
      // tslint:disable-next-line: no-any
      No(c)
    ) : c, h6 = i6.dtype === "string" ? (
      // tslint:disable-next-line: no-any
      No(u)
    ) : u, p6 = s || i6.dtype, [f, m] = t(i6.shape, a.shape, d, h6, p6);
    return l.makeTensorInfo(m, p6, f);
  } : ({ inputs: o, backend: r }) => {
    const { a: i6, b: a } = o, l = r;
    if (i6.dtype === "complex64" || a.dtype === "complex64") {
      const c = Ks({ inputs: { x: i6 }, backend: l, attrs: { dtype: "complex64" } }), u = l.data.get(c.dataId), d = u.complexTensorInfos.real, h6 = u.complexTensorInfos.imag, p6 = l.data.get(d.dataId).values, f = l.data.get(h6.dataId).values, m = Ks({ inputs: { x: a }, backend: l, attrs: { dtype: "complex64" } }), g6 = l.data.get(m.dataId), b6 = g6.complexTensorInfos.real, x6 = g6.complexTensorInfos.imag, w6 = l.data.get(b6.dataId).values, y6 = l.data.get(x6.dataId).values, [I, C6, k7] = e(i6.shape, a.shape, p6, f, w6, y6), S = l.makeTensorInfo(k7, "float32", I), N = l.makeTensorInfo(k7, "float32", C6), R = Ye({ inputs: { real: S, imag: N }, backend: l });
      return l.disposeIntermediateTensorInfo(c), l.disposeIntermediateTensorInfo(m), l.disposeIntermediateTensorInfo(S), l.disposeIntermediateTensorInfo(N), R;
    } else {
      const c = l.data.get(i6.dataId).values, u = l.data.get(a.dataId).values, d = s || i6.dtype, [h6, p6] = t(i6.shape, a.shape, c, u, d);
      return l.makeTensorInfo(p6, d, h6);
    }
  };
}
function Nf$1(n) {
  return (t, e, s, o, r, i6) => {
    const a = bt$1(t, e), l = O(a), c = a.length, u = dt(a), d = xe$1("float32", l), h6 = xe$1("float32", l), p6 = vo(t, a), f = vo(e, a), m = ms(s, o), g6 = ms(r, i6), b6 = t.length, x6 = dt(t), w6 = e.length, y6 = dt(e);
    if (p6.length + f.length === 0)
      for (let I = 0; I < d.length; I++) {
        const C6 = I % m.length, k7 = I % g6.length, S = n(m[C6 * 2], m[C6 * 2 + 1], g6[k7 * 2], g6[k7 * 2 + 1]);
        d[I] = S.real, h6[I] = S.imag;
      }
    else
      for (let I = 0; I < d.length; I++) {
        const C6 = Mo(I, c, u), k7 = C6.slice(-b6);
        p6.forEach((V) => k7[V] = 0);
        const S = zn$1(k7, b6, x6), N = C6.slice(-w6);
        f.forEach((V) => N[V] = 0);
        const R = zn$1(N, w6, y6), M6 = n(m[S * 2], m[S * 2 + 1], g6[R * 2], g6[R * 2 + 1]);
        d[I] = M6.real, h6[I] = M6.imag;
      }
    return [d, h6, a];
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const b1 = ce((n, t) => n + t), VL = Nf$1((n, t, e, s) => ({ real: n + e, imag: t + s })), cr = we(br, b1, VL), zL = {
  kernelName: br,
  backendName: "cpu",
  kernelFunc: cr
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rf$1(n, t, e, s, o) {
  const r = O(s), i6 = Se(o, e);
  for (let a = 0; a < n.length; a++) {
    const l = n[a];
    if (l < 0)
      throw new Error("Input x must be non-negative!");
    l >= o || (r > 0 ? i6[l] += t[a] : i6[l] += 1);
  }
  return i6;
}
function x1(n, t, e, s = false) {
  const o = n.shape[0], r = n.shape[1], i6 = vt$1([o, e], t.dtype);
  for (let a = 0; a < o; a++)
    for (let l = 0; l < r; l++) {
      const c = n.get(a, l);
      if (c < 0)
        throw new Error("Input x must be non-negative!");
      c >= e || (s ? i6.set(1, a, c) : t.size > 0 ? i6.set(i6.get(a, c) + t.get(a, l), a, c) : i6.set(i6.get(a, c) + 1, a, c));
    }
  return i6;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Js(n) {
  return (t, e, s) => {
    const o = xe$1(e, t.length);
    for (let r = 0; r < t.length; ++r)
      o[r] = n(t[r], s);
    return o;
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mt(n, t, e) {
  return ({ inputs: s, attrs: o, backend: r }) => {
    const { x: i6 } = s;
    if (it(i6, n), i6.dtype === "string" || e === "string")
      throw new Error("unaryKernelFunc does not support string input/output");
    const a = r, l = a.data.get(i6.dataId).values, c = O(i6.shape), u = e || i6.dtype, d = oe(u, c);
    for (let h6 = 0; h6 < c; ++h6)
      d[h6] = t(l[h6], o);
    return a.makeTensorInfo(i6.shape, u, d);
  };
}
function Sr(n, t, e) {
  return ({ inputs: s, attrs: o, backend: r }) => {
    const { x: i6 } = s;
    if (it(i6, n), i6.dtype === "string" || e === "string")
      throw new Error("unaryKernelFunc does not support string input/output");
    const a = r, l = a.data.get(i6.dataId).values, c = e || i6.dtype, u = t(l, c, o);
    return a.makeTensorInfo(i6.shape, c, u);
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const y1 = Js((n) => Math.ceil(n)), XL = Sr(yi, y1), PL = {
  kernelName: yi,
  backendName: "cpu",
  kernelFunc: XL
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function w1(n, t, e, s) {
  const o = oe(e, O(t));
  if (s && e !== "string") {
    let r = 0;
    n.forEach((i6) => {
      const a = O(i6.shape);
      o.set(i6.vals, r), r += a;
    });
  } else {
    let r = 0;
    n.forEach((i6) => {
      const a = e === "string" ? No(i6.vals) : i6.vals;
      let l = 0;
      for (let c = 0; c < i6.shape[0]; ++c) {
        const u = c * t[1] + r;
        for (let d = 0; d < i6.shape[1]; ++d)
          o[u + d] = a[l++];
      }
      r += i6.shape[1];
    });
  }
  return o;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const I1 = ce((n, t) => n === t ? 1 : 0), C1 = we(jl, I1, null, "bool"), AL = {
  kernelName: jl,
  backendName: "cpu",
  kernelFunc: C1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const v1 = Js((n) => Math.exp(n)), S1 = Sr(Ti, v1, "float32"), OL = {
  kernelName: Ti,
  backendName: "cpu",
  kernelFunc: S1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const k1 = Js((n) => Math.expm1(n)), KL = Sr(Ni, k1), ZL = {
  kernelName: Ni,
  backendName: "cpu",
  kernelFunc: KL
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const T1 = Js((n) => Math.floor(n)), BL = Sr(Ri, T1), HL = {
  kernelName: Ri,
  backendName: "cpu",
  kernelFunc: BL
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N1(n, t, e, s, o, r, i6, a, l) {
  const c = vt$1([s, r], e);
  for (let u = 0; u < s; u++) {
    const d = [];
    let h6 = 0;
    for (let p6 = 0; p6 < o; p6++) {
      const f = n[u * o + p6];
      h6 += f * i6[p6], d.push(f);
    }
    if (h6 < 0 || h6 >= l / r)
      throw new Error(`Invalid indices: ${d} does not index into ${a}`);
    for (let p6 = 0; p6 < r; p6++)
      c.values[u * r + p6] = t.get(...t.indexToLoc(h6 * r + p6));
  }
  return c;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R1(n, t, e) {
  const s = vt$1(e, n.dtype);
  for (let o = 0; o < s.size; ++o) {
    const i6 = s.indexToLoc(o).slice(), a = i6[0], l = i6[2], c = t.locToIndex([a, l]);
    i6[2] = t.values[c];
    const u = n.locToIndex(i6);
    0 <= u && u < n.values.length && (s.values[o] = n.values[u]);
  }
  return s;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $1 = ce((n, t) => n > t ? 1 : 0), _L = we(nc, $1, null, "bool"), UL = {
  kernelName: nc,
  backendName: "cpu",
  kernelFunc: _L
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const G1 = ce((n, t) => n >= t ? 1 : 0), YL = we(Gi, G1, null, "bool"), QL = {
  kernelName: Gi,
  backendName: "cpu",
  kernelFunc: YL
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const E1 = ce((n, t) => n < t ? 1 : 0), JL = we(oc, E1, null, "bool"), jL = {
  kernelName: oc,
  backendName: "cpu",
  kernelFunc: JL
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const L1 = ce((n, t) => n <= t ? 1 : 0), qL = we(rc, L1, null, "bool"), t3 = {
  kernelName: rc,
  backendName: "cpu",
  kernelFunc: qL
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function M1(n, t, e) {
  const s = (t - n) / (e - 1), o = Se(e, "float32");
  o[0] = n;
  for (let r = 1; r < o.length; r++)
    o[r] = o[r - 1] + s;
  return o;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const W1 = Js((n) => Math.log(n)), e3 = Sr(Di, W1), n3 = {
  kernelName: Di,
  backendName: "cpu",
  kernelFunc: e3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D1(n, t, e, s) {
  const o = xe$1(s, O(e));
  for (let r = 0; r < o.length; ++r) {
    const i6 = r * t;
    let a = n[i6];
    for (let l = 0; l < t; ++l) {
      const c = n[i6 + l];
      (Number.isNaN(c) || c > a) && (a = c);
    }
    o[r] = a;
  }
  return o;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F1 = ce((n, t) => Math.max(n, t)), s3 = we(Vi, F1), o3 = {
  kernelName: Vi,
  backendName: "cpu",
  kernelFunc: s3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const V1 = ce((n, t) => Math.min(n, t)), r3 = we(zi, V1), i3 = {
  kernelName: zi,
  backendName: "cpu",
  kernelFunc: r3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $f$1 = ce((n, t) => n * t), a3 = Nf$1((n, t, e, s) => ({
  real: n * e - t * s,
  imag: n * s + t * e
})), uu = we(Pi, $f$1, a3), l3 = {
  kernelName: Pi,
  backendName: "cpu",
  kernelFunc: uu
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function z1(n, t, e) {
  const s = bs(-1, e);
  return $f$1([], t, s, n, e);
}
function c3(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  it(s, "neg");
  const o = e.data.get(s.dataId).values, [r, i6] = z1(o, s.shape, s.dtype);
  return e.makeTensorInfo(i6, s.dtype, r);
}
const u3 = {
  kernelName: gc,
  backendName: "cpu",
  kernelFunc: c3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const X1 = ce((n, t) => n !== t ? 1 : 0), d3 = we(bc, X1, null, "bool"), h3 = {
  kernelName: bc,
  backendName: "cpu",
  kernelFunc: d3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gf$1(n, t, e, s, o) {
  const r = t.length, i6 = O(t), a = dt(t), l = dt(o), c = xe$1(e, O(o));
  for (let u = 0; u < i6; ++u) {
    const d = Mo(u, r, a), h6 = new Array(d.length);
    for (let f = 0; f < h6.length; f++)
      h6[f] = d[s[f]];
    const p6 = zn$1(h6, r, l);
    c[p6] = n[u];
  }
  return c;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ze(n) {
  const { inputs: t, attrs: e, backend: s } = n, { x: o } = t, { perm: r } = e;
  it(o, "transpose");
  const i6 = o.shape.length, a = new Array(i6);
  for (let d = 0; d < a.length; d++)
    a[d] = o.shape[r[d]];
  const l = s.data.get(o.dataId).values, c = Gf$1(l, o.shape, o.dtype, r, a);
  return { dataId: s.write(c, a, o.dtype), shape: a, dtype: o.dtype };
}
const p3 = {
  kernelName: Jo,
  backendName: "cpu",
  kernelFunc: Ze
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function P1(n, t, e, s) {
  const [o, r] = ye$1(n, s), i6 = je$1(t, "int32"), a = Se(O(o), i6), l = O(r);
  for (let c = 0; c < a.length; ++c) {
    const u = c * l;
    let d = 1;
    for (let h6 = 0; h6 < l; ++h6)
      d *= e[u + h6];
    a[c] = d;
  }
  return { outVals: a, outShape: o, outDtype: i6 };
}
function f3(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s;
  it(o, "prod");
  const a = o.shape.length, l = Ct(r, o.shape), c = qt$1(l, a);
  let u = l, d = o;
  const h6 = [];
  c != null && (d = Ze({ inputs: { x: o }, backend: e, attrs: { perm: c } }), h6.push(d), u = ie(u.length, a));
  const p6 = e.data.get(d.dataId).values, { outVals: f, outShape: m, outDtype: g6 } = P1(d.shape, d.dtype, p6, u);
  let b6 = m;
  return i6 && (b6 = re$1(m, l)), h6.forEach((x6) => e.disposeIntermediateTensorInfo(x6)), e.makeTensorInfo(b6, g6, f);
}
const m3 = {
  kernelName: vc,
  backendName: "cpu",
  kernelFunc: f3
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function g3(n, t, e) {
  n.forEach((s, o) => {
    if (s < 0 || s >= e) {
      const r = Mo(o, t.length, dt(t)).join(",");
      throw new Error(`indices[${r}] = ${s} is not in [0, ${e})`);
    }
  });
}
function b3(n, t) {
  for (let e = 0; e < n.length; ++e) {
    const s = n[e], o = e === n.length - 1 ? t : n[e + 1].length;
    if (s.length === 0)
      throw new Error("Ragged splits may not be empty");
    if (s[0] < 0)
      throw new Error("Ragged splits must be non-negative");
    if (s[s.length - 1] > o)
      throw new Error("Ragged splits must not point past values");
    for (let r = 1; r < s.length; ++r)
      if (s[r - 1] > s[r])
        throw new Error("Ragged splits must be sorted in ascending order");
  }
}
function x3(n, t, e, s) {
  const o = [];
  let r = 0;
  const i6 = t.length - 1 + e.length, a = new Array(i6).fill(null).map(() => [0]);
  b3(e, s);
  let l = 1;
  for (let c = 0; c < t.length - 1; ++c) {
    l *= t[c];
    const u = t[c + 1];
    for (let d = 1; d < l + 1; ++d)
      a[c].push(d * u);
  }
  for (let c = 0; c < n.length; ++c) {
    let u = n[c], d = n[c] + 1;
    for (let h6 = 0; h6 < e.length; ++h6) {
      const p6 = e[h6], f = h6 + t.length - 1;
      if (f >= 0) {
        const m = a[f], g6 = m[m.length - 1] - p6[u];
        for (let b6 = u; b6 < d; ++b6)
          a[f].push(p6[b6 + 1] + g6);
      }
      u = p6[u], d = p6[d];
    }
    d !== u && (o.push([u, d]), r += d - u);
  }
  return { outSplits: a, valueSlices: o, numValues: r };
}
function y3(n) {
  const t = [];
  for (let e = 0; e < n.length; ++e) {
    const s = n[e].length, o = oe("int32", s);
    t.push(o), n[e].forEach((r, i6) => o[i6] = r);
  }
  return t;
}
function Zm(n, t) {
  const e = n.slice(0, t);
  for (; e.length < t; )
    e.push(1);
  for (let s = t; s < n.length; s++)
    e[t - 1] *= n[s];
  return e;
}
function w3(n, t, e, s, o, r) {
  const i6 = Zm(t, 2)[1], a = Zm(r, 2)[1];
  let l = 0;
  for (const c of e)
    for (let u = c[0]; u < c[1]; ++u) {
      for (let d = 0; d < s; ++d)
        o[l * a + d] = n[u * i6 + d];
      ++l;
    }
}
function I3(n, t, e, s, o) {
  const r = t.slice();
  r[0] = o;
  const i6 = oe(e, O(r)), a = n.length, l = a === 0 ? 0 : a / t[0];
  return w3(n, t, s, l, i6, r), [i6, r];
}
function A1(n, t, e, s, o, r, i6, a) {
  if (n.length === 0)
    throw new Error("paramsNestedSplits must be non empty");
  if (t[0].length === 0)
    throw new Error("Split tensors must not be scalars");
  const l = t[0][0] - 1;
  if (g3(r, i6, l), s.length === 0)
    throw new Error("params.rank must be nonzero");
  const c = s[0], { outSplits: u, valueSlices: d, numValues: h6 } = x3(r, i6, n, c), p6 = y3(u), f = I3(e, s, o, d, h6);
  return [p6, f[0], f[1]];
}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Bm = 2147483647;
function O1(n, t, e, s, o, r, i6) {
  if (t.length > 1)
    throw new Error("starts must be a scalar or vector");
  if (o.length > 1)
    throw new Error("limits must be a scalar or vector");
  if (i6.length > 1)
    throw new Error("deltas must be a scalar or vector");
  const a = t.length === 0, l = o.length === 0, c = i6.length === 0, u = [];
  a || u.push(t[0]), l || u.push(o[0]), c || u.push(i6[0]);
  for (let g6 = 1; g6 < u.length; ++g6)
    if (u[g6] !== u[g6 - 1])
      throw new Error("starts, limits, and deltas must have the same shape");
  const d = u.length === 0 ? 1 : u[0], h6 = oe("int32", d + 1);
  h6[0] = 0;
  for (let g6 = 0; g6 < d; ++g6) {
    const b6 = a ? n[0] : n[g6], x6 = l ? s[0] : s[g6], w6 = c ? r[0] : r[g6];
    if (w6 === 0)
      throw new Error("Requires delta != 0");
    let y6;
    if (w6 > 0 && x6 < b6 || w6 < 0 && x6 > b6)
      y6 = 0;
    else if (y6 = Math.ceil(Math.abs((x6 - b6) / w6)), y6 > Bm)
      throw new Error(`Requires ((limit - start) / delta) <= ${Bm}`);
    h6[g6 + 1] = h6[g6] + y6;
  }
  const p6 = h6[d], f = oe(e, p6);
  let m = 0;
  for (let g6 = 0; g6 < d; ++g6) {
    const b6 = h6[g6 + 1] - h6[g6];
    let x6 = a ? n[0] : n[g6];
    const w6 = c ? r[0] : r[g6];
    for (let y6 = 0; y6 < b6; ++y6)
      f[m++] = x6, x6 += w6;
  }
  return [h6, f];
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var gn$1 = Fn$1;
class kl {
  constructor(t, e, s, o, r, i6, a, l, c, u) {
    this.shape = t, this.shapeShape = e, this.values = s, this.valuesShape = o, this.valuesDType = r, this.defaultValue = i6, this.defaultValueShape = a, this.rowPartitionValues = l, this.rowPartitionValuesShapes = c, this.rowPartitionTypes = N0(u), this.raggedRank = R0(this.rowPartitionTypes);
  }
  getRowPartitionTypeByDimension(t) {
    return this.rowPartitionTypes[0] === gn$1.FIRST_DIM_SIZE ? this.rowPartitionTypes[t + 1] : this.rowPartitionTypes[t];
  }
  // Returns the relationship between dimension and dimension + 1.
  getRowPartitionTensor(t) {
    return this.rowPartitionTypes[0] === gn$1.FIRST_DIM_SIZE ? this.rowPartitionValues[t + 1] : this.rowPartitionValues[t];
  }
  getMaxWidth(t) {
    const e = this.getRowPartitionTensor(t - 1);
    switch (this.getRowPartitionTypeByDimension(t - 1)) {
      case gn$1.VALUE_ROWIDS:
        return kl.getMaxWidthValueRowID(e);
      case gn$1.ROW_SPLITS:
        return kl.getMaxWidthRowSplit(e);
      default:
        throw new Error(`Cannot handle partition type ${gn$1[this.getRowPartitionTypeByDimension(t - 1)]}`);
    }
  }
  static getMaxWidthRowSplit(t) {
    const e = t.length;
    if (e === 0 || e === 1)
      return 0;
    let s = 0;
    for (let o = 0; o < e - 1; ++o) {
      const r = t[o + 1] - t[o];
      r > s && (s = r);
    }
    return s;
  }
  static getMaxWidthValueRowID(t) {
    const e = t.length;
    if (e === 0)
      return 0;
    let s = 0, o = t[0], r = 0;
    for (let i6 = 1; i6 < e; ++i6) {
      const a = t[i6];
      a !== o && (o = a, r = Math.max(i6 - s, r), s = i6);
    }
    return Math.max(e - s, r);
  }
  tensorShapeFromTensor(t, e, s = true) {
    if (e.length === 0) {
      if (t[0] === -1)
        return [];
      throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
    }
    return _m(t, s);
  }
  calculateOutputSize(t) {
    const e = this.valuesShape, s = this.defaultValueShape;
    $0(s, e);
    const o = this.tensorShapeFromTensor(this.shape, this.shapeShape), i6 = T0(this.raggedRank, o, e);
    i6[0] < 0 && (i6[0] = t);
    for (let a = 1; a <= this.raggedRank; ++a)
      i6[a] < 0 && (i6[a] = this.getMaxWidth(a));
    return i6;
  }
  /**
   * The outputIndex represents the index in the output tensor
   * where the first element of a particular dimension would be written.
   * If it is -1, it indicates that the index is out of scope.
   * Example, given firstDimension = 10, firstDimensionOutput = 6,
   * and outputIndexMultiplier = 100:
   * result = [0 100 200 300 400 500 -1 -1 -1 -1]
   * If firstDimensionOutput = 11 instead, then:
   * result = [0 100 200 300 400 500 600 700 800 900]
   */
  calculateFirstParentOutputIndex(t, e, s) {
    const o = Math.min(t, s), r = [];
    let i6 = 0;
    for (let a = 0; a < o; ++a, i6 += e)
      r.push(i6);
    for (let a = o; a < t; ++a)
      r.push(-1);
    return v(r.length === t, () => "Final length of result must be equal to firstDimension."), r;
  }
  calculateOutputIndexRowSplit(t, e, s, o) {
    const r = t.length, i6 = [];
    for (let a = 0; a < r - 1; ++a) {
      const l = t[a + 1] - t[a];
      let c = Math.min(o, l), u = e[a];
      u === -1 && (c = 0);
      for (let d = 0; d < c; ++d)
        i6.push(u), u += s;
      for (let d = 0; d < l - c; ++d)
        i6.push(-1);
    }
    if (r > 0 && i6.length !== t[r - 1])
      throw new Error("Invalid row split size.");
    return i6;
  }
  // Calculate the output index of the first element of a list.
  // The parentOutputIndex is the same computation for the previous list.
  // -1 indicates an element or list that is out of range.
  // The outputIndexMultiplier is the number of output indices one moves
  // forward for each column.
  // E.g., given:
  // valueRowIds:[0 1 2 2 2 3 5 5 6]
  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]
  // outputIndexMultiplier: 10
  // outputSize: 2
  // You get:
  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]
  // result[0] = parentOutputIndex[valueRowIds[0]]
  // result[1] = parentOutputIndex[valueRowIds[1]]
  // result[2] = parentOutputIndex[valueRowIds[2]]
  // result[3] = parentOutputIndex[valueRowIds[2] + 10]
  // result[4] = -1 because it is the third element the size is 2.
  // result[5] = parentOutputIndex[valueRowIds[3]]
  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1
  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1
  // result[8] = parentOutputIndex[valueRowIds[7]]
  calculateOutputIndexValueRowID(t, e, s, o) {
    const r = t.length, i6 = [];
    if (r === 0)
      return [];
    let a = 0, l = t[0];
    if (l >= e.length)
      throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);
    let c = e[l];
    i6.push(c);
    for (let u = 1; u < r; ++u) {
      const d = t[u];
      if (d === l)
        c >= 0 && (++a, a < o ? c += s : c = -1);
      else {
        if (a = 0, l = d, d >= e.length)
          throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);
        c = e[d];
      }
      i6.push(c);
    }
    if (i6.length !== t.length)
      throw new Error("Invalid row ids.");
    return i6;
  }
  calculateOutputIndex(t, e, s, o) {
    const r = this.getRowPartitionTensor(t), i6 = this.getRowPartitionTypeByDimension(t);
    switch (i6) {
      case gn$1.VALUE_ROWIDS:
        return this.calculateOutputIndexValueRowID(r, e, s, o);
      case gn$1.ROW_SPLITS:
        if (r.length - 1 > e.length)
          throw new Error(`Row partition size is greater than output size: ${r.length - 1} > ${e.length}`);
        return this.calculateOutputIndexRowSplit(r, e, s, o);
      default:
        throw new Error(`Unsupported partition type: ${gn$1[i6]}`);
    }
  }
  getFirstDimensionSize() {
    const t = this.rowPartitionValues[0];
    if (this.rowPartitionTypes.length === 0)
      throw new Error("No row_partition_types given.");
    const e = this.rowPartitionTypes[0];
    switch (e) {
      case gn$1.FIRST_DIM_SIZE:
        return t[0];
      case gn$1.VALUE_ROWIDS:
        throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
      case gn$1.ROW_SPLITS:
        return this.rowPartitionValuesShapes[0][0] - 1;
      default:
        throw new Error(`Cannot handle type ${gn$1[e]}`);
    }
  }
  compute() {
    if (this.rowPartitionValues[0].length <= 0)
      throw new Error("Invalid first partition input. Tensor requires at least one element.");
    const e = this.getFirstDimensionSize(), s = this.calculateOutputSize(e), o = new Array(this.raggedRank + 1);
    o[o.length - 1] = 1;
    for (let l = o.length - 2; l >= 0; --l)
      o[l] = o[l + 1] * s[l + 1];
    const r = _m(s, false), i6 = oe(this.valuesDType, O(r));
    if (o[0] * s[0] > 0) {
      let l = this.calculateFirstParentOutputIndex(e, o[0], s[0]);
      for (let c = 1; c <= this.raggedRank; ++c)
        l = this.calculateOutputIndex(c - 1, l, o[c], s[c]);
      this.setOutput(this.raggedRank, l, i6, r);
    }
    return [r, i6];
  }
  setOutput(t, e, s, o) {
    if (s.length === 0)
      return;
    const r = this.values, i6 = s;
    let a = o.slice();
    a = a.slice(t + 1);
    const l = O(a), c = e.length;
    let u = this.defaultValue;
    if (u.length !== l && u.length !== 1) {
      const f = this.defaultValueShape;
      D(() => {
        const m = W(u, f);
        u = Br(m, a).dataSync();
      });
    }
    let d = 0, h6 = 0, p6 = 0;
    for (let f = 0; f <= c; ++f) {
      let m = f < c ? e[f] : -1;
      if (m === p6) {
        ++p6;
        continue;
      }
      if (h6 < p6) {
        const g6 = r.subarray(d * l), b6 = i6.subarray(h6 * l), x6 = (p6 - h6) * l;
        Hm(b6, g6, x6);
      }
      if (f >= c) {
        const g6 = s.length;
        m = Math.floor(g6 / l);
      }
      if (m > p6)
        if (this.defaultValue.length === 1)
          i6.subarray(p6 * l, m * l).fill(this.defaultValue[0]), p6 = m;
        else
          for (; m > p6; ) {
            const g6 = i6.slice(p6 * l);
            Hm(g6, u, l), ++p6;
          }
      m < 0 ? (d = f + 1, h6 = p6) : (d = f, h6 = p6, p6 = h6 + 1);
    }
  }
}
function Hm(n, t, e) {
  for (let s = 0; s < e; s++)
    n[s] = t[s];
}
function _m(n, t) {
  const e = [];
  for (let s of n) {
    if (s < 0) {
      if (!t)
        throw new Error(`Dimension ${s} must be >= 0`);
      if (s < -1)
        throw new Error(`Dimension ${s} must be >= -1`);
      s = -1;
    }
    e.push(s);
  }
  return e;
}
function K1(n, t, e, s, o, r, i6, a, l, c) {
  return new kl(n, t, e, s, o, r, i6, a, l, c).compute();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Z1(n, t, e, s) {
  const o = n === t, r = n < t && e < 0, i6 = t < n && e > 1;
  if (o || r || i6)
    return Se(0, s);
  const a = Math.abs(Math.ceil((t - n) / e)), l = Se(a, s);
  t < n && e === 1 && (e = -1), l[0] = n;
  for (let c = 1; c < l.length; c++)
    l[c] = l[c - 1] + e;
  return l;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const B1 = Js((n) => 1 / Math.sqrt(n)), C3 = Sr(Hi, B1), v3 = {
  kernelName: Hi,
  backendName: "cpu",
  kernelFunc: C3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Qo(n, t, e, s, o, r, i6, a, l, c) {
  const u = [s / o, o], d = n.values, h6 = t.values;
  if (s === 0)
    return vt$1(e, t.dtype);
  const p6 = vt$1(u, t.dtype);
  typeof l == "string" || typeof l == "number" ? p6.values.fill(l) : typeof l == "boolean" && p6.values.fill(+l);
  for (let f = 0; f < r; f++) {
    const m = [];
    let g6 = 0;
    for (let b6 = 0; b6 < i6; b6++) {
      const x6 = d[f * i6 + b6];
      m.push(x6), g6 += x6 * a[b6];
    }
    if (g6 < 0 || g6 >= s / o)
      throw new Error(`Invalid indices: ${m} does not index into ${e}`);
    for (let b6 = 0; b6 < o; b6++)
      c ? p6.values[g6 * o + b6] += h6[f * o + b6] : p6.values[g6 * o + b6] = t.rank === 0 ? h6[0] : h6[f * o + b6];
  }
  return p6;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const S3 = Js((n) => 1 / (1 + Math.exp(-n))), H1 = Mt(Ji, (n) => 1 / (1 + Math.exp(-n))), k3 = {
  kernelName: Ji,
  backendName: "cpu",
  kernelFunc: H1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _1(n, t, e, s, o) {
  const r = Wp(s, t, e), i6 = O(e), a = dt(s);
  if (r) {
    const d = Dp(t, a);
    return o === "string" ? n.slice(d, d + i6) : n.subarray(d, d + i6);
  }
  const l = o === "string" ? No(n) : n, c = vt$1(s, o, l), u = vt$1(e, o);
  for (let d = 0; d < u.size; ++d) {
    const h6 = u.indexToLoc(d), p6 = h6.map((f, m) => f + t[m]);
    u.set(c.get(...p6), ...h6);
  }
  return o === "string" ? Y0(u.values) : u.values;
}
function Go(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { begin: r, size: i6 } = s;
  it(o, "slice");
  const [a, l] = Hc(o, r, i6);
  Lp(o, a, l);
  const c = e.data.get(o.dataId).values, u = _1(c, a, l, o.shape, o.dtype);
  return e.makeTensorInfo(l, o.dtype, u);
}
const T3 = {
  kernelName: $c,
  backendName: "cpu",
  kernelFunc: Go
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function U1(n, t, e, s, o, r, i6) {
  const a = t[0], l = r[0], c = new Array(l), u = new Array(a), d = t[1];
  if (l === 0) {
    if (a !== 0)
      throw new Error(F0(a));
    const g6 = oe(e, 0), b6 = oe(o, 0);
    return [
      g6,
      [0, d],
      b6,
      c,
      u
    ];
  }
  let h6 = true, p6 = 0;
  const f = new Array(l).fill(0);
  for (let g6 = 0; g6 < a; ++g6) {
    const b6 = n[g6 * d];
    if (b6 < 0)
      throw new Error(V0(g6, b6));
    if (b6 >= l)
      throw new Error(z0(g6, b6, l));
    ++f[b6], h6 = h6 && b6 >= p6, p6 = b6;
  }
  let m = true;
  for (let g6 = 0; g6 < l; ++g6) {
    const b6 = f[g6] === 0;
    c[g6] = b6, m = m && !b6, f[g6] = Math.max(f[g6], 1), g6 > 0 && (f[g6] += f[g6 - 1]);
  }
  if (m && h6) {
    const g6 = n, b6 = s;
    for (let x6 = 0; x6 < a; ++x6)
      u[x6] = x6;
    return [
      g6,
      [a, d],
      b6,
      c,
      u
    ];
  } else {
    const g6 = f[l - 1], b6 = oe(e, g6 * d), x6 = oe(o, g6), w6 = new Array(l).fill(0);
    for (let y6 = 0; y6 < a; ++y6) {
      const I = n[y6 * d], C6 = w6[I], k7 = (I === 0 ? 0 : f[I - 1]) + C6;
      w6[I]++;
      for (let S = 0; S < d; ++S)
        b6[k7 * d + S] = n[y6 * d + S];
      x6[k7] = s[y6], u[y6] = k7;
    }
    for (let y6 = 0; y6 < l; ++y6)
      if (w6[y6] === 0) {
        const C6 = y6 === 0 ? 0 : f[y6 - 1];
        b6[C6 * d + 0] = y6;
        for (let k7 = 1; k7 < d; ++k7)
          b6[C6 * d + k7] = 0;
        x6[C6] = i6;
      }
    return [
      b6,
      [g6, d],
      x6,
      c,
      u
    ];
  }
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Y1(n, t, e, s, o) {
  const r = O(s), i6 = t[0], a = o.length, l = [];
  let c = 1, u = -1;
  for (let g6 = 0; g6 < a; ++g6) {
    const b6 = o[g6];
    if (b6 === -1) {
      if (u !== -1)
        throw new Error(X0(u, g6));
      u = g6, l.push(1);
    } else {
      if (b6 < 0)
        throw new Error(P0(g6, b6));
      c *= b6, l.push(b6);
    }
  }
  if (u !== -1) {
    if (c <= 0)
      throw new Error(A0());
    const g6 = Math.trunc(r / c);
    if (c * g6 !== r)
      throw new Error(O0(s, l));
    l[u] = g6;
  }
  if (O(l) !== r)
    throw new Error(K0(s, l));
  const h6 = s.length, p6 = [];
  if (h6 > 0) {
    p6[h6 - 1] = 1;
    for (let g6 = h6 - 2; g6 >= 0; --g6)
      p6[g6] = p6[g6 + 1] * s[g6 + 1];
  }
  const f = [];
  if (a > 0) {
    f[a - 1] = 1;
    for (let g6 = a - 2; g6 >= 0; --g6)
      f[g6] = f[g6 + 1] * l[g6 + 1];
  }
  const m = oe(e, i6 * a);
  for (let g6 = 0; g6 < i6; ++g6) {
    let b6 = 0;
    for (let x6 = 0; x6 < h6; ++x6)
      b6 += n[g6 * h6 + x6] * p6[x6];
    for (let x6 = 0; x6 < a; ++x6)
      m[g6 * a + x6] = Math.trunc(b6 / f[x6]), b6 %= f[x6];
  }
  return [m, [i6, a], l];
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ef$1(n, t, e, s, o, r = false, i6 = 0) {
  const a = s.length, l = [t[0], n.length / t[0]], c = l[1], d = a > 0 ? o[a - 1] + 1 : 0;
  if (d < 0)
    throw new Error(Id$1());
  const h6 = t.slice();
  h6[0] = d;
  const p6 = h6.reduce((w6, y6) => w6 * y6, 1), f = oe(e, p6);
  if (a === 0)
    return d > 0 && f.fill(i6), [f, h6];
  if (d <= 0)
    throw new Error(Id$1());
  let m = 0, g6 = 1, b6 = 0, x6 = o[m];
  for (; ; ) {
    let w6 = 0;
    if (g6 < a) {
      if (w6 = o[g6], x6 === w6) {
        ++g6;
        continue;
      }
      if (x6 >= w6)
        throw new Error(Z0());
    }
    if (x6 < 0 || x6 >= d)
      throw new Error(B0(x6, d));
    x6 > b6 && f.fill(i6, b6 * c, x6 * c);
    for (let y6 = m; y6 < g6; ++y6) {
      const I = s[y6];
      if (I < 0 || I >= l[0])
        throw new Error(H0(y6, s[y6], l[0]));
      for (let C6 = 0; C6 < c; C6++)
        f[x6 * c + C6] += n[I * c + C6];
    }
    if (r)
      for (let y6 = 0; y6 < c; y6++)
        f[x6 * c + y6] /= g6 - m;
    if (m = g6, ++g6, b6 = x6 + 1, x6 = w6, g6 > a)
      break;
  }
  return b6 < d && f.fill(i6, b6 * c, d * c), [f, h6];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const N3 = Js((n) => Math.sqrt(n)), R3 = Mt(qi, (n) => Math.sqrt(n)), $3 = {
  kernelName: qi,
  backendName: "cpu",
  kernelFunc: R3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Q1 = ce((n, t) => {
  const e = n - t;
  return e * e;
}), G3 = we(ta, Q1), E3 = {
  kernelName: ta,
  backendName: "cpu",
  kernelFunc: G3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J1(n, t, e, s) {
  const o = vt$1(n, t.dtype);
  for (let r = 0; r < o.size; r++) {
    const i6 = o.indexToLoc(r), a = new Array(i6.length);
    for (let l = 0; l < a.length; l++)
      a[l] = i6[l] * e[l] + s[l];
    o.set(t.get(...a), ...i6);
  }
  return o;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class L3 {
  constructor(t, e, s, o, r, i6) {
    this.separator = hs(t), this.nGramWidths = e, this.leftPad = hs(s), this.rightPad = hs(o), this.padWidth = r, this.preserveShort = i6;
  }
  getPadWidth(t) {
    return Math.min(this.padWidth < 0 ? t - 1 : this.padWidth, t - 1);
  }
  getNumNGrams(t, e) {
    const s = this.getPadWidth(e);
    return Math.max(0, t + 2 * s - e + 1);
  }
  createNGrams(t, e, s, o, r, i6) {
    for (let a = 0; a < r; ++a) {
      const l = this.getPadWidth(i6), c = Math.max(0, l - a), u = Math.max(0, l - (r - (a + 1))), d = i6 - (c + u), h6 = e + (c > 0 ? 0 : a - l);
      let p6 = 0;
      p6 += c * this.leftPad.length;
      for (let x6 = 0; x6 < d; ++x6)
        p6 += t[h6 + x6].length;
      p6 += u * this.rightPad.length;
      const f = c + u + d - 1;
      p6 += f * this.separator.length, s[o + a] = new Uint8Array(p6);
      const m = s[o + a];
      let g6 = 0;
      const b6 = (x6) => x6.forEach((w6) => m[g6++] = w6);
      for (let x6 = 0; x6 < c; ++x6)
        b6(this.leftPad), b6(this.separator);
      for (let x6 = 0; x6 < d - 1; ++x6)
        b6(t[h6 + x6]), b6(this.separator);
      if (d > 0) {
        b6(t[h6 + d - 1]);
        for (let x6 = 0; x6 < u; ++x6)
          b6(this.separator), b6(this.rightPad);
      } else {
        for (let x6 = 0; x6 < u - 1; ++x6)
          b6(this.rightPad), b6(this.separator);
        b6(this.rightPad);
      }
    }
  }
  // Data and splits together form the definition of the ragged tensor,
  // where data is 1 dimensional and contains the values of the tensor
  // and splits denotes the indices at which each row starts.
  compute(t, e) {
    const s = t.length, o = e.length;
    if (o > 0) {
      let l = e[0];
      if (l !== 0)
        throw new Error(`First split value must be 0, got ${l}`);
      for (let c = 1; c < o; ++c) {
        let u = e[c] >= l;
        if (u = u && e[c] <= s, !u)
          throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${s}]`);
        l = e[c];
      }
      if (l !== s)
        throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`);
    }
    const r = o - 1, i6 = oe("int32", o);
    if (s === 0 || o === 0) {
      const l = new Array(s);
      for (let c = 0; c <= r; ++c)
        i6[c] = 0;
      return [l, i6];
    }
    i6[0] = 0;
    for (let l = 1; l <= r; ++l) {
      const c = e[l] - e[l - 1];
      let u = 0;
      this.nGramWidths.forEach((d) => {
        u += this.getNumNGrams(c, d);
      }), this.preserveShort && c > 0 && u === 0 && (u = 1), i6[l] = i6[l - 1] + u;
    }
    const a = new Array(i6[r]);
    for (let l = 0; l < r; ++l) {
      const c = e[l];
      let u = i6[l];
      if (this.nGramWidths.forEach((d) => {
        const h6 = e[l + 1] - e[l], p6 = this.getNumNGrams(h6, d);
        this.createNGrams(t, c, a, u, p6, d), u += p6;
      }), this.preserveShort && u === i6[l]) {
        const d = e[l + 1] - e[l];
        if (d === 0)
          continue;
        const h6 = d + 2 * this.padWidth, p6 = 1;
        this.createNGrams(t, c, a, u, p6, h6);
      }
    }
    return [a, i6];
  }
}
function j1(n, t, e, s, o, r, i6, a) {
  return new L3(e, s, o, r, i6, a).compute(n, t);
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function M3(n, t, e, s) {
  if (!n.length)
    return;
  if (t.length === 0) {
    for (let r = 0; r < n.length; ++r)
      s.push(n.subarray(r, r + 1));
    return;
  }
  if (t.length === 1) {
    const r = t[0];
    let i6 = n.indexOf(r);
    for (; i6 !== -1; ) {
      const a = n.subarray(0, i6);
      (!e || a.length !== 0) && s.push(a), n = n.subarray(i6 + 1), i6 = n.indexOf(r);
    }
    (!e || n.length !== 0) && s.push(n);
    return;
  }
  let o = 0;
  for (let r = 0; r < n.length + 1; r++)
    if (r === n.length || t.indexOf(n[r]) !== -1) {
      const i6 = n.subarray(o, r);
      (!e || i6.length !== 0) && s.push(i6), o = r + 1;
    }
}
function q1(n, t, e) {
  const s = n.length, o = [];
  let r = 0, i6 = 0;
  const a = new Array(s);
  for (let h6 = 0; h6 < s; ++h6) {
    const p6 = o.length;
    M3(n[h6], t, e, o);
    const f = o.length - p6;
    a[h6] = f, r += f, i6 = Math.max(i6, f);
  }
  const l = oe("int32", r * 2), c = new Array(r), u = [s, i6];
  let d = 0;
  for (let h6 = 0; h6 < s; ++h6)
    for (let p6 = 0; p6 < a[h6]; ++p6)
      l[d * 2] = h6, l[d * 2 + 1] = p6, c[d] = o[d], ++d;
  return [l, c, u];
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tw(n, t) {
  const e = oe("int32", n.length);
  for (let s = 0; s < n.length; ++s)
    e[s] = db$1(n[s]).modulo(t).getLowBitsUnsigned();
  return e;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ew = ce((n, t) => n - t), W3 = Nf$1((n, t, e, s) => ({ real: n - e, imag: t - s })), Lf$1 = we(ea, ew, W3), D3 = {
  kernelName: ea,
  backendName: "cpu",
  kernelFunc: Lf$1
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nw(n, t) {
  const e = new Array(n.rank);
  for (let o = 0; o < e.length; o++)
    e[o] = n.shape[o] * t[o];
  const s = vt$1(e, n.dtype);
  for (let o = 0; o < s.values.length; ++o) {
    const r = s.indexToLoc(o), i6 = new Array(n.rank);
    for (let l = 0; l < i6.length; l++)
      i6[l] = r[l] % n.shape[l];
    const a = n.locToIndex(i6);
    s.values[o] = n.values[a];
  }
  return s;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Or = (n, t) => {
  const e = t.value - n.value;
  return e === 0 ? n.index - t.index : e;
};
function sw(n, t, e = 0, s = n.length - 1) {
  for (; s > e; ) {
    if (s - e > 600) {
      const a = s - e + 1, l = t - e + 1, c = Math.log(a), u = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * u * (a - u) / a) * Math.sign(l - a / 2), h6 = Math.max(e, Math.floor(t - l * u / a + d)), p6 = Math.min(s, Math.floor(t + (a - l) * u / a + d));
      sw(n, t, h6, p6);
    }
    const o = n[t];
    let r = e, i6 = s;
    for (us(n, e, t), Or(n[s], o) > 0 && us(n, e, s); r < i6; ) {
      for (us(n, r, i6), r++, i6--; Or(n[r], o) < 0; )
        r = r + 1;
      for (; Or(n[i6], o) > 0; )
        i6 = i6 - 1;
    }
    Or(n[e], o) === 0 ? us(n, e, i6) : (i6 = i6 + 1, us(n, i6, s)), i6 <= t && (e = i6 + 1), t <= i6 && (s = i6 - 1);
  }
}
function ow(n, t, e, s, o) {
  const r = t[t.length - 1], [i6, a] = [n.length / r, r], l = xe$1(e, i6 * s), c = xe$1("int32", i6 * s);
  for (let d = 0; d < i6; d++) {
    const h6 = d * a, p6 = n.subarray(h6, h6 + a);
    let f = new Array(p6.length);
    p6.forEach((x6, w6) => f[w6] = { value: x6, index: w6 }), s < f.length && (sw(f, s), f = f.slice(0, s)), o && f.sort(Or);
    const m = d * s, g6 = l.subarray(m, m + s), b6 = c.subarray(m, m + s);
    for (let x6 = 0; x6 < s; x6++)
      g6[x6] = f[x6].value, b6[x6] = f[x6].index;
  }
  const u = t.slice();
  return u[u.length - 1] = s, [
    vt$1(u, e, l),
    vt$1(u, "int32", c)
  ];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rw(n, t, e, s) {
  const o = Ct(t, e)[0], r = [1, e[0], 1];
  for (let f = 0; f < o; f++)
    r[0] *= e[f];
  r[1] = e[o];
  for (let f = o + 1; f < e.length; f++)
    r[2] *= e[f];
  const i6 = {}, a = new Int32Array(e[o]), l = new $e(r, s, n), c = [], u = r[0] === 1 && r[2] === 1;
  for (let f = 0; f < e[o]; f++) {
    let m;
    if (u)
      m = n[f].toString();
    else {
      const g6 = [];
      for (let b6 = 0; b6 < r[0]; b6++)
        for (let x6 = 0; x6 < r[2]; x6++)
          g6.push(l.get(b6, f, x6));
      m = g6.join(",");
    }
    if (i6[m] !== void 0)
      a[f] = i6[m];
    else {
      const g6 = Object.keys(i6).length;
      i6[m] = g6, a[f] = g6, c.push(f);
    }
  }
  const d = r.slice();
  d[1] = Object.keys(i6).length;
  const h6 = new $e(d, s);
  c.forEach((f, m) => {
    for (let g6 = 0; g6 < r[0]; g6++)
      for (let b6 = 0; b6 < r[2]; b6++)
        h6.set(l.get(g6, f, b6), g6, m, b6);
  });
  const p6 = e.slice();
  return p6[o] = d[1], {
    outputValues: h6.values,
    outputShape: p6,
    indices: a
  };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const F3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addImpl: b1,
  bincountImpl: Rf$1,
  bincountReduceImpl: x1,
  castImpl: g1,
  ceilImpl: y1,
  concatImpl: w1,
  equalImpl: I1,
  expImpl: v1,
  expm1Impl: k1,
  floorImpl: T1,
  gatherNdImpl: N1,
  gatherV2Impl: R1,
  greaterEqualImpl: G1,
  greaterImpl: $1,
  lessEqualImpl: L1,
  lessImpl: E1,
  linSpaceImpl: M1,
  logImpl: W1,
  maxImpl: D1,
  maximumImpl: F1,
  minimumImpl: V1,
  multiplyImpl: $f$1,
  negImpl: z1,
  notEqualImpl: X1,
  prodImpl: P1,
  raggedGatherImpl: A1,
  raggedRangeImpl: O1,
  raggedTensorToTensorImpl: K1,
  rangeImpl: Z1,
  rsqrtImpl: B1,
  scatterImpl: Qo,
  sigmoidImpl: S3,
  simpleAbsImpl: m1,
  sliceImpl: _1,
  sparseFillEmptyRowsImpl: U1,
  sparseReshapeImpl: Y1,
  sparseSegmentReductionImpl: Ef$1,
  sqrtImpl: N3,
  squaredDifferenceImpl: Q1,
  stridedSliceImpl: J1,
  stringNGramsImpl: j1,
  stringSplitImpl: q1,
  stringToHashBucketFastImpl: tw,
  subImpl: ew,
  tileImpl: nw,
  topKImpl: ow,
  transposeImpl: Gf$1,
  uniqueImpl: rw
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
kb(
  "cpu",
  () => new cu(),
  1
  /* priority */
);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iw = Mt(Si, (n) => n >= 0 ? n : Math.exp(n) - 1), V3 = {
  kernelName: Si,
  backendName: "cpu",
  kernelFunc: iw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aw(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { alpha: r } = s;
  it([o], "leakyRelu");
  const i6 = O(o.shape), a = e.data.get(o.dataId).values, l = xe$1("float32", i6);
  for (let c = 0; c < a.length; c++)
    l[c] = a[c] < 0 ? r * a[c] : a[c];
  return e.makeTensorInfo(o.shape, "float32", l);
}
const z3 = {
  kernelName: sc,
  backendName: "cpu",
  kernelFunc: aw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const X3 = ce((n, t) => n < 0 ? t * n : n);
function lw(n) {
  const { inputs: t, backend: e } = n, { x: s, alpha: o } = t;
  it([s, o], "prelu");
  const r = e.data.get(s.dataId).values, i6 = e.data.get(o.dataId).values, [a, l] = X3(s.shape, o.shape, r, i6, "float32");
  return e.makeTensorInfo(l, "float32", a);
}
const P3 = {
  kernelName: Cc,
  backendName: "cpu",
  kernelFunc: lw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cw = Mt(Ki, (n) => Math.max(0, n)), A3 = {
  kernelName: Ki,
  backendName: "cpu",
  kernelFunc: cw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uw = Mt(Zi, (n) => Math.min(Math.max(0, n), 6)), O3 = {
  kernelName: Zi,
  backendName: "cpu",
  kernelFunc: uw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Tl(n, t, e, s, o) {
  if (e === "linear")
    return rs({ inputs: { x: t }, backend: n });
  if (e === "relu")
    return cw({ inputs: { x: t }, backend: n });
  if (e === "elu")
    return iw({ inputs: { x: t }, backend: n });
  if (e === "relu6")
    return uw({ inputs: { x: t }, backend: n });
  if (e === "prelu")
    return lw({ inputs: { x: t, alpha: s }, backend: n });
  if (e === "leakyrelu")
    return aw({ inputs: { x: t }, backend: n, attrs: { alpha: o } });
  if (e === "sigmoid")
    return H1({ inputs: { x: t }, backend: n });
  throw new Error(`Activation ${e} has not been implemented for the CPU backend.`);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ot$1(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { shape: r } = s, i6 = O(o.shape), a = Ad$1(r, i6), l = O(a);
  v(i6 === l, () => `The new shape (${a}) has ${l} elements and the old shape (${o.shape}) has ${i6} elements. The new shape and old shape must have the same number of elements.`), e.incRef(o.dataId);
  const c = e.data.get(o.dataId);
  if (c.complexTensorInfos != null) {
    const u = c.complexTensorInfos.real, d = c.complexTensorInfos.imag;
    u.shape = a, d.shape = a;
  }
  return { dataId: o.dataId, shape: a, dtype: o.dtype };
}
const K3 = {
  kernelName: Sc,
  backendName: "cpu",
  kernelFunc: Ot$1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dw(n) {
  const { inputs: t, backend: e, attrs: s } = n, { a: o, b: r } = t, { transposeA: i6, transposeB: a } = s;
  it([o, r], "matMul");
  const l = o.shape.length, c = r.shape.length, u = i6 ? o.shape[l - 2] : o.shape[l - 1], d = a ? r.shape[c - 1] : r.shape[c - 2], h6 = i6 ? o.shape[l - 1] : o.shape[l - 2], p6 = a ? r.shape[c - 2] : r.shape[c - 1], f = o.shape.slice(0, -2), m = r.shape.slice(0, -2), g6 = O(f), b6 = O(m), w6 = bt$1(o.shape.slice(0, -2), r.shape.slice(0, -2)).concat([h6, p6]);
  v(u === d, () => `Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${o.shape} and ${r.shape} and transposeA=${i6} and transposeB=${a} must match.`);
  const y6 = i6 ? [g6, u, h6] : [g6, h6, u], I = a ? [b6, p6, d] : [b6, d, p6], C6 = Ot$1({ inputs: { x: o }, backend: e, attrs: { shape: y6 } }), k7 = Ot$1({ inputs: { x: r }, backend: e, attrs: { shape: I } }), S = i6 ? C6.shape[1] : C6.shape[2], N = i6 ? C6.shape[2] : C6.shape[1], R = a ? k7.shape[1] : k7.shape[2], M6 = Math.max(g6, b6), V = e.data.get(C6.dataId).values, z = e.data.get(k7.dataId).values, X = dt(C6.shape), P6 = dt(k7.shape), [A6, B6, Z] = i6 ? [X[0], 1, X[1]] : [X[0], X[1], 1], [H6, Y, Q] = a ? [1, P6[1], P6[0]] : [P6[1], 1, P6[0]], j = N * R, J6 = vt$1([M6, N, R], C6.dtype), nt = J6.values, q = e.blockSize;
  for (let rt = 0; rt < M6; rt++) {
    const ht = rt % g6, ft2 = rt % b6;
    for (let pt = 0; pt < N; pt += q) {
      const wt2 = Math.min(pt + q, N);
      for (let It = 0; It < R; It += q) {
        const Et = Math.min(It + q, R);
        for (let Vt2 = 0; Vt2 < S; Vt2 += q) {
          const te = Math.min(Vt2 + q, S);
          for (let zt = pt; zt < wt2; zt++)
            for (let Wt2 = It; Wt2 < Et; Wt2++) {
              let Qt = 0;
              for (let _t2 = Vt2; _t2 < te; _t2++) {
                const as = (
                  // tslint:disable-next-line: max-line-length
                  V[ht * A6 + zt * B6 + _t2 * Z]
                ), Ie = (
                  // tslint:disable-next-line: max-line-length
                  z[_t2 * H6 + Wt2 * Y + ft2 * Q]
                );
                Qt += as * Ie;
              }
              nt[rt * j + (zt * R + Wt2)] += Qt;
            }
        }
      }
    }
  }
  return e.disposeIntermediateTensorInfo(C6), e.disposeIntermediateTensorInfo(k7), e.makeTensorInfo(w6, J6.dtype, J6.values);
}
const Z3 = {
  kernelName: Ol,
  backendName: "cpu",
  kernelFunc: dw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function B3(n) {
  const { inputs: t, backend: e, attrs: s } = n, { a: o, b: r, bias: i6, preluActivationWeights: a } = t, { transposeA: l, transposeB: c, activation: u, leakyreluAlpha: d } = s;
  let h6, p6, f;
  const m = [];
  h6 = dw({ inputs: { a: o, b: r }, attrs: { transposeA: l, transposeB: c }, backend: e }), i6 && (p6 = cr({ inputs: { a: h6, b: i6 }, backend: e }), m.push(h6), h6 = p6), u && (f = Tl(e, h6, u, a, d), m.push(h6), h6 = f);
  for (const b6 of m)
    e.disposeIntermediateTensorInfo(b6);
  return h6;
}
const H3 = {
  kernelName: ol,
  backendName: "cpu",
  kernelFunc: B3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _3 = Mt(di, (n) => Math.acos(n)), U3 = {
  kernelName: di,
  backendName: "cpu",
  kernelFunc: _3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Y3 = Mt(hi, (n) => Math.acosh(n)), Q3 = {
  kernelName: hi,
  backendName: "cpu",
  kernelFunc: Y3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J3(n) {
  const { inputs: t, backend: e } = n, s = t;
  it(t, "addN");
  const o = s.map((a) => e.data.get(a.dataId).values), r = vt$1(s[0].shape, s[0].dtype), i6 = r.values;
  for (let a = 0; a < s.length; a++) {
    const l = o[a];
    for (let c = 0; c < i6.length; c++)
      i6[c] += l[c];
  }
  return e.makeTensorInfo(r.shape, r.dtype, r.values);
}
const j3 = {
  kernelName: Bd$1,
  backendName: "cpu",
  kernelFunc: J3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function q3(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s;
  it(o, "all");
  const a = Ct(r, o.shape);
  let l = a;
  const c = qt$1(l, o.shape.length);
  let u = o;
  c != null && (u = Ze({ inputs: { x: o }, backend: e, attrs: { perm: c } }), l = ie(l.length, o.shape.length)), Te("all", l, u.shape.length);
  const [d, h6] = ye$1(u.shape, l), p6 = O(h6), f = Se(O(d), u.dtype), m = e.data.get(u.dataId).values;
  for (let b6 = 0; b6 < f.length; ++b6) {
    const x6 = b6 * p6;
    let w6 = m[x6];
    for (let y6 = 0; y6 < p6; ++y6) {
      const I = m[x6 + y6];
      w6 = w6 && I;
    }
    f[b6] = w6;
  }
  c != null && e.disposeIntermediateTensorInfo(u);
  const g6 = e.makeTensorInfo(d, u.dtype, f);
  if (i6) {
    const b6 = re$1(d, a), x6 = Ot$1({ inputs: { x: g6 }, backend: e, attrs: { shape: b6 } });
    return e.disposeIntermediateTensorInfo(g6), x6;
  }
  return g6;
}
const tM = {
  kernelName: Hd$1,
  backendName: "cpu",
  kernelFunc: q3
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s;
  it(o, "any");
  const a = Ct(r, o.shape);
  let l = a;
  const c = qt$1(l, o.shape.length);
  let u = o;
  c != null && (u = Ze({ inputs: { x: o }, backend: e, attrs: { perm: c } }), l = ie(l.length, o.shape.length)), Te("any", l, u.shape.length);
  const [d, h6] = ye$1(u.shape, l), p6 = O(h6), f = Se(O(d), u.dtype), m = e.data.get(u.dataId).values;
  for (let b6 = 0; b6 < f.length; ++b6) {
    const x6 = b6 * p6;
    let w6 = m[x6];
    for (let y6 = 0; y6 < p6; ++y6) {
      const I = m[x6 + y6];
      w6 = w6 || I;
    }
    f[b6] = w6;
  }
  c != null && e.disposeIntermediateTensorInfo(u);
  const g6 = e.makeTensorInfo(d, u.dtype, f);
  if (i6) {
    const b6 = re$1(d, a), x6 = Ot$1({ inputs: { x: g6 }, backend: e, attrs: { shape: b6 } });
    return e.disposeIntermediateTensorInfo(g6), x6;
  }
  return g6;
}
const nM = {
  kernelName: _d$1,
  backendName: "cpu",
  kernelFunc: eM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r } = s;
  it(o, "argMax");
  let i6 = Ct(r, o.shape);
  const a = qt$1(i6, o.shape.length);
  let l = o;
  const c = [];
  a != null && (l = Ze({ inputs: { x: o }, backend: e, attrs: { perm: a } }), c.push(l), i6 = ie(i6.length, l.shape.length)), i6 = [i6[0]], Te("argMax", i6, l.shape.length);
  const [u, d] = ye$1(l.shape, i6), h6 = O(u), p6 = Se(h6, "int32"), f = O(d), m = e.data.get(l.dataId).values;
  for (let g6 = 0; g6 < p6.length; ++g6) {
    const b6 = g6 * f;
    let x6 = m[b6], w6 = 0;
    for (let y6 = 0; y6 < f; ++y6) {
      const I = m[b6 + y6];
      I > x6 && (x6 = I, w6 = y6);
    }
    p6[g6] = w6;
  }
  return c.forEach((g6) => e.disposeIntermediateTensorInfo(g6)), e.makeTensorInfo(u, "int32", p6);
}
const oM = {
  kernelName: zl,
  backendName: "cpu",
  kernelFunc: sM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r } = s;
  it(o, "argMin");
  let i6 = Ct(r, o.shape);
  const a = qt$1(i6, o.shape.length);
  let l = o;
  const c = [];
  a != null && (l = Ze({ inputs: { x: o }, backend: e, attrs: { perm: a } }), c.push(l), i6 = ie(i6.length, l.shape.length)), i6 = [i6[0]], Te("argMin", i6, l.shape.length);
  const [u, d] = ye$1(l.shape, i6), h6 = O(u), p6 = Se(h6, "int32"), f = O(d), m = e.data.get(l.dataId).values;
  for (let g6 = 0; g6 < p6.length; ++g6) {
    const b6 = g6 * f;
    let x6 = m[b6], w6 = 0;
    for (let y6 = 0; y6 < f; ++y6) {
      const I = m[b6 + y6];
      I < x6 && (x6 = I, w6 = y6);
    }
    p6[g6] = w6;
  }
  return c.forEach((g6) => e.disposeIntermediateTensorInfo(g6)), e.makeTensorInfo(u, "int32", p6);
}
const iM = {
  kernelName: Xl,
  backendName: "cpu",
  kernelFunc: rM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aM = Mt(pi, (n) => Math.asin(n)), lM = {
  kernelName: pi,
  backendName: "cpu",
  kernelFunc: aM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cM = Mt(fi, (n) => Math.asinh(n)), uM = {
  kernelName: fi,
  backendName: "cpu",
  kernelFunc: cM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dM = Mt(mi, (n) => Math.atan(n)), hM = {
  kernelName: mi,
  backendName: "cpu",
  kernelFunc: dM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pM = ce((n, t) => Math.atan2(n, t)), fM = we(bi, pM), mM = {
  kernelName: bi,
  backendName: "cpu",
  kernelFunc: fM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const gM = Mt(gi, (n) => Math.atanh(n)), bM = {
  kernelName: gi,
  backendName: "cpu",
  kernelFunc: gM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Mf$1(n, t, e, s, o, r) {
  const i6 = o.strideHeight, a = o.strideWidth, l = o.dilationHeight, c = o.dilationWidth, u = o.effectiveFilterHeight, d = o.effectiveFilterWidth, h6 = o.padInfo.top, p6 = o.padInfo.left, f = r === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = vt$1(o.outShape, e), g6 = m.values, b6 = o.outShape[1] * o.outShape[2] * o.outShape[3], x6 = o.outShape[2] * o.outShape[3], w6 = o.outShape[3];
  for (let y6 = 0; y6 < o.batchSize; ++y6) {
    const I = y6 * b6, C6 = y6 * s[0];
    for (let k7 = 0; k7 < o.inChannels; ++k7)
      for (let S = 0; S < o.outHeight; ++S) {
        const N = S * i6 - h6, R = Math.max(0, N), M6 = Math.min(o.inHeight, u + N), V = I + S * x6;
        for (let z = 0; z < o.outWidth; ++z) {
          const X = z * a - p6, P6 = Math.max(0, X), A6 = Math.min(o.inWidth, d + X);
          let B6 = f, Z = 0, H6 = 0;
          for (let Q = R; Q < M6; Q += l) {
            const j = C6 + Q * s[1];
            for (let J6 = P6; J6 < A6; J6 += c) {
              const nt = j + J6 * s[2], q = n[nt + k7];
              r === "max" && q > B6 ? B6 = q : r === "avg" && (Z += q, H6++);
            }
            if (isNaN(B6))
              break;
          }
          const Y = V + z * w6 + k7;
          g6[Y] = r === "avg" ? Z / H6 : B6;
        }
      }
  }
  return m;
}
function hw(n, t, e, s, o = false, r = false) {
  const i6 = vt$1(s.outShape, "int32"), a = s.strideHeight, l = s.strideWidth, c = s.dilationHeight, u = s.dilationWidth, d = s.effectiveFilterHeight, h6 = s.effectiveFilterWidth, p6 = s.padInfo.top, f = s.padInfo.left, m = vt$1(t, e, n);
  for (let g6 = 0; g6 < s.batchSize; ++g6)
    for (let b6 = 0; b6 < s.inChannels; ++b6)
      for (let x6 = 0; x6 < s.outHeight; ++x6) {
        const w6 = x6 * a - p6;
        let y6 = w6;
        for (; y6 < 0; )
          y6 += c;
        const I = Math.min(s.inHeight, d + w6);
        for (let C6 = 0; C6 < s.outWidth; ++C6) {
          const k7 = C6 * l - f;
          let S = k7;
          for (; S < 0; )
            S += u;
          const N = Math.min(s.inWidth, h6 + k7);
          let R = Number.NEGATIVE_INFINITY, M6 = -1;
          for (let V = y6; V < I; V += c) {
            const z = V - w6;
            for (let X = S; X < N; X += u) {
              const P6 = X - k7, A6 = m.get(g6, V, X, b6);
              A6 > R && (R = A6, o ? M6 = r ? ((g6 * s.inHeight + V) * s.inWidth + X) * s.inChannels + b6 : (V * s.inWidth + X) * s.inChannels + b6 : M6 = z * h6 + P6);
            }
          }
          i6.set(M6, g6, x6, C6, b6);
        }
      }
  return i6;
}
function pw(n, t, e, s, o, r) {
  const i6 = o.strideDepth, a = o.strideHeight, l = o.strideWidth, c = o.dilationDepth, u = o.dilationHeight, d = o.dilationWidth, h6 = o.effectiveFilterDepth, p6 = o.effectiveFilterHeight, f = o.effectiveFilterWidth, m = o.padInfo.front, g6 = o.padInfo.top, b6 = o.padInfo.left, x6 = r === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, w6 = vt$1(o.outShape, e), y6 = w6.values, I = o.outShape[1] * o.outShape[2] * o.outShape[3] * o.outShape[4], C6 = o.outShape[2] * o.outShape[3] * o.outShape[4], k7 = o.outShape[3] * o.outShape[4], S = o.outShape[4];
  for (let N = 0; N < o.batchSize; ++N) {
    const R = N * I, M6 = N * s[0];
    for (let V = 0; V < o.inChannels; ++V)
      for (let z = 0; z < o.outDepth; ++z) {
        const X = z * i6 - m;
        let P6 = X;
        for (; P6 < 0; )
          P6 += c;
        const A6 = Math.min(o.inDepth, h6 + X), B6 = R + z * C6;
        for (let Z = 0; Z < o.outHeight; ++Z) {
          const H6 = Z * a - g6;
          let Y = H6;
          for (; Y < 0; )
            Y += u;
          const Q = Math.min(o.inHeight, p6 + H6), j = B6 + Z * k7;
          for (let J6 = 0; J6 < o.outWidth; ++J6) {
            const nt = J6 * l - b6;
            let q = nt;
            for (; q < 0; )
              q += d;
            const rt = Math.min(o.inWidth, f + nt), ht = j + J6 * S;
            let ft2 = x6, pt = 0, wt2 = 0;
            for (let Et = P6; Et < A6; Et += c) {
              const Vt2 = M6 + Et * s[1];
              for (let te = Y; te < Q; te += u) {
                const zt = Vt2 + te * s[2];
                for (let Wt2 = q; Wt2 < rt; Wt2 += d) {
                  const Qt = zt + Wt2 * s[3], _t2 = n[Qt + V];
                  if (r === "max" && _t2 > ft2 ? ft2 = _t2 : r === "avg" && (pt += _t2, wt2++), isNaN(ft2))
                    break;
                }
                if (isNaN(ft2))
                  break;
              }
              if (isNaN(ft2))
                break;
            }
            const It = ht + V;
            y6[It] = r === "avg" ? pt / Math.max(wt2, 1) : ft2;
          }
        }
      }
  }
  return w6;
}
function xM(n, t) {
  const e = vt$1(t.outShape, "int32"), s = t.strideDepth, o = t.strideHeight, r = t.strideWidth, i6 = t.dilationDepth, a = t.dilationHeight, l = t.dilationWidth, c = t.effectiveFilterDepth, u = t.effectiveFilterHeight, d = t.effectiveFilterWidth, h6 = t.padInfo.front, p6 = t.padInfo.top, f = t.padInfo.left;
  for (let m = 0; m < t.batchSize; ++m)
    for (let g6 = 0; g6 < t.inChannels; ++g6)
      for (let b6 = 0; b6 < t.outDepth; ++b6) {
        const x6 = b6 * s - h6;
        let w6 = x6;
        for (; w6 < 0; )
          w6 += i6;
        const y6 = Math.min(t.inDepth, c + x6);
        for (let I = 0; I < t.outHeight; ++I) {
          const C6 = I * o - p6;
          let k7 = C6;
          for (; k7 < 0; )
            k7 += a;
          const S = Math.min(t.inHeight, u + C6);
          for (let N = 0; N < t.outWidth; ++N) {
            const R = N * r - f;
            let M6 = R;
            for (; M6 < 0; )
              M6 += l;
            const V = Math.min(t.inWidth, d + R);
            let z = Number.NEGATIVE_INFINITY, X = -1;
            for (let P6 = w6; P6 < y6; P6 += i6) {
              const A6 = P6 - x6;
              for (let B6 = k7; B6 < S; B6 += a) {
                const Z = B6 - C6;
                for (let H6 = M6; H6 < V; H6 += l) {
                  const Y = H6 - R, Q = n.get(m, P6, B6, H6, g6);
                  Q >= z && (z = Q, X = A6 * u * d + Z * u + Y);
                }
              }
            }
            e.set(X, m, b6, I, N, g6);
          }
        }
      }
  return e;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t;
  it(o, "avgPool");
  const { filterSize: r, strides: i6, pad: a, dimRoundingMode: l } = s, c = 1;
  v(Ee$1(i6, c), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i6} and dilations '${c}'`);
  const u = $n$1(o.shape, r, i6, c, a, l);
  let d;
  if (u.filterWidth === 1 && u.filterHeight === 1 && Rt$1(u.inShape, u.outShape))
    d = rs({ inputs: { x: o }, backend: e });
  else {
    const h6 = e.data.get(o.dataId).values, p6 = dt(o.shape), f = Mf$1(h6, o.shape, o.dtype, p6, u, "avg");
    d = e.makeTensorInfo(u.outShape, o.dtype, f.values);
  }
  return d;
}
const wM = {
  kernelName: Pl,
  backendName: "cpu",
  kernelFunc: yM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { filterSize: r, strides: i6, pad: a, dimRoundingMode: l, dataFormat: c } = s;
  it(o, "avgPool3d");
  const u = xs(o.shape, r, i6, 1, a, l, c), d = e.data.get(o.dataId).values, h6 = pw(d, o.shape, o.dtype, dt(o.shape), u, "avg");
  return e.makeTensorInfo(h6.shape, "float32", h6.values);
}
const CM = {
  kernelName: Al,
  backendName: "cpu",
  kernelFunc: IM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, input: r } = t, { filterSize: i6, strides: a, pad: l, dimRoundingMode: c } = s;
  it([o, r], "avgPool3DGrad");
  const u = xs(r.shape, i6, a, 1, l, c), d = u.strideDepth, h6 = u.strideHeight, p6 = u.strideWidth, f = u.filterDepth, m = u.filterHeight, g6 = u.filterWidth, b6 = u.dilationDepth, x6 = u.dilationHeight, w6 = u.dilationWidth, y6 = u.effectiveFilterDepth, I = u.effectiveFilterHeight, C6 = u.effectiveFilterWidth, k7 = y6 - 1 - u.padInfo.front, S = C6 - 1 - u.padInfo.left, N = I - 1 - u.padInfo.top, R = vt$1(r.shape, "float32"), M6 = 1 / (f * m * g6), V = e.bufferSync(o);
  for (let z = 0; z < u.batchSize; ++z)
    for (let X = 0; X < u.inChannels; ++X)
      for (let P6 = 0; P6 < u.inDepth; ++P6)
        for (let A6 = 0; A6 < u.inHeight; ++A6)
          for (let B6 = 0; B6 < u.inWidth; ++B6) {
            const Z = P6 - k7, H6 = A6 - N, Y = B6 - S;
            let Q = 0;
            for (let j = 0; j < y6; j += b6) {
              const J6 = (Z + j) / d;
              if (!(J6 < 0 || J6 >= u.outDepth || Math.floor(J6) !== J6))
                for (let nt = 0; nt < I; nt += x6) {
                  const q = (H6 + nt) / h6;
                  if (!(q < 0 || q >= u.outHeight || Math.floor(q) !== q))
                    for (let rt = 0; rt < C6; rt += w6) {
                      const ht = (Y + rt) / p6;
                      if (ht < 0 || ht >= u.outWidth || Math.floor(ht) !== ht)
                        continue;
                      const ft2 = V.get(z, J6, q, ht, X);
                      Q += ft2;
                    }
                }
            }
            R.set(Q * M6, z, P6, A6, B6, X);
          }
  return e.makeTensorInfo(R.shape, R.dtype, R.values);
}
const SM = {
  kernelName: Yd$1,
  backendName: "cpu",
  kernelFunc: vM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, input: r } = t, i6 = r;
  it([o, r], "avgPoolGrad");
  const { filterSize: a, strides: l, pad: c } = s, u = $n$1(i6.shape, a, l, 1, c), d = u.strideHeight, h6 = u.strideWidth, p6 = u.filterHeight, f = u.filterWidth, m = u.dilationHeight, g6 = u.dilationWidth, b6 = u.effectiveFilterHeight, x6 = u.effectiveFilterWidth, w6 = x6 - 1 - u.padInfo.left, y6 = b6 - 1 - u.padInfo.top, I = vt$1(i6.shape, "float32"), C6 = 1 / (p6 * f), k7 = e.data.get(o.dataId).values, S = vt$1(o.shape, "float32", k7);
  for (let N = 0; N < u.batchSize; ++N)
    for (let R = 0; R < u.inChannels; ++R)
      for (let M6 = 0; M6 < u.inHeight; ++M6)
        for (let V = 0; V < u.inWidth; ++V) {
          const z = M6 - y6, X = V - w6;
          let P6 = 0;
          for (let A6 = 0; A6 < b6; A6 += m) {
            const B6 = (z + A6) / d;
            if (!(B6 < 0 || B6 >= u.outHeight || Math.floor(B6) !== B6))
              for (let Z = 0; Z < x6; Z += g6) {
                const H6 = (X + Z) / h6;
                if (H6 < 0 || H6 >= u.outWidth || Math.floor(H6) !== H6)
                  continue;
                const Y = S.get(N, B6, H6, R);
                P6 += Y;
              }
          }
          I.set(P6 * C6, N, M6, V, R);
        }
  return e.makeTensorInfo(I.shape, I.dtype, I.values);
}
const TM = {
  kernelName: Ud$1,
  backendName: "cpu",
  kernelFunc: kM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, scale: r, offset: i6, mean: a, variance: l } = t;
  v(a.shape.length === l.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), v(i6 == null || a.shape.length === i6.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), v(r == null || a.shape.length === r.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), it([o, a, l, r, i6], "batchNorm");
  let { varianceEpsilon: c } = s;
  c == null && (c = 1e-3);
  const u = e.data.get(o.dataId).values, d = e.data.get(a.dataId).values, h6 = e.data.get(l.dataId).values, p6 = r ? e.data.get(r.dataId).values : new Float32Array([1]), f = i6 ? e.data.get(i6.dataId).values : new Float32Array([0]), m = new Float32Array(u.length), g6 = f.length, b6 = p6.length, x6 = h6.length, w6 = d.length;
  let y6 = 0, I = 0, C6 = 0, k7 = 0;
  for (let S = 0; S < u.length; ++S)
    m[S] = f[y6++] + (u[S] - d[I++]) * p6[C6++] / Math.sqrt(h6[k7++] + c), y6 >= g6 && (y6 = 0), I >= w6 && (I = 0), C6 >= b6 && (C6 = 0), k7 >= x6 && (k7 = 0);
  return e.makeTensorInfo(o.shape, o.dtype, m);
}
const RM = {
  kernelName: tc,
  backendName: "cpu",
  kernelFunc: NM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $M(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { blockShape: r, crops: i6 } = s;
  it([o], "batchToSpaceND");
  const a = r.reduce((b6, x6) => b6 * x6), l = fa(o.shape, r, a), c = ma(l.length, r.length), u = ga(o.shape, r, a), d = Pp(i6, r.length), h6 = Ap(u, i6, r.length), p6 = Ot$1({ inputs: { x: o }, backend: e, attrs: { shape: l } }), f = Ze({ inputs: { x: p6 }, backend: e, attrs: { perm: c } }), m = Ot$1({ inputs: { x: f }, backend: e, attrs: { shape: u } }), g6 = Go({
    inputs: { x: m },
    backend: e,
    attrs: { begin: d, size: h6 }
  });
  return e.disposeIntermediateTensorInfo(p6), e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(m), g6;
}
const GM = {
  kernelName: Kl,
  backendName: "cpu",
  kernelFunc: $M
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, weights: r } = t, { size: i6 } = s, a = e.data.get(o.dataId).values, l = e.data.get(r.dataId).values, c = Rf$1(a, l, r.dtype, r.shape, i6);
  return e.makeTensorInfo([i6], r.dtype, c);
}
const LM = {
  kernelName: Qd$1,
  backendName: "cpu",
  kernelFunc: EM
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MM(n) {
  const { inputs: t, backend: e } = n, { s0: s, s1: o } = t, r = e.data.get(s.dataId).values, i6 = e.data.get(o.dataId).values, a = bt$1(Array.from(r), Array.from(i6));
  return e.makeTensorInfo([a.length], "int32", Int32Array.from(a));
}
const WM = {
  kernelName: Kg$1,
  backendName: "cpu",
  kernelFunc: MM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const DM = Mt(wi, (n, t) => {
  const e = t;
  return n > e.clipValueMax ? e.clipValueMax : n < e.clipValueMin ? e.clipValueMin : n;
}), FM = {
  kernelName: wi,
  backendName: "cpu",
  kernelFunc: DM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const VM = (n) => {
  const { x: t } = n.inputs, e = n.backend, s = new Float32Array(O(t.shape)), o = e.data.get(t.dataId), r = o.complexTensorInfos.real, i6 = o.complexTensorInfos.imag, a = e.data.get(r.dataId).values, l = e.data.get(i6.dataId).values;
  for (let c = 0; c < a.length; c++) {
    const u = a[c], d = l[c];
    s[c] = Math.hypot(u, d);
  }
  return e.makeOutput(s, t.shape, "float32");
}, zM = {
  kernelName: Zl,
  backendName: "cpu",
  kernelFunc: VM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ur(n) {
  const { inputs: t, backend: e } = n, { input: s } = t, o = e.data.get(s.dataId).complexTensorInfos.imag, r = e.data.get(o.dataId).values;
  return e.makeTensorInfo(o.shape, o.dtype, r);
}
const XM = {
  kernelName: hh$1,
  backendName: "cpu",
  kernelFunc: ur
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dr(n) {
  const { inputs: t, backend: e, attrs: s } = n, { axis: o } = s, r = Ct(o, t[0].shape)[0], i6 = t.map((m) => m.shape);
  Vp(i6, r);
  let a = ts(t.map((m) => m.shape), r);
  if (O(a) === 0)
    return e.makeTensorInfo(a, t[0].dtype, []);
  const l = t.filter((m) => O(m.shape) > 0);
  if (l.length === 1)
    return rs({ inputs: { x: l[0] }, backend: e });
  if (l[0].dtype === "complex64") {
    const m = l.map((y6) => $o({ inputs: { input: y6 }, backend: e })), g6 = l.map((y6) => ur({ inputs: { input: y6 }, backend: e })), b6 = dr({ inputs: m, backend: e, attrs: { axis: r } }), x6 = dr({ inputs: g6, backend: e, attrs: { axis: r } }), w6 = Ye({ inputs: { real: b6, imag: x6 }, backend: e });
    return m.forEach((y6) => e.disposeIntermediateTensorInfo(y6)), g6.forEach((y6) => e.disposeIntermediateTensorInfo(y6)), e.disposeIntermediateTensorInfo(b6), e.disposeIntermediateTensorInfo(x6), w6;
  }
  const c = l.map((m) => {
    const b6 = [-1, O(m.shape.slice(r))];
    return Ot$1({ inputs: { x: m }, backend: e, attrs: { shape: b6 } });
  }), u = c.map((m) => ({ vals: e.data.get(m.dataId).values, shape: m.shape }));
  a = ts(
    c.map((m) => m.shape),
    1
    /* axis */
  );
  const d = c[0].shape[0] === 1, h6 = w1(u, a, t[0].dtype, d), p6 = ts(l.map((m) => m.shape), r), f = e.makeTensorInfo(p6, t[0].dtype, h6);
  return c.forEach((m) => e.disposeIntermediateTensorInfo(m)), f;
}
const PM = {
  kernelName: Bl,
  backendName: "cpu",
  kernelFunc: dr
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fw(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r } = t, { strides: i6, pad: a, dataFormat: l, dilations: c, dimRoundingMode: u } = s;
  it([o, r], "conv2d");
  const d = ys(l), h6 = ke(o.shape, r.shape, i6, c, a, u, false, d), p6 = h6.filterHeight, f = h6.filterWidth, m = h6.dilationHeight, g6 = h6.dilationWidth, b6 = h6.padInfo.left, x6 = h6.padInfo.top, w6 = h6.dataFormat === "channelsLast", y6 = new $e(h6.outShape, o.dtype), I = dt(o.shape), C6 = dt(r.shape), k7 = I[0], S = w6 ? I[1] : I[2], N = w6 ? I[2] : 1, R = w6 ? 1 : I[1], M6 = y6.strides[0], V = w6 ? y6.strides[1] : y6.strides[2], z = w6 ? y6.strides[2] : 1, X = w6 ? 1 : y6.strides[1], P6 = e.data.get(o.dataId).values, A6 = e.data.get(r.dataId).values, B6 = y6.values;
  for (let Z = 0; Z < h6.batchSize; ++Z) {
    const H6 = Z * k7, Y = Z * M6;
    for (let Q = 0; Q < h6.outHeight; ++Q) {
      const j = Y + Q * V, J6 = Q * h6.strideHeight - x6;
      for (let nt = 0; nt < p6; ++nt) {
        const q = J6 + nt * m;
        if (q < 0 || q >= h6.inHeight)
          continue;
        const rt = nt * C6[0], ht = H6 + q * S;
        for (let ft2 = 0; ft2 < h6.outWidth; ++ft2) {
          const pt = j + ft2 * z, wt2 = ft2 * h6.strideWidth - b6;
          for (let It = 0; It < f; ++It) {
            const Et = wt2 + It * g6;
            if (Et < 0 || Et >= h6.inWidth)
              continue;
            const Vt2 = rt + It * C6[1], te = ht + Et * N;
            let zt = Vt2;
            for (let Wt2 = 0; Wt2 < h6.inChannels; ++Wt2) {
              const Qt = P6[te + Wt2 * R];
              for (let _t2 = 0; _t2 < h6.outChannels; ++_t2)
                B6[pt + _t2 * X] += Qt * A6[zt + _t2];
              zt += h6.outChannels;
            }
          }
        }
      }
    }
  }
  return e.makeTensorInfo(y6.shape, y6.dtype, B6);
}
const AM = {
  kernelName: Hl,
  backendName: "cpu",
  kernelFunc: fw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, dy: r } = t, { strides: i6, pad: a, dataFormat: l, dimRoundingMode: c, filterShape: u } = s;
  it([o, r], "conv2dBackpropFilter");
  const d = ys(l), h6 = ke(o.shape, u, i6, 1, a, c, false, d), { strideHeight: p6, strideWidth: f, filterHeight: m, filterWidth: g6 } = h6, b6 = h6.dataFormat === "channelsLast", x6 = new $e(h6.filterShape, "float32"), w6 = h6.padInfo.left, y6 = h6.padInfo.top, I = e.data.get(o.dataId).values, C6 = e.data.get(r.dataId).values, k7 = new $e(o.shape, o.dtype, I), S = new $e(r.shape, r.dtype, C6);
  for (let N = 0; N < m; ++N) {
    const R = Math.max(0, Math.ceil((y6 - N) / p6)), M6 = Math.min(h6.outHeight, (h6.inHeight + y6 - N) / p6);
    for (let V = 0; V < g6; ++V) {
      const z = Math.max(0, Math.ceil((w6 - V) / f)), X = Math.min(h6.outWidth, (h6.inWidth + w6 - V) / f);
      for (let P6 = 0; P6 < h6.inChannels; ++P6)
        for (let A6 = 0; A6 < h6.outChannels; ++A6) {
          let B6 = 0;
          for (let Z = 0; Z < h6.batchSize; ++Z)
            for (let H6 = R; H6 < M6; ++H6) {
              const Y = N + H6 * p6 - y6;
              for (let Q = z; Q < X; ++Q) {
                const j = V + Q * f - w6;
                b6 ? B6 += k7.get(Z, Y, j, P6) * S.get(Z, H6, Q, A6) : B6 += k7.get(Z, P6, Y, j) * S.get(Z, A6, H6, Q);
              }
            }
          x6.set(B6, N, V, P6, A6);
        }
    }
  }
  return e.makeTensorInfo(x6.shape, x6.dtype, x6.values);
}
const KM = {
  kernelName: jd$1,
  backendName: "cpu",
  kernelFunc: OM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, filter: r } = t, { inputShape: i6, strides: a, pad: l, dataFormat: c, dimRoundingMode: u } = s;
  it([o, r], "conv2dBackpropInput");
  const d = dt(r.shape), h6 = dt(o.shape);
  let p6 = ys(c);
  const f = ke(i6, r.shape, a, 1, l, u, false, p6), m = new $e(f.inShape, "float32"), g6 = m.values, b6 = e.data.get(o.dataId).values, x6 = e.data.get(r.dataId).values, [w6, y6, I] = d, { batchSize: C6, filterHeight: k7, filterWidth: S, inChannels: N, inHeight: R, inWidth: M6, outChannels: V, outHeight: z, outWidth: X, strideHeight: P6, strideWidth: A6 } = f;
  p6 = f.dataFormat;
  const B6 = k7 - 1 - f.padInfo.top, Z = S - 1 - f.padInfo.left, H6 = p6 === "channelsLast", Y = m.strides[0], Q = H6 ? m.strides[1] : m.strides[2], j = H6 ? m.strides[2] : 1, J6 = H6 ? 1 : m.strides[1], nt = h6[0], q = H6 ? h6[1] : h6[2], rt = H6 ? h6[2] : 1, ht = H6 ? 1 : h6[1];
  for (let ft2 = 0; ft2 < C6; ++ft2)
    for (let pt = 0; pt < N; ++pt)
      for (let wt2 = 0; wt2 < R; ++wt2) {
        const It = wt2 - B6, Et = Math.max(0, Math.ceil(It / P6)), Vt2 = Math.min(z, (k7 + It) / P6);
        for (let te = 0; te < M6; ++te) {
          const zt = te - Z, Wt2 = Math.max(0, Math.ceil(zt / A6)), Qt = Math.min(X, (S + zt) / A6);
          let _t2 = 0;
          for (let Ie = Et; Ie < Vt2; ++Ie) {
            const vs = Ie * P6 - It;
            for (let on2 = Wt2; on2 < Qt; ++on2) {
              const qs = on2 * A6 - zt, Ln2 = nt * ft2 + q * Ie + rt * on2, ls = w6 * (k7 - 1 - vs) + y6 * (S - 1 - qs) + I * pt;
              for (let Ss = 0; Ss < V; ++Ss) {
                const ks = b6[Ln2 + ht * Ss], Ts = x6[ls + Ss];
                _t2 += ks * Ts;
              }
            }
          }
          const as = Y * ft2 + Q * wt2 + j * te + J6 * pt;
          g6[as] = _t2;
        }
      }
  return e.makeTensorInfo(m.shape, m.dtype, m.values);
}
const BM = {
  kernelName: _l,
  backendName: "cpu",
  kernelFunc: ZM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function HM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r } = t, { strides: i6, pad: a, dilations: l } = s;
  it([o, r], "conv3d");
  const c = Bs(o.shape, r.shape, i6, l, a), { filterDepth: u, filterHeight: d, filterWidth: h6, dilationDepth: p6, dilationHeight: f, dilationWidth: m, padInfo: g6 } = c, b6 = g6.front, x6 = g6.left, w6 = g6.top, y6 = new $e(c.outShape, o.dtype), I = e.data.get(o.dataId).values, C6 = e.data.get(r.dataId).values, k7 = y6.values, S = dt(o.shape), N = dt(r.shape);
  for (let R = 0; R < c.batchSize; ++R) {
    const M6 = R * S[0], V = R * y6.strides[0];
    for (let z = 0; z < c.outDepth; ++z) {
      const X = V + z * y6.strides[1], P6 = z * c.strideDepth - b6;
      for (let A6 = 0; A6 < u; ++A6) {
        const B6 = P6 + A6 * p6;
        if (B6 < 0 || B6 >= c.inDepth)
          continue;
        const Z = A6 * N[0], H6 = M6 + B6 * S[1];
        for (let Y = 0; Y < c.outHeight; ++Y) {
          const Q = X + Y * y6.strides[2], j = Y * c.strideHeight - w6;
          for (let J6 = 0; J6 < d; ++J6) {
            const nt = j + J6 * f;
            if (nt < 0 || nt >= c.inHeight)
              continue;
            const q = Z + J6 * N[1], rt = H6 + nt * S[2];
            for (let ht = 0; ht < c.outWidth; ++ht) {
              const ft2 = Q + ht * c.outChannels, pt = ht * c.strideWidth - x6;
              for (let wt2 = 0; wt2 < h6; ++wt2) {
                const It = pt + wt2 * m;
                if (It < 0 || It >= c.inWidth)
                  continue;
                const Et = q + wt2 * N[2], Vt2 = rt + It * c.inChannels;
                let te = Et;
                for (let zt = 0; zt < c.inChannels; ++zt) {
                  const Wt2 = I[Vt2 + zt];
                  for (let Qt = 0; Qt < c.outChannels; ++Qt)
                    k7[ft2 + Qt] += Wt2 * C6[te + Qt];
                  te += c.outChannels;
                }
              }
            }
          }
        }
      }
    }
  }
  return e.makeTensorInfo(y6.shape, y6.dtype, y6.values);
}
const _M = {
  kernelName: Ul,
  backendName: "cpu",
  kernelFunc: HM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, dy: r } = t, { strides: i6, pad: a, filterShape: l } = s;
  it([o, r], "conv3dBackpropFilterV2");
  const c = dt(o.shape), u = dt(r.shape), d = Bs(o.shape, l, i6, 1, a), h6 = d.strideDepth, p6 = d.strideHeight, f = d.strideWidth, m = d.filterDepth, g6 = d.filterHeight, b6 = d.filterWidth, x6 = new $e(d.filterShape, "float32"), w6 = x6.values, [y6, I, C6, k7] = x6.strides, S = e.data.get(r.dataId).values, [N, R, M6, V] = u, z = e.data.get(o.dataId).values, [X, P6, A6, B6] = c, Z = d.padInfo.front, H6 = d.padInfo.left, Y = d.padInfo.top;
  for (let Q = 0; Q < m; ++Q) {
    const j = Math.max(0, Math.ceil((Z - Q) / h6)), J6 = Math.min(d.outDepth, (d.inDepth + Z - Q) / h6), nt = Q * y6;
    for (let q = 0; q < g6; ++q) {
      const rt = Math.max(0, Math.ceil((Y - q) / p6)), ht = Math.min(d.outHeight, (d.inHeight + Y - q) / p6), ft2 = q * I + nt;
      for (let pt = 0; pt < b6; ++pt) {
        const wt2 = Math.max(0, Math.ceil((H6 - pt) / f)), It = Math.min(d.outWidth, (d.inWidth + H6 - pt) / f), Et = pt * C6 + ft2;
        for (let Vt2 = 0; Vt2 < d.inChannels; ++Vt2) {
          const te = Vt2 * k7 + Et;
          for (let zt = 0; zt < d.outChannels; ++zt) {
            let Wt2 = 0;
            for (let Qt = 0; Qt < d.batchSize; ++Qt) {
              const _t2 = Qt * X, as = Qt * N;
              for (let Ie = j; Ie < J6; ++Ie) {
                const on2 = (Q + Ie * h6 - Z) * P6 + _t2, qs = Ie * R + as;
                for (let Ln2 = rt; Ln2 < ht; ++Ln2) {
                  const Ss = (q + Ln2 * p6 - Y) * A6 + on2, ks = Ln2 * M6 + qs;
                  for (let Ts = wt2; Ts < It; ++Ts) {
                    const bu = (pt + Ts * f - H6) * B6 + Ss, xu = Ts * V + ks;
                    Wt2 += z[bu + Vt2] * S[xu + zt];
                  }
                }
              }
            }
            w6[te + zt] = Wt2;
          }
        }
      }
    }
  }
  return e.makeTensorInfo(x6.shape, x6.dtype, x6.values);
}
const YM = {
  kernelName: qd$1,
  backendName: "cpu",
  kernelFunc: UM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QM(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, filter: r } = t, { pad: i6, strides: a, inputShape: l } = s;
  it([o], "conv3dBackpropInputV2");
  const c = dt(o.shape), u = dt(r.shape), d = Bs(l, r.shape, a, 1, i6), h6 = new $e(d.inShape, "float32"), p6 = h6.values, [f, m, g6, b6] = h6.strides, x6 = e.data.get(o.dataId).values, [w6, y6, I, C6] = c, k7 = e.data.get(r.dataId).values, [S, N, R, M6] = u, { batchSize: V, filterDepth: z, filterHeight: X, filterWidth: P6, inChannels: A6, inDepth: B6, inHeight: Z, inWidth: H6, outChannels: Y, outDepth: Q, outHeight: j, outWidth: J6, strideDepth: nt, strideHeight: q, strideWidth: rt } = d, ht = z - 1 - d.padInfo.front, ft2 = X - 1 - d.padInfo.top, pt = P6 - 1 - d.padInfo.left;
  for (let wt2 = 0; wt2 < V; ++wt2)
    for (let It = 0; It < A6; ++It)
      for (let Et = 0; Et < B6; ++Et) {
        const Vt2 = Et - ht, te = Math.max(0, Math.ceil(Vt2 / nt)), zt = Math.min(Q, (z + Vt2) / nt);
        for (let Wt2 = 0; Wt2 < Z; ++Wt2) {
          const Qt = Wt2 - ft2, _t2 = Math.max(0, Math.ceil(Qt / q)), as = Math.min(j, (X + Qt) / q);
          for (let Ie = 0; Ie < H6; ++Ie) {
            const vs = Ie - pt, on2 = Math.max(0, Math.ceil(vs / rt)), qs = Math.min(J6, (P6 + vs) / rt);
            let Ln2 = 0;
            for (let ls = te; ls < zt; ++ls) {
              const Ss = ls * nt - Vt2;
              for (let ks = _t2; ks < as; ++ks) {
                const Ts = ks * q - Qt;
                for (let Lr = on2; Lr < qs; ++Lr) {
                  const bu = Lr * rt - vs, xu = w6 * wt2 + y6 * ls + I * ks + C6 * Lr, SI = S * (z - 1 - Ss) + N * (X - 1 - Ts) + R * (P6 - 1 - bu) + M6 * It;
                  for (let Ma = 0; Ma < Y; ++Ma) {
                    const kI = x6[xu + Ma], TI = k7[SI + Ma];
                    Ln2 += kI * TI;
                  }
                }
              }
            }
            p6[f * wt2 + m * Et + g6 * Wt2 + b6 * Ie + It] = Ln2;
          }
        }
      }
  return e.makeTensorInfo(h6.shape, h6.dtype, h6.values);
}
const JM = {
  kernelName: th$1,
  backendName: "cpu",
  kernelFunc: QM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jM = Mt(Ii, (n) => Math.cos(n)), qM = {
  kernelName: Ii,
  backendName: "cpu",
  kernelFunc: jM
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tW = Mt(Ci, (n) => Math.cosh(n)), eW = {
  kernelName: Ci,
  backendName: "cpu",
  kernelFunc: tW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { image: o, boxes: r, boxInd: i6 } = t, { cropSize: a, method: l, extrapolationValue: c } = s, [u, d, h6, p6] = o.shape, f = r.shape[0], [m, g6] = a, b6 = vt$1([f, m, g6, p6], "float32"), x6 = e.data.get(r.dataId).values, w6 = e.data.get(i6.dataId).values, y6 = e.data.get(o.dataId).values, I = dt(o.shape), C6 = dt(b6.shape);
  for (let k7 = 0; k7 < f; k7++) {
    const S = k7 * 4, N = x6[S], R = x6[S + 1], M6 = x6[S + 2], V = x6[S + 3], z = w6[k7];
    if (z >= u)
      continue;
    const X = m > 1 ? (M6 - N) * (d - 1) / (m - 1) : 0, P6 = g6 > 1 ? (V - R) * (h6 - 1) / (g6 - 1) : 0;
    for (let A6 = 0; A6 < m; A6++) {
      const B6 = m > 1 ? N * (d - 1) + A6 * X : 0.5 * (N + M6) * (d - 1);
      if (B6 < 0 || B6 > d - 1) {
        for (let Z = 0; Z < g6; Z++)
          for (let H6 = 0; H6 < p6; H6++) {
            const Y = H6 + Z * C6[2] + A6 * C6[1] + k7 * C6[0];
            b6.values[Y] = c;
          }
        continue;
      }
      if (l === "bilinear") {
        const Z = Math.floor(B6), H6 = Math.ceil(B6), Y = B6 - Z;
        for (let Q = 0; Q < g6; Q++) {
          const j = g6 > 1 ? R * (h6 - 1) + Q * P6 : 0.5 * (R + V) * (h6 - 1);
          if (j < 0 || j > h6 - 1) {
            for (let rt = 0; rt < p6; rt++) {
              const ht = rt + Q * C6[2] + A6 * C6[1] + k7 * C6[0];
              b6.values[ht] = c;
            }
            continue;
          }
          const J6 = Math.floor(j), nt = Math.ceil(j), q = j - J6;
          for (let rt = 0; rt < p6; rt++) {
            let ht = rt + J6 * I[2] + Z * I[1] + z * I[0];
            const ft2 = y6[ht];
            ht = rt + nt * I[2] + Z * I[1] + z * I[0];
            const pt = y6[ht];
            ht = rt + J6 * I[2] + H6 * I[1] + z * I[0];
            const wt2 = y6[ht];
            ht = rt + nt * I[2] + H6 * I[1] + z * I[0];
            const It = y6[ht], Et = ft2 + (pt - ft2) * q, Vt2 = wt2 + (It - wt2) * q;
            ht = rt + Q * C6[2] + A6 * C6[1] + k7 * C6[0], b6.values[ht] = Et + (Vt2 - Et) * Y;
          }
        }
      } else
        for (let Z = 0; Z < g6; ++Z) {
          const H6 = g6 > 1 ? R * (h6 - 1) + Z * P6 : 0.5 * (R + V) * (h6 - 1);
          if (H6 < 0 || H6 > h6 - 1) {
            for (let j = 0; j < p6; j++) {
              const J6 = j + Z * C6[2] + A6 * C6[1] + k7 * C6[0];
              b6.values[J6] = c;
            }
            continue;
          }
          const Y = Math.round(H6), Q = Math.round(B6);
          for (let j = 0; j < p6; j++) {
            const J6 = j + Y * I[2] + Q * I[1] + z * I[0], nt = j + Z * C6[2] + A6 * C6[1] + k7 * C6[0];
            b6.values[nt] = y6[J6];
          }
        }
    }
  }
  return e.makeTensorInfo(b6.shape, b6.dtype, b6.values);
}
const sW = {
  kernelName: nh$1,
  backendName: "cpu",
  kernelFunc: nW
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, exclusive: i6, reverse: a } = s;
  it(o, "cumprod");
  const l = qt$1([r], o.shape.length);
  let c = o;
  l != null && (c = Ze({ inputs: { x: o }, backend: e, attrs: { perm: l } }));
  const u = ie(1, o.shape.length)[0];
  if (u !== c.shape.length - 1)
    throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length - 1} but got axis=${u}`);
  const d = je$1(c.dtype, "int32"), h6 = Fl(O(c.shape), d), p6 = e.data.get(c.dataId).values, f = c.shape[c.shape.length - 1], m = a ? (b6, x6) => b6 + f - x6 - 1 : (b6, x6) => b6 + x6;
  for (let b6 = 0; b6 < p6.length; b6 += f)
    for (let x6 = 0; x6 < f; x6++) {
      const w6 = m(b6, x6);
      if (x6 === 0)
        h6[w6] = i6 ? 1 : p6[w6];
      else {
        const y6 = m(b6, x6 - 1);
        h6[w6] = i6 ? p6[y6] * h6[y6] : p6[w6] * h6[y6];
      }
    }
  const g6 = e.makeTensorInfo(c.shape, d, h6);
  if (l != null) {
    const b6 = Hs(l), x6 = Ze({ inputs: { x: g6 }, backend: e, attrs: { perm: b6 } });
    return e.disposeIntermediateTensorInfo(g6), e.disposeIntermediateTensorInfo(c), x6;
  }
  return g6;
}
const rW = {
  kernelName: eh$1,
  backendName: "cpu",
  kernelFunc: oW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, exclusive: i6, reverse: a } = s;
  it(o, "cumsum");
  const l = qt$1([r], o.shape.length);
  let c = o;
  l != null && (c = Ze({ inputs: { x: o }, backend: e, attrs: { perm: l } }));
  const u = ie(1, o.shape.length)[0];
  if (u !== c.shape.length - 1)
    throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length - 1} but got axis=${u}`);
  const d = je$1(c.dtype, "int32"), h6 = Se(O(c.shape), d), p6 = e.data.get(c.dataId).values, f = c.shape[c.shape.length - 1], m = a ? (b6, x6) => b6 + f - x6 - 1 : (b6, x6) => b6 + x6;
  for (let b6 = 0; b6 < p6.length; b6 += f)
    for (let x6 = 0; x6 < f; x6++) {
      const w6 = m(b6, x6);
      if (x6 === 0)
        h6[w6] = i6 ? 0 : p6[w6];
      else {
        const y6 = m(b6, x6 - 1);
        h6[w6] = i6 ? p6[y6] + h6[y6] : p6[w6] + h6[y6];
      }
    }
  const g6 = e.makeTensorInfo(c.shape, d, h6);
  if (l != null) {
    const b6 = Hs(l), x6 = Ze({ inputs: { x: g6 }, backend: e, attrs: { perm: b6 } });
    return e.disposeIntermediateTensorInfo(g6), e.disposeIntermediateTensorInfo(c), x6;
  }
  return g6;
}
const aW = {
  kernelName: Yl,
  backendName: "cpu",
  kernelFunc: iW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, weights: r } = t, { size: i6, binaryOutput: a } = s;
  if (o.shape.length === 1) {
    const l = e.data.get(o.dataId).values, c = e.data.get(r.dataId).values, u = Rf$1(l, c, r.dtype, r.shape, i6);
    return e.makeTensorInfo([i6], r.dtype, u);
  } else if (o.shape.length === 2) {
    const l = e.bufferSync(o), c = e.bufferSync(r), u = x1(l, c, i6, a);
    return e.makeTensorInfo(u.shape, r.dtype, u.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`);
}
const cW = {
  kernelName: sh$1,
  backendName: "cpu",
  kernelFunc: lW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { blockSize: r, dataFormat: i6 } = s;
  v(i6 === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i6}`);
  const a = o.shape[0], l = o.shape[1], c = o.shape[2], u = o.shape[3], d = l * r, h6 = c * r, p6 = u / (r * r), f = e.data.get(o.dataId).values, m = new Float32Array(a * d * h6 * p6);
  let g6 = 0;
  for (let b6 = 0; b6 < a; ++b6)
    for (let x6 = 0; x6 < d; ++x6) {
      const w6 = Math.floor(x6 / r), y6 = x6 % r;
      for (let I = 0; I < h6; ++I) {
        const C6 = Math.floor(I / r), k7 = I % r, S = (y6 * r + k7) * p6;
        for (let N = 0; N < p6; ++N) {
          const M6 = N + S + u * (C6 + c * (w6 + l * b6));
          m[g6++] = f[M6];
        }
      }
    }
  return e.makeTensorInfo([a, d, h6, p6], o.dtype, m);
}
const dW = {
  kernelName: oh$1,
  backendName: "cpu",
  kernelFunc: uW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mw(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r } = t, { strides: i6, pad: a, dilations: l, dimRoundingMode: c } = s;
  it([o, r], "depthwiseConv2DNative");
  const u = dt(o.shape), d = dt(r.shape);
  let h6 = l;
  h6 == null && (h6 = [1, 1]), v(Ee$1(i6, h6), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i6} and dilations '${h6}'`);
  const p6 = ke(
    o.shape,
    r.shape,
    i6,
    h6,
    a,
    c,
    true
    /* depthwise */
  ), { filterHeight: f, filterWidth: m, dilationHeight: g6, dilationWidth: b6, padInfo: x6 } = p6, w6 = x6.left, y6 = x6.top, I = p6.outChannels / p6.inChannels, C6 = new $e(p6.outShape, o.dtype), k7 = e.data.get(o.dataId).values, S = e.data.get(r.dataId).values, N = C6.values;
  for (let R = 0; R < p6.batchSize; ++R) {
    const M6 = R * u[0], V = R * C6.strides[0];
    for (let z = 0; z < p6.outHeight; ++z) {
      const X = V + z * C6.strides[1], P6 = z * p6.strideHeight - y6;
      for (let A6 = 0; A6 < f; ++A6) {
        const B6 = P6 + A6 * g6;
        if (B6 < 0 || B6 >= p6.inHeight)
          continue;
        const Z = A6 * d[0], H6 = M6 + B6 * u[1];
        for (let Y = 0; Y < p6.outWidth; ++Y) {
          const Q = X + Y * C6.strides[2], j = Y * p6.strideWidth - w6;
          for (let J6 = 0; J6 < m; ++J6) {
            const nt = j + J6 * b6;
            if (nt < 0 || nt >= p6.inWidth)
              continue;
            const q = Z + J6 * d[1], rt = H6 + nt * p6.inChannels;
            let ht = Q, ft2 = q;
            for (let pt = 0; pt < p6.inChannels; ++pt) {
              const wt2 = k7[rt + pt];
              for (let It = 0; It < I; ++It)
                N[ht + It] += wt2 * S[ft2 + It];
              ht += I, ft2 += I;
            }
          }
        }
      }
    }
  }
  return e.makeTensorInfo(C6.shape, C6.dtype, C6.values);
}
const hW = {
  kernelName: Ql,
  backendName: "cpu",
  kernelFunc: mw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, dy: r } = t, { strides: i6, dilations: a, pad: l, dimRoundingMode: c, filterShape: u } = s;
  it([o, r], "depthwiseConv2dNativeBackpropFilter");
  const d = ke(
    o.shape,
    u,
    i6,
    a,
    l,
    c,
    true
    /* depthwise */
  ), { strideHeight: h6, strideWidth: p6, filterHeight: f, filterWidth: m } = d, g6 = new $e(d.filterShape, "float32"), b6 = d.padInfo.left, x6 = d.padInfo.top, w6 = d.outChannels / d.inChannels, y6 = e.data.get(o.dataId).values, I = new $e(o.shape, o.dtype, y6), C6 = e.data.get(r.dataId).values, k7 = new $e(r.shape, r.dtype, C6);
  for (let S = 0; S < f; ++S) {
    const N = Math.max(0, Math.ceil((x6 - S) / h6)), R = Math.min(d.outHeight, (d.inHeight + x6 - S) / h6);
    for (let M6 = 0; M6 < m; ++M6) {
      const V = Math.max(0, Math.ceil((b6 - M6) / p6)), z = Math.min(d.outWidth, (d.inWidth + b6 - M6) / p6);
      for (let X = 0; X < d.outChannels; ++X) {
        const P6 = Math.trunc(X / w6), A6 = X % w6;
        let B6 = 0;
        for (let Z = 0; Z < d.batchSize; ++Z)
          for (let H6 = N; H6 < R; ++H6) {
            const Y = S + H6 * h6 - x6;
            for (let Q = V; Q < z; ++Q) {
              const j = M6 + Q * p6 - b6;
              B6 += I.get(Z, Y, j, P6) * k7.get(Z, H6, Q, X);
            }
          }
        g6.set(B6, S, M6, P6, A6);
      }
    }
  }
  return e.makeTensorInfo(g6.shape, g6.dtype, g6.values);
}
const fW = {
  kernelName: rh$1,
  backendName: "cpu",
  kernelFunc: pW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, filter: r } = t, { strides: i6, dilations: a, pad: l, dimRoundingMode: c, inputShape: u } = s;
  it([o, r], "depthwiseConv2DNativeBackpropInput");
  const d = dt(o.shape), h6 = dt(r.shape), p6 = ke(
    u,
    r.shape,
    i6,
    a,
    l,
    c,
    true
    /* depthwise */
  ), f = new $e(p6.inShape, "float32"), m = f.values, [g6, b6, x6] = f.strides, w6 = e.data.get(o.dataId).values, [y6, I, C6] = d, k7 = e.data.get(r.dataId).values, [S, N, R] = h6, { batchSize: M6, filterHeight: V, filterWidth: z, inChannels: X, inHeight: P6, inWidth: A6, outChannels: B6, outHeight: Z, outWidth: H6, strideHeight: Y, strideWidth: Q } = p6, j = V - 1 - p6.padInfo.top, J6 = z - 1 - p6.padInfo.left, nt = B6 / X;
  for (let q = 0; q < M6; ++q)
    for (let rt = 0; rt < X; ++rt)
      for (let ht = 0; ht < P6; ++ht) {
        const ft2 = ht - j, pt = Math.max(0, Math.ceil(ft2 / Y)), wt2 = Math.min(Z, (V + ft2) / Y);
        for (let It = 0; It < A6; ++It) {
          const Et = It - J6, Vt2 = Math.max(0, Math.ceil(Et / Q)), te = Math.min(H6, (z + Et) / Q);
          let zt = 0;
          for (let Wt2 = pt; Wt2 < wt2; ++Wt2) {
            const Qt = Wt2 * Y - ft2;
            for (let _t2 = Vt2; _t2 < te; ++_t2) {
              const as = _t2 * Q - Et, Ie = y6 * q + I * Wt2 + C6 * _t2, vs = S * (V - 1 - Qt) + N * (z - 1 - as) + R * rt;
              for (let on2 = 0; on2 < nt; ++on2) {
                const qs = rt * nt + on2, Ln2 = w6[Ie + qs], ls = k7[vs + on2];
                zt += Ln2 * ls;
              }
            }
          }
          m[g6 * q + b6 * ht + x6 * It + rt] = zt;
        }
      }
  return e.makeTensorInfo(f.shape, f.dtype, f.values);
}
const gW = {
  kernelName: ih$1,
  backendName: "cpu",
  kernelFunc: mW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bW(n) {
  const { inputs: t, backend: e } = n, { x: s } = t, o = O(s.shape), r = e.data.get(s.dataId).values, i6 = vt$1([o, o], s.dtype), a = i6.values;
  for (let c = 0; c < r.length; c++)
    a[c * o + c] = r[c];
  const l = [...s.shape, ...s.shape];
  return e.makeTensorInfo(l, i6.dtype, i6.values);
}
const xW = {
  kernelName: Zg$1,
  backendName: "cpu",
  kernelFunc: bW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yW = {
  kernelName: Jl,
  backendName: "cpu",
  kernelFunc: ({ inputs: n, backend: t, attrs: e }) => {
    const { x: s, filter: o } = n, { strides: r, pad: i6, dilations: a } = e, l = t, c = l.data.get(s.dataId).values, u = s.shape.length, d = l.data.get(o.dataId).values, h6 = o.shape.length, { batchSize: p6, inHeight: f, inWidth: m, inChannels: g6, outHeight: b6, outWidth: x6, padInfo: w6, strideHeight: y6, strideWidth: I, filterHeight: C6, filterWidth: k7, dilationHeight: S, dilationWidth: N, outShape: R } = ca(s.shape, o.shape, r, i6, "NHWC", a), M6 = O(R), V = R.length, z = oe(s.dtype, M6);
    for (let P6 = 0; P6 < p6; ++P6)
      for (let A6 = 0; A6 < b6; ++A6) {
        const B6 = A6 * y6 - w6.top;
        for (let Z = 0; Z < x6; ++Z) {
          const H6 = Z * I - w6.left;
          for (let Y = 0; Y < g6; ++Y) {
            let Q = Number.MIN_SAFE_INTEGER;
            for (let J6 = 0; J6 < C6; ++J6) {
              const nt = B6 + J6 * S;
              if (nt >= 0 && nt < f)
                for (let q = 0; q < k7; ++q) {
                  const rt = H6 + q * N;
                  if (rt >= 0 && rt < m) {
                    const ht = zn$1([P6, nt, rt, Y], u, dt(s.shape)), ft2 = zn$1([J6, q, Y], h6, dt(o.shape)), pt = c[ht] + d[ft2];
                    pt > Q && (Q = pt);
                  }
                }
            }
            const j = zn$1([P6, A6, Z, Y], V, dt(R));
            z[j] = Q;
          }
        }
      }
    return { dataId: l.write(Zs(z, s.dtype), R, s.dtype), shape: R, dtype: s.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wW = {
  kernelName: nd,
  backendName: "cpu",
  kernelFunc: ({ inputs: n, backend: t, attrs: e }) => {
    const { x: s, filter: o, dy: r } = n, { strides: i6, pad: a, dilations: l } = e, c = t, u = Sn$1(s.shape, c.data.get(s.dataId).values), d = Sn$1(o.shape, c.data.get(o.dataId).values), { batchSize: h6, inHeight: p6, inWidth: f, inChannels: m, outHeight: g6, outWidth: b6, padInfo: x6, strideHeight: w6, strideWidth: y6, filterHeight: I, filterWidth: C6, dilationHeight: k7, dilationWidth: S, outShape: N } = ca(s.shape, o.shape, i6, a, "NHWC", l);
    v(r.rank === N.length, () => `Error in ${nd}, dy must have the same rank as output ${N.length}, but got ${r.rank}`);
    const R = Sn$1(N, c.data.get(r.dataId).values), M6 = Kd$1(o.shape, o.dtype);
    for (let z = 0; z < h6; ++z)
      for (let X = 0; X < g6; ++X) {
        const P6 = X * w6 - x6.top;
        for (let A6 = 0; A6 < b6; ++A6) {
          const B6 = A6 * y6 - x6.left;
          for (let Z = 0; Z < m; ++Z) {
            let H6 = Number.MIN_SAFE_INTEGER, Y = 0, Q = 0;
            for (let j = 0; j < I; ++j) {
              const J6 = P6 + j * k7;
              if (J6 >= 0 && J6 < p6)
                for (let nt = 0; nt < C6; ++nt) {
                  const q = B6 + nt * S;
                  if (q >= 0 && q < f) {
                    const rt = u[z][J6][q][Z] + d[j][nt][Z];
                    rt > H6 && (H6 = rt, Y = j, Q = nt);
                  }
                }
            }
            M6[Y][Q][Z] += R[z][X][A6][Z];
          }
        }
      }
    return { dataId: c.write(Zs(M6, s.dtype), o.shape, o.dtype), shape: o.shape, dtype: o.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IW = {
  kernelName: ed,
  backendName: "cpu",
  kernelFunc: ({ inputs: n, backend: t, attrs: e }) => {
    const { x: s, filter: o, dy: r } = n, { strides: i6, pad: a, dilations: l } = e, c = t, u = Sn$1(s.shape, c.data.get(s.dataId).values), d = Sn$1(o.shape, c.data.get(o.dataId).values), { batchSize: h6, inHeight: p6, inWidth: f, inChannels: m, outHeight: g6, outWidth: b6, padInfo: x6, strideHeight: w6, strideWidth: y6, filterHeight: I, filterWidth: C6, dilationHeight: k7, dilationWidth: S, outShape: N } = ca(s.shape, o.shape, i6, a, "NHWC", l);
    v(r.rank === N.length, () => `Error in ${ed}, dy must have the same rank as output ${N.length}, but got ${r.rank}`);
    const R = Sn$1(N, c.data.get(r.dataId).values), M6 = Kd$1(s.shape, s.dtype);
    for (let z = 0; z < h6; ++z)
      for (let X = 0; X < g6; ++X) {
        const P6 = X * w6 - x6.top;
        for (let A6 = 0; A6 < b6; ++A6) {
          const B6 = A6 * y6 - x6.left;
          for (let Z = 0; Z < m; ++Z) {
            let H6 = Number.MIN_SAFE_INTEGER, Y = P6 < 0 ? 0 : P6, Q = B6 < 0 ? 0 : B6;
            for (let j = 0; j < I; ++j) {
              const J6 = P6 + j * k7;
              if (J6 >= 0 && J6 < p6)
                for (let nt = 0; nt < C6; ++nt) {
                  const q = B6 + nt * S;
                  if (q >= 0 && q < f) {
                    const rt = u[z][J6][q][Z] + d[j][nt][Z];
                    rt > H6 && (H6 = rt, Y = J6, Q = q);
                  }
                }
            }
            M6[z][Y][Q][Z] += R[z][X][A6][Z];
          }
        }
      }
    return { dataId: c.write(Zs(M6, s.dtype), s.shape, s.dtype), shape: s.shape, dtype: s.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ka(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s;
  it(o, "sum");
  let a;
  o.dtype === "bool" ? a = Ks({ inputs: { x: o }, backend: e, attrs: { dtype: "int32" } }) : a = rs({ inputs: { x: o }, backend: e });
  const l = a.shape.length, c = Ct(r, a.shape), u = qt$1(c, l);
  let d = c, h6 = a;
  u != null && (h6 = Ze({ inputs: { x: a }, backend: e, attrs: { perm: u } }), d = ie(d.length, l)), Te("sum", d, h6.shape.length);
  const [p6, f] = ye$1(h6.shape, d), m = je$1(h6.dtype, "int32");
  let g6 = Sl(e, p6, m);
  const b6 = O(f), x6 = e.data.get(g6.dataId).values, w6 = e.data.get(h6.dataId).values;
  for (let y6 = 0; y6 < x6.length; ++y6) {
    const I = y6 * b6;
    let C6 = 0;
    for (let k7 = 0; k7 < b6; ++k7)
      C6 += w6[I + k7];
    x6[y6] = C6;
  }
  if (i6) {
    const y6 = re$1(g6.shape, c), I = g6;
    g6 = Ot$1({ inputs: { x: g6 }, backend: e, attrs: { shape: y6 } }), e.disposeIntermediateTensorInfo(I);
  }
  return e.disposeIntermediateTensorInfo(a), u != null && e.disposeIntermediateTensorInfo(h6), g6;
}
const CW = {
  kernelName: Gc,
  backendName: "cpu",
  kernelFunc: ka
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { equation: o } = s, r = t, { allDims: i6, summedDims: a, idDims: l } = Yp(o, r.length);
  Jp(i6.length, l, r);
  const { path: c, steps: u } = jp(a, l), d = u.length;
  let h6 = null, p6 = i6.length;
  const f = [];
  for (let m = 0; m < d; ++m) {
    for (const g6 of u[m]) {
      const { permutationIndices: b6, expandDims: x6 } = Qp(p6, l[g6]);
      let w6;
      qp(b6) ? w6 = r[g6] : (w6 = Ze({ inputs: { x: r[g6] }, backend: e, attrs: { perm: b6 } }), f.push(w6));
      const y6 = w6.shape.slice();
      for (let I = 0; I < x6.length; ++I)
        y6.splice(x6[I], 0, 1);
      Rt$1(w6.shape, y6) || (w6 = Ot$1({ inputs: { x: w6 }, backend: e, attrs: { shape: y6 } }), f.push(w6)), h6 === null ? h6 = w6 : (h6 = uu({ inputs: { a: w6, b: h6 }, backend: e }), f.push(h6));
    }
    m < d - 1 && (c[m] >= 0 && (h6 = ka({
      inputs: { x: h6 },
      backend: e,
      attrs: {
        axis: c[m] - (i6.length - p6),
        keepDims: false
      }
    }), f.push(h6)), p6--);
  }
  for (const m of f)
    m !== h6 && e.disposeIntermediateTensorInfo(m);
  return h6;
}
const SW = {
  kernelName: Bg$1,
  backendName: "cpu",
  kernelFunc: vW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kW(n) {
  const { inputs: t, backend: e } = n, { dy: s, y: o } = t;
  it([s, o], "eluGrad");
  const r = new Float32Array(O(o.shape)), i6 = e.data.get(o.dataId).values, a = e.data.get(s.dataId).values;
  for (let l = 0; l < i6.length; ++l) {
    const c = i6[l];
    c >= 1 ? r[l] = a[l] : r[l] = a[l] * (c + 1);
  }
  return e.makeTensorInfo(o.shape, "float32", r);
}
const TW = {
  kernelName: ah$1,
  backendName: "cpu",
  kernelFunc: kW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NW = Op, RW = Kp, $W = Zp, GW = Bp, EW = Hp, LW = _p, MW = Mt(ki, (n) => {
  const t = Math.sign(n), e = Math.abs(n), s = 1 / (1 + NW * e);
  return t * (1 - ((((LW * s + EW) * s + GW) * s + $W) * s + RW) * s * Math.exp(-e * e));
}), WW = {
  kernelName: ki,
  backendName: "cpu",
  kernelFunc: MW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Nl(n) {
  const { inputs: t, backend: e, attrs: s } = n, { input: o } = t, { dim: r } = s, i6 = o.shape.length, a = o.shape.slice();
  let l = r;
  return r < 0 && (v(-(i6 + 1) <= r, () => `Axis must be in the interval [${-(i6 + 1)}, ${i6}]`), l = i6 + r + 1), a.splice(l, 0, 1), Ot$1({ inputs: { x: o }, backend: e, attrs: { shape: a } });
}
const DW = {
  kernelName: ql,
  backendName: "cpu",
  kernelFunc: Nl
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const FW = ce((n, t) => n / t), Wf$1 = we(vi, FW), Ed$1 = {
  kernelName: vi,
  backendName: "cpu",
  kernelFunc: Wf$1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gw(n, t, e) {
  const s = n.shape, o = s[0], r = s[1], i6 = e.data.get(n.dataId), a = i6.complexTensorInfos.real, l = i6.complexTensorInfos.imag, c = [o, r], u = O(c), d = xe$1("float32", u), h6 = xe$1("float32", u);
  for (let g6 = 0; g6 < o; g6++) {
    const b6 = Go({
      inputs: { x: a },
      backend: e,
      attrs: { begin: [g6, 0], size: [1, r] }
    }), x6 = Go({
      inputs: { x: l },
      backend: e,
      attrs: { begin: [g6, 0], size: [1, r] }
    }), w6 = Ye({ inputs: { real: b6, imag: x6 }, backend: e }), { real: y6, imag: I } = VW(w6, t, e), C6 = ms(y6, I);
    for (let k7 = 0; k7 < r; k7++) {
      const S = Up(C6, k7);
      d[g6 * r + k7] = S.real, h6[g6 * r + k7] = S.imag;
    }
    e.disposeIntermediateTensorInfo(b6), e.disposeIntermediateTensorInfo(x6), e.disposeIntermediateTensorInfo(w6);
  }
  const p6 = e.makeTensorInfo(c, "float32", d), f = e.makeTensorInfo(c, "float32", h6), m = Ye({ inputs: { real: p6, imag: f }, backend: e });
  return e.disposeIntermediateTensorInfo(p6), e.disposeIntermediateTensorInfo(f), m;
}
function VW(n, t, e) {
  const s = O(n.shape), o = e.data.get(n.dataId), r = e.data.get(o.complexTensorInfos.real.dataId).values, i6 = e.data.get(o.complexTensorInfos.imag.dataId).values;
  if (zW(s)) {
    const a = Ld$1(r, i6, s, t, e), l = [n.shape[0], n.shape[1]];
    if (t) {
      const c = e.makeTensorInfo(l, "float32", a.real), u = e.makeTensorInfo(l, "float32", a.imag), d = e.makeTensorInfo([], "float32", bs(s, "float32")), h6 = rs({ inputs: { x: d }, backend: e }), p6 = Ed$1.kernelFunc({ inputs: { a: c, b: d }, backend: e }), f = Ed$1.kernelFunc({ inputs: { a: u, b: h6 }, backend: e }), m = e.data.get(p6.dataId).values, g6 = e.data.get(f.dataId).values;
      return e.disposeIntermediateTensorInfo(c), e.disposeIntermediateTensorInfo(u), e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(h6), e.disposeIntermediateTensorInfo(p6), e.disposeIntermediateTensorInfo(f), { real: m, imag: g6 };
    }
    return a;
  } else {
    const a = ms(r, i6), l = XW(a, s, t);
    return G0(l);
  }
}
function zW(n) {
  return (n & n - 1) === 0;
}
function Ld$1(n, t, e, s, o) {
  if (e === 1)
    return { real: n, imag: t };
  const r = ms(n, t), i6 = e / 2, a = E0(r), l = a.real, c = a.imag, u = [l.length], d = o.makeTensorInfo(u, "float32", l), h6 = o.makeTensorInfo(u, "float32", c), p6 = Ye({ inputs: { real: d, imag: h6 }, backend: o }), f = L0(r), m = f.real, g6 = f.imag, b6 = [m.length], x6 = o.makeTensorInfo(b6, "float32", m), w6 = o.makeTensorInfo(b6, "float32", g6), y6 = Ye({ inputs: { real: x6, imag: w6 }, backend: o }), I = Ld$1(l, c, i6, s, o), C6 = I.real, k7 = I.imag, S = [C6.length], N = o.makeTensorInfo(S, "float32", C6), R = o.makeTensorInfo(S, "float32", k7), M6 = Ye({
    inputs: { real: N, imag: R },
    backend: o
  }), V = Ld$1(m, g6, i6, s, o), z = V.real, X = V.imag, P6 = [z.length], A6 = o.makeTensorInfo(P6, "float32", z), B6 = o.makeTensorInfo(P6, "float32", X), Z = Ye({ inputs: { real: A6, imag: B6 }, backend: o }), H6 = W0(e, s), Y = [H6.real.length], Q = o.makeTensorInfo(Y, "float32", H6.real), j = o.makeTensorInfo(Y, "float32", H6.imag), J6 = Ye({ inputs: { real: Q, imag: j }, backend: o }), nt = uu({ inputs: { a: J6, b: Z }, backend: o }), q = cr({
    inputs: { a: M6, b: nt },
    backend: o
  }), rt = Lf$1({
    inputs: { a: M6, b: nt },
    backend: o
  }), ht = $o({ inputs: { input: q }, backend: o }), ft2 = $o({ inputs: { input: rt }, backend: o }), pt = ur({ inputs: { input: q }, backend: o }), wt2 = ur({ inputs: { input: rt }, backend: o }), It = dr({
    inputs: [ht, ft2],
    backend: o,
    attrs: { axis: 0 }
  }), Et = dr({
    inputs: [pt, wt2],
    backend: o,
    attrs: { axis: 0 }
  }), Vt2 = o.data.get(It.dataId).values, te = o.data.get(Et.dataId).values;
  return o.disposeIntermediateTensorInfo(d), o.disposeIntermediateTensorInfo(h6), o.disposeIntermediateTensorInfo(p6), o.disposeIntermediateTensorInfo(x6), o.disposeIntermediateTensorInfo(w6), o.disposeIntermediateTensorInfo(y6), o.disposeIntermediateTensorInfo(N), o.disposeIntermediateTensorInfo(R), o.disposeIntermediateTensorInfo(M6), o.disposeIntermediateTensorInfo(A6), o.disposeIntermediateTensorInfo(B6), o.disposeIntermediateTensorInfo(Z), o.disposeIntermediateTensorInfo(Q), o.disposeIntermediateTensorInfo(j), o.disposeIntermediateTensorInfo(J6), o.disposeIntermediateTensorInfo(nt), o.disposeIntermediateTensorInfo(q), o.disposeIntermediateTensorInfo(rt), o.disposeIntermediateTensorInfo(ht), o.disposeIntermediateTensorInfo(pt), o.disposeIntermediateTensorInfo(ft2), o.disposeIntermediateTensorInfo(wt2), o.disposeIntermediateTensorInfo(It), o.disposeIntermediateTensorInfo(Et), { real: Vt2, imag: te };
}
function XW(n, t, e) {
  const s = new Float32Array(t * 2);
  for (let o = 0; o < t; o++) {
    let r = 0, i6 = 0;
    for (let a = 0; a < t; a++) {
      const l = D0(o * a, t, e), c = Up(n, a);
      r += c.real * l.real - c.imag * l.imag, i6 += c.real * l.imag + c.imag * l.real;
    }
    e && (r /= t, i6 /= t), M0(s, r, i6, o);
  }
  return s;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PW(n) {
  const { inputs: t, backend: e } = n, { input: s } = t, o = O(s.shape), r = s.shape[s.shape.length - 1], i6 = o / r, a = Ot$1({
    inputs: { x: s },
    backend: e,
    attrs: { shape: [i6, r] }
  }), l = gw(a, false, e), c = Ot$1({ inputs: { x: l }, backend: e, attrs: { shape: s.shape } });
  return e.disposeIntermediateTensorInfo(a), e.disposeIntermediateTensorInfo(l), c;
}
const AW = {
  kernelName: lh$1,
  backendName: "cpu",
  kernelFunc: PW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Df$1(n) {
  const { backend: t, attrs: e } = n, { shape: s, value: o, dtype: r } = e, i6 = r || gr(o), a = oe(i6, O(s));
  return KW(a, o), t.makeTensorInfo(s, i6, a);
}
const OW = {
  kernelName: ch$1,
  backendName: "cpu",
  kernelFunc: Df$1
};
function KW(n, t, e) {
  n.fill(t);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ZW = {
  kernelName: uh$1,
  backendName: "cpu",
  kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
    const { image: s } = n, o = e, r = xe$1(s.dtype, O(s.shape)), [i6, a, l, c] = s.shape, u = o.data.get(s.dataId).values;
    for (let h6 = 0; h6 < i6; h6++) {
      const p6 = h6 * l * a * c;
      for (let f = 0; f < a; f++) {
        const m = f * (l * c);
        for (let g6 = 0; g6 < l; g6++) {
          const b6 = g6 * c;
          for (let x6 = 0; x6 < c; x6++) {
            const w6 = Math.round(l - g6 - 1), y6 = p6 + m + b6 + x6;
            let I = u[y6];
            if (w6 >= 0 && w6 < l) {
              const C6 = w6 * c, k7 = p6 + m + C6 + x6;
              I = u[k7];
            }
            r[y6] = I;
          }
        }
      }
    }
    return { dataId: o.write(r, s.shape, s.dtype), shape: s.shape, dtype: s.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BW = ce((n, t) => Math.floor(n / t)), HW = we($i, BW, null, "int32"), _W = {
  kernelName: $i,
  backendName: "cpu",
  kernelFunc: HW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r, bias: i6, preluActivationWeights: a } = t, { strides: l, pad: c, dataFormat: u, dilations: d, dimRoundingMode: h6, activation: p6, leakyreluAlpha: f } = s;
  let m = fw({
    inputs: { x: o, filter: r },
    backend: e,
    attrs: { strides: l, pad: c, dataFormat: u, dilations: d, dimRoundingMode: h6 }
  });
  if (i6) {
    const g6 = m;
    if (u === "NCHW" && i6.shape.length === 1 && i6.shape[0] !== 1) {
      const b6 = Ot$1({ inputs: { x: i6 }, backend: e, attrs: { shape: [i6.shape[0], 1, 1] } });
      m = cr({ inputs: { a: m, b: b6 }, backend: e }), e.disposeIntermediateTensorInfo(b6);
    } else
      m = cr({ inputs: { a: m, b: i6 }, backend: e });
    e.disposeIntermediateTensorInfo(g6);
  }
  if (p6) {
    const g6 = m;
    if (u === "NCHW" && p6 === "prelu" && a.shape.length === 1 && a.shape[0] !== 1) {
      const b6 = Ot$1({
        inputs: { x: a },
        backend: e,
        attrs: { shape: [a.shape[0], 1, 1] }
      });
      m = Tl(e, m, p6, b6, f), e.disposeIntermediateTensorInfo(b6);
    } else
      m = Tl(e, m, p6, a, f);
    e.disposeIntermediateTensorInfo(g6);
  }
  return m;
}
const YW = {
  kernelName: rl,
  backendName: "cpu",
  kernelFunc: UW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QW(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r, bias: i6, preluActivationWeights: a } = t, { strides: l, pad: c, dataFormat: u, dilations: d, dimRoundingMode: h6, activation: p6, leakyreluAlpha: f } = s;
  let m = mw({
    inputs: { x: o, filter: r },
    backend: e,
    attrs: { strides: l, pad: c, dataFormat: u, dilations: d, dimRoundingMode: h6 }
  });
  if (i6) {
    const g6 = m;
    m = cr({ inputs: { a: m, b: i6 }, backend: e }), e.disposeIntermediateTensorInfo(g6);
  }
  if (p6) {
    const g6 = m;
    m = Tl(e, m, p6, a, f), e.disposeIntermediateTensorInfo(g6);
  }
  return m;
}
const JW = {
  kernelName: nb$1,
  backendName: "cpu",
  kernelFunc: QW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jW(n) {
  const { inputs: t, backend: e } = n, { params: s, indices: o } = t, r = O(s.shape), i6 = o.shape, a = i6[i6.length - 1], [l, c, u, d] = Bc(s, o);
  if (c === 0)
    return e.makeTensorInfo(l, s.dtype, []);
  const h6 = e.data.get(o.dataId).values, p6 = e.bufferSync(s), f = N1(h6, p6, s.dtype, c, a, u, d, s.shape, r);
  return e.makeTensorInfo(l, s.dtype, f.values);
}
const qW = {
  kernelName: Hg$1,
  backendName: "cpu",
  kernelFunc: jW
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, indices: r } = t, { axis: i6, batchDims: a } = s;
  it([o, r], "gatherV2");
  const l = Ct(i6, o.shape)[0], c = e.data.get(r.dataId).values, u = o.shape[l];
  for (let y6 = 0; y6 < c.length; ++y6) {
    const I = c[y6];
    v(I <= u - 1 && I >= 0, () => `GatherV2: the index value ${I} is not in [0, ${u - 1}]`);
  }
  let d = a;
  a == null && (d = 0);
  const h6 = O(r.shape), p6 = ef$1(o, r, l, d), f = Ot$1({
    inputs: { x: o },
    backend: e,
    attrs: {
      shape: [
        p6.batchSize,
        p6.outerSize,
        p6.dimSize,
        p6.sliceSize
      ]
    }
  }), m = Ot$1({
    inputs: { x: r },
    backend: e,
    attrs: { shape: [p6.batchSize, h6 / p6.batchSize] }
  }), g6 = [
    p6.batchSize,
    p6.outerSize,
    h6 / p6.batchSize,
    p6.sliceSize
  ], b6 = e.bufferSync(m), x6 = e.bufferSync(f), w6 = R1(x6, b6, g6);
  return e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(m), e.makeTensorInfo(p6.outputShape, w6.dtype, w6.values);
}
const eD = {
  kernelName: ec,
  backendName: "cpu",
  kernelFunc: tD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nD(n) {
  const { inputs: t, backend: e } = n, { input: s } = t, o = O(s.shape), r = s.shape[s.shape.length - 1], i6 = o / r, a = Ot$1({
    inputs: { x: s },
    backend: e,
    attrs: { shape: [i6, r] }
  }), l = gw(a, true, e), c = Ot$1({ inputs: { x: l }, backend: e, attrs: { shape: s.shape } });
  return e.disposeIntermediateTensorInfo(a), e.disposeIntermediateTensorInfo(l), c;
}
const sD = {
  kernelName: dh$1,
  backendName: "cpu",
  kernelFunc: nD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oD = Mt(Li, (n) => Number.isFinite(n) ? 1 : 0, "bool"), rD = {
  kernelName: Li,
  backendName: "cpu",
  kernelFunc: oD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iD = Mt(Mi, (n) => Math.abs(n) === 1 / 0 ? 1 : 0, "bool"), aD = {
  kernelName: Mi,
  backendName: "cpu",
  kernelFunc: iD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lD = Mt(Wi, (n) => Number.isNaN(n) ? 1 : 0, "bool"), cD = {
  kernelName: Wi,
  backendName: "cpu",
  kernelFunc: lD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uD(n) {
  const { backend: t, attrs: e } = n, { start: s, stop: o, num: r } = e, i6 = M1(s, o, r);
  return t.makeTensorInfo([i6.length], "float32", i6);
}
const dD = {
  kernelName: _g$1,
  backendName: "cpu",
  kernelFunc: uD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hD = Mt(Fi, (n) => Math.log1p(n)), pD = {
  kernelName: Fi,
  backendName: "cpu",
  kernelFunc: hD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fD = ce((n, t) => n && t), mD = we(ic, fD, null, "bool"), gD = {
  kernelName: ic,
  backendName: "cpu",
  kernelFunc: mD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bD = Mt(ac, (n) => n ? 0 : 1, "bool"), xD = {
  kernelName: ac,
  backendName: "cpu",
  kernelFunc: bD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yD = ce((n, t) => n || t), wD = we(lc, yD, null, "bool"), ID = {
  kernelName: lc,
  backendName: "cpu",
  kernelFunc: wD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function CD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { depthRadius: r, bias: i6, alpha: a, beta: l } = s;
  it(o, "LRN");
  const c = o.shape[3], u = c - 1, d = e.data.get(o.dataId).values, h6 = O(o.shape), p6 = new Float32Array(h6);
  function f(m) {
    const g6 = m % c;
    let b6 = m - g6 + Math.max(0, g6 - r);
    const x6 = m - g6 + Math.min(g6 + r, u);
    let w6 = 0;
    for (; b6 <= x6; b6++) {
      const y6 = d[b6];
      w6 += y6 * y6;
    }
    return w6;
  }
  for (let m = 0; m < h6; m++) {
    const g6 = f(m), b6 = d[m] * Math.pow(i6 + a * g6, -l);
    p6[m] = b6;
  }
  return e.makeTensorInfo(o.shape, o.dtype, p6);
}
const vD = {
  kernelName: cc,
  backendName: "cpu",
  kernelFunc: CD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, y: r, dy: i6 } = t, { depthRadius: a, bias: l, alpha: c, beta: u } = s;
  it(i6, "LRNGrad");
  const d = O(i6.shape), h6 = i6.shape[3], p6 = e.data.get(i6.dataId).values, f = e.data.get(o.dataId).values, m = e.data.get(r.dataId).values, g6 = new Float32Array(d), b6 = d;
  for (let x6 = 0; x6 < b6; x6++) {
    const w6 = x6 % h6, y6 = x6 - w6 + Math.max(0, w6 - a), I = x6 - w6 + Math.min(h6, w6 + a + 1);
    let C6 = 0;
    for (let k7 = y6; k7 < I; k7++)
      C6 += Math.pow(f[k7], 2);
    C6 = c * C6 + l;
    for (let k7 = y6; k7 < I; k7++) {
      let S = -2 * c * u * f[k7] * m[x6] / C6;
      x6 === k7 && (S += Math.pow(C6, -u)), S *= p6[x6], g6[k7] += S;
    }
  }
  return e.makeTensorInfo(i6.shape, o.dtype, g6);
}
const kD = {
  kernelName: ph$1,
  backendName: "cpu",
  kernelFunc: SD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bw(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { reductionIndices: r, keepDims: i6 } = s, a = e;
  let l = o.shape;
  const c = l.length, u = Ct(r, l);
  let d = u;
  const h6 = qt$1(d, c);
  let p6 = a.data.get(o.dataId).values;
  if (h6 != null) {
    const y6 = new Array(c);
    for (let I = 0; I < y6.length; I++)
      y6[I] = l[h6[I]];
    p6 = Gf$1(p6, l, o.dtype, h6, y6), d = ie(d.length, c), l = y6;
  }
  it(o, "max"), Te("max", d, c);
  const [f, m] = ye$1(l, d), g6 = O(m), b6 = D1(p6, g6, f, o.dtype), x6 = a.write(b6, f, o.dtype);
  let w6 = f;
  return i6 && (w6 = re$1(f, u)), { dataId: x6, shape: w6, dtype: o.dtype };
}
const TD = {
  kernelName: uc,
  backendName: "cpu",
  kernelFunc: bw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ND(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t;
  it(o, "maxPool");
  const { filterSize: r, strides: i6, pad: a, dimRoundingMode: l } = s, c = 1;
  v(Ee$1(i6, c), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i6} and dilations '${c}'`);
  const u = $n$1(o.shape, r, i6, c, a, l);
  let d;
  if (u.filterWidth === 1 && u.filterHeight === 1 && Rt$1(u.inShape, u.outShape))
    d = rs({ inputs: { x: o }, backend: e });
  else {
    const h6 = e.data.get(o.dataId).values, p6 = dt(o.shape), f = Mf$1(h6, o.shape, o.dtype, p6, u, "max");
    d = e.makeTensorInfo(u.outShape, o.dtype, f.values);
  }
  return d;
}
const RD = {
  kernelName: dc,
  backendName: "cpu",
  kernelFunc: ND
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $D(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { filterSize: r, strides: i6, pad: a, dimRoundingMode: l, dataFormat: c } = s;
  it(o, "maxPool3d");
  const u = xs(o.shape, r, i6, 1, a, l, c), d = e.data.get(o.dataId).values, h6 = pw(d, o.shape, o.dtype, dt(o.shape), u, "max");
  return e.makeTensorInfo(h6.shape, "float32", h6.values);
}
const GD = {
  kernelName: hc,
  backendName: "cpu",
  kernelFunc: $D
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ED(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, input: r } = t, { filterSize: i6, strides: a, pad: l, dimRoundingMode: c } = s;
  it([o, r], "maxPool3DGrad");
  const u = xs(r.shape, i6, a, 1, l, c), d = e.bufferSync(r), h6 = xM(d, u), p6 = u.strideDepth, f = u.strideHeight, m = u.strideWidth, g6 = u.dilationDepth, b6 = u.dilationHeight, x6 = u.dilationWidth, w6 = u.effectiveFilterDepth, y6 = u.effectiveFilterHeight, I = u.effectiveFilterWidth, C6 = w6 - 1 - u.padInfo.front, k7 = I - 1 - u.padInfo.left, S = y6 - 1 - u.padInfo.top, N = vt$1(r.shape, "float32"), R = e.bufferSync(o);
  for (let M6 = 0; M6 < u.batchSize; ++M6)
    for (let V = 0; V < u.inChannels; ++V)
      for (let z = 0; z < u.inDepth; ++z)
        for (let X = 0; X < u.inHeight; ++X)
          for (let P6 = 0; P6 < u.inWidth; ++P6) {
            const A6 = z - C6, B6 = X - S, Z = P6 - k7;
            let H6 = 0;
            for (let Y = 0; Y < w6; Y += g6) {
              const Q = (A6 + Y) / p6;
              if (!(Q < 0 || Q >= u.outDepth || Math.floor(Q) !== Q))
                for (let j = 0; j < y6; j += b6) {
                  const J6 = (B6 + j) / f;
                  if (!(J6 < 0 || J6 >= u.outHeight || Math.floor(J6) !== J6))
                    for (let nt = 0; nt < I; nt += x6) {
                      const q = (Z + nt) / m;
                      if (q < 0 || q >= u.outWidth || Math.floor(q) !== q)
                        continue;
                      const rt = w6 * y6 * I - 1 - h6.get(M6, Q, J6, q, V), ht = Y * y6 * I + j * I + nt, ft2 = rt === ht ? 1 : 0;
                      if (ft2 === 0)
                        continue;
                      const pt = R.get(M6, Q, J6, q, V);
                      H6 += pt * ft2;
                    }
                }
            }
            N.set(H6, M6, z, X, P6, V);
          }
  return e.makeTensorInfo(N.shape, N.dtype, N.values);
}
const LD = {
  kernelName: mh$1,
  backendName: "cpu",
  kernelFunc: ED
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, input: r, output: i6 } = t, a = r;
  it([r, i6], "maxPoolGrad");
  const { filterSize: l, strides: c, pad: u, dimRoundingMode: d } = s, h6 = $n$1(a.shape, l, c, 1, u, d), p6 = e.data.get(a.dataId).values, f = vt$1(h6.outShape, a.dtype, hw(p6, a.shape, a.dtype, h6).values), m = h6.strideHeight, g6 = h6.strideWidth, b6 = h6.dilationHeight, x6 = h6.dilationWidth, w6 = h6.effectiveFilterHeight, y6 = h6.effectiveFilterWidth, I = y6 - 1 - h6.padInfo.left, C6 = w6 - 1 - h6.padInfo.top, k7 = vt$1(a.shape, "float32"), S = e.data.get(o.dataId).values, N = vt$1(o.shape, "float32", S);
  for (let R = 0; R < h6.batchSize; ++R)
    for (let M6 = 0; M6 < h6.inChannels; ++M6)
      for (let V = 0; V < h6.inHeight; ++V)
        for (let z = 0; z < h6.inWidth; ++z) {
          const X = V - C6, P6 = z - I;
          let A6 = 0;
          for (let B6 = 0; B6 < w6; B6 += b6) {
            const Z = (X + B6) / m;
            if (!(Z < 0 || Z >= h6.outHeight || Math.floor(Z) !== Z))
              for (let H6 = 0; H6 < y6; H6 += x6) {
                const Y = (P6 + H6) / g6;
                if (Y < 0 || Y >= h6.outWidth || Math.floor(Y) !== Y)
                  continue;
                const Q = w6 * y6 - 1 - f.get(R, Z, Y, M6), j = B6 * y6 + H6, J6 = Q === j ? 1 : 0;
                if (J6 === 0)
                  continue;
                const nt = N.get(R, Z, Y, M6);
                A6 += nt * J6;
              }
          }
          k7.set(A6, R, V, z, M6);
        }
  return e.makeTensorInfo(k7.shape, k7.dtype, k7.values);
}
const WD = {
  kernelName: fh$1,
  backendName: "cpu",
  kernelFunc: MD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DD(n, t, e, s, o) {
  const r = dt(t), i6 = Mf$1(n, t, e, r, o, "max"), a = hw(n, t, e, o, true, s);
  return [i6.values, a.values];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const FD = {
  kernelName: Ug$1,
  backendName: "cpu",
  kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
    const { x: s } = n, { filterSize: o, strides: r, pad: i6, includeBatchInIndex: a } = t, l = e;
    it(s, "MaxPoolWithArgmax");
    const c = l.data.get(s.dataId).values, u = $n$1(s.shape, o, r, [1, 1], i6), [d, h6] = DD(c, s.shape, s.dtype, a, u), p6 = l.write(d, u.outShape, s.dtype), f = l.write(h6, u.outShape, s.dtype);
    return [
      { dataId: p6, shape: u.outShape, dtype: s.dtype },
      { dataId: f, shape: u.outShape, dtype: "int32" }
    ];
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s, a = Ct(r, o.shape), c = ye$1(o.shape, a)[1], u = O(c), d = [], h6 = e.makeTensorInfo([], "float32", new Float32Array([u]));
  d.push(h6);
  const p6 = Ks({ inputs: { x: o }, backend: e, attrs: { dtype: "float32" } });
  d.push(p6);
  const f = Wf$1({ inputs: { a: p6, b: h6 }, backend: e });
  d.push(f);
  const m = ka({ inputs: { x: f }, backend: e, attrs: { axis: r, keepDims: i6 } });
  return d.forEach((g6) => e.disposeIntermediateTensorInfo(g6)), m;
}
const zD = {
  kernelName: pc,
  backendName: "cpu",
  kernelFunc: VD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function XD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s;
  it(o, "min");
  const a = Ct(r, o.shape);
  let l = a;
  const c = qt$1(l, o.shape.length);
  let u = o;
  c != null && (u = Ze({ inputs: { x: o }, backend: e, attrs: { perm: c } }), l = ie(l.length, o.shape.length)), Te("min", l, u.shape.length);
  const [d, h6] = ye$1(u.shape, l), p6 = O(h6), f = Se(O(d), u.dtype), m = e.data.get(u.dataId).values;
  for (let b6 = 0; b6 < f.length; ++b6) {
    const x6 = b6 * p6;
    let w6 = m[x6];
    for (let y6 = 0; y6 < p6; ++y6) {
      const I = m[x6 + y6];
      (Number.isNaN(I) || I < w6) && (w6 = I);
    }
    f[b6] = w6;
  }
  c != null && e.disposeIntermediateTensorInfo(u);
  const g6 = e.makeTensorInfo(d, u.dtype, f);
  if (i6) {
    const b6 = re$1(d, a), x6 = Ot$1({ inputs: { x: g6 }, backend: e, attrs: { shape: b6 } });
    return e.disposeIntermediateTensorInfo(g6), x6;
  }
  return g6;
}
const PD = {
  kernelName: fc,
  backendName: "cpu",
  kernelFunc: XD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { paddings: r, mode: i6 } = s;
  it(o, "mirrorPad");
  const a = r.map(
    (w6, y6) => w6[0] + o.shape[y6] + w6[1]
    /* afterPad */
  ), l = r.map((w6) => w6[0]), c = r.map((w6, y6) => w6[0] + o.shape[y6]), u = i6 === "reflect" ? 0 : 1, d = e.data.get(o.dataId).values, h6 = o.shape.length, p6 = dt(o.shape), f = O(a), m = a.length, g6 = dt(a), b6 = xe$1(o.dtype, f);
  for (let w6 = 0; w6 < f; w6++) {
    let y6 = Mo(w6, m, g6);
    for (let C6 = 0; C6 < m; C6++)
      y6[C6] < l[C6] ? y6[C6] = l[C6] * 2 - y6[C6] - u : y6[C6] >= c[C6] && (y6[C6] = (c[C6] - 1) * 2 - y6[C6] + u);
    y6 = y6.map((C6, k7) => C6 - l[k7]);
    const I = zn$1(y6, h6, p6);
    b6[w6] = d[I];
  }
  return { dataId: e.write(b6, a, o.dtype), shape: a, dtype: o.dtype };
}
const OD = {
  kernelName: mc,
  backendName: "cpu",
  kernelFunc: AD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KD = ce((n, t) => {
  const e = n % t;
  return n < 0 && t < 0 || n >= 0 && t >= 0 ? e : (e + t) % t;
}), ZD = we(Xi, KD), BD = {
  kernelName: Xi,
  backendName: "cpu",
  kernelFunc: ZD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xw(n) {
  const { inputs: t, backend: e, attrs: s } = n, { logits: o } = t, { dim: r } = s, i6 = o.shape.length;
  let a = r;
  if (a === -1 && (a = i6 - 1), a !== i6 - 1)
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i6} and dim was ${a}`);
  const l = Ct([a], o.shape), c = bw({
    inputs: { x: o },
    backend: e,
    attrs: { reductionIndices: l, keepDims: false }
  }), u = re$1(c.shape, l), d = Ot$1({ inputs: { x: c }, backend: e, attrs: { shape: u } }), h6 = Lf$1({ inputs: { a: o, b: d }, backend: e }), p6 = S1({ inputs: { x: h6 }, backend: e }), f = ka({ inputs: { x: p6 }, backend: e, attrs: { axis: l, keepDims: false } }), m = Ot$1({ inputs: { x: f }, backend: e, attrs: { shape: u } }), g6 = Wf$1({ inputs: { a: p6, b: m }, backend: e });
  return e.disposeIntermediateTensorInfo(c), e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(h6), e.disposeIntermediateTensorInfo(p6), e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(m), g6;
}
const HD = {
  kernelName: Mc,
  backendName: "cpu",
  kernelFunc: xw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _D(n) {
  const { inputs: t, backend: e, attrs: s } = n, { logits: o } = t, { numSamples: r, seed: i6, normalized: a } = s;
  it(o, "multinomial");
  const l = a ? o : xw({ inputs: { logits: o }, backend: e, attrs: { dim: -1 } }), c = l.shape[0], u = l.shape[1], d = e.data.get(l.dataId).values, h6 = [c, r], p6 = Se(O(h6), "int32");
  for (let f = 0; f < c; ++f) {
    const m = f * u, g6 = new Float32Array(u - 1);
    g6[0] = d[m];
    for (let w6 = 1; w6 < g6.length; ++w6)
      g6[w6] = g6[w6 - 1] + d[m + w6];
    const b6 = wr.alea(i6.toString()), x6 = f * r;
    for (let w6 = 0; w6 < r; ++w6) {
      const y6 = b6();
      p6[x6 + w6] = g6.length;
      for (let I = 0; I < g6.length; I++)
        if (y6 < g6[I]) {
          p6[x6 + w6] = I;
          break;
        }
    }
  }
  return a || e.disposeIntermediateTensorInfo(l), e.makeTensorInfo(h6, "int32", p6);
}
const UD = {
  kernelName: Yg$1,
  backendName: "cpu",
  kernelFunc: _D
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YD = Tp;
function QD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { boxes: o, scores: r } = t, { maxOutputSize: i6, iouThreshold: a, scoreThreshold: l } = s;
  it(o, "NonMaxSuppression");
  const c = e.data.get(o.dataId).values, u = e.data.get(r.dataId).values, { selectedIndices: d } = YD(c, u, i6, a, l);
  return e.makeTensorInfo([d.length], "int32", new Int32Array(d));
}
const JD = {
  kernelName: gh$1,
  backendName: "cpu",
  kernelFunc: QD
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jD = Np;
function qD(n) {
  const { inputs: t, backend: e, attrs: s } = n, { boxes: o, scores: r } = t, { maxOutputSize: i6, iouThreshold: a, scoreThreshold: l, padToMaxOutputSize: c } = s;
  it(o, "NonMaxSuppressionPadded");
  const u = e.data.get(o.dataId).values, d = e.data.get(r.dataId).values, { selectedIndices: h6, validOutputs: p6 } = jD(u, d, i6, a, l, c);
  return [
    e.makeTensorInfo([h6.length], "int32", new Int32Array(h6)),
    e.makeTensorInfo([], "int32", new Int32Array([p6]))
  ];
}
const tF = {
  kernelName: bh$1,
  backendName: "cpu",
  kernelFunc: qD
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eF = Rp;
function nF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { boxes: o, scores: r } = t, { maxOutputSize: i6, iouThreshold: a, scoreThreshold: l, softNmsSigma: c } = s;
  it(o, "NonMaxSuppressionWithScore");
  const u = e.data.get(o.dataId).values, d = e.data.get(r.dataId).values, h6 = i6, p6 = a, f = l, m = c, { selectedIndices: g6, selectedScores: b6 } = eF(u, d, h6, p6, f, m);
  return [
    e.makeTensorInfo([g6.length], "int32", new Int32Array(g6)),
    e.makeTensorInfo([b6.length], "float32", new Float32Array(b6))
  ];
}
const sF = {
  kernelName: xh$1,
  backendName: "cpu",
  kernelFunc: nF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { indices: o } = t, { dtype: r, depth: i6, onValue: a, offValue: l } = s;
  it(o, "oneHot");
  const c = O(o.shape), u = new Float32Array(c * i6);
  u.fill(l);
  const d = e.data.get(o.dataId).values;
  for (let h6 = 0; h6 < c; ++h6)
    d[h6] >= 0 && d[h6] < i6 && (u[h6 * i6 + d[h6]] = a);
  return e.makeTensorInfo([...o.shape, i6], r, u);
}
const rF = {
  kernelName: yc,
  backendName: "cpu",
  kernelFunc: oF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rl(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  if (s.dtype === "string")
    throw new Error("zerosLike is not supported for string tensors");
  if (s.dtype === "complex64") {
    const o = $o({ inputs: { input: s }, backend: e }), r = Rl({ inputs: { x: o }, backend: e }), i6 = ur({ inputs: { input: s }, backend: e }), a = Rl({ inputs: { x: i6 }, backend: e }), l = Ye({ inputs: { real: r, imag: a }, backend: e });
    return e.disposeIntermediateTensorInfo(o), e.disposeIntermediateTensorInfo(r), e.disposeIntermediateTensorInfo(i6), e.disposeIntermediateTensorInfo(a), l;
  } else
    return Df$1({ backend: e, attrs: { shape: s.shape, value: 0, dtype: s.dtype } });
}
const iF = {
  kernelName: Fc,
  backendName: "cpu",
  kernelFunc: Rl
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yw(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  if (s.dtype === "string")
    throw new Error("onesLike is not supported for string tensors");
  if (s.dtype === "complex64") {
    const o = $o({ inputs: { input: s }, backend: e }), r = yw({ inputs: { x: o }, backend: e }), i6 = ur({ inputs: { input: s }, backend: e }), a = Rl({ inputs: { x: i6 }, backend: e }), l = Ye({ inputs: { real: r, imag: a }, backend: e });
    return e.disposeIntermediateTensorInfo(o), e.disposeIntermediateTensorInfo(r), e.disposeIntermediateTensorInfo(i6), e.disposeIntermediateTensorInfo(a), l;
  } else
    return Df$1({ backend: e, attrs: { shape: s.shape, value: 1, dtype: s.dtype } });
}
const aF = {
  kernelName: xc,
  backendName: "cpu",
  kernelFunc: yw
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ww(n) {
  const { inputs: t, backend: e, attrs: s } = n, { axis: o } = s;
  if (t.length === 1)
    return Nl({ inputs: { input: t[0] }, backend: e, attrs: { dim: o } });
  const r = t[0].shape, i6 = t[0].dtype;
  t.forEach((u) => {
    Ve(r, u.shape, "All tensors passed to stack must have matching shapes"), v(i6 === u.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const a = [], l = t.map((u) => {
    const d = Nl({ inputs: { input: u }, backend: e, attrs: { dim: o } });
    return a.push(d), d;
  }), c = dr({ inputs: l, backend: e, attrs: { axis: o } });
  return a.forEach((u) => e.disposeIntermediateTensorInfo(u)), c;
}
const lF = {
  kernelName: wc,
  backendName: "cpu",
  kernelFunc: ww
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { paddings: r, constantValue: i6 } = s;
  it(o, "pad");
  const a = r.map(
    (x6, w6) => x6[0] + o.shape[w6] + x6[1]
    /* afterPad */
  ), l = r.map((x6) => x6[0]), c = e.data.get(o.dataId).values, u = O(o.shape), d = o.shape.length, h6 = dt(o.shape), p6 = O(a), f = a.length, m = dt(a), g6 = xe$1(o.dtype, p6);
  i6 !== 0 && g6.fill(i6);
  for (let x6 = 0; x6 < u; x6++) {
    const y6 = Mo(x6, d, h6).map((C6, k7) => C6 + l[k7]), I = zn$1(y6, f, m);
    g6[I] = c[x6];
  }
  return { dataId: e.write(g6, a, o.dtype), shape: a, dtype: o.dtype };
}
const Iw = {
  kernelName: Ic,
  backendName: "cpu",
  kernelFunc: cF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uF = ce((n, t) => Math.pow(n, t)), dF = we(Ai, uF), hF = {
  kernelName: Ai,
  backendName: "cpu",
  kernelFunc: dF
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { paramsNestedSplits: o, paramsDenseValues: r, indices: i6 } = t, a = o.map((g6) => e.data.get(g6.dataId).values), l = o.map((g6) => g6.shape), c = e.data.get(r.dataId).values, u = e.data.get(i6.dataId).values, [d, h6, p6] = A1(a, l, c, r.shape, r.dtype, u, i6.shape), f = d.map((g6) => e.makeTensorInfo([g6.length], "int32", g6)), m = e.makeTensorInfo(p6, r.dtype, h6);
  return f.concat([m]);
}
const fF = {
  kernelName: Qg$1,
  backendName: "cpu",
  kernelFunc: pF
};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mF(n) {
  const { inputs: t, backend: e } = n, { starts: s, limits: o, deltas: r } = t, i6 = e.data.get(s.dataId).values, a = e.data.get(o.dataId).values, l = e.data.get(r.dataId).values, [c, u] = O1(i6, s.shape, s.dtype, a, o.shape, l, r.shape), d = e.makeTensorInfo([c.length], "int32", c), h6 = e.makeTensorInfo([u.length], s.dtype, u);
  return [d, h6];
}
const gF = {
  kernelName: Jg$1,
  backendName: "cpu",
  kernelFunc: mF
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { shape: o, values: r, defaultValue: i6, rowPartitionTensors: a } = t, { rowPartitionTypes: l } = s, c = e.data.get(o.dataId).values, u = e.data.get(r.dataId).values, d = e.data.get(i6.dataId).values, h6 = a.map((g6) => e.data.get(g6.dataId).values), p6 = a.map((g6) => g6.shape), [f, m] = K1(c, o.shape, u, r.shape, r.dtype, d, i6.shape, h6, p6, l);
  return e.makeTensorInfo(f, r.dtype, m);
}
const xF = {
  kernelName: jg$1,
  backendName: "cpu",
  kernelFunc: bF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yF(n) {
  const { backend: t, attrs: e } = n, { start: s, stop: o, dtype: r, step: i6 } = e, a = Z1(s, o, i6, r);
  return t.makeTensorInfo([a.length], r, a);
}
const wF = {
  kernelName: yh$1,
  backendName: "cpu",
  kernelFunc: yF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IF = Mt(Oi, (n) => 1 / n), CF = {
  kernelName: Oi,
  backendName: "cpu",
  kernelFunc: IF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { images: o } = t, { alignCorners: r, halfPixelCenters: i6, size: a } = s;
  it(o, "resizeBilinear");
  const l = dt(o.shape), [c, u] = a, [d, h6, p6, f] = o.shape, m = e.data.get(o.dataId).values, g6 = new Float32Array(O([d, c, u, f])), b6 = [
    r && c > 1 ? h6 - 1 : h6,
    r && u > 1 ? p6 - 1 : p6
  ], x6 = [
    r && c > 1 ? c - 1 : c,
    r && u > 1 ? u - 1 : u
  ];
  let w6 = 0;
  const y6 = b6[0] / x6[0], I = b6[1] / x6[1];
  for (let C6 = 0; C6 < d; C6++)
    for (let k7 = 0; k7 < c; k7++) {
      let S;
      i6 ? S = y6 * (k7 + 0.5) - 0.5 : S = y6 * k7;
      const N = Math.max(0, Math.floor(S)), R = S - N, M6 = Math.min(h6 - 1, Math.ceil(S)), V = C6 * l[0] + N * l[1], z = C6 * l[0] + M6 * l[1];
      for (let X = 0; X < u; X++) {
        let P6;
        i6 ? P6 = I * (X + 0.5) - 0.5 : P6 = I * X;
        const A6 = Math.max(0, Math.floor(P6)), B6 = P6 - A6, Z = Math.min(p6 - 1, Math.ceil(P6)), H6 = V + A6 * l[2], Y = z + A6 * l[2], Q = V + Z * l[2], j = z + Z * l[2];
        for (let J6 = 0; J6 < f; J6++) {
          const nt = m[H6 + J6], q = m[Y + J6], rt = m[Q + J6], ht = m[j + J6], ft2 = nt + (rt - nt) * B6, pt = q + (ht - q) * B6, wt2 = ft2 + (pt - ft2) * R;
          g6[w6++] = wt2;
        }
      }
    }
  return e.makeTensorInfo([d, c, u, f], "float32", g6);
}
const SF = {
  kernelName: Tc,
  backendName: "cpu",
  kernelFunc: vF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { images: o, dy: r } = t, { alignCorners: i6 } = s;
  it([r, o], "resizeBilinearGrad");
  const a = dt(o.shape), [l, c, u, d] = o.shape, [, h6, p6] = r.shape, f = new Float32Array(l * c * u * d), m = [
    i6 && h6 > 1 ? c - 1 : c,
    i6 && p6 > 1 ? u - 1 : u
  ], g6 = [
    i6 && h6 > 1 ? h6 - 1 : h6,
    i6 && p6 > 1 ? p6 - 1 : p6
  ], b6 = m[0] / g6[0], x6 = m[1] / g6[1], w6 = e.data.get(r.dataId).values;
  let y6 = 0;
  for (let I = 0; I < l; I++) {
    const C6 = I * a[0];
    for (let k7 = 0; k7 < h6; k7++) {
      const S = k7 * b6, N = Math.floor(S), R = Math.min(Math.ceil(S), c - 1), M6 = C6 + N * a[1], V = C6 + R * a[1], z = S - N, X = 1 - z;
      for (let P6 = 0; P6 < p6; P6++) {
        const A6 = P6 * x6, B6 = Math.floor(A6), Z = Math.min(Math.ceil(A6), u - 1), H6 = A6 - B6, Y = 1 - H6, Q = M6 + B6 * a[2], j = M6 + Z * a[2], J6 = V + B6 * a[2], nt = V + Z * a[2], q = X * Y, rt = X * H6, ht = z * Y, ft2 = z * H6;
        for (let pt = 0; pt < d; pt++) {
          const wt2 = w6[y6++];
          f[Q + pt] += wt2 * q, f[j + pt] += wt2 * rt, f[J6 + pt] += wt2 * ht, f[nt + pt] += wt2 * ft2;
        }
      }
    }
  }
  return e.makeTensorInfo([l, u, c, d], "float32", f);
}
const TF = {
  kernelName: Ch$1,
  backendName: "cpu",
  kernelFunc: kF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { images: o } = t, { alignCorners: r, halfPixelCenters: i6, size: a } = s;
  it(o, "resizeNearestNeighbor");
  const l = dt(o.shape), [c, u] = a, [d, h6, p6, f] = o.shape, m = e.data.get(o.dataId).values, g6 = new Float32Array(d * c * u * f), b6 = [
    r && c > 1 ? h6 - 1 : h6,
    r && u > 1 ? p6 - 1 : p6
  ], x6 = [
    r && c > 1 ? c - 1 : c,
    r && u > 1 ? u - 1 : u
  ], w6 = b6[0] / x6[0], y6 = b6[1] / x6[1];
  let I = 0;
  for (let C6 = 0; C6 < d; C6++) {
    const k7 = C6 * l[0];
    for (let S = 0; S < c; S++) {
      const N = i6 ? w6 * (S + 0.5) : w6 * S;
      let R = Math.min(h6 - 1, r ? Math.round(N) : Math.floor(N));
      i6 && (R = Math.max(0, R));
      const M6 = k7 + R * l[1];
      for (let V = 0; V < u; V++) {
        const z = i6 ? y6 * (V + 0.5) : y6 * V;
        let X = Math.min(p6 - 1, r ? Math.round(z) : Math.floor(z));
        i6 && (X = Math.max(0, X));
        const P6 = M6 + X * l[2];
        for (let A6 = 0; A6 < f; A6++) {
          const B6 = m[P6 + A6];
          g6[I++] = B6;
        }
      }
    }
  }
  return e.makeTensorInfo([d, c, u, f], o.dtype, g6);
}
const RF = {
  kernelName: kc,
  backendName: "cpu",
  kernelFunc: NF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $F(n) {
  const { inputs: t, backend: e, attrs: s } = n, { images: o, dy: r } = t, { alignCorners: i6 } = s;
  it([r, o], "resizeNearestNeighborGrad");
  const a = dt(o.shape), l = dt(r.shape), [c, u, d, h6] = o.shape, [, p6, f] = r.shape, m = new Float32Array(c * u * d * h6), g6 = e.data.get(r.dataId).values, b6 = [
    i6 && p6 > 1 ? u - 1 : u,
    i6 && f > 1 ? d - 1 : d
  ], x6 = [
    i6 && p6 > 1 ? p6 - 1 : p6,
    i6 && f > 1 ? f - 1 : f
  ], w6 = b6[0] / x6[0], y6 = b6[1] / x6[1], I = 1 / w6, C6 = 1 / y6, k7 = Math.ceil(I) * 2 + 2, S = Math.ceil(C6) * 2 + 2;
  for (let N = 0; N < c; N++) {
    const R = N * a[0];
    for (let M6 = 0; M6 < u; M6++) {
      const V = R + M6 * a[1], z = Math.floor(M6 * I), X = Math.floor(z - k7 / 2);
      for (let P6 = 0; P6 < d; P6++) {
        const A6 = V + P6 * a[2], B6 = Math.floor(P6 * C6), Z = Math.floor(B6 - S / 2);
        for (let H6 = 0; H6 < h6; H6++) {
          let Y = 0;
          for (let Q = 0; Q < k7; Q++) {
            const j = Q + X;
            if (j < 0 || j >= p6)
              continue;
            const J6 = R + j * l[1], nt = j * w6, q = Math.min(u - 1, i6 ? Math.round(nt) : Math.floor(nt));
            if (M6 === q)
              for (let rt = 0; rt < S; rt++) {
                const ht = rt + Z;
                if (ht < 0 || ht >= f)
                  continue;
                const ft2 = J6 + ht * l[2], pt = ht * y6, wt2 = Math.min(d - 1, i6 ? Math.round(pt) : Math.floor(pt));
                P6 === wt2 && (Y += g6[ft2 + H6]);
              }
          }
          m[A6 + H6] = Y;
        }
      }
    }
  }
  return e.makeTensorInfo(o.shape, o.dtype, m);
}
const GF = {
  kernelName: Ih$1,
  backendName: "cpu",
  kernelFunc: $F
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { dims: r } = s;
  it(o, "reverse");
  const i6 = o.shape.length, a = Ct(r, o.shape);
  if (i6 === 0)
    return rs({ inputs: { x: o }, backend: e });
  const l = new $e(o.shape, o.dtype), c = e.bufferSync(o);
  for (let u = 0; u < l.size; u++) {
    const d = l.indexToLoc(u), h6 = d.slice();
    a.forEach((p6) => h6[p6] = o.shape[p6] - 1 - h6[p6]), l.set(c.get(...h6), ...d);
  }
  return e.makeTensorInfo(l.shape, l.dtype, l.values);
}
const LF = {
  kernelName: Nc,
  backendName: "cpu",
  kernelFunc: EF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const MF = {
  kernelName: Dh$1,
  backendName: "cpu",
  kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
    const { image: s } = n, { radians: o, fillValue: r, center: i6 } = t, a = e, l = xe$1(s.dtype, O(s.shape)), [c, u, d, h6] = s.shape, [p6, f] = Xp(i6, u, d), m = 255, g6 = Math.sin(o), b6 = Math.cos(o), x6 = a.data.get(s.dataId).values;
    for (let y6 = 0; y6 < c; y6++) {
      const I = y6 * d * u * h6;
      for (let C6 = 0; C6 < u; C6++) {
        const k7 = C6 * (d * h6);
        for (let S = 0; S < d; S++) {
          const N = S * h6;
          for (let R = 0; R < h6; R++) {
            const M6 = [c, C6, S, R], V = M6[2], z = M6[1];
            let X = (V - p6) * b6 - (z - f) * g6, P6 = (V - p6) * g6 + (z - f) * b6;
            X = Math.round(X + p6), P6 = Math.round(P6 + f);
            let A6 = r;
            if (typeof r != "number" && (R === 3 ? A6 = m : A6 = r[R]), X >= 0 && X < d && P6 >= 0 && P6 < u) {
              const Z = P6 * (d * h6), H6 = X * h6, Y = I + Z + H6 + R;
              A6 = x6[Y];
            }
            const B6 = I + k7 + N + R;
            l[B6] = A6;
          }
        }
      }
    }
    return { dataId: a.write(l, s.shape, s.dtype), shape: s.shape, dtype: s.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WF = Mt(Bi, (n) => {
  const t = Math.floor(n);
  return n - t < 0.5 ? Math.floor(n) : n - t > 0.5 ? Math.ceil(n) : t % 2 === 0 ? t : t + 1;
}), DF = {
  kernelName: Bi,
  backendName: "cpu",
  kernelFunc: WF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { indices: o, updates: r } = t, { shape: i6 } = s, { sliceRank: a, numUpdates: l, sliceSize: c, strides: u, outputSize: d } = Ir(r, o, i6), h6 = true, p6 = e.bufferSync(o), f = e.bufferSync(r), m = Qo(p6, f, i6, d, c, l, a, u, 0, h6);
  return e.makeTensorInfo(i6, m.dtype, m.values);
}
const VF = {
  kernelName: qg$1,
  backendName: "cpu",
  kernelFunc: FF
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zF(n, t) {
  let e = 0, s = n.length, o = 0;
  for (; e < s; )
    o = Math.floor((e + s) / 2), n[o] < t ? e = o + 1 : s = o;
  return s;
}
function XF(n, t) {
  let e = 0, s = n.length, o = 0;
  for (; e < s; )
    o = Math.floor((e + s) / 2), n[o] <= t ? e = o + 1 : s = o;
  return s;
}
function PF(n, t, e, s, o, r) {
  const i6 = oe("int32", e * o);
  for (let a = 0; a < e; ++a) {
    const l = n.slice(a * s, (a + 1) * s), c = a * o;
    for (let u = 0; u < o; ++u)
      i6[c + u] = r === "left" ? zF(l, t[u + c]) : XF(l, t[u + c]);
  }
  return i6;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AF(n) {
  const { inputs: t, backend: e, attrs: s } = n, { sortedSequence: o, values: r } = t, { side: i6 } = s, a = e.data.get(o.dataId).values, l = e.data.get(r.dataId).values, c = PF(a, l, o.shape[0], o.shape[1], r.shape[1], i6);
  return e.makeTensorInfo(r.shape, "int32", c);
}
const OF = {
  kernelName: tb$1,
  backendName: "cpu",
  kernelFunc: AF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KF(n) {
  const { inputs: t, backend: e } = n, { condition: s, t: o, e: r } = t;
  it([s, o, r], "select");
  const i6 = s.shape.length, a = e.data.get(s.dataId).values, l = e.data.get(o.dataId).values, c = e.data.get(r.dataId).values, u = je$1(o.dtype, r.dtype), d = Se(O(o.shape), u);
  let h6 = 0;
  const p6 = i6 === 0 || i6 > 1 || o.shape.length === 1 ? 1 : O(o.shape.slice(1));
  for (let f = 0; f < a.length; f++)
    for (let m = 0; m < p6; m++)
      a[f] === 1 ? d[h6++] = l[f] : d[h6++] = c[f];
  return e.makeTensorInfo(o.shape, u, d);
}
const ZF = {
  kernelName: Rc,
  backendName: "cpu",
  kernelFunc: KF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BF = Yc, HF = Qc, _F = Mt(_i, (n) => n >= 0 ? HF * n : BF * (Math.exp(n) - 1)), UF = {
  kernelName: _i,
  backendName: "cpu",
  kernelFunc: _F
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YF = Mt(Qi, (n) => n < 0 ? -1 : n > 0 ? 1 : 0), QF = {
  kernelName: Qi,
  backendName: "cpu",
  kernelFunc: YF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const JF = Mt(Ui, (n) => Math.sin(n)), jF = {
  kernelName: Ui,
  backendName: "cpu",
  kernelFunc: JF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qF = Mt(Yi, (n) => Math.sinh(n)), tV = {
  kernelName: Yi,
  backendName: "cpu",
  kernelFunc: qF
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eV = 11920928955078125e-23, Um = Math.log(eV) + 2, nV = Mt(ji, (n) => {
  const t = n > -Um, e = n < Um, s = Math.exp(n);
  let o;
  return e ? o = s : t ? o = n : o = Math.log(1 + s), o;
}), sV = {
  kernelName: ji,
  backendName: "cpu",
  kernelFunc: nV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { blockShape: r, paddings: i6 } = s;
  it([o], "spaceToBatchND");
  const a = O(r), l = [[0, 0]];
  l.push(...i6);
  for (let C6 = 1 + r.length; C6 < o.shape.length; ++C6)
    l.push([0, 0]);
  const c = Iw.kernelFunc({
    inputs: { x: o },
    backend: e,
    attrs: { paddings: l, constantValue: 0 }
  }), u = fa(c.shape, r, a, false), d = ma(u.length, r.length, false), h6 = ga(c.shape, r, a, false), m = Ot$1({ inputs: { x: c }, backend: e, attrs: { shape: u } }), x6 = Ze({ inputs: { x: m }, backend: e, attrs: { perm: d } }), I = Ot$1({ inputs: { x: x6 }, backend: e, attrs: { shape: h6 } });
  return e.disposeIntermediateTensorInfo(c), e.disposeIntermediateTensorInfo(m), e.disposeIntermediateTensorInfo(x6), I;
}
const rV = {
  kernelName: Ec,
  backendName: "cpu",
  kernelFunc: oV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function iV(n) {
  const { inputs: t, backend: e } = n, { indices: s, values: o, denseShape: r, defaultValue: i6 } = t;
  if (r.shape.length !== 1)
    throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);
  if (s.shape.length !== 2)
    throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);
  if (o.shape.length !== 1)
    throw new Error(`Values must be a vector, saw:
        ${o.shape}`);
  if (i6.shape.length !== 0)
    throw new Error(`Default value must be a scalar, saw:
        ${i6.shape}`);
  const a = e.data.get(s.dataId).values, l = e.data.get(o.dataId).values, c = e.data.get(r.dataId).values, u = e.data.get(i6.dataId).values[0], [d, h6, p6, f, m] = U1(a, s.shape, s.dtype, l, o.dtype, c, u);
  return [
    e.makeTensorInfo(h6, s.dtype, d),
    e.makeTensorInfo([h6[0]], o.dtype, p6),
    e.makeTensorInfo([f.length], "bool", new Uint8Array(f.map((g6) => Number(g6)))),
    e.makeTensorInfo([m.length], s.dtype, new Int32Array(m))
  ];
}
const aV = {
  kernelName: vh$1,
  backendName: "cpu",
  kernelFunc: iV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lV(n) {
  const { inputs: t, backend: e } = n, { inputIndices: s, inputShape: o, newShape: r } = t;
  if (s.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);
  if (o.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${r.shape}`);
  const i6 = Array.from(e.data.get(o.dataId).values), a = e.data.get(s.dataId).values, l = Array.from(e.data.get(r.dataId).values), [c, u, d] = Y1(a, s.shape, s.dtype, i6, l);
  return [
    e.makeTensorInfo(u, s.dtype, c),
    e.makeTensorInfo([d.length], r.dtype, new Int32Array(d))
  ];
}
const cV = {
  kernelName: Sh$1,
  backendName: "cpu",
  kernelFunc: lV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uV(n) {
  const { inputs: t, backend: e } = n, { data: s, indices: o, segmentIds: r } = t;
  if (s.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (o.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);
  if (o.shape[0] !== r.shape[0])
    throw new Error("segmentIds and indices should have same size.");
  const i6 = e.data.get(s.dataId).values, a = e.data.get(o.dataId).values, l = e.data.get(r.dataId).values, [c, u] = Ef$1(i6, s.shape, s.dtype, a, l, true);
  return e.makeTensorInfo(u, s.dtype, c);
}
const dV = {
  kernelName: kh$1,
  backendName: "cpu",
  kernelFunc: uV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hV(n) {
  const { inputs: t, backend: e } = n, { data: s, indices: o, segmentIds: r } = t;
  if (s.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (o.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);
  if (o.shape[0] !== r.shape[0])
    throw new Error("segmentIds and indices should have same size.");
  const i6 = e.data.get(s.dataId).values, a = e.data.get(o.dataId).values, l = e.data.get(r.dataId).values, [c, u] = Ef$1(i6, s.shape, s.dtype, a, l);
  return e.makeTensorInfo(u, s.dtype, c);
}
const pV = {
  kernelName: Th$1,
  backendName: "cpu",
  kernelFunc: hV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { sparseIndices: o, sparseValues: r, defaultValue: i6 } = t, { outputShape: a } = s, { sliceRank: l, numUpdates: c, sliceSize: u, strides: d, outputSize: h6 } = Ir(r, o, a), p6 = false, f = e.bufferSync(o);
  let m;
  switch (r.dtype) {
    case "bool": {
      const g6 = e.bufferSync(r), b6 = !!e.data.get(i6.dataId).values[0];
      m = Qo(f, g6, a, h6, u, c, l, d, b6, p6);
      break;
    }
    case "float32": {
      const g6 = e.bufferSync(r), b6 = e.data.get(i6.dataId).values[0];
      m = Qo(f, g6, a, h6, u, c, l, d, b6, p6);
      break;
    }
    case "int32": {
      const g6 = e.bufferSync(r), b6 = e.data.get(i6.dataId).values[0];
      m = Qo(f, g6, a, h6, u, c, l, d, b6, p6);
      break;
    }
    case "string": {
      const g6 = e.bufferSync(r), b6 = ps(e.data.get(i6.dataId).values[0]);
      m = Qo(f, g6, a, h6, u, c, l, d, b6, p6);
      break;
    }
    default:
      throw new Error(`Unsupported type ${r.dtype}`);
  }
  return e.makeTensorInfo(a, m.dtype, m.values);
}
const mV = {
  kernelName: eb$1,
  backendName: "cpu",
  kernelFunc: fV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { numOrSizeSplits: r, axis: i6 } = s, a = Ct(i6, o.shape)[0], l = tf$1(o, r, a), c = new Array(o.shape.length).fill(0), u = o.shape.slice();
  return l.map((d) => {
    const h6 = [...u];
    h6[a] = d;
    const p6 = Go({ inputs: { x: o }, backend: e, attrs: { begin: c, size: h6 } });
    return c[a] += d, p6;
  });
}
const bV = {
  kernelName: Lc,
  backendName: "cpu",
  kernelFunc: gV
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xV = {
  kernelName: Nh$1,
  backendName: "cpu",
  kernelFunc: ({ inputs: n, backend: t }) => {
    const { x: e } = n, s = t;
    it(e, "square");
    const o = s.data.get(e.dataId).values, r = new Float32Array(o.length);
    for (let a = 0; a < o.length; ++a) {
      const l = o[a];
      r[a] = l * l;
    }
    return { dataId: s.write(r, e.shape, e.dtype), shape: e.shape, dtype: e.dtype };
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yV = Mt(ra, (n, t) => {
  const e = t;
  return isNaN(n) ? NaN : n > 0 ? 1 : e.alpha;
}), wV = {
  kernelName: ra,
  backendName: "cpu",
  kernelFunc: yV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { begin: r, end: i6, strides: a, beginMask: l, endMask: c, ellipsisMask: u, newAxisMask: d, shrinkAxisMask: h6 } = s;
  it(o, "stridedSlice");
  const { finalShapeSparse: p6, finalShape: f, isIdentity: m, sliceDim0: g6, isSimpleSlice: b6, begin: x6, end: w6, strides: y6 } = Fp(o.shape, r, i6, a, l, c, u, d, h6);
  let I;
  if (m)
    I = Ot$1({ inputs: { x: o }, backend: e, attrs: { shape: f } });
  else if (g6 || b6) {
    v(o.shape.length >= 1, () => `Input must have rank at least 1, got: ${o.shape.length}`);
    const C6 = Mp(x6, w6, y6), k7 = Go({ inputs: { x: o }, backend: e, attrs: { begin: x6, size: C6 } });
    I = Ot$1({ inputs: { x: k7 }, backend: e, attrs: { shape: f } }), e.disposeIntermediateTensorInfo(k7);
  } else {
    const C6 = e.bufferSync(o), k7 = J1(p6, C6, y6, x6);
    I = e.makeTensorInfo(f, k7.dtype, k7.values);
  }
  return I;
}
const CV = {
  kernelName: Rh$1,
  backendName: "cpu",
  kernelFunc: IV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function vV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { separator: o, nGramWidths: r, leftPad: i6, rightPad: a, padWidth: l, preserveShortSequences: c } = s, { data: u, dataSplits: d } = t, h6 = e.data.get(u.dataId).values, p6 = e.data.get(d.dataId).values, [f, m] = j1(h6, p6, o, r, i6, a, l, c);
  return [
    e.makeTensorInfo([f.length], "string", f),
    e.makeTensorInfo(d.shape, "int32", m)
  ];
}
const SV = {
  kernelName: $h$1,
  backendName: "cpu",
  kernelFunc: vV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { skipEmpty: o } = s, { input: r, delimiter: i6 } = t;
  if (r.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (r.shape.length !== 1)
    throw new Error(`Input must be a vector, got shape: ${r.shape}`);
  if (i6.shape.length !== 0)
    throw new Error(`Delimiter must be a scalar, got shape: ${i6.shape}`);
  const a = e.data.get(r.dataId).values, l = e.data.get(i6.dataId).values[0], [c, u, d] = q1(a, l, o), h6 = u.length;
  return [
    e.makeTensorInfo([h6, 2], "int32", c),
    e.makeTensorInfo([h6], "string", u),
    e.makeTensorInfo([2], "int32", new Int32Array(d))
  ];
}
const TV = {
  kernelName: Gh$1,
  backendName: "cpu",
  kernelFunc: kV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { numBuckets: o } = s, { input: r } = t;
  if (r.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (o <= 0)
    throw new Error("Number of buckets must be at least 1");
  const i6 = e.data.get(r.dataId).values, a = tw(i6, o);
  return e.makeTensorInfo(r.shape, "int32", a);
}
const RV = {
  kernelName: Eh$1,
  backendName: "cpu",
  kernelFunc: NV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $V = Mt(na, (n) => Math.tan(n)), GV = {
  kernelName: na,
  backendName: "cpu",
  kernelFunc: $V
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EV = Mt(sa, (n) => Math.tanh(n)), LV = {
  kernelName: sa,
  backendName: "cpu",
  kernelFunc: EV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function MV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { reps: r } = s;
  it(o, "tile");
  const i6 = nw(e.bufferSync(o), r);
  return e.makeTensorInfo(i6.shape, i6.dtype, i6.values);
}
const WV = {
  kernelName: oa,
  backendName: "cpu",
  kernelFunc: MV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { k: r, sorted: i6 } = s;
  it(o, "topk");
  const a = e.data.get(o.dataId).values, [l, c] = ow(a, o.shape, o.dtype, r, i6);
  return [
    e.makeTensorInfo(l.shape, l.dtype, l.values),
    e.makeTensorInfo(c.shape, c.dtype, c.values)
  ];
}
const FV = {
  kernelName: Lh$1,
  backendName: "cpu",
  kernelFunc: DV
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VV(n) {
  const { inputs: t, attrs: e, backend: s } = n, { image: o, transforms: r } = t, { interpolation: i6, fillMode: a, fillValue: l, outputShape: c } = e, [u, d, h6, p6] = o.shape, [f, m] = c ?? [d, h6], g6 = [u, f, m, p6], b6 = dt(o.shape), x6 = b6[0], w6 = b6[1], y6 = b6[2], I = dt(g6), C6 = I[0], k7 = I[1], S = I[2], N = xe$1(o.dtype, O(g6));
  N.fill(l);
  const R = s.data.get(o.dataId).values, M6 = s.data.get(r.dataId).values;
  for (let z = 0; z < u; ++z) {
    const X = r.shape[0] === 1 ? M6 : M6.subarray(z * 8, z * 8 + 8);
    for (let P6 = 0; P6 < f; ++P6)
      for (let A6 = 0; A6 < m; ++A6)
        for (let B6 = 0; B6 < p6; ++B6) {
          let Z;
          const H6 = X[6] * A6 + X[7] * P6 + 1;
          if (H6 === 0)
            continue;
          const Y = (X[0] * A6 + X[1] * P6 + X[2]) / H6, Q = (X[3] * A6 + X[4] * P6 + X[5]) / H6, j = Ym(Y, h6, a), J6 = Ym(Q, d, a);
          switch (i6) {
            case "nearest":
              Z = KV(R, d, h6, x6, w6, y6, z, J6, j, B6, l);
              break;
            case "bilinear":
              Z = ZV(R, d, h6, x6, w6, y6, z, J6, j, B6, l);
              break;
            default:
              throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i6}`);
          }
          const nt = z * C6 + P6 * k7 + A6 * S + B6;
          N[nt] = Z;
        }
    return s.makeTensorInfo(g6, o.dtype, N);
  }
  return { dataId: s.write(N, g6, o.dtype), shape: o.shape, dtype: o.dtype };
}
const zV = {
  kernelName: Mh$1,
  backendName: "cpu",
  kernelFunc: VV
};
function Ym(n, t, e) {
  switch (e) {
    case "reflect":
      return XV(n, t);
    case "wrap":
      return PV(n, t);
    case "nearest":
      return OV(n, t);
    case "constant":
    default:
      return AV(n);
  }
}
function XV(n, t) {
  let e = n;
  if (e < 0)
    if (t <= 1)
      e = 0;
    else {
      const s = 2 * t;
      e < s && (e = s * Math.trunc(-e / s) + e), e = e < -t ? e + s : -e - 1;
    }
  else if (e > t - 1)
    if (t <= 1)
      e = 0;
    else {
      const s = 2 * t;
      e -= s * Math.trunc(e / s), e >= t && (e = s - e - 1);
    }
  return Fs(0, e, t - 1);
}
function PV(n, t) {
  let e = n;
  if (e < 0)
    if (t <= 1)
      e = 0;
    else {
      const s = t - 1;
      e += t * (Math.trunc(-e / s) + 1);
    }
  else if (e > t - 1)
    if (t <= 1)
      e = 0;
    else {
      const s = t - 1;
      e -= t * Math.trunc(e / s);
    }
  return Fs(0, e, t - 1);
}
function AV(n, t) {
  return n;
}
function OV(n, t) {
  return Fs(0, n, t - 1);
}
function Kr(n, t, e, s, o, r, i6, a, l, c, u) {
  const d = i6 * s + a * o + l * r + c;
  return 0 <= a && a < t && 0 <= l && l < e ? n[d] : u;
}
function KV(n, t, e, s, o, r, i6, a, l, c, u) {
  const d = Math.round(a), h6 = Math.round(l);
  return Kr(n, t, e, s, o, r, i6, d, h6, c, u);
}
function ZV(n, t, e, s, o, r, i6, a, l, c, u) {
  const d = Math.floor(a), h6 = Math.floor(l), p6 = d + 1, f = h6 + 1, m = (f - l) * Kr(n, t, e, s, o, r, i6, d, h6, c, u) + (l - h6) * Kr(n, t, e, s, o, r, i6, d, f, c, u), g6 = (f - l) * Kr(n, t, e, s, o, r, i6, p6, h6, c, u) + (l - h6) * Kr(n, t, e, s, o, r, i6, p6, f, c, u);
  return (p6 - a) * m + (a - d) * g6;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BV(n) {
  const { inputs: t, attrs: e, backend: s } = n, { axis: o } = e, { x: r } = t;
  it(r, "unique");
  const i6 = s.data.get(r.dataId).values, { outputValues: a, outputShape: l, indices: c } = rw(i6, o, r.shape, r.dtype);
  return [
    s.makeTensorInfo(l, r.dtype, a),
    s.makeTensorInfo([c.length], "int32", c)
  ];
}
const HV = {
  kernelName: Wh$1,
  backendName: "cpu",
  kernelFunc: BV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _V(n) {
  const { inputs: t, backend: e, attrs: s } = n, { value: o } = t;
  let { axis: r } = s;
  r < 0 && (r += o.shape.length);
  const i6 = o.shape.length, a = o.shape[r], l = new Array(i6 - 1);
  let c = 0;
  for (let p6 = 0; p6 < i6; p6++)
    p6 !== r && (l[c++] = o.shape[p6]);
  const u = new Array(i6).fill(0), d = o.shape.slice();
  d[r] = 1;
  const h6 = new Array(a);
  for (let p6 = 0; p6 < h6.length; p6++) {
    u[r] = p6;
    const f = Go({ inputs: { x: o }, backend: e, attrs: { begin: u, size: d } });
    h6[p6] = Ot$1({ inputs: { x: f }, backend: e, attrs: { shape: l } }), e.disposeIntermediateTensorInfo(f);
  }
  return h6;
}
const UV = {
  kernelName: Wc,
  backendName: "cpu",
  kernelFunc: _V
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function YV(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, segmentIds: r } = t, { numSegments: i6 } = s;
  it(o, "unsortedSegmentSum");
  const a = o.shape.length, l = r.shape.length, c = [], u = [], d = a - l;
  let h6 = r;
  for (let f = 0; f < d; ++f) {
    const m = Nl({ inputs: { input: h6 }, backend: e, attrs: { dim: f + 1 } });
    h6 = m, u.push(m);
  }
  for (let f = 0; f < i6; ++f) {
    const m = bs(f, "int32"), g6 = e.makeTensorInfo([], "int32", m), b6 = C1({ inputs: { a: g6, b: h6 }, backend: e }), x6 = Ks({ inputs: { x: b6 }, backend: e, attrs: { dtype: "float32" } }), w6 = uu({ inputs: { a: x6, b: o }, backend: e }), y6 = ka({ inputs: { x: w6 }, backend: e, attrs: { axis: 0, keepDims: false } });
    c.push(y6), u.push(g6), u.push(b6), u.push(x6), u.push(w6), u.push(y6);
  }
  const p6 = ww({ inputs: c, backend: e, attrs: { axis: 0 } });
  return u.forEach((f) => e.disposeIntermediateTensorInfo(f)), p6;
}
const QV = {
  kernelName: Dc,
  backendName: "cpu",
  kernelFunc: YV
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const JV = [
  H3,
  LL,
  U3,
  Q3,
  zL,
  j3,
  tM,
  nM,
  oM,
  iM,
  lM,
  uM,
  hM,
  mM,
  bM,
  wM,
  CM,
  SM,
  TM,
  Z3,
  RM,
  GM,
  LM,
  WM,
  FL,
  PL,
  FM,
  ML,
  zM,
  PM,
  AM,
  KM,
  BM,
  _M,
  YM,
  JM,
  qM,
  eW,
  sW,
  rW,
  aW,
  cW,
  dW,
  hW,
  fW,
  gW,
  xW,
  yW,
  wW,
  IW,
  SW,
  V3,
  TW,
  AL,
  WW,
  OL,
  DW,
  ZL,
  AW,
  OW,
  ZW,
  HL,
  _W,
  YW,
  JW,
  qW,
  eD,
  UL,
  QL,
  WL,
  sD,
  XM,
  rD,
  aD,
  cD,
  z3,
  jL,
  t3,
  dD,
  n3,
  pD,
  gD,
  xD,
  ID,
  vD,
  kD,
  TD,
  o3,
  RD,
  GD,
  LD,
  WD,
  FD,
  zD,
  PD,
  i3,
  OD,
  BD,
  UD,
  l3,
  u3,
  JD,
  tF,
  sF,
  h3,
  rF,
  aF,
  lF,
  Iw,
  hF,
  P3,
  m3,
  fF,
  gF,
  xF,
  wF,
  DL,
  Ed$1,
  CF,
  A3,
  O3,
  K3,
  SF,
  TF,
  RF,
  GF,
  LF,
  MF,
  DF,
  v3,
  VF,
  OF,
  ZF,
  UF,
  k3,
  QF,
  jF,
  tV,
  T3,
  HD,
  sV,
  rV,
  aV,
  cV,
  dV,
  pV,
  mV,
  bV,
  $3,
  xV,
  E3,
  wV,
  CV,
  SV,
  TV,
  RV,
  D3,
  CW,
  GV,
  LV,
  WV,
  FV,
  zV,
  p3,
  HV,
  UV,
  QV,
  iF
];
for (const n of JV)
  en$1(n);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const io = {}, Xa = {
  alpha: false,
  antialias: false,
  premultipliedAlpha: false,
  preserveDrawingBuffer: false,
  depth: false,
  stencil: false,
  failIfMajorPerformanceCaveat: true
};
function jV(n, t) {
  io[n] = t;
}
function Zn$1(n, t) {
  if (!(n in io) || t != null) {
    const s = tz(n, t);
    if (s !== null)
      io[n] = s;
    else
      return console.log("Could not get context for WebGL version", n), null;
  }
  const e = io[n];
  return e == null || e.isContextLost() ? (delete io[n], Zn$1(n)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), io[n]);
}
function qV(n) {
  if (typeof OffscreenCanvas < "u" && n === 2)
    return new OffscreenCanvas(300, 150);
  if (typeof document < "u")
    return document.createElement("canvas");
  throw new Error("Cannot create a canvas in this context");
}
function tz(n, t) {
  if (n !== 1 && n !== 2)
    throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
  const e = t ?? qV(n);
  return e.addEventListener("webglcontextlost", (s) => {
    s.preventDefault(), delete io[n];
  }, false), F().getBool("SOFTWARE_WEBGL_ENABLED") && (Xa.failIfMajorPerformanceCaveat = false), n === 1 ? e.getContext("webgl", Xa) || e.getContext("experimental-webgl", Xa) : e.getContext("webgl2", Xa);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var ii$1;
(function(n) {
  n[n.DENSE = 0] = "DENSE", n[n.SHARED_BATCH = 1] = "SHARED_BATCH";
})(ii$1 || (ii$1 = {}));
var ln$1;
(function(n) {
  n[n.RENDER = 0] = "RENDER", n[n.UPLOAD = 1] = "UPLOAD", n[n.PIXELS = 2] = "PIXELS", n[n.DOWNLOAD = 3] = "DOWNLOAD";
})(ln$1 || (ln$1 = {}));
var ve;
(function(n) {
  n[n.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", n[n.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", n[n.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", n[n.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", n[n.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
})(ve || (ve = {}));
function Ta(n, t) {
  return [t, n];
}
function ez(n, t) {
  return n * t;
}
function Pa(n) {
  const t = O(n), e = Math.ceil(t / 4);
  return el(e);
}
function kr(n, t) {
  return [
    Math.max(1, Math.ceil(t / 2)),
    Math.max(1, Math.ceil(n / 2))
  ];
}
function nz(n, t) {
  const [e, s] = kr(n, t);
  return e * s * 4;
}
function Ff$1(n, t) {
  const e = n;
  let s, o, r, i6, a, l, c, u, d, h6;
  return F().getNumber("WEBGL_VERSION") === 2 ? (s = e.R32F, o = e.R16F, r = e.RGBA16F, i6 = e.RGBA32F, a = e.RED, c = 4, u = 1, d = e.HALF_FLOAT, h6 = e.FLOAT, l = e.RGBA8) : (s = n.RGBA, o = n.RGBA, r = n.RGBA, i6 = e.RGBA, a = n.RGBA, c = 4, u = 4, d = t != null ? t.HALF_FLOAT_OES : null, h6 = n.FLOAT, l = n.RGBA), {
    internalFormatFloat: s,
    internalFormatHalfFloat: o,
    internalFormatPackedHalfFloat: r,
    internalFormatPackedFloat: i6,
    textureFormatFloat: a,
    downloadTextureFormat: l,
    downloadUnpackNumChannels: c,
    defaultNumChannels: u,
    textureTypeHalfFloat: d,
    textureTypeFloat: h6
  };
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ot(n, t) {
  const e = t();
  return F().getBool("DEBUG") && sz(n), e;
}
function sz(n) {
  const t = n.getError();
  if (t !== n.NO_ERROR)
    throw new Error("WebGL Error: " + az(n, t));
}
const oz = 596e-10, rz = 65504;
function iz(n) {
  return !!(F().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || n === 0 || oz < Math.abs(n) && Math.abs(n) < rz);
}
function az(n, t) {
  switch (t) {
    case n.NO_ERROR:
      return "NO_ERROR";
    case n.INVALID_ENUM:
      return "INVALID_ENUM";
    case n.INVALID_VALUE:
      return "INVALID_VALUE";
    case n.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case n.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case n.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case n.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return `Unknown error code ${t}`;
  }
}
function Aa(n, t) {
  return Cs(n, () => n.getExtension(t), 'Extension "' + t + '" not supported on this browser.');
}
function lz(n, t) {
  const e = Cs(n, () => n.createShader(n.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
  if (ot(n, () => n.shaderSource(e, t)), ot(n, () => n.compileShader(e)), n.getShaderParameter(e, n.COMPILE_STATUS) === false)
    throw console.log(n.getShaderInfoLog(e)), new Error("Failed to compile vertex shader.");
  return e;
}
function cz(n, t) {
  const e = Cs(n, () => n.createShader(n.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
  if (ot(n, () => n.shaderSource(e, t)), ot(n, () => n.compileShader(e)), F().get("ENGINE_COMPILE_ONLY"))
    return e;
  if (n.getShaderParameter(e, n.COMPILE_STATUS) === false)
    throw Cw(t, n.getShaderInfoLog(e)), new Error("Failed to compile fragment shader.");
  return e;
}
const uz = /ERROR: [0-9]+:([0-9]+):/g;
function Cw(n, t) {
  const e = uz.exec(t);
  if (e == null) {
    console.log(`Couldn't parse line number in error: ${t}`), console.log(n);
    return;
  }
  const s = +e[1], o = n.split(`
`), r = o.length.toString().length + 2, i6 = o.map((d, h6) => ho((h6 + 1).toString(), r) + d);
  let a = 0;
  for (let d = 0; d < i6.length; d++)
    a = Math.max(i6[d].length, a);
  const l = i6.slice(0, s - 1), c = i6.slice(s - 1, s), u = i6.slice(s);
  console.log(l.join(`
`)), console.log(t.split(`
`)[0]), console.log(`%c ${ho(c[0], a)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(u.join(`
`));
}
function dz(n) {
  return Cs(n, () => n.createProgram(), "Unable to create WebGLProgram.");
}
function hz(n, t) {
  if (ot(n, () => n.linkProgram(t)), !F().get("ENGINE_COMPILE_ONLY") && n.getProgramParameter(t, n.LINK_STATUS) === false)
    throw console.log(n.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
}
function Gu(n, t) {
  if (ot(n, () => n.validateProgram(t)), n.getProgramParameter(t, n.VALIDATE_STATUS) === false)
    throw console.log(n.getProgramInfoLog(t)), new Error("Shader program validation failed.");
}
function pz(n, t) {
  const e = Cs(n, () => n.createBuffer(), "Unable to create WebGLBuffer");
  return ot(n, () => n.bindBuffer(n.ARRAY_BUFFER, e)), ot(n, () => n.bufferData(n.ARRAY_BUFFER, t, n.STATIC_DRAW)), e;
}
function fz(n, t) {
  const e = Cs(n, () => n.createBuffer(), "Unable to create WebGLBuffer");
  return ot(n, () => n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e)), ot(n, () => n.bufferData(n.ELEMENT_ARRAY_BUFFER, t, n.STATIC_DRAW)), e;
}
function mz(n) {
  return Cs(n, () => n.createTexture(), "Unable to create WebGLTexture.");
}
function gz(n, t) {
  const e = F().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (n <= 0 || t <= 0) {
    const s = `[${n}x${t}]`;
    throw new Error("Requested texture size " + s + " is invalid.");
  }
  if (n > e || t > e) {
    const s = `[${n}x${t}]`, o = `[${e}x${e}]`;
    throw new Error("Requested texture size " + s + " greater than WebGL maximum on this browser / GPU " + o + ".");
  }
}
function bz(n) {
  return Cs(n, () => n.createFramebuffer(), "Unable to create WebGLFramebuffer.");
}
function Qm(n, t, e, s, o, r, i6) {
  const a = n.getAttribLocation(t, e);
  return a === -1 ? false : (ot(n, () => n.bindBuffer(n.ARRAY_BUFFER, s)), ot(n, () => n.vertexAttribPointer(a, o, n.FLOAT, false, r, i6)), ot(n, () => n.enableVertexAttribArray(a)), true);
}
function xz(n, t, e) {
  vz(n, e), ot(n, () => n.activeTexture(n.TEXTURE0 + e)), ot(n, () => n.bindTexture(n.TEXTURE_2D, t));
}
function yz(n, t, e) {
  return Cs(n, () => n.getUniformLocation(t, e), 'uniform "' + e + '" not present in program.');
}
function wz(n, t, e) {
  return n.getUniformLocation(t, e);
}
function Iz(n, t, e, s) {
  ot(n, () => xz(n, t, s)), ot(n, () => n.uniform1i(e, s));
}
function Eu(n, t, e) {
  ot(n, () => n.bindFramebuffer(n.FRAMEBUFFER, e)), ot(n, () => n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0));
}
function Jm(n, t) {
  ot(n, () => n.bindFramebuffer(n.FRAMEBUFFER, t)), ot(n, () => n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, null, 0));
}
function Oa(n) {
  const t = n.checkFramebufferStatus(n.FRAMEBUFFER);
  if (t !== n.FRAMEBUFFER_COMPLETE)
    throw new Error("Error binding framebuffer: " + Cz(n, t));
}
function Cz(n, t) {
  switch (t) {
    case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case n.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return `unknown error ${t}`;
  }
}
function Cs(n, t, e) {
  const s = ot(n, () => t());
  if (s == null)
    throw new Error(e);
  return s;
}
function vz(n, t) {
  const e = n.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, s = t + n.TEXTURE0;
  if (s < n.TEXTURE0 || s > e) {
    const o = `[gl.TEXTURE0, gl.TEXTURE${e}]`;
    throw new Error(`textureUnit must be in ${o}.`);
  }
}
function hr(n, t = 2) {
  return O(n.slice(0, n.length - t));
}
function pr(n) {
  if (n.length === 0)
    throw Error("Cannot get rows and columns of an empty shape array.");
  return [
    n.length > 1 ? n[n.length - 2] : 1,
    n[n.length - 1]
  ];
}
function Ka(n) {
  let t = [1, 1, 1];
  return n.length === 0 || n.length === 1 && n[0] === 1 || (t = [hr(n), ...pr(n)]), t;
}
function Sz(n, t = false) {
  let e = F().getNumber("WEBGL_MAX_TEXTURE_SIZE"), s = F().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
  s === 1 / 0 && F().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (s = e / 2), t && (e = e * 2, s = s * 2, n = n.map((a, l) => l >= n.length - 2 ? Wl(n[l]) : n[l]), n.length === 1 && (n = [2, n[0]])), n.length !== 2 && (n = gs(n).newShape);
  let o = O(n), r = null;
  n.length <= 1 && o <= e ? r = [1, o] : n.length === 2 && n[0] <= e && n[1] <= e ? r = n : n.length === 3 && n[0] * n[1] <= e && n[2] <= e ? r = [n[0] * n[1], n[2]] : n.length === 3 && n[0] <= e && n[1] * n[2] <= e ? r = [n[0], n[1] * n[2]] : n.length === 4 && n[0] * n[1] * n[2] <= e && n[3] <= e ? r = [n[0] * n[1] * n[2], n[3]] : n.length === 4 && n[0] <= e && n[1] * n[2] * n[3] <= e && (r = [n[0], n[1] * n[2] * n[3]]);
  const i6 = r != null && Math.max(...r) > s && Math.min(...r) <= (t ? 2 : 1) && Math.min(...r) > 0;
  if (r == null || i6)
    if (t) {
      const a = hr(n);
      let l = 2, c = 2;
      n.length && ([l, c] = pr(n)), o = a * (l / 2) * (c / 2), r = el(o).map((u) => u * 2);
    } else
      r = el(o);
  return r;
}
function Za(n) {
  return n % 2 === 0;
}
function $l(n, t) {
  if (n = n.slice(-2), t = t.slice(-2), Rt$1(n, t) || !n.length || !t.length || n[0] === 0 || n[1] === 0 || t[0] === 0 || t[1] === 0)
    return true;
  if (n.length !== t.length) {
    const e = n.slice(-1)[0], s = t.slice(-1)[0];
    if (e === s || Za(e) && Za(s) && (n[0] === 1 || t[0] === 1))
      return true;
  }
  return n[1] === t[1] && Za(n[0]) && Za(t[0]);
}
let Lu, Mu;
function kz(n) {
  if (Lu == null) {
    const t = Zn$1(n);
    Lu = t.getParameter(t.MAX_TEXTURE_SIZE);
  }
  return Lu;
}
function Tz(n) {
  if (Mu == null) {
    const t = Zn$1(n);
    Mu = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, Mu);
}
function Nz(n) {
  if (n === 0)
    return 0;
  let t;
  const e = Zn$1(n);
  return vn$1(e, "EXT_disjoint_timer_query_webgl2") && n === 2 ? t = 2 : vn$1(e, "EXT_disjoint_timer_query") ? t = 1 : t = 0, t;
}
function vn$1(n, t) {
  return n.getExtension(t) != null;
}
function jm(n) {
  try {
    if (Zn$1(n) != null)
      return true;
  } catch (t) {
    return console.log("Error when getting WebGL context: ", t), false;
  }
  return false;
}
function Rz(n) {
  if (n === 0)
    return false;
  const t = Zn$1(n);
  if (n === 1) {
    if (!vn$1(t, "OES_texture_float"))
      return false;
  } else if (!vn$1(t, "EXT_color_buffer_float"))
    return false;
  return Md$1(t);
}
function $z(n) {
  if (n === 0)
    return false;
  const t = Zn$1(n);
  if (n === 1) {
    if (!vn$1(t, "OES_texture_float") || !vn$1(t, "WEBGL_color_buffer_float"))
      return false;
  } else {
    if (vn$1(t, "EXT_color_buffer_float"))
      return Md$1(t);
    const s = "EXT_color_buffer_half_float";
    if (vn$1(t, s)) {
      const o = t.getExtension(s);
      return Gz(t, o);
    }
    return false;
  }
  return Md$1(t);
}
function Md$1(n) {
  const t = Ff$1(n), e = n.createTexture();
  n.bindTexture(n.TEXTURE_2D, e);
  const s = 1, o = 1;
  n.texImage2D(n.TEXTURE_2D, 0, t.internalFormatFloat, s, o, 0, t.textureFormatFloat, t.textureTypeFloat, null);
  const r = n.createFramebuffer();
  n.bindFramebuffer(n.FRAMEBUFFER, r), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0);
  const i6 = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
  return n.bindTexture(n.TEXTURE_2D, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteTexture(e), n.deleteFramebuffer(r), i6;
}
function Gz(n, t) {
  const e = Ff$1(n, t), s = n.createTexture();
  n.bindTexture(n.TEXTURE_2D, s);
  const o = 1, r = 1;
  n.texImage2D(n.TEXTURE_2D, 0, e.internalFormatHalfFloat, o, r, 0, e.textureFormatFloat, e.textureTypeHalfFloat, null);
  const i6 = n.createFramebuffer();
  n.bindFramebuffer(n.FRAMEBUFFER, i6), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, s, 0);
  const a = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
  return n.bindTexture(n.TEXTURE_2D, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteTexture(s), n.deleteFramebuffer(i6), a;
}
function Ez(n) {
  return n !== 2 ? false : Zn$1(n).fenceSync != null;
}
function Na(n, t) {
  Array.isArray(n) || (n = [n]), n.forEach((e) => {
    e != null && v(e.dtype !== "complex64", () => `${t} does not support complex64 tensors in the WebGL backend.`);
  });
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ct = F();
ct.registerFlag("HAS_WEBGL", () => ct.getNumber("WEBGL_VERSION") > 0);
ct.registerFlag("WEBGL_VERSION", () => jm(2) ? 2 : jm(1) ? 1 : 0);
ct.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
ct.registerFlag("WEBGL_BUFFER_SUPPORTED", () => ct.get("WEBGL_VERSION") === 2);
ct.registerFlag("WEBGL_CPU_FORWARD", () => true);
ct.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
ct.registerFlag("WEBGL_PACK", () => ct.getBool("HAS_WEBGL"));
ct.registerFlag("WEBGL_PACK_NORMALIZATION", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_PACK_CLIP", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_PACK_REDUCE", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_LAZILY_UNPACK", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_CONV_IM2COL", () => ct.getBool("WEBGL_PACK"));
ct.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => kz(ct.getNumber("WEBGL_VERSION")));
ct.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => Tz(ct.getNumber("WEBGL_VERSION")));
ct.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
  const n = ct.getNumber("WEBGL_VERSION");
  return n === 0 ? 0 : Nz(n);
});
ct.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ct.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !Xh$1());
ct.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => Rz(ct.getNumber("WEBGL_VERSION")));
ct.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => ct.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : ct.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));
ct.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => $z(ct.getNumber("WEBGL_VERSION")));
ct.registerFlag("WEBGL_FENCE_API_ENABLED", () => Ez(ct.getNumber("WEBGL_VERSION")));
ct.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => ct.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0);
ct.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (n) => {
  if (n < 0 && n !== -1)
    throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`);
});
ct.registerFlag("WEBGL_FLUSH_THRESHOLD", () => Xh$1() ? 1 : -1, (n) => {
  if (n < 0 && n !== -1)
    throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`);
});
ct.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
ct.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
ct.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
ct.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
ct.registerFlag("WEBGL_EXP_CONV", () => false);
ct.registerFlag("SOFTWARE_WEBGL_ENABLED", () => ct.getBool("IS_TEST"));
ct.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0);
ct.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false);
ct.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false);
ct.registerFlag("ENGINE_COMPILE_ONLY", () => false);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ze$1() {
  let n, t, e, s, o, r, i6, a, l, c;
  return F().getNumber("WEBGL_VERSION") === 2 ? (n = "#version 300 es", t = "in", e = "out", s = "in", o = "texture", r = "outputColor", i6 = "out vec4 outputColor;", a = F().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "", l = "", c = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (n = "", t = "attribute", e = "varying", s = "varying", o = "texture2D", r = "gl_FragColor", i6 = "", a = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, l = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, c = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), {
    version: n,
    attribute: t,
    varyingVs: e,
    varyingFs: s,
    texture2D: o,
    output: r,
    defineOutput: i6,
    defineSpecialNaN: a,
    defineSpecialInf: l,
    defineRound: c
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Po(n, t, e = "index") {
  const s = dt(t);
  return s.map((o, r) => {
    const i6 = `int ${n[r]} = ${e} / ${o}`, a = r === s.length - 1 ? `int ${n[r + 1]} = ${e} - ${n[r]} * ${o}` : `index -= ${n[r]} * ${o}`;
    return `${i6}; ${a};`;
  }).join("");
}
function du(n, t, e = "index") {
  const s = dt(t);
  return s.map((o, r) => {
    const i6 = `int ${n[r]} = ${e} / outShapeStrides[${r}]`, a = r === s.length - 1 ? `int ${n[r + 1]} = ${e} - ${n[r]} * outShapeStrides[${r}]` : `index -= ${n[r]} * outShapeStrides[${r}]`;
    return `${i6}; ${a};`;
  }).join("");
}
function Lz(n, t) {
  const e = n.length, s = n.map((r) => `${t}[${r}]`), o = new Array(e - 1);
  o[e - 2] = s[e - 1];
  for (let r = e - 3; r >= 0; --r)
    o[r] = `(${o[r + 1]} * ${s[r + 1]})`;
  return o;
}
function Mz(n, t, e = "index") {
  const s = n.map((r, i6) => i6), o = Lz(s, t);
  return o.map((r, i6) => {
    const a = `int ${n[i6]} = ${e} / ${o[i6]}`, l = i6 === o.length - 1 ? `int ${n[i6 + 1]} = ${e} - ${n[i6]} * ${o[i6]}` : `index -= ${n[i6]} * ${o[i6]}`;
    return `${a}; ${l};`;
  }).join("");
}
function Vf$1(n) {
  const t = dt(n).map((e) => e.toString());
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`;
}
function zf$1() {
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
}
const vw = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const { getBroadcastDims: Sw } = cR;
function Wz(n, t, e) {
  const s = [];
  if (n.forEach((p6) => {
    const f = O(p6.shapeInfo.logicalShape);
    if (p6.shapeInfo.isUniform ? s.push(`uniform float ${p6.name}${f > 1 ? `[${f}]` : ""};`) : (s.push(`uniform sampler2D ${p6.name};`), s.push(`uniform int offset${p6.name};`)), e.enableShapeUniforms) {
      const { uniformShape: m } = Xf$1(e.packedInputs, p6.shapeInfo.logicalShape, p6.shapeInfo.texShape);
      switch (m.length) {
        case 1:
          s.push(`uniform int ${p6.name}Shape;`);
          break;
        case 2:
          s.push(`uniform ivec2 ${p6.name}Shape;`);
          break;
        case 3:
          s.push(`uniform ivec3 ${p6.name}Shape;`);
          break;
        case 4:
          s.push(`uniform ivec4 ${p6.name}Shape;`);
          break;
      }
      s.push(`uniform ivec2 ${p6.name}TexShape;`);
    }
  }), e.enableShapeUniforms) {
    switch (t.logicalShape.length) {
      case 1:
        s.push("uniform int outShape;");
        break;
      case 2:
        s.push("uniform ivec2 outShape;"), s.push("uniform int outShapeStrides;");
        break;
      case 3:
        s.push("uniform ivec3 outShape;"), s.push("uniform ivec2 outShapeStrides;");
        break;
      case 4:
        s.push("uniform ivec4 outShape;"), s.push("uniform ivec3 outShapeStrides;");
        break;
    }
    s.push("uniform ivec2 outTexShape;");
  }
  e.customUniforms && e.customUniforms.forEach((p6) => {
    s.push(`uniform ${p6.type} ${p6.name}${p6.arrayIndex ? `[${p6.arrayIndex}]` : ""};`);
  });
  const o = s.join(`
`), r = n.map((p6) => Dz(p6, t, e.packedInputs, e.enableShapeUniforms)).join(`
`), i6 = t.texShape, a = ze$1(), l = zz(a);
  let c, u, d = Az(a);
  return t.isPacked ? (c = Fz(t.logicalShape, i6, e.enableShapeUniforms), u = Pz(a)) : (c = Vz(t.logicalShape, i6, e.enableShapeUniforms), u = Xz(a)), e.packedInputs && (d += Bz), [
    d,
    l,
    u,
    o,
    c,
    r,
    e.userCode
  ].join(`
`);
}
function Tr(n, t = false) {
  const e = n.shapeInfo.logicalShape;
  switch (e.length) {
    case 0:
      return sX(n, t);
    case 1:
      return rX(n, t);
    case 2:
      return aX(n, t);
    case 3:
      return cX(n, t);
    case 4:
      return dX(n, t);
    case 5:
      return hX(n);
    case 6:
      return pX(n);
    default:
      throw new Error(`${e.length}-D input sampling is not yet supported`);
  }
}
function kw(n, t) {
  switch (n.shapeInfo.logicalShape.length) {
    case 0:
      return nX(n);
    case 1:
      return oX(n, t);
    case 2:
      return iX(n, t);
    case 3:
      return lX(n, t);
    default:
      return uX(n, t);
  }
}
function Dz(n, t, e = false, s) {
  let o = "";
  e ? o += kw(n, s) : o += Tr(n, s);
  const r = n.shapeInfo.logicalShape, i6 = t.logicalShape;
  return r.length <= i6.length && (e ? o += fX(n, t) : o += mX(n, t)), o;
}
function Fz(n, t, e) {
  switch (n.length) {
    case 0:
      return Tw();
    case 1:
      return Hz(n, t, e);
    case 2:
      return tX(n, t, e);
    case 3:
      return Uz(n, t, e);
    default:
      return Qz(n, t, e);
  }
}
function Vz(n, t, e) {
  switch (n.length) {
    case 0:
      return Tw();
    case 1:
      return _z(n, t, e);
    case 2:
      return eX(n, t, e);
    case 3:
      return Yz(n, t, e);
    case 4:
      return Jz(n, t, e);
    case 5:
      return jz(n, t);
    case 6:
      return qz(n, t);
    default:
      throw new Error(`${n.length}-D output sampling is not yet supported`);
  }
}
function zz(n) {
  return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `;
}
function Xz(n) {
  return `
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `;
}
function Pz(n) {
  return `
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `;
}
function Az(n) {
  return `${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Oz}
    ${Kz}
    ${Zz}
  `;
}
const Oz = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, Kz = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, Zz = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, Bz = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
function Tw() {
  return `
    int getOutputCoords() {
      return 0;
    }
  `;
}
function Hz(n, t, e) {
  const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
  return s[0] === 1 ? e ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    ` : s[1] === 1 ? e ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    ` : e ? `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `;
}
function _z(n, t, e) {
  return t[0] === 1 ? e ? `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    ` : t[1] === 1 ? e ? `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    ` : e ? `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `;
}
function Uz(n, t, e) {
  if (e)
    return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
  const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)], o = Math.ceil(n[2] / 2), r = o * Math.ceil(n[1] / 2);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `;
}
function Yz(n, t, e) {
  if (e)
    return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${du(["r", "c", "d"], n)}
    return ivec3(r, c, d);
  }
`;
  const s = Po(["r", "c", "d"], n);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `;
}
function Qz(n, t, e) {
  if (e)
    return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
  const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)], o = Math.ceil(n[n.length - 1] / 2), r = o * Math.ceil(n[n.length - 2] / 2);
  let i6 = r, a = "", l = "b, r, c";
  for (let c = 2; c < n.length - 1; c++)
    i6 *= n[n.length - c - 1], a = `
      int b${c} = index / ${i6};
      index -= b${c} * ${i6};
    ` + a, l = `b${c}, ` + l;
  return `
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${n.length}(${l});
    }
  `;
}
function Jz(n, t, e) {
  if (e)
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${du(["r", "c", "d", "d2"], n)}
      return ivec4(r, c, d, d2);
    }
  `;
  const s = Po(["r", "c", "d", "d2"], n);
  return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `;
}
function jz(n, t) {
  const e = Po(["r", "c", "d", "d2", "d3"], n);
  return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
}
function qz(n, t) {
  const e = Po(["r", "c", "d", "d2", "d3", "d4"], n);
  return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
}
function tX(n, t, e) {
  const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
  if (Rt$1(n, t))
    return e ? `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;
  const o = Math.ceil(n[1] / 2);
  return e ? `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `;
}
function eX(n, t, e) {
  return Rt$1(n, t) ? e ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    ` : n[1] === 1 ? e ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : n[0] === 1 ? e ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : e ? `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `;
}
function Ao(n) {
  return `offset${n}`;
}
function nX(n) {
  const t = n.name, e = "get" + t.charAt(0).toUpperCase() + t.slice(1), s = ze$1();
  return `
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `;
}
function sX(n, t) {
  const e = n.name, s = "get" + e.charAt(0).toUpperCase() + e.slice(1);
  if (n.shapeInfo.isUniform)
    return `float ${s}() {return ${e};}`;
  const [o, r] = n.shapeInfo.texShape;
  if (o === 1 && r === 1)
    return `
      float ${s}() {
        return sampleTexture(${e}, halfCR);
      }
    `;
  const i6 = Ao(e);
  if (t)
    return `
    float ${s}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i6});
      return sampleTexture(${e}, uv);
    }
  `;
  const [a, l] = n.shapeInfo.texShape;
  return `
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i6});
      return sampleTexture(${e}, uv);
    }
  `;
}
function oX(n, t) {
  const e = n.name, s = "get" + e.charAt(0).toUpperCase() + e.slice(1), o = n.shapeInfo.texShape, r = ze$1();
  if (t)
    return `
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${e}, uv);
    }
  `;
  const i6 = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];
  return `
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i6[0]}, ${i6[1]}, index);
      return ${r.texture2D}(${e}, uv);
    }
  `;
}
function rX(n, t) {
  const e = n.name, s = "get" + e.charAt(0).toUpperCase() + e.slice(1);
  if (n.shapeInfo.isUniform)
    return `
      float ${s}(int index) {
        ${Nr(n)}
      }
    `;
  const o = n.shapeInfo.texShape, r = o[0], i6 = o[1];
  if (i6 === 1 && r === 1)
    return `
      float ${s}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;
  const a = Ao(e);
  return i6 === 1 ? t ? `
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    ` : `
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);
        return sampleTexture(${e}, uv);
      }
    ` : r === 1 ? t ? `
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    ` : `
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i6}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    ` : t ? `
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  ` : `
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${r}, ${i6}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `;
}
function iX(n, t) {
  const e = n.shapeInfo.logicalShape, s = n.name, o = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = n.shapeInfo.texShape, i6 = r[0], a = r[1], l = ze$1();
  if (r != null && Rt$1(e, r))
    return t ? `
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    ` : `
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i6}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;
  if (t)
    return `
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;
  const c = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], u = Math.ceil(e[1] / 2);
  return `
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;
}
function aX(n, t) {
  const e = n.shapeInfo.logicalShape, s = n.name, o = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = n.shapeInfo.texShape;
  if (r != null && Rt$1(e, r)) {
    if (t)
      return `
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;
    const h6 = r[0], p6 = r[1];
    return `
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p6}.0, ${h6}.0);
      return sampleTexture(${s}, uv);
    }
  `;
  }
  const { newShape: i6, keptDims: a } = gs(e), l = i6;
  if (l.length < e.length) {
    const h6 = Rr(n, l), p6 = ["row", "col"];
    return `
      ${Tr(h6, t)}
      float ${o}(int row, int col) {
        return ${o}(${$r(p6, a)});
      }
    `;
  }
  if (n.shapeInfo.isUniform)
    return `
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Nr(n)}
      }
    `;
  const c = r[0], u = r[1], d = Ao(s);
  return u === 1 ? t ? `
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    ` : `
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  ` : c === 1 ? t ? `
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    ` : `
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  ` : t ? `
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    ` : `
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${s}, uv);
  }
`;
}
function lX(n, t) {
  const e = n.shapeInfo.logicalShape, s = n.name, o = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = n.shapeInfo.texShape, i6 = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)];
  if (e[0] === 1) {
    const h6 = e.slice(1), p6 = [1, 2], f = Rr(n, h6), m = ["b", "row", "col"];
    return `
        ${kw(f, t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${$r(m, p6)});
        }
      `;
  }
  const a = ze$1();
  if (t)
    return `
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;
  const l = i6[0], c = i6[1], u = Math.ceil(e[2] / 2), d = u * Math.ceil(e[1] / 2);
  return `
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${u}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;
}
function cX(n, t) {
  const e = n.shapeInfo.logicalShape, s = n.name, o = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = e[1] * e[2], i6 = e[2], { newShape: a, keptDims: l } = gs(e), c = a;
  if (c.length < e.length) {
    const m = Rr(n, c), g6 = ["row", "col", "depth"];
    return `
        ${Tr(m, t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${$r(g6, l)});
        }
      `;
  }
  if (n.shapeInfo.isUniform)
    return `
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${i6}, 1)));
        ${Nr(n)}
      }
    `;
  const u = n.shapeInfo.texShape, d = u[0], h6 = u[1], p6 = n.shapeInfo.flatOffset;
  if (h6 === r && p6 == null)
    return t ? `
      float ${o}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    ` : `
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i6}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h6}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;
  if (h6 === i6 && p6 == null)
    return t ? `
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    ` : `
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h6}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;
  const f = Ao(s);
  return t ? `
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    ` : `
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${i6} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h6}, index);
        return sampleTexture(${s}, uv);
      }
  `;
}
function uX(n, t) {
  const e = n.name, s = "get" + e.charAt(0).toUpperCase() + e.slice(1), o = ze$1();
  if (t)
    return `
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;
  const r = n.shapeInfo.logicalShape, i6 = r.length, a = n.shapeInfo.texShape, l = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)], c = l[0], u = l[1], d = Math.ceil(r[i6 - 1] / 2);
  let h6 = d * Math.ceil(r[i6 - 2] / 2), p6 = "int b, int row, int col", f = `b * ${h6} + (row / 2) * ${d} + (col / 2)`;
  for (let m = 2; m < i6 - 1; m++)
    p6 = `int b${m}, ` + p6, h6 *= r[i6 - m - 1], f = `b${m} * ${h6} + ` + f;
  return `
    vec4 ${s}(${p6}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${o.texture2D}(${e}, uv);
    }
  `;
}
function dX(n, t) {
  const e = n.shapeInfo.logicalShape, s = n.name, o = "get" + s.charAt(0).toUpperCase() + s.slice(1), r = e[3], i6 = e[2] * r, a = e[1] * i6, { newShape: l, keptDims: c } = gs(e);
  if (l.length < e.length) {
    const x6 = Rr(n, l), w6 = ["row", "col", "depth", "depth2"];
    return `
      ${Tr(x6, t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${$r(w6, c)});
      }
    `;
  }
  if (n.shapeInfo.isUniform)
    return `
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i6}, ${r}, 1)));
        ${Nr(n)}
      }
    `;
  const u = n.shapeInfo.flatOffset, d = n.shapeInfo.texShape, h6 = d[0], p6 = d[1], f = `int stride2 = ${s}Shape[3];`, m = `int stride1 = ${s}Shape[2] * stride2;`, g6 = `int stride0 = ${s}Shape[1] * stride1;`;
  if (p6 === a && u == null)
    return t ? `
      float ${o}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    ` : `
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i6}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p6}.0, ${h6}.0);
        return sampleTexture(${s}, uv);
      }
    `;
  if (p6 === r && u == null)
    return t ? `
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    ` : `
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1] * e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p6}.0, ${h6}.0);
        return sampleTexture(${s}, uv);
      }
    `;
  const b6 = Ao(s);
  return t ? `
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g6}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b6});
      return sampleTexture(${s}, uv);
    }
  ` : `
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i6} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${h6}, ${p6}, index + ${b6});
      return sampleTexture(${s}, uv);
    }
  `;
}
function hX(n) {
  const t = n.shapeInfo.logicalShape, e = n.name, s = "get" + e.charAt(0).toUpperCase() + e.slice(1), o = t[4], r = t[3] * o, i6 = t[2] * r, a = t[1] * i6, { newShape: l, keptDims: c } = gs(t);
  if (l.length < t.length) {
    const m = Rr(n, l), g6 = ["row", "col", "depth", "depth2", "depth3"];
    return `
      ${Tr(m)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${$r(g6, c)});
      }
    `;
  }
  if (n.shapeInfo.isUniform)
    return `
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i6}, ${r}, ${o})) +
          depth3;
        ${Nr(n)}
      }
    `;
  const u = n.shapeInfo.flatOffset, d = n.shapeInfo.texShape, h6 = d[0], p6 = d[1];
  if (p6 === a && u == null)
    return `
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i6}, ${r}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p6}.0, ${h6}.0);
        return sampleTexture(${e}, uv);
      }
    `;
  if (p6 === o && u == null)
    return `
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3]},
               ${t[2] * t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p6}.0, ${h6}.0);
        return sampleTexture(${e}, uv);
      }
    `;
  const f = Ao(e);
  return `
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i6} + depth * ${r} +
          depth2 * ${o} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h6}, ${p6}, index);
      return sampleTexture(${e}, uv);
    }
  `;
}
function pX(n) {
  const t = n.shapeInfo.logicalShape, e = n.name, s = "get" + e.charAt(0).toUpperCase() + e.slice(1), { newShape: o, keptDims: r } = gs(t);
  if (o.length < t.length) {
    const g6 = Rr(n, o), b6 = ["row", "col", "depth", "depth2", "depth3", "depth4"];
    return `
      ${Tr(g6)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${$r(b6, r)});
      }
    `;
  }
  const i6 = t[5], a = t[4] * i6, l = t[3] * a, c = t[2] * l, u = t[1] * c;
  if (n.shapeInfo.isUniform)
    return `
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i6}, 1)));
        ${Nr(n)}
      }
    `;
  const d = n.shapeInfo.flatOffset, h6 = n.shapeInfo.texShape, p6 = h6[0], f = h6[1];
  if (f === u && d == null)
    return `
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${i6})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p6}.0);
        return sampleTexture(${e}, uv);
      }
    `;
  if (f === i6 && d == null)
    return `
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3] * t[4]},
               ${t[2] * t[3] * t[4]},
               ${t[3] * t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p6}.0);
        return sampleTexture(${e}, uv);
      }
    `;
  const m = Ao(e);
  return `
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i6} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p6}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `;
}
function Nr(n) {
  const t = n.name, e = O(n.shapeInfo.logicalShape);
  return e < 2 ? `return ${t};` : `
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `;
}
function fX(n, t) {
  const e = n.name, s = e.charAt(0).toUpperCase() + e.slice(1), o = "get" + s + "AtOutCoords", r = n.shapeInfo.logicalShape.length, i6 = t.logicalShape.length, a = Sw(n.shapeInfo.logicalShape, t.logicalShape), l = Kt(i6), c = i6 - r;
  let u;
  const d = ["x", "y", "z", "w", "u", "v"];
  r === 0 ? u = "" : i6 < 2 && a.length >= 1 ? u = "coords = 0;" : u = a.map((x6) => `coords.${d[x6 + c]} = 0;`).join(`
`);
  let h6 = "";
  i6 < 2 && r > 0 ? h6 = "coords" : h6 = n.shapeInfo.logicalShape.map((x6, w6) => `coords.${d[w6 + c]}`).join(", ");
  let p6 = "return outputValue;";
  const m = O(n.shapeInfo.logicalShape) === 1, b6 = O(t.logicalShape) === 1;
  if (r === 1 && !m && !b6)
    p6 = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
  else if (m && !b6)
    i6 === 1 ? p6 = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : p6 = `
        return vec4(outputValue.x);
      `;
  else if (a.length) {
    const x6 = r - 2, w6 = r - 1;
    a.indexOf(x6) > -1 && a.indexOf(w6) > -1 ? p6 = "return vec4(outputValue.x);" : a.indexOf(x6) > -1 ? p6 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : a.indexOf(w6) > -1 && (p6 = "return vec4(outputValue.xx, outputValue.zz);");
  }
  return `
    vec4 ${o}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${h6});
      ${p6}
    }
  `;
}
function mX(n, t) {
  const e = n.name, s = e.charAt(0).toUpperCase() + e.slice(1), o = "get" + s + "AtOutCoords", r = t.texShape, i6 = n.shapeInfo.texShape, a = n.shapeInfo.logicalShape.length, l = t.logicalShape.length;
  if (!n.shapeInfo.isUniform && a === l && n.shapeInfo.flatOffset == null && Rt$1(i6, r))
    return `
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;
  const c = Kt(l), u = Sw(n.shapeInfo.logicalShape, t.logicalShape), d = l - a;
  let h6;
  const p6 = ["x", "y", "z", "w", "u", "v"];
  a === 0 ? h6 = "" : l < 2 && u.length >= 1 ? h6 = "coords = 0;" : h6 = u.map((m) => `coords.${p6[m + d]} = 0;`).join(`
`);
  let f = "";
  return l < 2 && a > 0 ? f = "coords" : f = n.shapeInfo.logicalShape.map((m, g6) => `coords.${p6[g6 + d]}`).join(", "), `
    float ${o}() {
      ${c} coords = getOutputCoords();
      ${h6}
      return get${s}(${f});
    }
  `;
}
function Kt(n) {
  if (n <= 1)
    return "int";
  if (n === 2)
    return "ivec2";
  if (n === 3)
    return "ivec3";
  if (n === 4)
    return "ivec4";
  if (n === 5)
    return "ivec5";
  if (n === 6)
    return "ivec6";
  throw Error(`GPU for rank ${n} is not yet supported`);
}
function Xf$1(n, t, e) {
  const { newShape: s, keptDims: o } = gs(t), r = t.length, i6 = n && r === 3 && t[0] === 1, a = i6 ? t.slice(1) : s, l = !n && r > 1 && !Rt$1(t, e) && s.length < r || i6;
  return { useSqueezeShape: l, uniformShape: l ? a : t, keptDims: o };
}
function Rr(n, t) {
  const e = JSON.parse(JSON.stringify(n));
  return e.shapeInfo.logicalShape = t, e;
}
function $r(n, t) {
  return t.map((e) => n[e]).join(", ");
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gX(n, t, e, s) {
  const o = e.map((u, d) => {
    const h6 = {
      logicalShape: u.shape,
      texShape: u.isUniform ? null : u.texData.texShape,
      isUniform: u.isUniform,
      isPacked: u.isUniform ? false : u.texData.isPacked,
      flatOffset: null
    };
    return u.texData != null && u.texData.slice != null && u.texData.slice.flatOffset > 0 && (h6.flatOffset = u.texData.slice.flatOffset), { name: t.variableNames[d], shapeInfo: h6 };
  }), r = o.map((u) => u.shapeInfo), i6 = {
    logicalShape: s.shape,
    texShape: s.texData.texShape,
    isUniform: false,
    isPacked: s.texData.isPacked,
    flatOffset: null
  }, a = Wz(o, i6, t), l = cz(n.gl, a), c = n.createProgram(l);
  return F().get("ENGINE_COMPILE_ONLY") ? {
    program: t,
    fragmentShader: l,
    source: a,
    webGLProgram: c,
    inShapeInfos: r,
    outShapeInfo: i6,
    uniformLocations: null,
    customUniformLocations: null,
    infLoc: null,
    nanLoc: null,
    inShapesLocations: null,
    inTexShapesLocations: null,
    outShapeLocation: null,
    outShapeStridesLocation: null,
    outTexShapeLocation: null
  } : Object.assign({
    program: t,
    fragmentShader: l,
    source: a,
    webGLProgram: c,
    inShapeInfos: r,
    outShapeInfo: i6
  }, Nw(n, t, c));
}
function Nw(n, t, e) {
  const s = {}, o = {}, r = {}, i6 = [];
  let a, l, c, u = null, d = null;
  d = n.getUniformLocation(e, "NAN", false), F().getNumber("WEBGL_VERSION") === 1 && (u = n.getUniformLocation(e, "INFINITY", false));
  const h6 = false;
  for (let p6 = 0; p6 < t.variableNames.length; p6++) {
    const f = t.variableNames[p6];
    s[f] = n.getUniformLocation(e, f, h6), s[`offset${f}`] = n.getUniformLocation(e, `offset${f}`, h6), t.enableShapeUniforms && (o[`${f}Shape`] = n.getUniformLocation(e, `${f}Shape`, h6), r[`${f}TexShape`] = n.getUniformLocation(e, `${f}TexShape`, h6));
  }
  return t.enableShapeUniforms && (a = n.getUniformLocation(e, "outShape", h6), c = n.getUniformLocation(e, "outShapeStrides", h6), l = n.getUniformLocation(e, "outTexShape", h6)), t.customUniforms && t.customUniforms.forEach((p6, f) => {
    i6[f] = n.getUniformLocation(e, p6.name, h6);
  }), {
    uniformLocations: s,
    customUniformLocations: i6,
    infLoc: u,
    nanLoc: d,
    inShapesLocations: o,
    inTexShapesLocations: r,
    outShapeLocation: a,
    outShapeStridesLocation: c,
    outTexShapeLocation: l
  };
}
function qm(n, t) {
  if (n.length !== t.length)
    throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);
  n.forEach((e, s) => {
    const o = e.logicalShape, r = t[s], i6 = r.shape;
    if (!Rt$1(o, i6))
      throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i6} must match`);
    if (e.isUniform && r.isUniform)
      return;
    const a = e.texShape, l = r.isUniform ? null : r.texData.texShape;
    if (!Rt$1(a, l))
      throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`);
  });
}
function bX(n, t, e, s, o) {
  t.program.enableShapeUniforms || (qm(t.inShapeInfos, e), qm([t.outShapeInfo], [s]));
  const r = s.texData.texture, i6 = s.texData.texShape;
  s.texData.isPacked ? n.setOutputPackedMatrixTexture(r.texture, i6[0], i6[1]) : n.setOutputMatrixTexture(r.texture, i6[0], i6[1]), n.setProgram(t.webGLProgram), F().getNumber("WEBGL_VERSION") === 1 && t.infLoc !== null && n.gl.uniform1f(t.infLoc, 1 / 0), t.nanLoc !== null && n.gl.uniform1f(t.nanLoc, NaN), e.forEach((l, c) => {
    const u = t.program.variableNames[c], d = t.uniformLocations[u], h6 = t.uniformLocations[`offset${u}`], p6 = t.inShapesLocations[`${u}Shape`], f = t.inTexShapesLocations[`${u}TexShape`];
    if (p6) {
      const { uniformShape: m } = Xf$1(t.program.packedInputs, l.shape, l.texData.texShape);
      switch (m.length) {
        case 1:
          n.gl.uniform1iv(p6, new Int32Array(m));
          break;
        case 2:
          n.gl.uniform2iv(p6, new Int32Array(m));
          break;
        case 3:
          n.gl.uniform3iv(p6, new Int32Array(m));
          break;
        case 4:
          n.gl.uniform4iv(p6, new Int32Array(m));
          break;
      }
    }
    if (f && n.gl.uniform2i(f, l.texData.texShape[0], l.texData.texShape[1]), d != null) {
      if (l.isUniform) {
        if (O(l.shape) < 2)
          n.gl.uniform1f(d, l.uniformValues[0]);
        else {
          let m = l.uniformValues;
          m instanceof Float32Array || (m = new Float32Array(m)), n.gl.uniform1fv(d, m);
        }
        return;
      }
      l.texData.slice != null && h6 != null && n.gl.uniform1i(h6, l.texData.slice.flatOffset), n.setInputMatrixTexture(l.texData.texture.texture, d, c);
    }
  });
  const a = t.outShapeLocation;
  if (a)
    switch (s.shape.length) {
      case 1:
        n.gl.uniform1iv(a, new Int32Array(s.shape));
        break;
      case 2:
        n.gl.uniform2iv(a, new Int32Array(s.shape));
        break;
      case 3:
        n.gl.uniform3iv(a, new Int32Array(s.shape));
        break;
      case 4:
        n.gl.uniform4iv(a, new Int32Array(s.shape));
        break;
    }
  if (t.outShapeStridesLocation) {
    const l = dt(s.shape);
    switch (s.shape.length) {
      case 2:
        n.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(l));
        break;
      case 3:
        n.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(l));
        break;
      case 4:
        n.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(l));
        break;
    }
  }
  t.outTexShapeLocation && n.gl.uniform2i(t.outTexShapeLocation, s.texData.texShape[0], s.texData.texShape[1]), t.program.customUniforms && o && t.program.customUniforms.forEach((l, c) => {
    const u = t.customUniformLocations[c], d = o[c];
    if (l.type === "float")
      n.gl.uniform1fv(u, d);
    else if (l.type === "vec2")
      n.gl.uniform2fv(u, d);
    else if (l.type === "vec3")
      n.gl.uniform3fv(u, d);
    else if (l.type === "vec4")
      n.gl.uniform4fv(u, d);
    else if (l.type === "int")
      n.gl.uniform1iv(u, d);
    else if (l.type === "ivec2")
      n.gl.uniform2iv(u, d);
    else if (l.type === "ivec3")
      n.gl.uniform3iv(u, d);
    else if (l.type === "ivec4")
      n.gl.uniform4iv(u, d);
    else
      throw Error(`uniform type ${l.type} is not supported yet.`);
  }), n.executeProgram();
}
function xX(n, t, e) {
  let s = "";
  t.concat(e).forEach((i6) => {
    const a = i6.texData != null && i6.texData.slice != null && i6.texData.slice.flatOffset > 0;
    if (n.enableShapeUniforms && !i6.isUniform) {
      const l = i6.texData.texShape, { useSqueezeShape: c, uniformShape: u, keptDims: d } = Xf$1(n.packedInputs, i6.shape, l);
      let h6 = "", p6 = "", f = "";
      if (u.length === 1 && n.packedInputs) {
        const I = [Math.ceil(l[0] / 2), Math.ceil(l[1] / 2)];
        h6 = `${I[0] > 1}_${I[1] > 1}`;
      } else if (u.length === 2 && !n.packedInputs)
        p6 = `${u[0] > 1}_${u[1] > 1}`;
      else if (u.length > 2 && !n.packedInputs) {
        const I = dt(u);
        f = `${I[0] === l[1]}_${I[I.length - 1] === l[1]}`;
      }
      const m = i6.shape.length, g6 = u.length === 2 && Rt$1(i6.shape, l), b6 = O(i6.shape) === 1, x6 = vo(i6.shape, e.shape), w6 = !n.packedInputs && m === e.shape.length && Rt$1(l, e.texData.texShape), y6 = n.packedInputs || u.length > 2 ? "" : `${l[0] > 1}_${l[1] > 1}`;
      s += `${m}_${w6}_${c ? d : ""}_${u.length}_${b6}_${x6}_${g6}_${h6}_${p6}_${f}_${y6}_${a}`;
    } else {
      const l = i6.isUniform ? "uniform" : i6.texData.texShape;
      s += `${i6.shape}_${l}_${a}`;
    }
  });
  const o = n.userCode;
  let r = n.constructor.name;
  return r += "_" + s + "_" + o + `${F().getNumber("WEBGL_VERSION")}`, r;
}
function Xe(n) {
  return F().getBool("WEBGL_USE_SHAPES_UNIFORMS") && n <= 4;
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class yX {
  constructor(t) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = ii$1.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const e = ze$1();
    this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? du(["r", "c", "d"], t) : Po(["r", "c", "d"], t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class wX {
  constructor(t) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = ii$1.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const e = ze$1();
    this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? du(["r", "c", "d"], t) : Po(["r", "c", "d"], t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class IX {
  constructor(t) {
    this.variableNames = ["A"], this.outTexUsage = ln$1.DOWNLOAD;
    const e = ze$1();
    this.outputShape = t, this.userCode = `
      ${vw}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class CX {
  constructor(t) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = ln$1.DOWNLOAD;
    const e = ze$1();
    this.outputShape = t, this.userCode = `
      ${vw}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const vX = {
  R: 0,
  G: 1,
  B: 2,
  A: 3
};
let tg$1 = class tg {
  constructor(t, e = false, s = "RGBA") {
    this.variableNames = ["A"], this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const o = ze$1();
    this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length);
    let r = "result";
    e && (r = "floor(result * 255. + 0.5)");
    let i6 = "";
    for (let a = 0; a < s.length; a++) {
      const l = s[a];
      i6 += `
          if(offset == ${a}) {
            result = values[${vX[l]}];
          }`;
    }
    this.userCode = `
      ${this.enableShapeUniforms ? zf$1() : Vf$1(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i6}
        }
        ${o.output} = vec4(${r}, 0., 0., 0.);
      }
    `;
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class SX {
  constructor(t, e = false) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const s = ze$1();
    this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length);
    let o = "", r = "result";
    e && (r = "floor(result * 255. + 0.5)");
    for (let i6 = 0; i6 <= 1; i6++)
      for (let a = 0; a <= 1; a++) {
        const l = i6 * 2 + a;
        o += `
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms ? "outShape[2]" : `${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i6} < ${this.enableShapeUniforms ? "outShape[1]" : `${t[1]}`}) {
            localCoords[1] += ${i6};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `;
      }
    this.userCode = `
        ${this.enableShapeUniforms ? zf$1() : Vf$1(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${s.output} = ${r};
        }
    `;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kX(n) {
  const t = ze$1(), e = `${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
  return lz(n, e);
}
function TX(n) {
  const t = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
  return pz(n, t);
}
function NX(n) {
  const t = new Uint16Array([0, 1, 2, 2, 1, 3]);
  return fz(n, t);
}
function Ra(n, t, e, s, o, r) {
  gz(t, e);
  const i6 = mz(n), a = n.TEXTURE_2D;
  return ot(n, () => n.bindTexture(a, i6)), ot(n, () => n.texParameteri(a, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE)), ot(n, () => n.texParameteri(a, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE)), ot(n, () => n.texParameteri(a, n.TEXTURE_MIN_FILTER, n.NEAREST)), ot(n, () => n.texParameteri(a, n.TEXTURE_MAG_FILTER, n.NEAREST)), F().getNumber("WEBGL_VERSION") === 1 ? ot(n, () => n.texImage2D(a, 0, s, t, e, 0, o, r, null)) : ot(n, () => n.texStorage2D(a, 1, s, t, e)), ot(n, () => n.bindTexture(n.TEXTURE_2D, null)), { texture: i6, texShape: [e, t] };
}
function Rw(n) {
  return n.internalFormatFloat;
}
function RX(n, t, e, s) {
  const [o, r] = Ta(t, e);
  return Ra(n, o, r, Rw(s), s.textureFormatFloat, n.FLOAT);
}
function $w(n) {
  return n.internalFormatHalfFloat;
}
function $X(n, t, e, s) {
  const [o, r] = Ta(t, e);
  return Ra(n, o, r, $w(s), s.textureFormatFloat, s.textureTypeHalfFloat);
}
function Gw(n) {
  return n.downloadTextureFormat;
}
function GX(n, t, e, s) {
  const [o, r] = Ta(t, e);
  return Ra(n, o, r, Gw(s), n.RGBA, n.UNSIGNED_BYTE);
}
function Ew(n) {
  return n.internalFormatPackedFloat;
}
function EX(n, t, e, s) {
  const [o, r] = kr(t, e);
  return Ra(n, o, r, Ew(s), n.RGBA, n.FLOAT);
}
function Lw(n) {
  return n.internalFormatPackedHalfFloat;
}
function LX(n, t, e, s) {
  const [o, r] = kr(t, e);
  return Ra(n, o, r, Lw(s), n.RGBA, s.textureTypeHalfFloat);
}
function MX(n, t, e) {
  return ot(n, () => n.bindBuffer(n.ARRAY_BUFFER, e)), Qm(n, t, "clipSpacePos", e, 3, 20, 0) && Qm(n, t, "uv", e, 2, 20, 12);
}
function WX(n, t, e, s, o, r) {
  ot(n, () => n.bindTexture(n.TEXTURE_2D, t));
  let i6, a, l;
  o instanceof Uint8Array ? (i6 = new Uint8Array(e * s * 4), a = n.UNSIGNED_BYTE, l = n.RGBA) : (i6 = new Float32Array(e * s * 4), a = n.FLOAT, l = r.internalFormatPackedFloat), i6.set(o), F().getNumber("WEBGL_VERSION") === 2 ? ot(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e, s, n.RGBA, a, i6)) : ot(n, () => n.texImage2D(n.TEXTURE_2D, 0, l, e, s, 0, n.RGBA, a, i6)), ot(n, () => n.bindTexture(n.TEXTURE_2D, null));
}
function DX(n, t, e) {
  ot(n, () => n.bindTexture(n.TEXTURE_2D, t)), e.data instanceof Uint8Array ? F().getNumber("WEBGL_VERSION") === 2 ? ot(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.width, e.height, n.RGBA, n.UNSIGNED_BYTE, e.data)) : ot(n, () => n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, e.width, e.height, 0, n.RGBA, n.UNSIGNED_BYTE, e.data)) : F().getNumber("WEBGL_VERSION") === 2 ? ot(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, e)) : ot(n, () => n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, e)), ot(n, () => n.bindTexture(n.TEXTURE_2D, null));
}
function FX(n, t, e, s) {
  const o = n.createBuffer();
  ot(n, () => n.bindBuffer(n.PIXEL_PACK_BUFFER, o));
  const a = 4 * 4 * t * e;
  return ot(n, () => n.bufferData(n.PIXEL_PACK_BUFFER, a, n.STREAM_READ)), ot(n, () => n.readPixels(0, 0, e, t, n.RGBA, n.FLOAT, 0)), ot(n, () => n.bindBuffer(n.PIXEL_PACK_BUFFER, null)), o;
}
function VX(n, t, e) {
  const s = n, o = new Float32Array(e);
  return s.bindBuffer(s.PIXEL_PACK_BUFFER, t), s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, o), s.bindBuffer(s.PIXEL_PACK_BUFFER, null), o;
}
function zX(n, t, e, s) {
  const [o, r] = Ta(t, e), i6 = 4, a = new Uint8Array(ez(t * e, i6));
  return ot(n, () => n.readPixels(0, 0, o, r, s.downloadTextureFormat, n.UNSIGNED_BYTE, a)), new Float32Array(a.buffer);
}
function XX(n, t, e, s, o, r, i6, a) {
  const l = n, c = new Float32Array(nz(r, i6));
  return l.bindBuffer(l.PIXEL_PACK_BUFFER, t), l.getBufferSubData(l.PIXEL_PACK_BUFFER, 0, c), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), c;
}
function PX(n, t, e) {
  const s = new Float32Array(t * e * 4);
  return ot(n, () => n.readPixels(0, 0, e, t, n.RGBA, n.FLOAT, s)), s;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Wu {
  constructor(t) {
    this.outputTexture = null, this.program = null, this.disposed = false, this.itemsToPoll = [];
    const e = F().getNumber("WEBGL_VERSION");
    if (t != null ? (this.gl = t, jV(e, t)) : this.gl = Zn$1(e), t = this.gl, F().getNumber("WEBGL_VERSION") === 2) {
      const r = t;
      this.createVertexArray = () => ot(r, () => r.createVertexArray()), this.bindVertexArray = (i6) => ot(r, () => r.bindVertexArray(i6)), this.deleteVertexArray = (i6) => ot(r, () => r.deleteVertexArray(i6)), this.getVertexArray = () => ot(r, () => r.getParameter(r.VERTEX_ARRAY_BINDING));
    } else if (t != null) {
      const r = t.getExtension("OES_vertex_array_object");
      if (r == null)
        throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
      this.createVertexArray = () => ot(t, () => r.createVertexArrayOES()), this.bindVertexArray = (i6) => ot(t, () => r.bindVertexArrayOES(i6)), this.deleteVertexArray = (i6) => ot(t, () => r.deleteVertexArrayOES(i6)), this.getVertexArray = () => ot(t, () => t.getParameter(r.VERTEX_ARRAY_BINDING_OES));
    }
    let s = "WEBGL_color_buffer_float";
    const o = "EXT_color_buffer_half_float";
    if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), F().getNumber("WEBGL_VERSION") === 1) {
      const r = "OES_texture_float", i6 = "OES_texture_half_float";
      if (this.textureFloatExtension = Aa(this.gl, r), vn$1(this.gl, i6))
        this.textureHalfFloatExtension = Aa(this.gl, i6);
      else if (F().get("WEBGL_FORCE_F16_TEXTURES"))
        throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(s), vn$1(this.gl, o))
        this.colorBufferHalfFloatExtension = Aa(this.gl, o);
      else if (F().get("WEBGL_FORCE_F16_TEXTURES"))
        throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (s = "EXT_color_buffer_float", vn$1(this.gl, s))
      this.colorBufferFloatExtension = this.gl.getExtension(s);
    else if (vn$1(this.gl, o))
      this.colorBufferHalfFloatExtension = this.gl.getExtension(o);
    else
      throw new Error("GL context does not support color renderable floats");
    this.vertexBuffer = TX(this.gl), this.indexBuffer = NX(this.gl), this.framebuffer = bz(this.gl), this.textureConfig = Ff$1(this.gl, this.textureHalfFloatExtension);
  }
  get debug() {
    return F().getBool("DEBUG");
  }
  dispose() {
    if (this.disposed)
      return;
    this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
    const t = this.gl;
    ot(t, () => t.finish()), ot(t, () => t.bindFramebuffer(t.FRAMEBUFFER, null)), ot(t, () => t.deleteFramebuffer(this.framebuffer)), ot(t, () => t.bindBuffer(t.ARRAY_BUFFER, null)), ot(t, () => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)), ot(t, () => t.deleteBuffer(this.indexBuffer)), this.disposed = true;
  }
  createFloat32MatrixTexture(t, e) {
    return this.throwIfDisposed(), RX(this.gl, t, e, this.textureConfig);
  }
  createFloat16MatrixTexture(t, e) {
    return this.throwIfDisposed(), $X(this.gl, t, e, this.textureConfig);
  }
  createUnsignedBytesMatrixTexture(t, e) {
    return this.throwIfDisposed(), GX(this.gl, t, e, this.textureConfig);
  }
  uploadPixelDataToTexture(t, e) {
    this.throwIfDisposed(), DX(this.gl, t, e);
  }
  uploadDenseMatrixToTexture(t, e, s, o) {
    this.throwIfDisposed(), WX(this.gl, t, e, s, o, this.textureConfig);
  }
  createFloat16PackedMatrixTexture(t, e) {
    return this.throwIfDisposed(), LX(this.gl, t, e, this.textureConfig);
  }
  createPackedMatrixTexture(t, e) {
    return this.throwIfDisposed(), EX(this.gl, t, e, this.textureConfig);
  }
  deleteMatrixTexture(t) {
    this.throwIfDisposed(), this.outputTexture === t && (Jm(this.gl, this.framebuffer), this.outputTexture = null), ot(this.gl, () => this.gl.deleteTexture(t));
  }
  downloadByteEncodedFloatMatrixFromOutputTexture(t, e, s) {
    return this.downloadMatrixDriver(t, () => zX(this.gl, e, s, this.textureConfig));
  }
  downloadPackedMatrixFromBuffer(t, e, s, o, r, i6) {
    return XX(this.gl, t, e, s, o, r, i6, this.textureConfig);
  }
  downloadFloat32MatrixFromBuffer(t, e) {
    return VX(this.gl, t, e);
  }
  createBufferFromTexture(t, e, s) {
    this.bindTextureToFrameBuffer(t);
    const o = FX(this.gl, e, s, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), o;
  }
  createAndWaitForFence() {
    const t = this.createFence(this.gl);
    return this.pollFence(t);
  }
  createFence(t) {
    let e, s;
    if (F().getBool("WEBGL_FENCE_API_ENABLED")) {
      const o = t, r = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
      t.flush(), s = () => {
        const i6 = o.clientWaitSync(r, 0, 0);
        return i6 === o.ALREADY_SIGNALED || i6 === o.CONDITION_SATISFIED;
      }, e = r;
    } else
      F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(), this.endQuery(), s = () => this.isQueryAvailable(e, F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : s = () => true;
    return { query: e, isFencePassed: s };
  }
  downloadMatrixFromPackedTexture(t, e, s) {
    return this.downloadMatrixDriver(t, () => PX(this.gl, e, s));
  }
  createProgram(t) {
    this.throwIfDisposed();
    const e = this.gl;
    this.vertexShader == null && (this.vertexShader = kX(e));
    const s = dz(e);
    ot(e, () => e.attachShader(s, this.vertexShader)), ot(e, () => e.attachShader(s, t)), hz(e, s);
    let o;
    return o = Object.assign(s, {
      vao: this.createVertexArray()
    }), this.bindVertexArray(o.vao), ot(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer)), console.assert(MX(e, o, this.vertexBuffer), "gpgpu_util.bindVertexProgramAttributeStreams not fully successful."), this.debug && Gu(e, o), this.setProgram(o), o;
  }
  deleteProgram(t) {
    this.throwIfDisposed(), t === this.program && (this.program = null), t != null && (ot(this.gl, () => this.gl.deleteProgram(t)), this.deleteVertexArray(t.vao));
  }
  setProgram(t) {
    this.throwIfDisposed(), this.program = t, this.program != null && (this.bindVertexArray(this.program.vao), this.debug && Gu(this.gl, this.program)), ot(this.gl, () => this.gl.useProgram(t));
  }
  getUniformLocation(t, e, s = true) {
    return this.throwIfDisposed(), s ? yz(this.gl, t, e) : wz(this.gl, t, e);
  }
  getAttributeLocation(t, e) {
    return this.throwIfDisposed(), ot(this.gl, () => this.gl.getAttribLocation(t, e));
  }
  getUniformLocationNoThrow(t, e) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);
  }
  setInputMatrixTexture(t, e, s) {
    this.throwIfDisposed(), this.throwIfNoProgram(), Iz(this.gl, t, e, s);
  }
  setOutputMatrixTexture(t, e, s) {
    this.setOutputMatrixTextureDriver(t, s, e);
  }
  setOutputPackedMatrixTexture(t, e, s) {
    this.throwIfDisposed();
    const [o, r] = kr(e, s);
    this.setOutputMatrixTextureDriver(t, o, r);
  }
  setOutputMatrixWriteRegion(t, e, s, o) {
    this.setOutputMatrixWriteRegionDriver(s, t, o, e);
  }
  setOutputPackedMatrixWriteRegion(t, e, s, o) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }
  debugValidate() {
    this.program != null && Gu(this.gl, this.program), Oa(this.gl);
  }
  executeProgram() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    const t = this.gl;
    if (this.debug) {
      const e = this.getVertexArray();
      console.assert(e === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate();
    }
    ot(t, () => t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0));
  }
  blockUntilAllProgramsCompleted() {
    this.throwIfDisposed(), ot(this.gl, () => this.gl.finish());
  }
  getQueryTimerExtension() {
    return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = Aa(this.gl, F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }
  getQueryTimerExtensionWebGL2() {
    return this.getQueryTimerExtension();
  }
  getQueryTimerExtensionWebGL1() {
    return this.getQueryTimerExtension();
  }
  beginQuery() {
    if (F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const s = this.gl, o = this.getQueryTimerExtensionWebGL2(), r = s.createQuery();
      return s.beginQuery(o.TIME_ELAPSED_EXT, r), r;
    }
    const t = this.getQueryTimerExtensionWebGL1(), e = t.createQueryEXT();
    return t.beginQueryEXT(t.TIME_ELAPSED_EXT, e), e;
  }
  endQuery() {
    if (F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const e = this.gl, s = this.getQueryTimerExtensionWebGL2();
      e.endQuery(s.TIME_ELAPSED_EXT);
      return;
    }
    const t = this.getQueryTimerExtensionWebGL1();
    t.endQueryEXT(t.TIME_ELAPSED_EXT);
  }
  async waitForQueryAndGetTime(t) {
    return await td(() => this.disposed || // while testing contexts are created / disposed
    // in rapid succession, so without this check we
    // may poll for the query timer indefinitely
    this.isQueryAvailable(t, F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(t, F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
  }
  getQueryTime(t, e) {
    if (e === 0)
      return null;
    if (e === 2) {
      const s = this.gl;
      return s.getQueryParameter(t, s.QUERY_RESULT) / 1e6;
    } else {
      const s = this.getQueryTimerExtensionWebGL1();
      return s.getQueryObjectEXT(t, s.QUERY_RESULT_EXT) / 1e6;
    }
  }
  isQueryAvailable(t, e) {
    if (e === 0)
      return true;
    if (e === 2) {
      const s = this.gl, o = this.getQueryTimerExtensionWebGL2(), r = s.getQueryParameter(t, s.QUERY_RESULT_AVAILABLE);
      return this.disjoint == null && (this.disjoint = this.gl.getParameter(o.GPU_DISJOINT_EXT)), r && !this.disjoint;
    } else {
      const s = this.getQueryTimerExtensionWebGL1(), o = s.getQueryObjectEXT(t, s.QUERY_RESULT_AVAILABLE_EXT);
      return this.disjoint == null && (this.disjoint = this.gl.getParameter(s.GPU_DISJOINT_EXT)), o && !this.disjoint;
    }
  }
  pollFence(t) {
    return new Promise((e) => {
      this.addItemToPoll(() => t.isFencePassed(), () => e());
    });
  }
  pollItems() {
    const t = AX(this.itemsToPoll.map((e) => e.isDoneFn));
    for (let e = 0; e <= t; ++e) {
      const { resolveFn: s } = this.itemsToPoll[e];
      s();
    }
    this.itemsToPoll = this.itemsToPoll.slice(t + 1);
  }
  addItemToPoll(t, e) {
    if (this.itemsToPoll.push({ isDoneFn: t, resolveFn: e }), this.itemsToPoll.length > 1)
      return;
    let s;
    "setTimeoutCustom" in F().platform && (s = F().platform.setTimeoutCustom.bind(F().platform)), td(() => (this.pollItems(), this.itemsToPoll.length === 0), () => 0, null, s);
  }
  bindTextureToFrameBuffer(t) {
    this.throwIfDisposed(), Eu(this.gl, t, this.framebuffer), this.debug && Oa(this.gl);
  }
  unbindTextureToFrameBuffer() {
    this.outputTexture != null ? (Eu(this.gl, this.outputTexture, this.framebuffer), this.debug && Oa(this.gl)) : Jm(this.gl, this.framebuffer);
  }
  downloadMatrixDriver(t, e) {
    this.bindTextureToFrameBuffer(t);
    const s = e();
    return this.unbindTextureToFrameBuffer(), s;
  }
  setOutputMatrixTextureDriver(t, e, s) {
    this.throwIfDisposed();
    const o = this.gl;
    Eu(o, t, this.framebuffer), this.debug && Oa(o), this.outputTexture = t, ot(o, () => o.viewport(0, 0, e, s)), ot(o, () => o.scissor(0, 0, e, s));
  }
  setOutputMatrixWriteRegionDriver(t, e, s, o) {
    this.throwIfDisposed(), ot(this.gl, () => this.gl.scissor(t, e, s, o));
  }
  throwIfDisposed() {
    if (this.disposed)
      throw new Error("Attempted to use disposed GPGPUContext.");
  }
  throwIfNoProgram() {
    if (this.program == null)
      throw new Error("No GPU program is currently set.");
  }
}
function AX(n) {
  let t = 0;
  for (; t < n.length && n[t](); ++t)
    ;
  return t - 1;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const { addImpl: OX, bincountImpl: Mw, bincountReduceImpl: KX, castImpl: ZX, ceilImpl: BX, concatImpl: HX, equalImpl: _X, expImpl: UX, expm1Impl: YX, floorImpl: QX, gatherNdImpl: JX, gatherV2Impl: jX, greaterImpl: qX, greaterEqualImpl: tP, lessImpl: eP, lessEqualImpl: nP, linSpaceImpl: sP, logImpl: oP, maxImpl: rP, maximumImpl: iP, minimumImpl: aP, multiplyImpl: lP, negImpl: cP, notEqualImpl: uP, prodImpl: dP, raggedGatherImpl: hP, raggedRangeImpl: pP, raggedTensorToTensorImpl: fP, rangeImpl: mP, rsqrtImpl: gP, scatterImpl: bP, sigmoidImpl: xP, simpleAbsImpl: Ww, sliceImpl: yP, sparseFillEmptyRowsImpl: wP, sparseReshapeImpl: IP, sparseSegmentReductionImpl: Dw, sqrtImpl: CP, stridedSliceImpl: vP, stringNGramsImpl: SP, stringSplitImpl: kP, stringToHashBucketFastImpl: TP, subImpl: NP, tileImpl: RP, topKImpl: $P, transposeImpl: Pf$1, uniqueImpl: GP } = F3;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fw(n, t) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, t).map((e) => `${n}.${e}`);
}
function We$1(n, t) {
  return t === 1 ? [n] : Fw(n, t);
}
function EP(n, t) {
  if (n === 1)
    return "rc";
  let e = "";
  for (let s = 0; s < n; s++)
    e += t[s], s < n - 1 && (e += ",");
  return e;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class LP {
  constructor(t) {
    if (this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = t, this.rank = t.length, this.enableShapeUniforms = Xe(this.outputShape.length), this.rank === 0)
      this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
    else {
      const e = We$1("rc", this.rank), s = Kt(this.rank), o = this.getOutOfBoundsCondition(e), r = this.getSetup(e), i6 = this.getOutput(e);
      this.userCode = `
        void main() {
          ${s} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${i6}));
          }
        }
      `;
    }
  }
  getSourceCoordsArr(t) {
    const e = [];
    for (let s = 0; s <= 1; s++)
      for (let o = 0; o <= 1; o++) {
        let r = `${s === 0 ? "r" : "rp1"}, ${o === 0 ? "c" : "cp1"}`;
        for (let i6 = 2; i6 < this.rank; i6++)
          r = `${t[t.length - 1 - i6]},` + r;
        e.push(r);
      }
    return e;
  }
  getOutOfBoundsCondition(t) {
    if (this.rank === 1)
      return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
    let e = "";
    for (let s = this.rank - 2; s < this.rank; s++)
      e += `${t[s]} >= ${this.enableShapeUniforms ? `outShape[${s}]` : this.outputShape[s]}`, s < this.rank - 1 && (e += "||");
    return e;
  }
  getSetup(t) {
    if (this.rank === 1)
      return "";
    const e = t.slice(-2), s = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1], o = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
    return `
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${o};
    `;
  }
  getOutput(t) {
    const e = this.getSourceCoordsArr(t);
    return this.rank === 1 ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Vw {
  constructor(t, e) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec3" }], this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length);
    let s = "";
    for (let o = 0; o < 4; o++) {
      let r = "thisRC = rc;";
      o % 2 === 1 && (r += "thisRC.z += 1;"), o > 1 && (r += "thisRC.y += 1;"), s += `
        ${r}
        ${o > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o > 0 ? "}" : ""}
      `;
    }
    this.userCode = `
      ${MP(e, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? zf$1() : Vf$1(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : t[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : t[2]};

        ${s}

        setOutput(result);
      }
    `;
  }
}
function MP(n, t) {
  return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t ? Mz(["r", "c", "d"], "inputShape") : Po(["r", "c", "d"], n)}
      return ivec3(r, c, d);
    }
  `;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class WP {
  constructor(t) {
    this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.logEnabled = false, this.usedTextures = {};
  }
  acquireTexture(t, e, s) {
    const o = ng$1(e, s), r = sg$1(t, o, s);
    r in this.freeTextures || (this.freeTextures[r] = []), r in this.usedTextures || (this.usedTextures[r] = []);
    const i6 = eg$1(t, o, this.gpgpu.gl, this.gpgpu.textureConfig, s);
    if (this.freeTextures[r].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= i6, this.log();
      const l = this.freeTextures[r].shift();
      return this.usedTextures[r].push(l), l;
    }
    let a;
    return o === ve.PACKED_2X2_FLOAT32 ? a = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === ve.PACKED_2X2_FLOAT16 ? a = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === ve.UNPACKED_FLOAT32 ? a = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === ve.UNPACKED_FLOAT16 ? a = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === ve.PACKED_4X1_UNSIGNED_BYTE && (a = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[r].push(a), this.numUsedTextures++, this._numBytesAllocated += i6, this.log(), a;
  }
  releaseTexture(t, e, s, o) {
    if (this.freeTextures == null)
      return;
    const r = ng$1(s, o), i6 = sg$1(e, r, o);
    i6 in this.freeTextures || (this.freeTextures[i6] = []);
    const a = eg$1(e, r, this.gpgpu.gl, this.gpgpu.textureConfig, o), l = F().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
    l !== -1 && this._numBytesAllocated > l ? (this.gpgpu.deleteMatrixTexture(t.texture), this._numBytesAllocated -= a) : (this.freeTextures[i6].push(t), this.numFreeTextures++, this._numBytesFree += a), this.numUsedTextures--;
    const c = this.usedTextures[i6], u = c.indexOf(t);
    if (u < 0)
      throw new Error("Cannot release a texture that was never provided by this texture manager");
    c.splice(u, 1), this.log();
  }
  log() {
    if (!this.logEnabled)
      return;
    const t = this.numFreeTextures + this.numUsedTextures;
    console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${t})`);
    const e = this._numBytesFree / this._numBytesAllocated;
    console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * e)}%)`);
  }
  get numBytesAllocated() {
    return this._numBytesAllocated;
  }
  get numBytesFree() {
    return this._numBytesFree;
  }
  getNumUsedTextures() {
    return this.numUsedTextures;
  }
  getNumFreeTextures() {
    return this.numFreeTextures;
  }
  dispose() {
    if (this.freeTextures != null) {
      for (const t in this.freeTextures)
        this.freeTextures[t].forEach((e) => {
          this.gpgpu.deleteMatrixTexture(e.texture);
        });
      for (const t in this.usedTextures)
        this.usedTextures[t].forEach((e) => {
          this.gpgpu.deleteMatrixTexture(e.texture);
        });
      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
    }
  }
}
function DP(n, t) {
  const e = n;
  if (t === e.R32F)
    return 4;
  if (t === e.R16F)
    return 2;
  if (t === e.RGBA32F)
    return 16;
  if (t === n.RGBA)
    return 16;
  if (t === e.RGBA16F)
    return 8;
  if (t === e.RGBA8)
    return 4;
  throw new Error(`Unknown internal format ${t}`);
}
function eg$1(n, t, e, s, o) {
  const r = FP(t, s);
  let i6;
  if (o) {
    const [l, c] = kr(n[0], n[1]);
    i6 = l * c;
  } else {
    const [l, c] = Ta(n[0], n[1]);
    i6 = l * c;
  }
  const a = DP(e, r);
  return i6 * a;
}
function FP(n, t) {
  switch (n) {
    case ve.PACKED_2X2_FLOAT32:
      return Ew(t);
    case ve.PACKED_2X2_FLOAT16:
      return Lw(t);
    case ve.UNPACKED_FLOAT32:
      return Rw(t);
    case ve.UNPACKED_FLOAT16:
      return $w(t);
    case ve.PACKED_4X1_UNSIGNED_BYTE:
      return Gw(t);
    default:
      throw new Error(`Unknown physical texture type ${n}`);
  }
}
function VP(n) {
  return F().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? n ? ve.PACKED_2X2_FLOAT32 : ve.UNPACKED_FLOAT32 : n ? ve.PACKED_2X2_FLOAT16 : ve.UNPACKED_FLOAT16;
}
function ng$1(n, t) {
  if (n === ln$1.UPLOAD)
    return ve.PACKED_2X2_FLOAT32;
  if (n === ln$1.RENDER || n == null)
    return VP(t);
  if (n === ln$1.DOWNLOAD || n === ln$1.PIXELS)
    return ve.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error(`Unknown logical texture type ${n}`);
}
function sg$1(n, t, e) {
  return `${n[0]}_${n[1]}_${t}_${e}`;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let qn$1 = class qn {
  constructor(t, e) {
    this.variableNames = ["A"], this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length), this.userCode = `
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
};
const En$1 = "if (isnan(x)) return x;", zP = "return x;", og$1 = "return abs(x);", XP = "return (x >= 0.0) ? x : (exp(x) - 1.0);", PP = En$1 + `
  return (x < 0.0) ? 0.0 : x;
`, AP = En$1 + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, Ns = "return x;", OP = "return 1.0 / (1.0 + exp(-1.0 * x));";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KP = "return x;", ZP = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, BP = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, HP = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, _P = "return 1.0 / (1.0 + exp(-1.0 * x));";
class Ls {
  constructor(t, e) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length), this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class UP {
  constructor(t) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length);
    const e = t.length, s = We$1("rc", e), o = Kt(e), r = EP(e, s), i6 = s.slice(-2), a = e <= 1 ? "rc" : `vec2(${i6.join(",")})`;
    this.userCode = `
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${a}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YP = t0, QP = 1e-7, JP = 1e-4, Ba = {};
function jP(n) {
  return n in Ba || (Ba[n] = {}), Ba[n];
}
const qP = F().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"), tA = 600;
function eA() {
  return F().global.screen == null ? 1024 : F().global.screen.height * F().global.screen.width * window.devicePixelRatio * tA / 1024 / 1024;
}
class hu extends Xd$1 {
  constructor(t) {
    if (super(), this.pendingRead = /* @__PURE__ */ new WeakMap(), this.pendingDisposal = /* @__PURE__ */ new WeakSet(), this.dataRefCount = /* @__PURE__ */ new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = false, this.pendingDeletes = 0, this.disposed = false, !F().getBool("HAS_WEBGL"))
      throw new Error("WebGL is not supported on this device");
    let e;
    if (t != null) {
      if (t instanceof Wu)
        e = t;
      else {
        const s = Zn$1(F().getNumber("WEBGL_VERSION"), t);
        e = new Wu(s);
      }
      this.binaryCache = {}, this.gpgpuCreatedLocally = false;
    } else {
      const s = Zn$1(F().getNumber("WEBGL_VERSION"));
      e = new Wu(s), this.binaryCache = jP(F().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = true;
    }
    this.gpgpu = e, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new WP(this.gpgpu), this.numMBBeforeWarning = eA(), this.texData = new Mg$1(this, Xt());
  }
  nextDataId() {
    return hu.nextDataId++;
  }
  numDataIds() {
    return this.texData.numDataIds() - this.pendingDeletes;
  }
  // Writes a new entry to the data store with a WebGL texture, and registers it
  // to the texture manager.
  writeTexture(t, e, s, o, r, i6) {
    const a = this.makeTensorInfo(e, s), l = this.texData.get(a.dataId);
    l.isPacked = false, l.texture = { texture: t, texShape: [o, r] }, l.texShape = [o, r];
    const c = Ka(e), u = new tg$1(c, false, i6), d = this.runWebGLProgram(u, [a], s, [[o, r]]);
    return d.shape = e, l.texture = null, this.disposeIntermediateTensorInfo(a), d.dataId;
  }
  write(t, e, s) {
    if ((F().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || F().getBool("DEBUG")) && this.checkNumericalProblems(t), s === "complex64" && t != null)
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    const o = { id: this.nextDataId() };
    return this.texData.set(o, { shape: e, dtype: s, values: t, usage: ln$1.UPLOAD, refCount: 1 }), o;
  }
  /** Return refCount of a `TensorData`. */
  refCount(t) {
    return this.texData.has(t) ? this.texData.get(t).refCount : 0;
  }
  /** Increase refCount of a `TextureData`. */
  incRef(t) {
    const e = this.texData.get(t);
    e.refCount++;
  }
  /** Decrease refCount of a `TextureData`. */
  decRef(t) {
    if (this.texData.has(t)) {
      const e = this.texData.get(t);
      e.refCount--;
    }
  }
  move(t, e, s, o, r) {
    if (F().getBool("DEBUG") && this.checkNumericalProblems(e), o === "complex64")
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(t, { shape: s, dtype: o, values: e, usage: ln$1.UPLOAD, refCount: r });
  }
  disposeIntermediateTensorInfo(t) {
    this.disposeData(t.dataId);
  }
  readSync(t) {
    const e = this.texData.get(t), { values: s, dtype: o, complexTensorInfos: r, slice: i6, shape: a, isPacked: l } = e;
    if (i6 != null) {
      let h6;
      l ? h6 = new Ls(a, Ns) : h6 = new qn$1(a, Ns);
      const p6 = this.runWebGLProgram(h6, [{ dataId: t, shape: a, dtype: o }], o), f = this.readSync(p6.dataId);
      return this.disposeIntermediateTensorInfo(p6), f;
    }
    if (s != null)
      return this.convertAndCacheOnCPU(t);
    if (o === "string")
      return s;
    const c = this.activeTimers != null;
    let u;
    c && (u = Ce$1());
    let d;
    if (o === "complex64") {
      const h6 = this.readSync(r.real.dataId), p6 = this.readSync(r.imag.dataId);
      d = ms(h6, p6);
    } else
      d = this.getValuesFromTexture(t);
    return c && (this.downloadWaitMs += Ce$1() - u), this.convertAndCacheOnCPU(t, d);
  }
  async read(t) {
    if (this.pendingRead.has(t)) {
      const f = this.pendingRead.get(t);
      return new Promise((m) => f.push(m));
    }
    const e = this.texData.get(t), { values: s, shape: o, slice: r, dtype: i6, complexTensorInfos: a, isPacked: l } = e;
    if (r != null) {
      let f;
      l ? f = new Ls(o, Ns) : f = new qn$1(o, Ns);
      const m = this.runWebGLProgram(f, [{ dataId: t, shape: o, dtype: i6 }], i6), g6 = this.read(m.dataId);
      return this.disposeIntermediateTensorInfo(m), g6;
    }
    if (s != null)
      return this.convertAndCacheOnCPU(t);
    if (F().getBool("DEBUG") && !F().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && F().getNumber("WEBGL_VERSION") === 2)
      throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
    let c = null, u;
    if (i6 !== "complex64" && F().get("WEBGL_BUFFER_SUPPORTED")) {
      u = this.decode(t);
      const f = this.texData.get(u.dataId);
      c = this.gpgpu.createBufferFromTexture(f.texture.texture, ...Pa(o));
    }
    this.pendingRead.set(t, []), i6 !== "complex64" && await this.gpgpu.createAndWaitForFence();
    let d;
    if (i6 === "complex64") {
      const f = await Promise.all([
        this.read(a.real.dataId),
        this.read(a.imag.dataId)
      ]), m = f[0], g6 = f[1];
      d = ms(m, g6);
    } else if (c == null)
      d = this.getValuesFromTexture(t);
    else {
      const f = O(o);
      d = this.gpgpu.downloadFloat32MatrixFromBuffer(c, f);
    }
    if (u != null && this.disposeIntermediateTensorInfo(u), c != null) {
      const f = this.gpgpu.gl;
      ot(f, () => f.deleteBuffer(c));
    }
    const h6 = this.convertAndCacheOnCPU(t, d), p6 = this.pendingRead.get(t);
    return this.pendingRead.delete(t), p6.forEach((f) => f(h6)), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t) && Xt().removeDataId(t, this), this.pendingDeletes--), h6;
  }
  /**
   * Read tensor to a new texture that is densely packed for ease of use.
   * @param dataId The source tensor.
   * @param options
   *     customTexShape: Optional. If set, will use the user defined texture
   *     shape to create the texture.
   */
  readToGPU(t, e = {}) {
    const s = this.texData.get(t), { values: o, shape: r, slice: i6, dtype: a, isPacked: l, texture: c } = s;
    if (a === "complex64")
      throw new Error("Does not support reading texture for complex64 dtype.");
    if (i6 != null) {
      let p6;
      l ? p6 = new Ls(r, Ns) : p6 = new qn$1(r, Ns);
      const f = this.runWebGLProgram(p6, [{ dataId: t, shape: r, dtype: a }], a), m = this.readToGPU(f, e);
      return this.disposeIntermediateTensorInfo(f), m;
    }
    if (c == null)
      throw o != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
    const u = this.decode(t, e.customTexShape), d = Xt().makeTensorFromTensorInfo(u), h6 = this.texData.get(u.dataId);
    return Object.assign({ tensorRef: d }, h6.texture);
  }
  bufferSync(t) {
    const e = this.readSync(t.dataId);
    if (t.dtype === "string")
      try {
        const s = e.map((o) => ps(o));
        return vt$1(t.shape, t.dtype, s);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return vt$1(t.shape, t.dtype, e);
  }
  checkNumericalProblems(t) {
    if (t != null)
      for (let e = 0; e < t.length; e++) {
        const s = t[e];
        if (!iz(s))
          throw F().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${s} cannot be represented on this device.`);
      }
  }
  getValuesFromTexture(t) {
    const { shape: e, dtype: s, isPacked: o } = this.texData.get(t), r = O(e);
    if (F().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      const h6 = this.decode(t), p6 = this.texData.get(h6.dataId), f = this.gpgpu.downloadMatrixFromPackedTexture(p6.texture.texture, ...Pa(e)).subarray(0, r);
      return this.disposeIntermediateTensorInfo(h6), f;
    }
    const i6 = F().getBool("WEBGL_PACK") && o === true, a = i6 ? Ka(e) : e, l = i6 ? new CX(a) : new IX(a), c = this.runWebGLProgram(l, [{ shape: a, dtype: s, dataId: t }], "float32"), u = this.texData.get(c.dataId), d = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture, u.texShape[0], u.texShape[1]).subarray(0, r);
    return this.disposeIntermediateTensorInfo(c), d;
  }
  timerAvailable() {
    return F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
  }
  time(t) {
    const e = this.activeTimers, s = [];
    let o = false;
    this.programTimersStack == null ? (this.programTimersStack = s, o = true) : this.activeTimers.push(s), this.activeTimers = s, t();
    const r = zs(this.activeTimers.map((l) => l.query)).filter((l) => l != null), i6 = zs(this.activeTimers.map((l) => l.name)).filter((l) => l != null);
    this.activeTimers = e, o && (this.programTimersStack = null);
    const a = {
      uploadWaitMs: this.uploadWaitMs,
      downloadWaitMs: this.downloadWaitMs,
      kernelMs: null,
      wallMs: null
      // will be filled by the engine
    };
    return (async () => {
      if (F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        const l = await Promise.all(r);
        a.kernelMs = Wg$1(l), a.getExtraProfileInfo = () => l.map((c, u) => ({ name: i6[u], ms: c })).map((c) => `${c.name}: ${c.ms}`).join(", ");
      } else
        a.kernelMs = {
          error: "WebGL query timers are not supported in this environment."
        };
      return this.uploadWaitMs = 0, this.downloadWaitMs = 0, a;
    })();
  }
  memory() {
    return {
      unreliable: false,
      numBytesInGPU: this.numBytesInGPU,
      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
      numBytesInGPUFree: this.textureManager.numBytesFree
    };
  }
  startTimer() {
    return F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: Ce$1(), endMs: null };
  }
  endTimer(t) {
    return F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = Ce$1(), t);
  }
  async getQueryTime(t) {
    if (F().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)
      return this.gpgpu.waitForQueryAndGetTime(t);
    const e = t;
    return e.endMs - e.startMs;
  }
  /**
   * Decrease the RefCount on the dataId and dispose the memory if the dataId
   * has 0 refCount. If there are pending read on the data, the disposal would
   * added to the pending delete queue. Return true if the dataId is removed
   * from backend or the backend does not contain the dataId, false if the
   * dataId is not removed. Memory may or may not be released even when dataId
   * is removed, which also depends on dataRefCount, see `releaseGPU`.
   * @param dataId
   * @oaram force Optional, remove the data regardless of refCount
   */
  disposeData(t, e = false) {
    if (this.pendingDisposal.has(t))
      return false;
    if (!this.texData.has(t))
      return true;
    if (e ? this.texData.get(t).refCount = 0 : this.texData.get(t).refCount--, !e && this.texData.get(t).refCount > 0)
      return false;
    if (this.pendingRead.has(t))
      return this.pendingDisposal.add(t), this.pendingDeletes++, false;
    this.releaseGPUData(t);
    const { complexTensorInfos: s } = this.texData.get(t);
    return s != null && (this.disposeData(s.real.dataId, e), this.disposeData(s.imag.dataId, e)), this.texData.delete(t), true;
  }
  releaseGPUData(t) {
    const { texture: e, dtype: s, texShape: o, usage: r, isPacked: i6, slice: a } = this.texData.get(t), l = a && a.origDataId || t, c = this.dataRefCount.get(l);
    c > 1 ? this.dataRefCount.set(l, c - 1) : (this.dataRefCount.delete(l), e != null && (this.numBytesInGPU -= this.computeBytes(o, s), this.textureManager.releaseTexture(e, o, r, i6)));
    const u = this.texData.get(t);
    u.texture = null, u.texShape = null, u.isPacked = false, u.slice = null;
  }
  getTexture(t) {
    return this.uploadToGPU(t), this.texData.get(t).texture.texture;
  }
  /**
   * Returns internal information for the specific data bucket. Used in unit
   * tests.
   */
  getDataInfo(t) {
    return this.texData.get(t);
  }
  /*
  Tests whether all the inputs to an op are small and on the CPU. This heuristic
  determines when it would be faster to execute a kernel on the CPU. WebGL
  kernels opt into running this check and forwarding when appropriate.
  TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more
  sustainable strategy for optimizing backend execution of ops.
   */
  shouldExecuteOnCPU(t, e = qP) {
    return F().getBool("WEBGL_CPU_FORWARD") && t.every((s) => this.texData.get(s.dataId).texture == null && O(s.shape) < e);
  }
  getGPGPUContext() {
    return this.gpgpu;
  }
  where(t) {
    rn$1("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    const e = t.dataSync();
    return YP(t.shape, e);
  }
  packedUnaryOp(t, e, s) {
    const o = new Ls(t.shape, e), r = this.compileAndRun(o, [t], s);
    return Xt().makeTensorFromTensorInfo(r);
  }
  // TODO(msoulanille) remove this once the backend has been modularized
  // a copy is needed here to break a circular dependency.
  // Also remove the op from unary_op.
  abs(t) {
    if (this.shouldExecuteOnCPU([t]) && t.dtype !== "complex64") {
      const o = Ww(this.texData.get(t.dataId).values);
      return this.makeOutput(t.shape, t.dtype, o);
    }
    if (F().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t, og$1, t.dtype);
    const e = new qn$1(t.shape, og$1), s = this.compileAndRun(e, [t]);
    return Xt().makeTensorFromTensorInfo(s);
  }
  makeTensorInfo(t, e, s) {
    let o;
    if (e === "string" && s != null && s.length > 0 && mr(s[0])) {
      const r = s.map((i6) => hs(i6));
      o = this.write(r, t, e);
    } else
      o = this.write(s, t, e);
    return this.texData.get(o).usage = null, { dataId: o, shape: t, dtype: e };
  }
  makeOutput(t, e, s) {
    return Xt().makeTensorFromTensorInfo(this.makeTensorInfo(t, e, s), this);
  }
  unpackTensor(t) {
    const e = new UP(t.shape);
    return this.runWebGLProgram(e, [t], t.dtype);
  }
  packTensor(t) {
    const e = new LP(t.shape), s = true;
    return this.runWebGLProgram(e, [t], t.dtype, null, s);
  }
  packedReshape(t, e) {
    const s = [
      hr(t.shape),
      ...pr(t.shape)
    ], o = {
      dtype: t.dtype,
      shape: s,
      dataId: t.dataId
    }, r = [
      hr(e),
      ...pr(e)
    ], i6 = new Vw(r, s), a = true, l = [s], c = this.runWebGLProgram(i6, [o], t.dtype, l, a);
    return { dataId: c.dataId, shape: e, dtype: c.dtype };
  }
  decode(t, e) {
    const s = this.texData.get(t), { isPacked: o, shape: r, dtype: i6 } = s;
    if (e != null) {
      const h6 = O(r), p6 = e[0] * e[1] * 4;
      v(h6 <= p6, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
    }
    const a = Ka(r);
    let l;
    o ? l = new wX(a) : l = new yX(a);
    const c = true, u = [e ?? Pa(a)], d = this.runWebGLProgram(l, [{ shape: a, dtype: i6, dataId: t }], i6, u, c, e);
    return { dtype: i6, shape: r, dataId: d.dataId };
  }
  runWebGLProgram(t, e, s, o, r = false, i6) {
    const a = this.makeTensorInfo(t.outputShape, s), l = this.texData.get(a.dataId);
    if (t.packedOutput && (l.isPacked = true), t.outPackingScheme === ii$1.DENSE) {
      const b6 = i6 ?? Pa(t.outputShape);
      l.texShape = b6.map((x6) => x6 * 2);
    }
    if (t.outTexUsage != null && (l.usage = t.outTexUsage), O(a.shape) === 0)
      return l.values = xe$1(a.dtype, 0), a;
    const c = [], u = e.map((b6) => {
      if (b6.dtype === "complex64")
        throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      let x6 = this.texData.get(b6.dataId);
      if (x6.texture == null) {
        if (!t.packedInputs && O(b6.shape) <= F().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
          return {
            shape: b6.shape,
            texData: null,
            isUniform: true,
            uniformValues: x6.values
          };
        t.packedInputs && (x6.isPacked = true, x6.shape = b6.shape);
      }
      if (this.uploadToGPU(b6.dataId), !!x6.isPacked != !!t.packedInputs)
        b6 = x6.isPacked ? this.unpackTensor(b6) : this.packTensor(b6), c.push(b6), x6 = this.texData.get(b6.dataId);
      else if (x6.isPacked && !$l(x6.shape, b6.shape)) {
        const w6 = b6, y6 = b6.shape;
        b6.shape = x6.shape, b6 = this.packedReshape(b6, y6), c.push(b6), x6 = this.texData.get(b6.dataId), w6.shape = y6;
      }
      return { shape: b6.shape, texData: x6, isUniform: false };
    });
    this.uploadToGPU(a.dataId);
    const d = { shape: a.shape, texData: l, isUniform: false }, h6 = xX(t, u, d), p6 = this.getAndSaveBinary(h6, () => gX(this.gpgpu, t, u, d)), f = this.activeTimers != null;
    let m;
    f && (m = this.startTimer()), F().get("ENGINE_COMPILE_ONLY") || bX(this.gpgpu, p6, u, d, o), c.forEach((b6) => this.disposeIntermediateTensorInfo(b6)), f && (m = this.endTimer(m), this.activeTimers.push({ name: t.constructor.name, query: this.getQueryTime(m) }));
    const g6 = F().get("WEBGL_FLUSH_THRESHOLD");
    if (g6 > 0) {
      const b6 = Ce$1();
      b6 - this.lastGlFlushTime > g6 && (this.gpgpu.gl.flush(), this.lastGlFlushTime = b6);
    }
    if (!F().getBool("WEBGL_LAZILY_UNPACK") && l.isPacked && r === false) {
      const b6 = this.unpackTensor(a);
      return this.disposeIntermediateTensorInfo(a), b6;
    }
    return a;
  }
  compileAndRun(t, e, s, o, r = false) {
    return s = s || e[0].dtype, this.runWebGLProgram(t, e, s, o, r);
  }
  getAndSaveBinary(t, e) {
    return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t];
  }
  getTextureManager() {
    return this.textureManager;
  }
  dispose() {
    this.disposed || (F().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((e) => {
      this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram), delete this.binaryCache[e];
    }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
  }
  floatPrecision() {
    return this.floatPrecisionValue == null && (this.floatPrecisionValue = D(() => {
      if (!F().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        const t = F().getBool("DEBUG");
        F().set("DEBUG", false);
        const e = this.abs(gt$1(1e-8)).dataSync()[0];
        if (F().set("DEBUG", t), e > 0)
          return 32;
      }
      return 16;
    })), this.floatPrecisionValue;
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return this.floatPrecision() === 32 ? QP : JP;
  }
  uploadToGPU(t) {
    const e = this.texData.get(t), { shape: s, dtype: o, values: r, texture: i6, usage: a, isPacked: l } = e;
    if (i6 != null)
      return;
    const c = this.activeTimers != null;
    let u;
    c && (u = Ce$1());
    let d = e.texShape;
    if (d == null && (d = Sz(s, l), e.texShape = d), r != null) {
      const h6 = Ka(s);
      let p6, f = d[1], m = d[0];
      const g6 = r instanceof Uint8Array || r instanceof Uint8ClampedArray;
      (l || !g6) && ([f, m] = kr(d[0], d[1])), l ? p6 = new SX(h6, g6) : p6 = new tg$1(h6, g6);
      const b6 = g6 ? [m, f] : d, x6 = this.makeTensorInfo(b6, o), w6 = this.texData.get(x6.dataId);
      g6 ? w6.usage = ln$1.PIXELS : w6.usage = ln$1.UPLOAD, w6.texShape = b6, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x6.dataId), f, m, r);
      const y6 = [[m, f]], I = true, C6 = this.runWebGLProgram(p6, [x6], o, y6, I), k7 = this.texData.get(C6.dataId);
      e.texShape = k7.texShape, e.isPacked = k7.isPacked, e.usage = k7.usage, F().get("ENGINE_COMPILE_ONLY") ? this.disposeData(C6.dataId) : (e.texture = k7.texture, e.values = null, this.texData.delete(C6.dataId)), this.disposeIntermediateTensorInfo(x6), c && (this.uploadWaitMs += Ce$1() - u);
    } else {
      const h6 = this.acquireTexture(d, a, o, l);
      e.texture = h6;
    }
  }
  convertAndCacheOnCPU(t, e) {
    const s = this.texData.get(t), { dtype: o } = s;
    return e != null && (s.values = nA(e, o)), s.values;
  }
  acquireTexture(t, e, s, o) {
    if (this.numBytesInGPU += this.computeBytes(t, s), !this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
      const r = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = true, console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`);
    }
    return this.textureManager.acquireTexture(t, e, o);
  }
  computeBytes(t, e) {
    return t[0] * t[1] * Ur(e);
  }
  checkCompileCompletion() {
    for (const [, t] of Object.entries(this.binaryCache))
      this.checkCompletion_(t);
  }
  async checkCompileCompletionAsync() {
    const t = [];
    if (this.gpgpu.parallelCompilationExtension) {
      for (const [, e] of Object.entries(this.binaryCache))
        t.push(this.checkCompletionAsync_(e));
      return Promise.all(t);
    } else {
      for (const [, e] of Object.entries(this.binaryCache)) {
        const s = new Promise((o) => {
          try {
            this.checkCompletion_(e), o(true);
          } catch (r) {
            throw r;
          }
        });
        t.push(s);
      }
      return Promise.all(t);
    }
  }
  async checkCompletionAsync_(t) {
    return this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(t) : (await _c(), this.checkCompletionAsync_(t));
  }
  checkCompletion_(t) {
    if (this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false)
      throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)), this.gpgpu.gl.getShaderParameter(t.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false ? (Cw(t.source, this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)), new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
    return true;
  }
  getUniformLocations() {
    for (const [, t] of Object.entries(this.binaryCache)) {
      const { uniformLocations: e, customUniformLocations: s, infLoc: o, nanLoc: r, inShapesLocations: i6, inTexShapesLocations: a, outShapeLocation: l, outShapeStridesLocation: c, outTexShapeLocation: u } = Nw(this.gpgpu, t.program, t.webGLProgram);
      t.uniformLocations = e, t.customUniformLocations = s, t.infLoc = o, t.nanLoc = r, t.inShapesLocations = i6, t.inTexShapesLocations = a, t.outShapeLocation = l, t.outShapeStridesLocation = c, t.outTexShapeLocation = u;
    }
  }
  /**
   * Create a TF.js tensor out of an existing WebGL texture. A new texture will
   * be created.
   */
  createTensorFromGPUData(t, e, s) {
    t.channels = t.channels || "RGBA";
    const { texture: o, height: r, width: i6, channels: a } = t, l = Xt().backend;
    if (!l.gpgpu.gl.isTexture(o))
      throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
    const c = l.writeTexture(o, e, s, r, i6, a);
    return Xt().makeTensorFromDataId(c, e, s, l);
  }
}
hu.nextDataId = 0;
function nA(n, t) {
  if (t === "float32" || t === "complex64")
    return n;
  if (t === "int32" || t === "bool") {
    const e = t === "int32" ? new Int32Array(n.length) : new Uint8Array(n.length);
    for (let s = 0; s < e.length; ++s)
      e[s] = Math.round(n[s]);
    return e;
  } else
    throw new Error(`Unknown dtype ${t}`);
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Ph$1() && kb(
  "webgl",
  () => new hu(),
  2
  /* priority */
);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Af$1 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
class fr {
  constructor(t, e, s) {
    this.variableNames = ["A", "B"], this.outputShape = bt$1(e, s), this.enableShapeUniforms = Xe(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const $a = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
class Ga {
  constructor(t, e, s, o = false) {
    this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = bt$1(e, s);
    const r = this.outputShape.length;
    this.enableShapeUniforms = Xe(r);
    let i6 = "";
    if (o)
      if (r === 0 || O(this.outputShape) === 1)
        i6 = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
      else if (i6 = `
          ${Kt(r)} coords = getOutputCoords();
        `, r === 1)
        this.enableShapeUniforms ? i6 += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          ` : i6 += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
      else {
        const l = We$1("coords", r);
        this.enableShapeUniforms ? i6 += `
            bool nextRowOutOfBounds =
              (${l[r - 2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${l[r - 1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : i6 += `
            bool nextRowOutOfBounds =
              (${l[r - 2]} + 1) >= ${this.outputShape[r - 2]};
            bool nextColOutOfBounds =
              (${l[r - 1]} + 1) >= ${this.outputShape[r - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
      }
    this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i6}

        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tn$1(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  return e.incRef(s.dataId), { dataId: s.dataId, shape: s.shape, dtype: s.dtype };
}
const sA = {
  kernelName: Ei,
  backendName: "webgl",
  kernelFunc: tn$1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function js(n) {
  const { inputs: t, backend: e } = n, { real: s, imag: o } = t, r = e.makeTensorInfo(s.shape, "complex64"), i6 = e.texData.get(r.dataId), a = tn$1({ inputs: { x: s }, backend: e }), l = tn$1({ inputs: { x: o }, backend: e });
  return i6.complexTensorInfos = { real: a, imag: l }, r;
}
const oA = {
  kernelName: Jd$1,
  backendName: "webgl",
  kernelFunc: js
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zw = "return (a < 0.) ? b * a : a;", Xw = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function rA(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { alpha: r } = s, i6 = e.makeTensorInfo([], "float32", bs(r, "float32")), a = F().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ga(Xw, o.shape, i6.shape) : new fr(zw, o.shape, i6.shape), l = e.runWebGLProgram(a, [o, i6], "float32");
  return e.disposeIntermediateTensorInfo(i6), l;
}
const iA = {
  kernelName: sc,
  backendName: "webgl",
  kernelFunc: rA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Pw = "return (a < 0.) ? b * a : a;", Aw = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function aA(n) {
  const { inputs: t, backend: e } = n, { x: s, alpha: o } = t, r = F().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ga(Aw, s.shape, o.shape) : new fr(Pw, s.shape, o.shape);
  return e.runWebGLProgram(r, [s, o], "float32");
}
const lA = {
  kernelName: Cc,
  backendName: "webgl",
  kernelFunc: aA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Gr = "if (isnan(x)) return x;";
function Nt$1({ opSnippet: n, packedOpSnippet: t, cpuKernelImpl: e, dtype: s }) {
  return ({ inputs: o, backend: r }) => {
    const { x: i6 } = o, a = r, l = s || i6.dtype;
    if (a.shouldExecuteOnCPU([i6]) && e != null) {
      const d = a.texData.get(i6.dataId), h6 = e(d.values, l);
      return a.makeTensorInfo(i6.shape, l, h6);
    }
    const c = F().getBool("WEBGL_PACK_UNARY_OPERATIONS") && t != null;
    let u;
    return c ? u = new Ls(i6.shape, t) : u = new qn$1(i6.shape, n), a.runWebGLProgram(u, [i6], l);
  };
}
function Ne({ opSnippet: n, packedOpSnippet: t, checkOutOfBounds: e = false, supportsComplex: s = false, cpuKernelImpl: o, dtype: r }) {
  return ({ inputs: i6, backend: a }) => {
    const { a: l, b: c } = i6, u = a;
    if (s && l.dtype === "complex64") {
      const f = u.texData.get(l.dataId), m = u.texData.get(c.dataId), [g6, b6] = [
        [f.complexTensorInfos.real, m.complexTensorInfos.real],
        [f.complexTensorInfos.imag, m.complexTensorInfos.imag]
      ].map((w6) => {
        const [y6, I] = w6, C6 = {
          dataId: y6.dataId,
          dtype: y6.dtype,
          shape: l.shape
        }, k7 = {
          dataId: I.dataId,
          dtype: I.dtype,
          shape: c.shape
        }, S = new fr(n, l.shape, c.shape);
        return u.runWebGLProgram(S, [C6, k7], je$1(y6.dtype, I.dtype));
      }), x6 = js({ inputs: { real: g6, imag: b6 }, backend: u });
      return u.disposeIntermediateTensorInfo(g6), u.disposeIntermediateTensorInfo(b6), x6;
    }
    const d = r || je$1(l.dtype, c.dtype);
    if ((l.dtype === "string" || c.dtype === "string" || u.shouldExecuteOnCPU([l, c])) && o != null) {
      const f = u.texData.get(l.dataId).values, m = u.texData.get(c.dataId).values, g6 = l.dtype === "string" ? (
        // tslint:disable-next-line: no-any
        No(f)
      ) : f, b6 = l.dtype === "string" ? (
        // tslint:disable-next-line: no-any
        No(m)
      ) : m, [x6, w6] = o(l.shape, c.shape, g6, b6, d), y6 = u.makeTensorInfo(w6, d), I = u.texData.get(y6.dataId);
      return I.values = x6, y6;
    }
    const h6 = F().getBool("WEBGL_PACK_BINARY_OPERATIONS") && t != null;
    let p6;
    return h6 ? p6 = new Ga(t, l.shape, c.shape, e) : p6 = new fr(n, l.shape, c.shape), u.runWebGLProgram(p6, [l, c], d);
  };
}
function ai$1(n, t = false) {
  if (n === "linear")
    return t ? KP : zP;
  if (n === "relu")
    return t ? BP : PP;
  if (n === "elu")
    return t ? ZP : XP;
  if (n === "relu6")
    return t ? HP : AP;
  if (n === "prelu")
    return t ? Aw : Pw;
  if (n === "leakyrelu")
    return t ? Xw : zw;
  if (n === "sigmoid")
    return t ? _P : OP;
  throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Ow {
  constructor(t, e, s, o = false, r = false, i6 = false, a = null, l = false, c = false) {
    this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = s, this.enableShapeUniforms = Xe(this.outputShape.length);
    const u = o ? t[1] : t[2], d = Math.ceil(u / 2), h6 = o ? "i * 2, rc.y" : "rc.y, i * 2", p6 = r ? "rc.z, i * 2" : "i * 2, rc.z", f = o ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], m = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    let g6 = "", b6 = "";
    a && (l ? g6 = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }` : c ? g6 = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }` : g6 = `vec4 activation(vec4 x) {
          ${a}
        }`, b6 = "result = activation(result);");
    const x6 = i6 ? "result += getBiasAtOutCoords();" : "";
    i6 && this.variableNames.push("bias"), l && this.variableNames.push("preluActivationWeights"), c && this.variableNames.push("leakyreluAlpha");
    let w6 = "rc.x", y6 = "rc.x";
    t[0] < e[0] ? w6 = `imod(rc.x, ${t[0]})` : e[0] < t[0] && (y6 = `imod(rc.x, ${e[0]})`), this.userCode = `
      ${g6}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w6};
        int batchB = ${y6};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${h6});
          vec4 b = getMatrixB(batchB, ${p6});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x6}

        ${b6}

        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rg$1 = {
  REAL: "return areal * breal - aimag * bimag;",
  IMAG: "return areal * bimag + aimag * breal;"
};
let ig$1 = class ig {
  constructor(t, e, s) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = bt$1(e, s), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ag$1 = "return a * b;";
function Of$1(n) {
  const { inputs: t, backend: e } = n, { a: s, b: o } = t, r = je$1(s.dtype, o.dtype);
  if (s.dtype === "complex64") {
    const a = e.texData.get(s.dataId), l = e.texData.get(o.dataId), c = new ig$1(rg$1.REAL, s.shape, o.shape), u = new ig$1(rg$1.IMAG, s.shape, o.shape), d = [
      {
        dataId: a.complexTensorInfos.real.dataId,
        dtype: a.complexTensorInfos.real.dtype,
        shape: s.shape
      },
      {
        dataId: a.complexTensorInfos.imag.dataId,
        dtype: a.complexTensorInfos.imag.dtype,
        shape: s.shape
      },
      {
        dataId: l.complexTensorInfos.real.dataId,
        dtype: l.complexTensorInfos.real.dtype,
        shape: o.shape
      },
      {
        dataId: l.complexTensorInfos.imag.dataId,
        dtype: l.complexTensorInfos.imag.dtype,
        shape: o.shape
      }
    ], h6 = e.runWebGLProgram(c, d, "float32"), p6 = e.runWebGLProgram(u, d, "float32"), f = js({ inputs: { real: h6, imag: p6 }, backend: e });
    return e.disposeIntermediateTensorInfo(h6), e.disposeIntermediateTensorInfo(p6), f;
  }
  if (e.shouldExecuteOnCPU([s, o])) {
    const a = e.texData.get(s.dataId), l = e.texData.get(o.dataId), [c, u] = lP(s.shape, o.shape, a.values, l.values, r), d = e.makeTensorInfo(u, r), h6 = e.texData.get(d.dataId);
    return h6.values = c, d;
  }
  let i6;
  return F().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? i6 = new Ga(ag$1, s.shape, o.shape) : i6 = new fr(ag$1, s.shape, o.shape), e.runWebGLProgram(i6, [s, o], r);
}
const cA = {
  kernelName: Pi,
  backendName: "webgl",
  kernelFunc: Of$1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uA(n, t, e) {
  const s = [
    hr(n.shape),
    ...pr(n.shape)
  ], o = {
    dtype: n.dtype,
    shape: s,
    dataId: n.dataId
  }, r = [
    hr(t),
    ...pr(t)
  ], i6 = new Vw(r, s), a = true, l = [s], c = e.runWebGLProgram(i6, [o], n.dtype, l, a);
  return { dataId: c.dataId, shape: t, dtype: c.dtype };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function st(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { shape: r } = s, i6 = e, a = O(o.shape), l = Ad$1(r, a), c = O(l);
  v(a === c, () => `The new shape (${l}) has ${c} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);
  const u = i6.texData.get(o.dataId);
  return u.isPacked && !$l(o.shape, l) && !(u.texture !== null && $l(u.shape, l)) ? uA(o, l, i6) : (i6.incRef(o.dataId), { dataId: o.dataId, shape: l, dtype: o.dtype });
}
const dA = {
  kernelName: Sc,
  backendName: "webgl",
  kernelFunc: st
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let lg$1 = class lg {
  constructor(t, e) {
    this.variableNames = ["x"];
    const { windowSize: s, batchSize: o, inSize: r, outSize: i6 } = t;
    this.outputShape = [o, i6];
    const a = Math.floor(s / 4) * 4, l = s % 4;
    let c = "sumValue += dot(values, ones);";
    if (e != null) {
      const d = 1 / e;
      c = `sumValue += dot(values * ${go(d) ? d.toPrecision(2) : d}, ones);`;
    }
    let u = "";
    r % s > 0 && (u = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `;
  }
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hA {
  constructor(t, e) {
    this.variableNames = ["x"];
    const { windowSize: s, batchSize: o, inSize: r, outSize: i6 } = t;
    this.outputShape = [o, i6];
    let a = "0.0", l = "";
    e === "prod" ? a = "1.0" : e === "min" ? (a = "1.0 / 1e-20", l = "min") : e === "max" && (a = "-1.0 / 1e-20", l = "max");
    let c = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    e === "sum" ? c = "sumValue" : e === "prod" ? c = "prodValue" : e === "all" ? c = "allValue" : e === "any" && (c = "anyValue");
    const u = Math.floor(s / 4) * 4, d = s % 4;
    let h6 = `
      if (${e === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${e === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e === "min"} || ${e === "max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, p6 = "vec4";
    e === "all" ? (a = "1.0", h6 = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, p6 = "bvec4") : e === "any" && (a = "0.0", h6 = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, p6 = "bvec4");
    let f = "";
    r % s > 0 && (f = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p6} values = ${p6}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h6}
        }

        int inIdx = inOffset + ${u};
        if (${d === 1}) {
          ${p6} values = ${p6}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h6}
        } else if (${d === 2}) {
          ${p6} values = ${p6}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h6}
        } else if (${d === 3}) {
          ${p6} values = ${p6}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h6}
        }
        setOutput(${c});
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pA(n) {
  const t = [];
  for (; t.length === 0 || t[t.length - 1].outSize !== 1; ) {
    const e = t.length ? t[t.length - 1].outSize : n[1], s = Uc(e);
    t.push({
      inSize: e,
      windowSize: s,
      outSize: Math.ceil(e / s)
    });
  }
  return t;
}
function Oo(n, t, e, s) {
  const o = pA(n.shape);
  let r = n;
  for (let i6 = 0; i6 < o.length; i6++) {
    const { inSize: a, windowSize: l, outSize: c } = o[i6];
    let u, d;
    e === "mean" ? u = i6 === 0 ? new lg$1({ windowSize: l, inSize: a, batchSize: n.shape[0], outSize: c }, a) : new lg$1({ windowSize: l, inSize: a, batchSize: n.shape[0], outSize: c }) : u = new hA({ windowSize: l, inSize: a, batchSize: n.shape[0], outSize: c }, e), d = r, r = s.runWebGLProgram(u, [r], t), d.dataId !== n.dataId && s.disposeIntermediateTensorInfo(d);
  }
  return r;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class fA {
  constructor(t, e) {
    this.variableNames = ["A"];
    const s = new Array(t.length);
    for (let i6 = 0; i6 < s.length; i6++)
      s[i6] = t[e[i6]];
    this.outputShape = s, this.rank = s.length;
    const o = Kt(this.rank), r = mA(e);
    this.userCode = `
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `;
  }
}
function mA(n) {
  const t = n.length;
  if (t > 6)
    throw Error(`Transpose for rank ${t} is not yet supported`);
  const e = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], s = new Array(t);
  for (let o = 0; o < n.length; o++)
    s[n[o]] = e[o];
  return s.join();
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class gA {
  constructor(t, e) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
    const s = new Array(t.length);
    for (let u = 0; u < s.length; u++)
      s[u] = t[e[u]];
    if (this.outputShape = s, this.rank = s.length, this.rank > 6)
      throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
    const o = Kt(this.rank), r = Fw("rc", this.rank), i6 = new Array(this.rank);
    for (let u = 0; u < e.length; u++)
      i6[e[u]] = r[u];
    const a = `vec2(${i6.slice(-2).join()})`, l = `++${r[this.rank - 1]} < ${s[this.rank - 1]}`, c = `getChannel(getA(${i6.join()}), ${a})`;
    this.userCode = `
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${r[this.rank - 1]};
      if(++${r[this.rank - 2]} < ${s[this.rank - 2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pu(n, t, e) {
  const s = F().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new gA(n.shape, t) : new fA(n.shape, t);
  return e.runWebGLProgram(s, [n], n.dtype);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bA(n, t, e, s) {
  const o = t, r = n.shape.length, i6 = Ct(o, n.shape);
  let a = i6;
  const l = qt$1(a, r), c = l != null;
  let u = n;
  c && (u = pu(n, l, s), a = ie(a.length, r)), Te("sum", a, r);
  const [d, h6] = ye$1(u.shape, a);
  let p6 = d;
  e && (p6 = re$1(d, i6));
  const f = O(h6), g6 = O(n.shape) / f, b6 = st({ inputs: { x: u }, attrs: { shape: [g6, f] }, backend: s }), x6 = zh$1(n.dtype), w6 = Oo(b6, x6, "sum", s), y6 = st({ inputs: { x: w6 }, attrs: { shape: p6 }, backend: s });
  return s.disposeIntermediateTensorInfo(b6), s.disposeIntermediateTensorInfo(w6), c && s.disposeIntermediateTensorInfo(u), y6;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fu(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s;
  return bA(o, r, i6, e);
}
const xA = {
  kernelName: Gc,
  backendName: "webgl",
  kernelFunc: fu
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fe(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { perm: r } = s, i6 = e, a = o.shape.length, l = new Array(a);
  for (let u = 0; u < l.length; u++)
    l[u] = o.shape[r[u]];
  let c;
  if (i6.shouldExecuteOnCPU([o])) {
    const d = i6.texData.get(o.dataId).values, h6 = Pf$1(d, o.shape, o.dtype, r, l);
    c = i6.makeTensorInfo(l, o.dtype);
    const p6 = i6.texData.get(c.dataId);
    p6.values = h6;
  } else
    c = pu(o, r, i6);
  return c;
}
const yA = {
  kernelName: Jo,
  backendName: "webgl",
  kernelFunc: Fe
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Kw = 1e3;
function Gl({ a: n, b: t, transposeA: e, transposeB: s, backend: o, bias: r = null, preluActivationWeights: i6 = null, leakyreluAlpha: a = 0, activation: l = null }) {
  const c = n.shape.length, u = t.shape.length, d = e ? n.shape[c - 2] : n.shape[c - 1], h6 = s ? t.shape[u - 1] : t.shape[u - 2], p6 = e ? n.shape[c - 1] : n.shape[c - 2], f = s ? t.shape[u - 2] : t.shape[u - 1], m = n.shape.slice(0, -2), g6 = t.shape.slice(0, -2), b6 = O(m), x6 = O(g6), y6 = bt$1(n.shape.slice(0, -2), t.shape.slice(0, -2)).concat([p6, f]);
  v(d === h6, () => `Error in matMul: inner shapes (${d}) and (${h6}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);
  const I = e ? [b6, d, p6] : [b6, p6, d], C6 = s ? [x6, f, h6] : [x6, h6, f], k7 = st({ inputs: { x: n }, backend: o, attrs: { shape: I } }), S = st({ inputs: { x: t }, backend: o, attrs: { shape: C6 } }), N = [k7, S], R = Math.max(b6, x6), M6 = e ? k7.shape[1] : k7.shape[2], V = r != null, z = i6 != null, X = l === "leakyrelu", P6 = l != null ? ai$1(l, true) : null, A6 = V || z || X || P6 != null;
  let B6;
  if ((p6 === 1 || f === 1) && M6 > Kw && A6 === false) {
    let H6 = k7, Y = S;
    e && (H6 = Fe({ inputs: { x: k7 }, backend: o, attrs: { perm: [0, 2, 1] } }), N.push(H6)), s && (Y = Fe({ inputs: { x: S }, backend: o, attrs: { perm: [0, 2, 1] } }), N.push(Y));
    const Q = f !== 1, j = f === 1;
    let J6 = H6;
    Q && (J6 = st({
      inputs: { x: H6 },
      backend: o,
      attrs: { shape: [R, M6, 1] }
    }), N.push(J6));
    const nt = f === 1 ? 2 : 1;
    let q = Y;
    j && (q = st({
      inputs: { x: Y },
      backend: o,
      attrs: { shape: [R, 1, M6] }
    }), N.push(q));
    const rt = Of$1({ inputs: { a: J6, b: q }, backend: o });
    B6 = fu({ inputs: { x: rt }, backend: o, attrs: { axis: nt, keepDims: true } }), N.push(rt);
  } else {
    const H6 = je$1(n.dtype, t.dtype), Y = new Ow(I, C6, [R, p6, f], e, s, V, P6, z, X), Q = [k7, S];
    if (r != null && Q.push(r), z && Q.push(i6), X) {
      const j = o.makeTensorInfo([], "float32", bs(a, "float32"));
      Q.push(j), N.push(j);
    }
    B6 = o.runWebGLProgram(Y, Q, H6);
  }
  const Z = st({ inputs: { x: B6 }, backend: o, attrs: { shape: y6 } });
  N.push(B6);
  for (const H6 of N)
    o.disposeIntermediateTensorInfo(H6);
  return Z;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wA(n) {
  const { inputs: t, backend: e, attrs: s } = n, { a: o, b: r, bias: i6, preluActivationWeights: a } = t, { transposeA: l, transposeB: c, activation: u, leakyreluAlpha: d } = s;
  return Gl({
    a: o,
    b: r,
    transposeA: l,
    transposeB: c,
    backend: e,
    bias: i6,
    preluActivationWeights: a,
    leakyreluAlpha: d,
    activation: u
  });
}
const IA = {
  kernelName: ol,
  backendName: "webgl",
  kernelFunc: wA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cg$1 = "return abs(x);";
function CA(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  if (e.shouldExecuteOnCPU([s]) && s.dtype !== "complex64") {
    const r = e.texData.get(s.dataId), i6 = Ww(r.values);
    return e.makeTensorInfo(s.shape, s.dtype, i6);
  }
  let o;
  return F().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? o = new Ls(s.shape, cg$1) : o = new qn$1(s.shape, cg$1), e.runWebGLProgram(o, [s], s.dtype);
}
const vA = {
  kernelName: Vl,
  backendName: "webgl",
  kernelFunc: CA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SA = En$1 + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`, kA = Nt$1({ opSnippet: SA }), TA = {
  kernelName: di,
  backendName: "webgl",
  kernelFunc: kA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NA = En$1 + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`, RA = Nt$1({ opSnippet: NA }), $A = {
  kernelName: hi,
  backendName: "webgl",
  kernelFunc: RA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ug$1 = "return a + b;", GA = Ne({
  opSnippet: ug$1,
  packedOpSnippet: ug$1,
  supportsComplex: true,
  cpuKernelImpl: OX
}), EA = {
  kernelName: br,
  backendName: "webgl",
  kernelFunc: GA
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class LA {
  constructor(t, e) {
    this.outputShape = [], this.outputShape = t, this.variableNames = e.map((r, i6) => `T${i6}`);
    const s = [];
    this.variableNames.forEach((r) => {
      s.push(`float v${r} = get${r}AtOutCoords();`);
    });
    const o = this.variableNames.map((r) => `v${r}`).join(" + ");
    this.userCode = `
      void main() {
        ${s.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MA {
  constructor(t, e) {
    this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.variableNames = e.map((r, i6) => `T${i6}`);
    const s = [];
    this.variableNames.forEach((r) => {
      s.push(`vec4 v${r} = get${r}AtOutCoords();`);
    });
    const o = this.variableNames.map((r) => `v${r}`).join(" + ");
    this.userCode = `
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tl(n) {
  const { inputs: t, backend: e } = n, s = t;
  if (s.length === 1)
    return tn$1({ inputs: { x: s[0] }, backend: e });
  if (s.length > F().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    const l = Math.floor(s.length / 2), c = tl({ inputs: s.slice(0, l), backend: e }), u = tl({ inputs: s.slice(l), backend: e });
    return tl({ inputs: [c, u], backend: e });
  }
  const o = s.map((l) => l.dtype).reduce((l, c) => je$1(l, c)), r = s.map((l) => l.shape), a = F().getBool("WEBGL_PACK") ? new MA(s[0].shape, r) : new LA(s[0].shape, r);
  return e.runWebGLProgram(a, s, o);
}
const WA = {
  kernelName: Bd$1,
  backendName: "webgl",
  kernelFunc: tl
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DA(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s, a = o.shape.length, l = Ct(r, o.shape);
  let c = l;
  const u = qt$1(c, a);
  let d = o;
  u != null && (d = Fe({ inputs: { x: o }, backend: e, attrs: { perm: u } }), c = ie(c.length, a)), Te("all", c, a);
  const [h6, p6] = ye$1(d.shape, c), f = O(p6), m = st({ inputs: { x: d }, backend: e, attrs: { shape: [-1, f] } }), g6 = Oo(m, m.dtype, "all", e);
  let b6;
  if (i6) {
    const x6 = re$1(h6, l);
    b6 = st({ inputs: { x: g6 }, backend: e, attrs: { shape: x6 } });
  } else
    b6 = st({ inputs: { x: g6 }, backend: e, attrs: { shape: h6 } });
  return e.disposeIntermediateTensorInfo(m), e.disposeIntermediateTensorInfo(g6), u != null && e.disposeIntermediateTensorInfo(d), b6;
}
const FA = {
  kernelName: Hd$1,
  backendName: "webgl",
  kernelFunc: DA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VA(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s, a = o.shape.length, l = Ct(r, o.shape);
  let c = l;
  const u = qt$1(c, a);
  let d = o;
  u != null && (d = Fe({ inputs: { x: o }, backend: e, attrs: { perm: u } }), c = ie(c.length, a)), Te("any", c, a);
  const [h6, p6] = ye$1(d.shape, c), f = O(p6), m = st({ inputs: { x: d }, backend: e, attrs: { shape: [-1, f] } }), g6 = Oo(m, m.dtype, "any", e);
  let b6;
  if (i6) {
    const x6 = re$1(h6, l);
    b6 = st({ inputs: { x: g6 }, backend: e, attrs: { shape: x6 } });
  } else
    b6 = st({ inputs: { x: g6 }, backend: e, attrs: { shape: h6 } });
  return e.disposeIntermediateTensorInfo(m), e.disposeIntermediateTensorInfo(g6), u != null && e.disposeIntermediateTensorInfo(d), b6;
}
const zA = {
  kernelName: _d$1,
  backendName: "webgl",
  kernelFunc: VA
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class XA {
  constructor(t, e, s) {
    this.variableNames = ["A"];
    const { windowSize: o, batchSize: r, outSize: i6 } = t;
    s || this.variableNames.push("bestIndicesA"), this.outputShape = [r, i6];
    const a = e === "max" ? ">" : "<", l = s ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class PA {
  constructor(t, e, s, o) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, v(t.length > 2, () => `Packed arg${s.charAt(0).toUpperCase() + s.slice(1)} supports only inputs with rank above 2.`);
    const r = t[t.length - 1], i6 = Math.ceil(r / e);
    this.outputShape = t.slice(0, -1), i6 > 1 && this.outputShape.push(i6), o || this.variableNames.push("bestIndicesA");
    const a = this.outputShape, l = a.length, c = Kt(l), u = We$1("coords", l);
    let d, h6;
    if (i6 === 1) {
      h6 = l + 1;
      const S = Kt(h6);
      d = `
        ${S} sourceLocR = ${S}(${u.join()}, 0);
        ++${u[l - 1]};
        ${S} sourceLocG = ${S}(${u.join()}, 0);
        ++${u[l - 2]};
        ${S} sourceLocA = ${S}(${u.join()}, 0);
        --${u[l - 1]};
        ${S} sourceLocB = ${S}(${u.join()}, 0);
        --${u[l - 2]};`;
    } else
      h6 = l, d = `
        ${c} sourceLocR = coords;
        ++${u[l - 1]};
        ${c} sourceLocG = coords;
        ++${u[l - 2]};
        ${c} sourceLocA = coords;
        --${u[l - 1]};
        ${c} sourceLocB = coords;
        --${u[l - 2]};`;
    const p6 = ["x", "y", "z", "w", "u", "v"].slice(0, h6), f = "." + p6[h6 - 1], m = p6.map((S) => "int " + S), g6 = We$1("sourceLocR", h6 - 1).concat("inIdx.r"), b6 = We$1("sourceLocG", h6 - 1).concat("inIdx.g"), x6 = We$1("sourceLocB", h6 - 1).concat("inIdx.b"), w6 = We$1("sourceLocA", h6 - 1).concat("inIdx.a"), y6 = s === "max" ? "greaterThan" : "lessThan", I = o ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${g6.join()}),
                             getBestIndicesAChannel(${b6.join()}),
                             getBestIndicesAChannel(${x6.join()}),
                             getBestIndicesAChannel(${w6.join()})));`, C6 = `vec4(
            getAChannel(${g6.join()}),
            hasNextCol ? getAChannel(${b6.join()}) : 0.,
            hasNextRow ? getAChannel(${x6.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w6.join()}) : 0.)`, k7 = o ? "" : `
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p6.join()}),
                                          vec2(${p6.slice(-2).join()}));
      }`;
    this.userCode = `
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p6.join()}),
                               vec2(${p6.slice(-2).join()}));
      }
      ${k7}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l - 1]} < ${a[l - 1] - 1};
        bool hasNextRow = ${u[l - 2]} < ${a[l - 2] - 1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${C6};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${C6};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${y6}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zw(n, t, e, s = null) {
  let o = t.shape[0], r = t.shape[1];
  s != null && (o = s.shape[0], r = s.shape[1]);
  const i6 = Uc(r), a = { windowSize: i6, inSize: r, batchSize: o, outSize: Math.ceil(r / i6) }, l = new XA(a, e, s == null), c = [t];
  s != null && c.push(s);
  const u = n.runWebGLProgram(l, c, "int32");
  if (u.shape[1] === 1)
    return u;
  const d = Zw(n, t, e, u);
  return n.disposeIntermediateTensorInfo(u), d;
}
function Bw(n, t, e, s = null) {
  const o = s != null ? s.shape : t.shape, r = o[o.length - 1], i6 = Uc(r), a = new PA(o, i6, e, s == null), l = s == null ? [t] : [t, s], c = n.runWebGLProgram(a, l, "int32");
  if (c.shape.length === t.shape.length) {
    const u = Bw(n, t, e, c);
    return n.disposeIntermediateTensorInfo(c), u;
  }
  return c;
}
function Hw(n, t, e, s) {
  const o = [e];
  if (Te("arg" + s.charAt(0).toUpperCase() + s.slice(1), o, t.shape.length), !F().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
    const r = [], i6 = n.texData.get(t.dataId), a = i6 !== null && i6.isPacked;
    let l = t;
    a && (l = n.unpackTensor(t), r.push(l));
    const [c, u] = ye$1(l.shape, o), d = O(u), h6 = st({ inputs: { x: l }, backend: n, attrs: { shape: [-1, d] } });
    r.push(h6);
    const p6 = Zw(n, h6, s);
    r.push(p6);
    const f = st({ inputs: { x: p6 }, backend: n, attrs: { shape: c } });
    return r.forEach((m) => n.disposeIntermediateTensorInfo(m)), f;
  }
  return Bw(n, t, s);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function AA(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r } = s;
  let i6 = Ct(r, o.shape);
  const a = qt$1(i6, o.shape.length);
  let l = o;
  const c = [];
  a != null && (l = Fe({ inputs: { x: o }, backend: e, attrs: { perm: a } }), c.push(l), i6 = ie(i6.length, l.shape.length)), Te("argMax", [i6[0]], l.shape.length);
  const u = Hw(e, l, i6[0], "max");
  return c.forEach((d) => e.disposeIntermediateTensorInfo(d)), u;
}
const OA = {
  kernelName: zl,
  backendName: "webgl",
  kernelFunc: AA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function KA(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r } = s;
  let i6 = Ct(r, o.shape);
  const a = qt$1(i6, o.shape.length);
  let l = o;
  const c = [];
  a != null && (l = Fe({ inputs: { x: o }, backend: e, attrs: { perm: a } }), c.push(l), i6 = ie(i6.length, l.shape.length)), Te("argMin", [i6[0]], l.shape.length);
  const u = Hw(e, l, i6[0], "min");
  return c.forEach((d) => e.disposeIntermediateTensorInfo(d)), u;
}
const ZA = {
  kernelName: Xl,
  backendName: "webgl",
  kernelFunc: KA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BA = En$1 + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`, HA = Nt$1({ opSnippet: BA }), _A = {
  kernelName: pi,
  backendName: "webgl",
  kernelFunc: HA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const UA = En$1 + "return log(x + sqrt(x * x + 1.0));", YA = Nt$1({ opSnippet: UA }), QA = {
  kernelName: fi,
  backendName: "webgl",
  kernelFunc: YA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const JA = En$1 + `
  return atan(x);
`, jA = Nt$1({ opSnippet: JA }), qA = {
  kernelName: mi,
  backendName: "webgl",
  kernelFunc: jA
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tO = Af$1 + `
  return atan(a, b);
`, eO = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + $a + `
  return result;
`, nO = Ne({ opSnippet: tO, packedOpSnippet: eO }), sO = {
  kernelName: bi,
  backendName: "webgl",
  kernelFunc: nO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oO = En$1 + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`, rO = Nt$1({ opSnippet: oO }), iO = {
  kernelName: gi,
  backendName: "webgl",
  kernelFunc: rO
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class li {
  constructor(t, e, s, o = false, r = false) {
    if (this.variableNames = ["x"], e === "avg" && s)
      throw new Error("Cannot compute positions for average pool.");
    const i6 = t.filterWidth, a = t.strideHeight, l = t.strideWidth, c = t.dilationHeight, u = t.dilationWidth, d = t.effectiveFilterHeight, h6 = t.effectiveFilterWidth, p6 = t.padInfo.top, f = t.padInfo.left;
    this.outputShape = t.outShape;
    const m = e === "avg", g6 = `((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`, b6 = `(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;
    let x6 = "0.0";
    if (m || (x6 = "-1.0 / 1e-20"), s) {
      const S = ">=";
      this.userCode = `
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p6}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h6};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${S} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o ? r ? g6 : b6 : `wR * ${h6} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    const w6 = "max";
    let y6 = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    e === "avg" && (y6 = "avgValue / max(count, 1.0)");
    const I = Math.floor(i6 / 4) * 4, C6 = i6 % 4, k7 = `
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w6}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p6}, ${f});
      const float initializationValue = ${x6};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x6});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k7}
          }

          int xC = xCCorner + ${I};
          if (${C6 === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k7}
          } else if (${C6 === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k7}
          } else if (${C6 === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k7}
          }
        }
        setOutput(${y6});
      }
    `;
  }
}
let Kf$1 = class Kf {
  constructor(t, e, s, o = false, r = false) {
    if (this.variableNames = ["x"], e === "avg" && s)
      throw new Error("Cannot compute positions for average pool.");
    const i6 = t.filterWidth, a = t.strideDepth, l = t.strideHeight, c = t.strideWidth, u = t.dilationDepth, d = t.dilationHeight, h6 = t.dilationWidth, p6 = t.effectiveFilterDepth, f = t.effectiveFilterHeight, m = t.effectiveFilterWidth, g6 = t.padInfo.front, b6 = t.padInfo.top, x6 = t.padInfo.left;
    this.outputShape = t.outShape;
    const w6 = e === "avg";
    let y6 = "0.0";
    if (w6 || (y6 = "-1.0 / 1e-20"), s) {
      const R = ">=";
      this.userCode = `
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${g6}, ${b6}, ${x6});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p6};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${h6}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${R} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o ? r ? `(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    const I = "max";
    let C6 = `${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    e === "avg" && (C6 = "avgValue / max(count, 1.0)");
    const k7 = Math.floor(i6 / 4) * 4, S = i6 % 4, N = `
      if (${w6}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${g6}, ${b6}, ${x6});
      const float initializationValue = ${y6};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y6});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p6};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k7}; wC += 4) {
              int xC = xCCorner + wC * ${h6};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h6}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h6}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h6}, ch)
              );

              ${N}
            }

            int xC = xCCorner + ${k7};
            if (${S === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${S === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h6}, ch),
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${S === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h6}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h6}, ch),
                initializationValue
              );

              ${N}
            }
          }
        }
        setOutput(${C6});
      }
    `;
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aO(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t;
  Na(o, "avgPool");
  const { filterSize: r, strides: i6, pad: a, dimRoundingMode: l } = s, c = 1;
  v(Ee$1(i6, c), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i6} and dilations '${c}'`);
  const u = $n$1(o.shape, r, i6, c, a, l);
  if (u.filterWidth === 1 && u.filterHeight === 1 && Rt$1(u.inShape, u.outShape))
    return tn$1({ inputs: { x: o }, backend: e });
  const d = new li(u, "avg", false);
  return e.runWebGLProgram(d, [o], "float32");
}
const lO = {
  kernelName: Pl,
  backendName: "webgl",
  kernelFunc: aO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cO(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { filterSize: r, strides: i6, pad: a, dimRoundingMode: l, dataFormat: c } = s, u = [1, 1, 1], d = xs(o.shape, r, i6, u, a, l, c), h6 = new Kf$1(d, "avg", false);
  return e.runWebGLProgram(h6, [o], "float32");
}
const uO = {
  kernelName: Al,
  backendName: "webgl",
  kernelFunc: cO
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class dO {
  constructor(t) {
    this.variableNames = ["dy"], this.outputShape = t.inShape;
    const e = t.filterHeight, s = t.filterWidth, o = t.strideHeight, r = t.strideWidth, i6 = t.dilationHeight, a = t.dilationWidth, l = t.effectiveFilterHeight, c = t.effectiveFilterWidth, u = l - 1 - t.padInfo.top, d = c - 1 - t.padInfo.left, h6 = 1 / (e * s);
    this.userCode = `
      const ivec2 pads = ivec2(${u}, ${d});
      const float avgMultiplier = float(${h6});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i6}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class hO {
  constructor(t) {
    this.variableNames = ["dy"], this.outputShape = t.inShape;
    const e = t.filterDepth, s = t.filterHeight, o = t.filterWidth, r = t.strideDepth, i6 = t.strideHeight, a = t.strideWidth, l = t.dilationDepth, c = t.dilationHeight, u = t.dilationWidth, d = t.effectiveFilterDepth, h6 = t.effectiveFilterHeight, p6 = t.effectiveFilterWidth, f = d - 1 - t.padInfo.front, m = h6 - 1 - t.padInfo.top, g6 = p6 - 1 - t.padInfo.left, b6 = 1 / (e * s * o);
    this.userCode = `
      const ivec3 pads = ivec3(${f}, ${m}, ${g6});
      const float avgMultiplier = float(${b6});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h6};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${i6}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p6};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pO(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, input: r } = t, i6 = r, { filterSize: a, strides: l, pad: c, dimRoundingMode: u } = s, d = [1, 1, 1], h6 = xs(i6.shape, a, l, d, c, u), p6 = new hO(h6);
  return e.runWebGLProgram(p6, [o], i6.dtype);
}
const fO = {
  kernelName: Yd$1,
  backendName: "webgl",
  kernelFunc: pO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mO(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, input: r } = t, i6 = r;
  Na([o, r], "avgPoolGrad");
  const { filterSize: a, strides: l, pad: c } = s, u = $n$1(i6.shape, a, l, 1, c), d = new dO(u);
  return e.runWebGLProgram(d, [o], i6.dtype);
}
const gO = {
  kernelName: Ud$1,
  backendName: "webgl",
  kernelFunc: mO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bO(n) {
  const { inputs: t, backend: e, attrs: s } = n, { a: o, b: r } = t, { transposeA: i6, transposeB: a } = s;
  return Gl({ a: o, b: r, transposeA: i6, transposeB: a, backend: e });
}
const xO = {
  kernelName: Ol,
  backendName: "webgl",
  kernelFunc: bO
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class yO {
  constructor(t, e, s, o, r, i6) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], bt$1(t, e), bt$1(t, s);
    let a = "0.0";
    o != null && (bt$1(t, o), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
    let l = "1.0";
    r != null && (bt$1(t, r), this.variableNames.push("scale"), l = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i6}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class wO {
  constructor(t, e, s, o, r, i6) {
    this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], bt$1(t, e), bt$1(t, s);
    let a = "vec4(0.0)";
    o != null && (bt$1(t, o), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
    let l = "vec4(1.0)";
    r != null && (bt$1(t, r), this.variableNames.push("scale"), l = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = `
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i6}));

        setOutput((x - mean) * inv + offset);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IO = ({ inputs: n, backend: t, attrs: e }) => {
  const { x: s, mean: o, variance: r, offset: i6, scale: a } = n;
  v(o.shape.length === r.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), v(i6 == null || o.shape.length === i6.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), v(a == null || o.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  let { varianceEpsilon: l } = e;
  l == null && (l = 1e-3);
  const c = [s, o, r];
  let u = null;
  i6 != null && (u = i6.shape, c.push(i6));
  let d = null;
  a != null && (d = a.shape, c.push(a));
  const h6 = F().getBool("WEBGL_PACK_NORMALIZATION") ? new wO(s.shape, o.shape, r.shape, u, d, l) : new yO(s.shape, o.shape, r.shape, u, d, l);
  return t.runWebGLProgram(h6, c, c[0].dtype);
}, CO = {
  kernelName: tc,
  backendName: "webgl",
  kernelFunc: IO
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class vO {
  constructor(t) {
    this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;
    const e = Kt(this.rank);
    this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    const s = SO(this.rank);
    let o;
    const r = t.map((i6, a) => `sourceLoc.${Wd$1[a]} = start[${a}] + coords.${Wd$1[a]};`);
    o = `
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${r.join(`
`)}
      `, this.userCode = `
      void main() {
        ${o}
        setOutput(getSource(${s}));
      }
    `;
  }
}
const Wd$1 = ["x", "y", "z", "w", "u", "v"];
function SO(n) {
  if (n === 1)
    return "sourceLoc";
  if (n <= 6)
    return Wd$1.slice(0, n).map((t) => "sourceLoc." + t).join(",");
  throw Error(`Slicing for rank ${n} is not yet supported`);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class kO {
  constructor(t) {
    this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t, this.rank = t.length, this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    const e = Kt(this.rank), s = We$1("coords", this.rank), o = We$1("sourceLoc", this.rank), r = this.rank === 1 ? "sourceLoc" : `vec2(${o.slice(-2).join()})`, i6 = `getChannel(getSource(${o.join()}), ${r})`, a = `
      result.x = ${i6};
      if (++${s[this.rank - 1]} < ${t[this.rank - 1]}) {
        ++${o[this.rank - 1]};
        result.y = ${i6};
        --${o[this.rank - 1]};
      }
    `, l = this.rank === 1 ? "" : `
      --${s[this.rank - 1]};
      if (++${s[this.rank - 2]} < ${t[this.rank - 2]}) {
        ++${o[this.rank - 2]};
        result.z = ${i6};
        if (++${s[this.rank - 1]} < ${t[this.rank - 1]}) {
          ++${o[this.rank - 1]};
          result.w = ${i6};
        }
      }
    `, c = this.rank <= 4 ? `sourceLoc = coords +
            ${e}(${t.map((u, d) => `start[${d}]`).join()});` : t.map((u, d) => `${o[d]} = ${s[d]} + start[${d}];`).join(`
`);
    this.userCode = `
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function TO(n, t, e, s) {
  const o = s.texData.get(n.dataId), r = s.makeTensorInfo(e, n.dtype), i6 = s.texData.get(r.dataId);
  Object.assign(i6, o), i6.refCount = 1, i6.shape = e, i6.dtype = n.dtype;
  let a = Dp(t, dt(n.shape));
  o.slice && (a += o.slice.flatOffset), i6.slice = {
    flatOffset: a,
    // Point to the original dataId, which is used to do ref counting.
    origDataId: o.slice && o.slice.origDataId || n.dataId
  };
  const l = s.dataRefCount.get(i6.slice.origDataId) || 1;
  return s.dataRefCount.set(i6.slice.origDataId, l + 1), r;
}
function Er(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { begin: r, size: i6 } = s, [a, l] = Hc(o, r, i6);
  if (Lp(o, a, l), O(l) === 0)
    return e.makeTensorInfo(l, o.dtype, []);
  if (e.shouldExecuteOnCPU([o]) || o.dtype === "string") {
    const d = e.texData.get(o.dataId), h6 = yP(d.values, a, l, o.shape, o.dtype);
    return e.makeTensorInfo(l, o.dtype, h6);
  }
  const { isPacked: c } = e.texData.get(o.dataId), u = Wp(o.shape, a, l);
  if (c || !u) {
    const d = F().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new kO(l) : new vO(l), h6 = [a];
    return e.runWebGLProgram(d, [o], o.dtype, h6);
  }
  return e.uploadToGPU(o.dataId), TO(o, a, l, e);
}
const NO = {
  kernelName: $c,
  backendName: "webgl",
  kernelFunc: Er
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const RO = (n) => {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { blockShape: r, crops: i6 } = s;
  v(o.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
  const a = r.reduce((x6, w6) => x6 * w6), l = fa(o.shape, r, a), c = ma(l.length, r.length), u = ga(o.shape, r, a), d = Pp(i6, r.length), h6 = Ap(u, i6, r.length), p6 = [], f = st({ inputs: { x: o }, backend: e, attrs: { shape: l } }), m = Fe({ inputs: { x: f }, backend: e, attrs: { perm: c } }), g6 = st({
    inputs: { x: m },
    backend: e,
    attrs: { shape: u }
  }), b6 = Er({
    inputs: { x: g6 },
    backend: e,
    attrs: { begin: d, size: h6 }
  });
  return p6.push(f), p6.push(m), p6.push(g6), p6.forEach((x6) => e.disposeIntermediateTensorInfo(x6)), b6;
}, $O = {
  kernelName: Kl,
  backendName: "webgl",
  kernelFunc: RO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function GO(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, weights: r } = t, { size: i6 } = s, a = e.readSync(o.dataId), l = e.readSync(r.dataId), c = Mw(a, l, r.dtype, r.shape, i6);
  return e.makeTensorInfo([i6], r.dtype, c);
}
const EO = {
  kernelName: Qd$1,
  backendName: "webgl",
  kernelFunc: GO
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function LO(n) {
  const { inputs: t, backend: e } = n, { s0: s, s1: o } = t, r = e.readSync(s.dataId), i6 = e.readSync(o.dataId), a = bt$1(Array.from(r), Array.from(i6));
  return e.makeTensorInfo([a.length], "int32", Int32Array.from(a));
}
const MO = {
  kernelName: Kg$1,
  backendName: "webgl",
  kernelFunc: LO
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WO = "return float(a != b);", _w = Ne({ opSnippet: WO, cpuKernelImpl: uP, dtype: "bool" }), DO = {
  kernelName: bc,
  backendName: "webgl",
  kernelFunc: _w
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ea(n) {
  const { inputs: t, backend: e } = n, { input: s } = t, o = e.texData.get(s.dataId);
  return tn$1({ inputs: { x: o.complexTensorInfos.real }, backend: e });
}
const FO = {
  kernelName: wh$1,
  backendName: "webgl",
  kernelFunc: Ea
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const VO = "return float(int(x));";
function zO(n, t) {
  const e = new qn$1(n.shape, VO), s = t.runWebGLProgram(e, [n], "int32");
  return { dataId: s.dataId, shape: s.shape, dtype: s.dtype };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dd$1(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { dtype: r } = s;
  if (r === "complex64") {
    if (o.dtype === "complex64")
      return tn$1({ inputs: { x: o }, backend: e });
    const i6 = ge$1(o.shape), a = Dd$1({ inputs: { x: o }, backend: e, attrs: { dtype: "float32" } }), l = js({ inputs: { real: a, imag: i6 }, backend: e });
    return i6.dispose(), e.disposeIntermediateTensorInfo(a), l;
  }
  if (o.dtype === "complex64") {
    const i6 = Ea({ inputs: { input: o }, backend: e }), a = Dd$1({ inputs: { x: i6 }, backend: e, attrs: { dtype: r } });
    return e.disposeIntermediateTensorInfo(i6), a;
  }
  if (!Od$1(o.dtype, r)) {
    const i6 = tn$1({ inputs: { x: o }, backend: e });
    return { dataId: i6.dataId, shape: i6.shape, dtype: r };
  }
  if (e.shouldExecuteOnCPU([o])) {
    const i6 = e.texData.get(o.dataId).values, [a, l, c] = ZX(i6, o.shape, o.dtype, r);
    return e.makeTensorInfo(a, l, c);
  }
  if (r === "int32")
    return zO(o, e);
  if (r === "bool") {
    const i6 = e.makeTensorInfo([], "bool", xe$1("bool", 1)), l = _w({ inputs: { a: o, b: i6 }, backend: e });
    return e.disposeIntermediateTensorInfo(i6), l;
  }
  throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${r}`);
}
const XO = {
  kernelName: xi,
  backendName: "webgl",
  kernelFunc: Dd$1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dg$1 = "return ceil(x);", PO = Nt$1({ opSnippet: dg$1, packedOpSnippet: dg$1, cpuKernelImpl: BX }), AO = {
  kernelName: yi,
  backendName: "webgl",
  kernelFunc: PO
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class OO {
  constructor(t) {
    this.variableNames = ["A"], this.customUniforms = [
      { name: "minVal", type: "float" },
      { name: "maxVal", type: "float" }
    ], this.outputShape = t, this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class KO {
  constructor(t) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
      { name: "minVal", type: "float" },
      { name: "maxVal", type: "float" }
    ], this.outputShape = t, this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ZO(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { clipValueMin: r, clipValueMax: i6 } = s;
  let a;
  F().getBool("WEBGL_PACK_CLIP") ? a = new KO(o.shape) : a = new OO(o.shape);
  const l = [[r], [i6]];
  return e.runWebGLProgram(a, [o], o.dtype, l);
}
const BO = {
  kernelName: wi,
  backendName: "webgl",
  kernelFunc: ZO
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class HO {
  constructor(t) {
    this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hg$1(n, t) {
  return {
    dataId: t.dataId,
    dtype: t.dtype,
    shape: n.shape
  };
}
function _O(n) {
  const { inputs: t, backend: e } = n, { x: s } = t, o = e.texData.get(s.dataId), r = new HO(s.shape), i6 = [
    hg$1(s, o.complexTensorInfos.real),
    hg$1(s, o.complexTensorInfos.imag)
  ];
  return e.runWebGLProgram(r, i6, i6[0].dtype);
}
const UO = {
  kernelName: Zl,
  backendName: "webgl",
  kernelFunc: _O
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class YO {
  // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().
  constructor(t) {
    this.outputShape = [], this.outputShape = ts(
      t,
      1
      /* axis */
    ), this.variableNames = t.map((i6, a) => `T${a}`);
    const e = new Array(t.length - 1);
    e[0] = t[0][1];
    for (let i6 = 1; i6 < e.length; i6++)
      e[i6] = e[i6 - 1] + t[i6][1];
    const s = [`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];
    for (let i6 = 1; i6 < e.length; i6++) {
      const a = e[i6 - 1];
      s.push(`else if (yC < ${e[i6]}) setOutput(getT${i6}(yR, yC-${a}));`);
    }
    const o = e.length, r = e[e.length - 1];
    s.push(`else setOutput(getT${o}(yR, yC-${r}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class QO {
  constructor(t, e) {
    this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = ts(t, e);
    const s = this.outputShape, o = s.length, r = Kt(o), i6 = We$1("coords", o), a = ["x", "y", "z", "w", "u", "v"].slice(0, o);
    this.variableNames = t.map((m, g6) => `T${g6}`);
    const l = new Array(t.length - 1);
    l[0] = t[0][e];
    for (let m = 1; m < l.length; m++)
      l[m] = l[m - 1] + t[m][e];
    const c = a[e], u = a.slice(-2), d = a.join();
    let h6 = `if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${u.join()}));
        }`;
    for (let m = 1; m < l.length; m++) {
      const g6 = l[m - 1];
      h6 += `
        if (${c} < ${l[m]}  && ${c} >= ${l[m - 1]}) {
          return getChannel(
            getT${m}(${Ha(a, c, g6)}),
            vec2(${Ha(u, c, g6)}));
        }`;
    }
    const p6 = l.length, f = l[l.length - 1];
    h6 += `
        return getChannel(
          getT${p6}(${Ha(a, c, f)}),
          vec2(${Ha(u, c, f)}));`, this.userCode = `
      float getValue(${a.map((m) => "int " + m)}) {
        ${h6}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i6}), 0., 0., 0.);

        ${i6[o - 1]} = ${i6[o - 1]} + 1;
        if (${i6[o - 1]} < ${s[o - 1]}) {
          result.g = getValue(${i6});
        }

        ${i6[o - 2]} = ${i6[o - 2]} + 1;
        if (${i6[o - 2]} < ${s[o - 2]}) {
          result.a = getValue(${i6});
        }

        ${i6[o - 1]} = ${i6[o - 1]} - 1;
        if (${i6[o - 2]} < ${s[o - 2]} &&
            ${i6[o - 1]} < ${s[o - 1]}) {
          result.b = getValue(${i6});
        }
        setOutput(result);
      }
    `;
  }
}
function Ha(n, t, e) {
  const s = n.indexOf(t);
  return n.map((r, i6) => i6 === s ? `${r} - ${e}` : r).join();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mu(n) {
  const { inputs: t, backend: e } = n, { input: s } = t, o = e.texData.get(s.dataId);
  return tn$1({ inputs: { x: o.complexTensorInfos.imag }, backend: e });
}
const JO = {
  kernelName: hh$1,
  backendName: "webgl",
  kernelFunc: mu
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zr(n, t, e) {
  const s = n[0].dtype;
  if (s === "complex64") {
    const p6 = n.map((x6) => Ea({ inputs: { input: x6 }, backend: e })), f = n.map((x6) => mu({ inputs: { input: x6 }, backend: e })), m = Zr(p6, t, e), g6 = Zr(f, t, e), b6 = js({ inputs: { real: m, imag: g6 }, backend: e });
    return p6.forEach((x6) => e.disposeIntermediateTensorInfo(x6)), f.forEach((x6) => e.disposeIntermediateTensorInfo(x6)), e.disposeIntermediateTensorInfo(m), e.disposeIntermediateTensorInfo(g6), b6;
  }
  let o = e.shouldExecuteOnCPU(n);
  if (s === "string" && (o = true), o) {
    const p6 = n.map((y6) => {
      const C6 = [-1, O(y6.shape.slice(t))];
      return st({ inputs: { x: y6 }, backend: e, attrs: { shape: C6 } });
    }), f = p6.map((y6) => ({ vals: e.readSync(y6.dataId), shape: y6.shape })), m = ts(
      p6.map((y6) => y6.shape),
      1
      /* axis */
    ), g6 = p6[0].shape[0] === 1, b6 = HX(f, m, s, g6), x6 = ts(n.map((y6) => y6.shape), t), w6 = e.makeTensorInfo(x6, s, b6);
    return p6.forEach((y6) => e.disposeIntermediateTensorInfo(y6)), w6;
  }
  const r = n.filter((p6) => O(p6.shape) > 0), i6 = F().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && r[0].shape.length > 1;
  if (r.length === 1) {
    const p6 = i6 ? new qn$1(n[0].shape, Ns) : new Ls(n[0].shape, Ns);
    return e.runWebGLProgram(p6, n, s);
  }
  const a = F().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
  if (r.length > a) {
    const p6 = [];
    for (let m = 0; m < r.length; m += a) {
      const g6 = r.slice(m, m + a);
      p6.push(Zr(g6, t, e));
    }
    const f = Zr(p6, t, e);
    for (const m of p6)
      e.disposeIntermediateTensorInfo(m);
    return f;
  }
  if (i6) {
    const p6 = new QO(r.map((f) => f.shape), t);
    return e.runWebGLProgram(p6, r, s);
  }
  const { tensors2D: l, outShape: c } = jO(r, t, e), u = new YO(l.map((p6) => p6.shape)), d = e.runWebGLProgram(u, l, s);
  l.forEach((p6) => e.disposeIntermediateTensorInfo(p6));
  const h6 = st({ inputs: { x: d }, attrs: { shape: c }, backend: e });
  return e.disposeIntermediateTensorInfo(d), h6;
}
function jO(n, t, e) {
  const s = ts(n.map((r) => r.shape), t);
  return { tensors2D: n.map((r) => st({
    inputs: { x: r },
    attrs: { shape: [-1, O(r.shape.slice(t))] },
    backend: e
  })), outShape: s };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Uw(n) {
  const { inputs: t, backend: e, attrs: s } = n, { axis: o } = s, r = Ct(o, t[0].shape)[0], i6 = t.map((c) => c.shape);
  Vp(i6, r);
  const a = ts(t.map((c) => c.shape), r);
  if (O(a) === 0)
    return e.makeTensorInfo(a, t[0].dtype, []);
  const l = t.filter((c) => O(c.shape) > 0);
  return l.length === 1 ? tn$1({ inputs: { x: l[0] }, backend: e }) : Zr(l, r, e);
}
const qO = {
  kernelName: Bl,
  backendName: "webgl",
  kernelFunc: Uw
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Yw {
  constructor(t, e = false, s = null, o = false, r = false) {
    this.variableNames = ["x", "W"], this.outputShape = t.outShape;
    const i6 = t.padInfo.top, a = t.padInfo.left, l = t.strideHeight, c = t.strideWidth, u = t.dilationHeight, d = t.dilationWidth, h6 = t.filterHeight, p6 = t.filterWidth, f = Math.floor(t.inChannels / 4) * 4, m = t.inChannels % 4, g6 = t.dataFormat === "channelsLast", b6 = g6 ? 1 : 2, x6 = g6 ? 2 : 3, w6 = g6 ? 3 : 1;
    let y6 = "", I = "";
    s && (o ? y6 = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }` : r ? y6 = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }` : y6 = `
          float activation(float x) {
            ${s}
          }
        `, I = "result = activation(result);");
    const C6 = e ? "result += getBiasAtOutCoords();" : "";
    e && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${y6}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${i6}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w6}];

        ivec2 xRCCorner =
            ivec2(coords[${b6}], coords[${x6}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h6}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p6}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g6}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m === 1}) {

              if (${g6}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g6}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g6}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${C6}
        ${I}
        setOutput(result);
      }
    `;
  }
}
class tK {
  constructor(t) {
    this.variableNames = ["x", "W"], this.outputShape = t.outShape;
    const e = t.padInfo.front, s = t.padInfo.top, o = t.padInfo.left, r = t.strideDepth, i6 = t.strideHeight, a = t.strideWidth, l = t.dilationDepth, c = t.dilationHeight, u = t.dilationWidth, d = t.filterDepth, h6 = t.filterHeight, p6 = t.filterWidth, f = Math.floor(t.inChannels / 4) * 4, m = t.inChannels % 4;
    this.userCode = `
      const ivec3 strides = ivec3(${r}, ${i6}, ${a});
      const ivec3 pads = ivec3(${e}, ${s}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h6}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p6}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Qw {
  constructor(t, e = false, s = null, o = false, r = false) {
    this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ], this.outputShape = t.outShape, this.enableShapeUniforms = Xe(this.outputShape.length);
    const i6 = t.padInfo.left, a = t.strideWidth, l = t.dilationWidth, c = t.filterHeight, u = t.filterWidth, d = u;
    let h6 = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
    for (let g6 = 0; g6 < u; g6++)
      h6 += `
           vec4 xTexelC${g6 * 2};
           int xTexelC${g6 * 2}Ready;
           vec4 xTexelC${g6 * 2 + 1};
           int xTexelC${g6 * 2 + 1}Ready;
           vec4 xC${g6};`;
    h6 += `
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;
    for (let g6 = 0; g6 < u; g6++)
      h6 += `
           xTexelC${g6 * 2} = vec4(0.0);
           xTexelC${g6 * 2}Ready = 0;
           xTexelC${g6 * 2 + 1} = vec4(0.0);
           xTexelC${g6 * 2 + 1}Ready = 0;
           xC${g6} = vec4(0.0);`;
    h6 += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
    for (let g6 = 0; g6 < (d + 1) / 2; g6++) {
      const b6 = g6 * 2;
      if (h6 += `
           xC = xCCorner + ${b6 * l};
           `, a === 1) {
        if (b6 < u && (i6 % 2 === 1 ? (h6 += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b6}Ready == 0) {
                   xTexelC${b6} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b6}.zw = vec2(0.0);
                   }
                   xTexelC${b6}Ready = 1;
                 }
               `, l === 1 && b6 > 0 ? h6 += `
                 xC${b6} = vec4(xTexelC${b6 - 2}.zw, xTexelC${b6}.xy);
                 ` : h6 += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b6} = vec4(previous.zw, xTexelC${b6}.xy);
                   } else {
                     xC${b6} = vec4(0.0, 0.0, xTexelC${b6}.xy);
                   }
                   `) : h6 += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b6}Ready == 0) {
                   xTexelC${b6} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b6}.zw = vec2(0.0);
                   }
                   xTexelC${b6}Ready = 1;
                 }

                 xC${b6} = xTexelC${b6};
                 `, b6 + 1 < u)) {
          const x6 = i6 % 2 === 0 ? Wl(l) : l;
          l % 2 === 0 && i6 % 2 === 1 || l % 2 !== 0 && i6 % 2 !== 1 ? (h6 += `
                   xCOffset = xC + imod(pads[1], 2) + ${x6};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b6 + 1}Ready == 0) {
                     xTexelC${b6 + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b6 + 1}.zw = vec2(0.0);
                     }
                     xTexelC${b6 + 1}Ready = 1;
                   }
                   `, l > 1 ? h6 += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b6 + 1} = vec4(previous.zw, xTexelC${b6 + 1}.xy);
                     } else {
                      xC${b6 + 1} = vec4(0.0, 0.0, xTexelC${b6 + 1}.xy);
                     }
                     ` : h6 += `
                     xC${b6 + 1} = vec4(xTexelC${b6}.zw, xTexelC${b6 + 1}.xy);
                     `) : x6 === 1 ? h6 += `
                     xC${b6 + 1} = xTexelC${b6};
                     ` : h6 += `
                     xCOffset = xC + ${x6};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b6 + 1}Ready == 0) {
                       xTexelC${b6 + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b6 + 1}.zw = vec2(0.0);
                       }
                       xTexelC${b6 + 1}Ready = 1;
                     }

                     xC${b6 + 1} = xTexelC${b6 + 1};
                     `;
        }
      } else
        b6 < u && (i6 % 2 === 1 ? (h6 += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b6}Ready == 0) {
                   xTexelC${b6} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b6}.zw = vec2(0.0);
                   }
                   xTexelC${b6}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b6 + 1}Ready == 0) {
                   xTexelC${b6 + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b6 + 1}.zw = vec2(0.0);
                   }
                   xTexelC${b6 + 1}Ready = 1;
                 }

                 xC${b6} = vec4(xTexelC${b6}.zw, xTexelC${b6 + 1}.zw);
               `, b6 + 1 < u && (h6 += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b6 + 1} = vec4(xTexelC${b6 + 1}.xy, final.xy);
                 `)) : (h6 += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b6}Ready == 0) {
                   xTexelC${b6} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b6}.zw = vec2(0.0);
                   }
                   xTexelC${b6}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b6 + 1}Ready == 0) {
                   xTexelC${b6 + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b6 + 1}.zw = vec2(0.);
                   }
                   xTexelC${b6 + 1}Ready = 1;
                 }

                 xC${b6} = vec4(
                   xTexelC${b6}.xy, xTexelC${b6 + 1}.xy);
               `, b6 + 1 < u && (h6 += `
                   xC${b6 + 1} = vec4(xTexelC${b6}.zw, xTexelC${b6 + 1}.zw);
                 `)));
      b6 < u && (h6 += `
             wTexel = getW(r, ${b6}, d1, d2);
             dotProd += xC${b6}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${b6}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `, b6 + 1 < u && (h6 += `
               wTexel = getW(r, ${b6 + 1}, d1, d2);
               dotProd += xC${b6 + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${b6 + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `));
    }
    h6 += `
     }
   `, h6 += `
     }
   `, h6 += `
     }
   `;
    let p6 = "", f = "";
    s && (o ? p6 = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }` : r ? p6 = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }` : p6 = `vec4 activation(vec4 x) {
           ${s}
         }`, f = "result = activation(result);");
    const m = e ? "result += getBiasAtOutCoords();" : "";
    e && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
       ${p6}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h6}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class eK {
  constructor(t, e) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
      { name: "inputShape", type: "ivec4" },
      { name: "pad", type: "ivec2" },
      { name: "stride", type: "ivec2" },
      { name: "dilation", type: "ivec2" },
      { name: "inChannels", type: "int" },
      { name: "itemsPerBlockRow", type: "int" },
      { name: "outWidth", type: "int" }
    ], this.outputShape = t, this.enableShapeUniforms = Xe(this.outputShape.length);
    const { dataFormat: s } = e, o = ze$1(), r = s === "channelsLast", i6 = r ? 1 : 2, a = r ? 2 : 3, l = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;
    let c = "";
    for (let u = 0; u <= 1; u++)
      for (let d = 0; d <= 1; d++)
        c += `
          blockIndex = rc.z + ${d};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i6}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${u * 2 + d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u * 2 + d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
    this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${o.output} = result;
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function El(n, t) {
  const e = n.length;
  return e >= 3 ? t ? [
    ...n.slice(0, -3),
    n[e - 3] * n[e - 2],
    n[e - 1]
    /* channel */
  ] : [
    ...n.slice(0, -3),
    n[e - 3],
    n[e - 2] * n[e - 1]
    /* height * width */
  ] : !t && e === 1 && n[0] > 1 ? [n[0], 1] : null;
}
function Jw({ x: n, filter: t, convInfo: e, backend: s, bias: o = null, preluActivationWeights: r = null, leakyreluAlpha: i6 = 0, activation: a = null }) {
  const l = n.shape, c = s.texData.get(n.dataId), u = e.inChannels, d = l[0] * l[1] * l[2], h6 = e.outChannels, p6 = e.dataFormat === "channelsLast", f = false, m = false;
  let g6;
  const b6 = [];
  if (r != null) {
    const y6 = El(r.shape, p6);
    y6 != null && (r = st({
      inputs: { x: r },
      backend: s,
      attrs: { shape: y6 }
    }), b6.push(r));
  }
  if (o != null) {
    const y6 = El(o.shape, p6);
    y6 != null && (o = st({ inputs: { x: o }, backend: s, attrs: { shape: y6 } }), b6.push(o));
  }
  if (!((d === 1 || h6 === 1) && u > Kw) && c.isPacked && p6 && c.texture != null && l[2] % 2 !== 0 && Rt$1(c.shape.slice(-3), l.slice(-3))) {
    const y6 = l[0] * l[1] * (l[2] + 1), I = {
      dataId: n.dataId,
      shape: [1, y6, e.inChannels],
      dtype: n.dtype
    }, C6 = c.shape;
    c.shape = c.shape.slice(), c.shape[c.shape.length - 2]++, v($l(c.shape, I.shape), () => `packed reshape ${c.shape} to ${I.shape} isn't free`);
    const k7 = st({
      inputs: { x: t },
      backend: s,
      attrs: { shape: [1, e.inChannels, e.outChannels] }
    });
    b6.push(k7);
    const S = Gl({
      a: I,
      b: k7,
      backend: s,
      transposeA: f,
      transposeB: m,
      bias: o,
      activation: a,
      preluActivationWeights: r,
      leakyreluAlpha: i6
    }), N = s.texData.get(S.dataId);
    v(N.isPacked, () => "batchMatMul result is expected to be packed"), c.shape = C6, N.shape = e.outShape, g6 = tn$1({ inputs: { x: S }, backend: s }), g6.shape = e.outShape, b6.push(S);
  } else {
    const y6 = e.outHeight * e.outWidth, I = st({
      inputs: { x: n },
      backend: s,
      attrs: {
        shape: p6 ? [e.batchSize, y6, e.inChannels] : [e.batchSize, e.inChannels, y6]
      }
    }), C6 = st({
      inputs: { x: t },
      backend: s,
      attrs: { shape: [1, e.inChannels, e.outChannels] }
    }), k7 = Gl({
      a: p6 ? I : C6,
      b: p6 ? C6 : I,
      transposeA: !p6,
      transposeB: m,
      backend: s,
      bias: o,
      activation: a,
      preluActivationWeights: r,
      leakyreluAlpha: i6
    });
    g6 = st({ inputs: { x: k7 }, backend: s, attrs: { shape: e.outShape } }), b6.push(I), b6.push(C6), b6.push(k7);
  }
  for (const y6 of b6)
    s.disposeIntermediateTensorInfo(y6);
  return g6;
}
function jw({ x: n, filter: t, convInfo: e, backend: s, bias: o = null, preluActivationWeights: r = null, leakyreluAlpha: i6 = 0, activation: a = null }) {
  const { filterWidth: l, filterHeight: c, inChannels: u, outWidth: d, outHeight: h6, dataFormat: p6 } = e, f = p6 === "channelsLast", m = l * c * u, g6 = h6 * d, b6 = [e.batchSize, m, g6], x6 = true, w6 = false, y6 = [];
  if (r != null) {
    const Z = El(r.shape, f);
    Z != null && (r = st({
      inputs: { x: r },
      backend: s,
      attrs: { shape: Z }
    }), y6.push(r));
  }
  if (o != null) {
    const Z = El(o.shape, f);
    Z != null && (o = st({ inputs: { x: o }, backend: s, attrs: { shape: Z } }), y6.push(o));
  }
  const I = st({
    inputs: { x: t },
    backend: s,
    attrs: { shape: [1, m, O(t.shape) / m] }
  });
  y6.push(I);
  const C6 = new eK(b6, e), k7 = [
    n.shape,
    [e.padInfo.top, e.padInfo.left],
    [e.strideHeight, e.strideWidth],
    [e.dilationHeight, e.dilationWidth],
    [e.inChannels],
    [e.filterWidth * e.inChannels],
    [e.outWidth]
  ], S = s.runWebGLProgram(C6, [n], "float32", k7), N = st({ inputs: { x: S }, backend: s, attrs: { shape: b6 } });
  y6.push(S), y6.push(N);
  const R = o != null, M6 = r != null, V = a === "leakyrelu", z = a ? ai$1(a, true) : null, X = new Ow(f ? N.shape : I.shape, f ? I.shape : N.shape, f ? [e.batchSize, g6, e.outChannels] : [e.batchSize, e.outChannels, g6], x6, w6, R, z, M6, V), P6 = f ? [N, I] : [I, N];
  if (o && P6.push(o), M6 && P6.push(r), V) {
    const Z = s.makeTensorInfo([], "float32", bs(i6, "float32"));
    P6.push(Z), y6.push(Z);
  }
  const A6 = s.runWebGLProgram(X, P6, "float32"), B6 = st({ inputs: { x: A6 }, backend: s, attrs: { shape: e.outShape } });
  y6.push(A6);
  for (const Z of y6)
    s.disposeIntermediateTensorInfo(Z);
  return B6;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r } = t, { strides: i6, pad: a, dataFormat: l, dilations: c, dimRoundingMode: u } = s, d = ys(l), h6 = ke(o.shape, r.shape, i6, c, a, u, false, d);
  let p6;
  if (h6.filterHeight === 1 && h6.filterWidth === 1 && h6.dilationHeight === 1 && h6.dilationWidth === 1 && h6.strideHeight === 1 && h6.strideWidth === 1 && (h6.padInfo.type === "SAME" || h6.padInfo.type === "VALID"))
    p6 = Jw({ x: o, filter: r, convInfo: h6, backend: e });
  else if (h6.strideWidth <= 2 && d === "channelsLast" && F().getBool("WEBGL_EXP_CONV")) {
    const m = new Qw(h6), g6 = [
      [h6.padInfo.top, h6.padInfo.left],
      [h6.strideHeight, h6.strideWidth],
      [h6.dilationHeight, h6.dilationWidth],
      [h6.inHeight, h6.inWidth]
    ];
    p6 = e.runWebGLProgram(m, [o, r], "float32", g6);
  } else if (F().getBool("WEBGL_CONV_IM2COL"))
    p6 = jw({ x: o, filter: r, convInfo: h6, backend: e });
  else {
    const m = new Yw(h6);
    p6 = e.runWebGLProgram(m, [o, r], "float32");
  }
  const f = st({ inputs: { x: p6 }, backend: e, attrs: { shape: h6.outShape } });
  return e.disposeIntermediateTensorInfo(p6), f;
}
const sK = {
  kernelName: Hl,
  backendName: "webgl",
  kernelFunc: nK
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class oK {
  constructor(t) {
    this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
    const e = t.strideHeight, s = t.strideWidth, o = t.padInfo.top, r = t.padInfo.left, i6 = t.dataFormat === "channelsLast";
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${i6}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class rK {
  constructor(t) {
    this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
    const e = t.filterHeight, s = t.filterWidth, o = t.strideHeight, r = t.strideWidth, i6 = t.dataFormat === "channelsLast", a = e - 1 - t.padInfo.top, l = s - 1 - t.padInfo.left, c = i6 ? 1 : 2, u = i6 ? 2 : 3, d = i6 ? 3 : 1;
    this.userCode = `
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i6}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class iK {
  constructor(t) {
    this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
    const e = t.strideDepth, s = t.strideHeight, o = t.strideWidth, r = t.padInfo.front, i6 = t.padInfo.top, a = t.padInfo.left;
    this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${r};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${i6};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class aK {
  constructor(t) {
    this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
    const e = t.filterDepth, s = t.filterHeight, o = t.filterWidth, r = t.strideDepth, i6 = t.strideHeight, a = t.strideWidth, l = e - 1 - t.padInfo.front, c = s - 1 - t.padInfo.top, u = o - 1 - t.padInfo.left;
    this.userCode = `
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i6}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, dy: r } = t, { strides: i6, pad: a, dataFormat: l, dimRoundingMode: c, filterShape: u } = s, d = ys(l), h6 = ke(o.shape, u, i6, 1, a, c, false, d), p6 = new oK(h6);
  return e.runWebGLProgram(p6, [o, r], "float32");
}
const cK = {
  kernelName: jd$1,
  backendName: "webgl",
  kernelFunc: lK
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function uK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, filter: r } = t, { inputShape: i6, strides: a, pad: l, dataFormat: c, dimRoundingMode: u } = s, d = ys(c), h6 = ke(i6, r.shape, a, 1, l, u, false, d), p6 = new rK(h6);
  return e.runWebGLProgram(p6, [o, r], "float32");
}
const dK = {
  kernelName: _l,
  backendName: "webgl",
  kernelFunc: uK
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r } = t, { strides: i6, pad: a, dilations: l } = s, c = Bs(o.shape, r.shape, i6, l, a), u = new tK(c);
  return e.runWebGLProgram(u, [o, r], "float32");
}
const pK = {
  kernelName: Ul,
  backendName: "webgl",
  kernelFunc: hK
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, dy: r } = t, { strides: i6, pad: a, filterShape: l } = s, c = Bs(o.shape, l, i6, 1, a), u = new iK(c);
  return e.runWebGLProgram(u, [o, r], "float32");
}
const mK = {
  kernelName: qd$1,
  backendName: "webgl",
  kernelFunc: fK
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, filter: r } = t, { pad: i6, strides: a, inputShape: l } = s, c = Bs(l, r.shape, a, 1, i6), u = new aK(c);
  return e.runWebGLProgram(u, [o, r], "float32");
}
const bK = {
  kernelName: th$1,
  backendName: "webgl",
  kernelFunc: gK
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xK = Gr + `
  return cos(x);
`, yK = Nt$1({ opSnippet: xK }), wK = {
  kernelName: Ii,
  backendName: "webgl",
  kernelFunc: yK
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IK = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`, CK = Nt$1({ opSnippet: IK }), vK = {
  kernelName: Ci,
  backendName: "webgl",
  kernelFunc: CK
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class SK {
  constructor(t, e, s, o, r) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    const [i6, a, l, c] = t, [u] = e, [d, h6] = s;
    this.outputShape = [u, d, h6, c];
    const p6 = o === "bilinear" ? 1 : 0, [f, m] = [`${a - 1}.0`, `${l - 1}.0`], [g6, b6, x6] = d > 1 ? [
      `${(a - 1) / (d - 1)}`,
      "(y2-y1) * height_ratio",
      `y1*${f} + float(y)*(height_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (y1+y2) * ${f}`
    ], [w6, y6, I] = h6 > 1 ? [
      `${(l - 1) / (h6 - 1)}`,
      "(x2-x1) * width_ratio",
      `x1*${m} + float(x)*(width_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (x1+x2) * ${m}`
    ];
    this.userCode = `
      const float height_ratio = float(${g6});
      const float width_ratio = float(${w6});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i6}) {
          return;
        }

        float height_scale = ${b6};
        float width_scale = ${y6};

        float in_y = ${x6};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p6} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kK = (n) => {
  const { inputs: t, backend: e, attrs: s } = n, { image: o, boxes: r, boxInd: i6 } = t, { cropSize: a, method: l, extrapolationValue: c } = s, u = new SK(o.shape, r.shape, a, l, c);
  return e.runWebGLProgram(u, [o, r, i6], "float32");
}, TK = {
  kernelName: nh$1,
  backendName: "webgl",
  kernelFunc: kK
};
var ci;
(function(n) {
  n.Prod = "*", n.Sum = "+";
})(ci || (ci = {}));
let pg$1 = class pg {
  constructor(t, e, s, o) {
    this.op = t, this.outputShape = e, this.variableNames = ["x"], this.customUniforms = [{ name: "index", type: "float" }];
    const r = this.outputShape.length, i6 = this.op === ci.Prod ? "1.0" : "0.0", a = s ? i6 : `getX(${fg$1(r, "coords", this.op)})`, l = this.outputShape[this.outputShape.length - 1];
    let c = "", u = "";
    s ? (c = o ? `end != ${l - 1}` : "end != 0", u = o ? "end + 1" : "end - 1") : (c = o ? `end + pow2 < ${l}` : "end >= pow2", u = o ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${Kt(r)} coords = getOutputCoords();
        int end = ${mg$1(r, "coords", this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${mg$1(r, "coords", this.op)} = idx;
          val ${this.op}= getX(${fg$1(r, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
  }
};
function fg$1(n, t, e) {
  if (n === 1)
    return `${t}`;
  if (n === 2)
    return `${t}.x, ${t}.y`;
  if (n === 3)
    return `${t}.x, ${t}.y, ${t}.z`;
  if (n === 4)
    return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
  throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`);
}
function mg$1(n, t, e) {
  if (n === 1)
    return `${t}`;
  if (n === 2)
    return `${t}.y`;
  if (n === 3)
    return `${t}.z`;
  if (n === 4)
    return `${t}.w`;
  throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`);
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qw(n, t, e, s, o, r) {
  const i6 = t.shape.length, a = qt$1([s], i6);
  let l = t;
  a != null && (l = Fe({ inputs: { x: t }, backend: e, attrs: { perm: a } }));
  const c = ie(1, i6)[0];
  if (c !== i6 - 1)
    throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length - 1} but got axis=${s}`);
  const u = l.shape[c];
  let d = tn$1({ inputs: { x: l }, backend: e });
  for (let h6 = 0; h6 <= Math.ceil(Math.log2(u)) - 1; h6++) {
    const p6 = new pg$1(n, l.shape, false, r), f = [[h6]], m = d;
    d = e.runWebGLProgram(p6, [d], d.dtype, f), e.disposeIntermediateTensorInfo(m);
  }
  if (o) {
    const h6 = new pg$1(n, l.shape, o, r), p6 = d;
    d = e.runWebGLProgram(h6, [d], d.dtype), e.disposeIntermediateTensorInfo(p6);
  }
  if (a != null) {
    const h6 = Hs(a), p6 = Fe({ inputs: { x: d }, backend: e, attrs: { perm: h6 } });
    return e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(l), p6;
  }
  return d;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function NK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, exclusive: i6, reverse: a } = s;
  return qw(ci.Prod, o, e, r, i6, a);
}
const RK = {
  kernelName: eh$1,
  backendName: "webgl",
  kernelFunc: NK
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $K(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, exclusive: i6, reverse: a } = s;
  return qw(ci.Sum, o, e, r, i6, a);
}
const GK = {
  kernelName: Yl,
  backendName: "webgl",
  kernelFunc: $K
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, weights: r } = t, { size: i6, binaryOutput: a } = s;
  if (o.shape.length === 1) {
    const l = e.readSync(o.dataId), c = e.readSync(r.dataId), u = Mw(l, c, r.dtype, r.shape, i6);
    return e.makeTensorInfo([i6], r.dtype, u);
  } else if (o.shape.length === 2) {
    const l = e.bufferSync(o), c = e.bufferSync(r), u = KX(l, c, i6, a);
    return e.makeTensorInfo(u.shape, r.dtype, u.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`);
}
const LK = {
  kernelName: sh$1,
  backendName: "webgl",
  kernelFunc: EK
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MK {
  constructor(t, e, s) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = s, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
  }
  getHeightCoordString() {
    return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
  }
  getWidthCoordString() {
    return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
  }
  getDepthCoordString() {
    return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
  }
  getOutputDepthSize() {
    return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
  }
  getInputSamplingString() {
    return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function WK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { blockSize: r, dataFormat: i6 } = s, a = o.shape[0], l = i6 === "NHWC" ? o.shape[1] : o.shape[2], c = i6 === "NHWC" ? o.shape[2] : o.shape[3], u = i6 === "NHWC" ? o.shape[3] : o.shape[1], d = l * r, h6 = c * r, p6 = u / (r * r), f = i6 === "NHWC" ? [a, d, h6, p6] : [a, p6, d, h6], m = new MK(f, r, i6);
  return e.runWebGLProgram(m, [o], o.dtype);
}
const DK = {
  kernelName: oh$1,
  backendName: "webgl",
  kernelFunc: WK
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class tI {
  constructor(t, e = false, s = null, o = false, r = false) {
    this.variableNames = ["x", "W"], this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ], this.outputShape = t.outShape, this.enableShapeUniforms = Xe(this.outputShape.length);
    const i6 = t.filterHeight, a = t.filterWidth, l = t.outChannels / t.inChannels;
    let c = "", u = "";
    s && (o ? c = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }` : r ? c = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }` : c = `
          float activation(float x) {
            ${s}
          }
        `, u = "result = activation(result);");
    const d = e ? "result += getBiasAtOutCoords();" : "";
    e && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i6}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${u}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class eI {
  constructor(t, e = false, s = null, o = false, r = false) {
    this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ], this.outputShape = t.outShape, this.enableShapeUniforms = Xe(this.outputShape.length);
    const i6 = t.outChannels / t.inChannels, a = t.padInfo.left, l = t.strideWidth, c = t.dilationWidth, u = t.filterHeight, d = t.filterWidth, h6 = d;
    let p6 = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
    for (let b6 = 0; b6 < d; b6++)
      p6 += `
          vec4 xTexelC${b6 * 2};
          int xTexelC${b6 * 2}Ready;
          vec4 xTexelC${b6 * 2 + 1};
          int xTexelC${b6 * 2 + 1}Ready;
          vec4 xC${b6};`;
    p6 += `
    for (int r = 0; r < ${u}; r++) {
      `;
    for (let b6 = 0; b6 < d; b6++)
      p6 += `
          xTexelC${b6 * 2} = vec4(0.0);
          xTexelC${b6 * 2}Ready = 0;
          xTexelC${b6 * 2 + 1} = vec4(0.0);
          xTexelC${b6 * 2 + 1}Ready = 0;
          xC${b6} = vec4(0.0);`;
    p6 += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
    for (let b6 = 0; b6 < (h6 + 1) / 2; b6++) {
      const x6 = b6 * 2;
      if (p6 += `
          xC = xCCorner + ${x6 * c};
          `, l === 1) {
        if (x6 < d && (a % 2 === 1 ? (p6 += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x6}Ready == 0) {
                  xTexelC${x6} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x6}.zw = vec2(0.0);
                  }
                  xTexelC${x6}Ready = 1;
                }
              `, c === 1 && x6 > 0 ? p6 += `
                xC${x6} = vec4(xTexelC${x6 - 2}.zw, xTexelC${x6}.xy);
                ` : p6 += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x6} = vec4(previous.zw, xTexelC${x6}.xy);
                  } else {
                    xC${x6} = vec4(0.0, 0.0, xTexelC${x6}.xy);
                  }
                  `) : p6 += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${x6}Ready == 0) {
                  xTexelC${x6} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x6}.zw = vec2(0.0);
                  }
                  xTexelC${x6}Ready = 1;
                }

                xC${x6} = xTexelC${x6};
                `, x6 + 1 < d)) {
          const w6 = a % 2 === 0 ? Wl(c) : c;
          c % 2 === 0 && a % 2 === 1 || c % 2 !== 0 && a % 2 !== 1 ? (p6 += `
                  xCOffset = xC + imod(pads[1], 2) + ${w6};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x6 + 1}Ready == 0) {
                    xTexelC${x6 + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x6 + 1}.zw = vec2(0.0);
                    }
                    xTexelC${x6 + 1}Ready = 1;
                  }
                  `, c > 1 ? p6 += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x6 + 1} = vec4(previous.zw, xTexelC${x6 + 1}.xy);
                    } else {
                     xC${x6 + 1} = vec4(0.0, 0.0, xTexelC${x6 + 1}.xy);
                    }
                    ` : p6 += `
                    xC${x6 + 1} = vec4(xTexelC${x6}.zw, xTexelC${x6 + 1}.xy);
                    `) : w6 === 1 ? p6 += `
                    xC${x6 + 1} = xTexelC${x6};
                    ` : p6 += `
                    xCOffset = xC + ${w6};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x6 + 1}Ready == 0) {
                      xTexelC${x6 + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x6 + 1}.zw = vec2(0.0);
                      }
                      xTexelC${x6 + 1}Ready = 1;
                    }

                    xC${x6 + 1} = xTexelC${x6 + 1};
                    `;
        }
      } else
        x6 < d && (a % 2 === 1 ? (p6 += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x6}Ready == 0) {
                  xTexelC${x6} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x6}.zw = vec2(0.0);
                  }
                  xTexelC${x6}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x6 + 1}Ready == 0) {
                  xTexelC${x6 + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x6 + 1}.zw = vec2(0.0);
                  }
                  xTexelC${x6 + 1}Ready = 1;
                }

                xC${x6} = vec4(xTexelC${x6}.zw, xTexelC${x6 + 1}.zw);
              `, x6 + 1 < d && (p6 += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x6 + 1} = vec4(xTexelC${x6 + 1}.xy, final.xy);
                `)) : (p6 += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${x6}Ready == 0) {
                  xTexelC${x6} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x6}.zw = vec2(0.0);
                  }
                  xTexelC${x6}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x6 + 1}Ready == 0) {
                  xTexelC${x6 + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x6 + 1}.zw = vec2(0.);
                  }
                  xTexelC${x6 + 1}Ready = 1;
                }

                xC${x6} = vec4(
                  xTexelC${x6}.xy, xTexelC${x6 + 1}.xy);
              `, x6 + 1 < d && (p6 += `
                  xC${x6 + 1} = vec4(xTexelC${x6}.zw, xTexelC${x6 + 1}.zw);
                `)));
      x6 < d && (p6 += `
            wTexel = getW(r, ${x6}, d1, q);
            dotProd += xC${x6} * vec4(wTexel.xz, wTexel.xz);
          `, x6 + 1 < d && (p6 += `
              wTexel = getW(r, ${x6 + 1}, d1, q);
              dotProd += xC${x6 + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
    }
    p6 += `
    }
  `, p6 += `
      }
    `;
    let f = "", m = "";
    s && (o ? f = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }` : r ? f = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }` : f = `vec4 activation(vec4 x) {
          ${s}
        }`, m = "result = activation(result);");
    const g6 = e ? "result += getBiasAtOutCoords();" : "";
    e && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i6};
        int q = d2 - d1 * ${i6};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p6}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g6}
        ${m}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function FK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r } = t, { strides: i6, pad: a, dilations: l, dimRoundingMode: c } = s;
  let u = l;
  u == null && (u = [1, 1]), v(Ee$1(i6, u), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i6} and dilations '${u}'`);
  const d = ke(
    o.shape,
    r.shape,
    i6,
    u,
    a,
    c,
    true
    /* depthwise */
  );
  let h6;
  F().getBool("WEBGL_PACK_DEPTHWISECONV") && d.strideWidth <= 2 && d.outChannels / d.inChannels === 1 ? h6 = new eI(d) : h6 = new tI(d);
  const p6 = [
    [d.padInfo.top, d.padInfo.left],
    [d.strideHeight, d.strideWidth],
    [d.dilationHeight, d.dilationWidth],
    [d.inHeight, d.inWidth]
  ];
  return e.runWebGLProgram(h6, [o, r], "float32", p6);
}
const VK = {
  kernelName: Ql,
  backendName: "webgl",
  kernelFunc: FK
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class zK {
  constructor(t) {
    this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
    const e = t.strideHeight, s = t.strideWidth, o = t.padInfo.top, r = t.padInfo.left, i6 = t.outChannels / t.inChannels;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i6} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class XK {
  constructor(t) {
    this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
    const e = t.filterHeight, s = t.filterWidth, o = t.strideHeight, r = t.strideWidth, i6 = e - 1 - t.padInfo.top, a = s - 1 - t.padInfo.left, l = t.outChannels / t.inChannels;
    this.userCode = `
      const ivec2 pads = ivec2(${i6}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, dy: r } = t, { strides: i6, dilations: a, pad: l, dimRoundingMode: c, filterShape: u } = s, d = ke(
    o.shape,
    u,
    i6,
    a,
    l,
    c,
    true
    /* depthwise */
  ), h6 = new zK(d);
  return e.runWebGLProgram(h6, [o, r], "float32");
}
const AK = {
  kernelName: rh$1,
  backendName: "webgl",
  kernelFunc: PK
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function OK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, filter: r } = t, { strides: i6, dilations: a, pad: l, dimRoundingMode: c, inputShape: u } = s, d = ke(
    u,
    r.shape,
    i6,
    a,
    l,
    c,
    true
    /* depthwise */
  ), h6 = new XK(d);
  return e.runWebGLProgram(h6, [o, r], "float32");
}
const KK = {
  kernelName: ih$1,
  backendName: "webgl",
  kernelFunc: OK
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class ZK {
  constructor(t) {
    this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BK(n) {
  const { inputs: t, backend: e } = n, { x: s } = t, o = [...s.shape, ...s.shape], r = O(s.shape), i6 = st({ inputs: { x: s }, backend: e, attrs: { shape: [r] } }), a = new ZK(r), l = e.runWebGLProgram(a, [i6], i6.dtype), c = st({ inputs: { x: l }, backend: e, attrs: { shape: o } });
  return e.disposeIntermediateTensorInfo(i6), e.disposeIntermediateTensorInfo(l), c;
}
const HK = {
  kernelName: Zg$1,
  backendName: "webgl",
  kernelFunc: BK
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class _K {
  constructor(t) {
    this.variableNames = ["x", "W"], this.outputShape = t.outShape;
    const { inHeight: e, inWidth: s, padInfo: o, strideHeight: r, strideWidth: i6, filterHeight: a, filterWidth: l, dilationHeight: c, dilationWidth: u } = t, { top: d, left: h6 } = o;
    this.userCode = `
      const ivec2 strides = ivec2(${r}, ${i6});
      const ivec2 pads = ivec2(${d}, ${h6});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function UK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r } = t, { strides: i6, pad: a, dilations: l } = s, c = ca(o.shape, r.shape, i6, a, "NHWC", l);
  let u;
  const d = new _K(c);
  u = e.runWebGLProgram(d, [o, r], "float32");
  const h6 = st({ inputs: { x: u }, backend: e, attrs: { shape: c.outShape } });
  return e.disposeIntermediateTensorInfo(u), h6;
}
const YK = {
  kernelName: Jl,
  backendName: "webgl",
  kernelFunc: UK
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function QK(n) {
  const { inputs: t, backend: e, attrs: s } = n, { equation: o } = s, r = t, { allDims: i6, summedDims: a, idDims: l } = Yp(o, r.length);
  Jp(i6.length, l, r);
  const { path: c, steps: u } = jp(a, l), d = u.length;
  let h6 = null, p6 = i6.length;
  const f = [];
  for (let m = 0; m < d; ++m) {
    for (const g6 of u[m]) {
      const { permutationIndices: b6, expandDims: x6 } = Qp(p6, l[g6]);
      let w6;
      qp(b6) ? w6 = r[g6] : (w6 = Fe({ inputs: { x: r[g6] }, backend: e, attrs: { perm: b6 } }), f.push(w6));
      const y6 = w6.shape.slice();
      for (let I = 0; I < x6.length; ++I)
        y6.splice(x6[I], 0, 1);
      Rt$1(w6.shape, y6) || (w6 = st({ inputs: { x: w6 }, backend: e, attrs: { shape: y6 } }), f.push(w6)), h6 === null ? h6 = w6 : (h6 = Of$1({ inputs: { a: w6, b: h6 }, backend: e }), f.push(h6));
    }
    m < d - 1 && (c[m] >= 0 && (h6 = fu({
      inputs: { x: h6 },
      backend: e,
      attrs: {
        axis: c[m] - (i6.length - p6),
        keepDims: false
      }
    }), f.push(h6)), p6--);
  }
  for (const m of f)
    m !== h6 && e.disposeIntermediateTensorInfo(m);
  return h6;
}
const JK = {
  kernelName: Bg$1,
  backendName: "webgl",
  kernelFunc: QK
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jK = "return (x >= 0.0) ? x : (exp(x) - 1.0);", qK = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, tZ = Nt$1({ opSnippet: jK, packedOpSnippet: qK }), eZ = {
  kernelName: Si,
  backendName: "webgl",
  kernelFunc: tZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nZ = "return (b >= 1.0) ? a : a * (b + 1.0);", sZ = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`, oZ = (n) => {
  const { inputs: t, backend: e } = n, { dy: s, y: o } = t, r = F().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ga(sZ, s.shape, o.shape) : new fr(nZ, s.shape, o.shape);
  return e.runWebGLProgram(r, [s, o], s.dtype);
}, rZ = {
  kernelName: ah$1,
  backendName: "webgl",
  kernelFunc: oZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iZ = `
  return vec4(equal(a, b));
`, aZ = "return float(a == b);", lZ = Ne({
  opSnippet: aZ,
  packedOpSnippet: iZ,
  dtype: "bool",
  cpuKernelImpl: _X
}), cZ = {
  kernelName: jl,
  backendName: "webgl",
  kernelFunc: lZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uZ = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Op};
  float a1 = ${Kp};
  float a2 = ${Zp};
  float a3 = ${Bp};
  float a4 = ${Hp};
  float a5 = ${_p};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`, dZ = Nt$1({ opSnippet: uZ }), hZ = {
  kernelName: ki,
  backendName: "webgl",
  kernelFunc: dZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pZ = Gr + `
  return exp(x);
`, fZ = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, nI = Nt$1({
  opSnippet: pZ,
  packedOpSnippet: fZ,
  cpuKernelImpl: UX,
  dtype: "float32"
}), mZ = {
  kernelName: Ti,
  backendName: "webgl",
  kernelFunc: nI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Fd$1(n) {
  const { inputs: t, attrs: e, backend: s } = n, { dim: o } = e, { input: r } = t, i6 = r.shape.length, a = r.shape.slice();
  let l = o;
  return o < 0 && (v(-(i6 + 1) <= o, () => `Axis must be in the interval [${-(i6 + 1)}, ${i6}]`), l = i6 + o + 1), a.splice(l, 0, 1), st({ inputs: { x: r }, backend: s, attrs: { shape: a } });
}
const gZ = {
  kernelName: ql,
  backendName: "webgl",
  kernelFunc: Fd$1
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const gg$1 = "return exp(x) - 1.0;", bZ = Nt$1({ opSnippet: gg$1, packedOpSnippet: gg$1, cpuKernelImpl: YX }), xZ = {
  kernelName: Ni,
  backendName: "webgl",
  kernelFunc: bZ
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let bg$1 = class bg {
  constructor(t, e, s) {
    this.variableNames = ["real", "imag"];
    const o = e[1];
    this.outputShape = e;
    const r = s ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`, i6 = s ? `${o}.0` : "1.0";
    let a;
    if (t === "real")
      a = "return real * expR - imag * expI;";
    else if (t === "imag")
      a = "return real * expI + imag * expR;";
    else
      throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);
    this.userCode = `
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i6};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sI(n, t, e) {
  const s = e.texData.get(n.dataId), o = O(n.shape), r = n.shape[n.shape.length - 1], i6 = o / r, a = st({ inputs: { x: n }, backend: e, attrs: { shape: [i6, r] } }), l = a.shape, c = new bg$1("real", l, t), u = new bg$1("imag", l, t), d = [
    {
      dataId: s.complexTensorInfos.real.dataId,
      dtype: s.complexTensorInfos.real.dtype,
      shape: l
    },
    {
      dataId: s.complexTensorInfos.imag.dataId,
      dtype: s.complexTensorInfos.imag.dtype,
      shape: l
    }
  ], h6 = e.runWebGLProgram(c, d, "float32"), p6 = e.runWebGLProgram(u, d, "float32"), f = js({ inputs: { real: h6, imag: p6 }, backend: e });
  e.disposeIntermediateTensorInfo(h6), e.disposeIntermediateTensorInfo(p6);
  const m = st({ inputs: { x: f }, backend: e, attrs: { shape: n.shape } });
  return e.disposeIntermediateTensorInfo(a), e.disposeIntermediateTensorInfo(f), m;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yZ(n) {
  const { inputs: t, backend: e } = n, { input: s } = t;
  return sI(s, false, e);
}
const wZ = {
  kernelName: lh$1,
  backendName: "webgl",
  kernelFunc: yZ
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class IZ {
  constructor(t, e) {
    this.outputShape = [], this.customUniforms = [{ name: "value", type: "float" }], this.variableNames = ["x"], this.outputShape = t, this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function La(n) {
  const { backend: t, attrs: e } = n, { shape: s, value: o } = e;
  let { dtype: r } = e;
  if (r = r || gr(o), r === "string") {
    const i6 = oe(r, O(s));
    return i6.fill(o), t.makeTensorInfo(s, r, i6);
  } else {
    const i6 = new IZ(s, o), a = [[o]];
    return t.runWebGLProgram(i6, [], r, a);
  }
}
const CZ = {
  kernelName: ch$1,
  backendName: "webgl",
  kernelFunc: La
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class vZ {
  constructor(t) {
    this.variableNames = ["Image"], this.outputShape = [];
    const e = t[2];
    this.outputShape = t, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SZ = {
  kernelName: uh$1,
  backendName: "webgl",
  kernelFunc: ({ inputs: n, backend: t }) => {
    const { image: e } = n, s = t, o = new vZ(e.shape);
    return s.runWebGLProgram(o, [e], e.dtype);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xg$1 = "return floor(x);", kZ = Nt$1({ opSnippet: xg$1, packedOpSnippet: xg$1, cpuKernelImpl: QX }), TZ = {
  kernelName: Ri,
  backendName: "webgl",
  kernelFunc: kZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NZ = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`, RZ = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`, $Z = Ne({ opSnippet: NZ, packedOpSnippet: RZ, dtype: "int32" }), GZ = {
  kernelName: $i,
  backendName: "webgl",
  kernelFunc: $Z
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class EZ {
  constructor(t) {
    this.variableNames = ["A"];
    const e = ze$1(), [s, o] = t;
    this.outputShape = t, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class LZ {
  constructor(t) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
    const e = ze$1(), [s, o] = t;
    this.outputShape = t, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const MZ = {
  kernelName: sd,
  backendName: "webgl",
  kernelFunc: WZ
};
let Bo, Du = F().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
function WZ(n) {
  const { inputs: t, backend: e, attrs: s } = n;
  let { pixels: o } = t;
  const { numChannels: r } = s, i6 = typeof HTMLVideoElement < "u" && o instanceof HTMLVideoElement, a = typeof HTMLImageElement < "u" && o instanceof HTMLImageElement, [l, c] = i6 ? [
    o.videoWidth,
    o.videoHeight
  ] : [o.width, o.height], u = [c, l], d = [c, l, r];
  if (a || i6) {
    const m = F().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
    (Bo == null || m !== Du) && (Du = m, Bo = document.createElement("canvas").getContext("2d", { willReadFrequently: Du })), Bo.canvas.width = l, Bo.canvas.height = c, Bo.drawImage(o, 0, 0, l, c), o = Bo.canvas;
  }
  const h6 = e.makeTensorInfo(u, "int32");
  e.texData.get(h6.dataId).usage = ln$1.PIXELS, e.gpgpu.uploadPixelDataToTexture(e.getTexture(h6.dataId), o);
  const p6 = F().getBool("WEBGL_PACK") ? new LZ(d) : new EZ(d), f = e.runWebGLProgram(p6, [h6], "int32");
  return e.disposeData(h6.dataId), f;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function DZ(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r, bias: i6, preluActivationWeights: a } = t, { strides: l, pad: c, dataFormat: u, dilations: d, dimRoundingMode: h6, activation: p6, leakyreluAlpha: f } = s, m = ys(u), g6 = ke(o.shape, r.shape, l, d, c, h6, false, m);
  let b6;
  const x6 = [], w6 = i6 != null, y6 = a != null, I = p6 === "leakyrelu", C6 = () => {
    const S = [o, r], N = (R, M6) => {
      if (M6 === "NCHW" && R.shape.length === 1 && R.shape[0] !== 1) {
        const V = st({
          inputs: { x: R },
          backend: e,
          attrs: { shape: [R.shape[0], 1, 1] }
        });
        return x6.push(V), V;
      }
      return R;
    };
    if (w6 && S.push(N(i6, u)), y6 && S.push(N(a, u)), I) {
      const R = e.makeTensorInfo([], "float32", bs(f, "float32"));
      S.push(R), x6.push(R);
    }
    return S;
  };
  if (g6.filterHeight === 1 && g6.filterWidth === 1 && g6.dilationHeight === 1 && g6.dilationWidth === 1 && g6.strideHeight === 1 && g6.strideWidth === 1 && (g6.padInfo.type === "SAME" || g6.padInfo.type === "VALID"))
    b6 = Jw({
      x: o,
      filter: r,
      convInfo: g6,
      backend: e,
      bias: i6,
      activation: p6,
      preluActivationWeights: a,
      leakyreluAlpha: f
    });
  else if (g6.strideWidth <= 2 && m === "channelsLast" && F().getBool("WEBGL_EXP_CONV")) {
    const S = p6 ? ai$1(p6, true) : null, N = new Qw(g6, w6, S, y6, I), R = [
      [g6.padInfo.top, g6.padInfo.left],
      [g6.strideHeight, g6.strideWidth],
      [g6.dilationHeight, g6.dilationWidth],
      [g6.inHeight, g6.inWidth]
    ], M6 = C6();
    b6 = e.runWebGLProgram(N, M6, "float32", R);
  } else if (F().getBool("WEBGL_CONV_IM2COL"))
    b6 = jw({
      x: o,
      filter: r,
      convInfo: g6,
      backend: e,
      bias: i6,
      activation: p6,
      preluActivationWeights: a,
      leakyreluAlpha: f
    });
  else {
    const S = p6 ? ai$1(p6, false) : null, N = new Yw(g6, w6, S, y6, I), R = C6();
    b6 = e.runWebGLProgram(N, R, "float32");
  }
  const k7 = st({ inputs: { x: b6 }, backend: e, attrs: { shape: g6.outShape } });
  return x6.push(b6), x6.forEach((S) => e.disposeIntermediateTensorInfo(S)), k7;
}
const FZ = {
  kernelName: rl,
  backendName: "webgl",
  kernelFunc: DZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function VZ(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, filter: r, bias: i6, preluActivationWeights: a } = t, { strides: l, pad: c, dilations: u, dimRoundingMode: d, activation: h6, leakyreluAlpha: p6 } = s, f = [];
  let m = u;
  m == null && (m = [1, 1]), v(Ee$1(l, m), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);
  const g6 = ke(
    o.shape,
    r.shape,
    l,
    m,
    c,
    d,
    true
    /* depthwise */
  ), b6 = F().getBool("WEBGL_PACK_DEPTHWISECONV") && g6.strideWidth <= 2 && g6.outChannels / g6.inChannels === 1, x6 = h6 ? ai$1(h6, b6) : null, w6 = [o, r], y6 = i6 != null, I = a != null, C6 = h6 === "leakyrelu";
  if (y6 && w6.push(i6), I && w6.push(a), C6) {
    const R = e.makeTensorInfo([], "float32", bs(p6, "float32"));
    w6.push(R), f.push(R);
  }
  let k7;
  b6 ? k7 = new eI(g6, y6, x6, I, C6) : k7 = new tI(g6, y6, x6, I, C6);
  const S = [
    [g6.padInfo.top, g6.padInfo.left],
    [g6.strideHeight, g6.strideWidth],
    [g6.dilationHeight, g6.dilationWidth],
    [g6.inHeight, g6.inWidth]
  ], N = e.runWebGLProgram(k7, w6, "float32", S);
  return f.forEach((R) => e.disposeIntermediateTensorInfo(R)), N;
}
const zZ = {
  kernelName: nb$1,
  backendName: "webgl",
  kernelFunc: VZ
};
class XZ {
  constructor(t, e, s, o) {
    this.sliceDim = t, this.strides = e, this.paramsShape = o, this.variableNames = ["x", "indices"], this.outputShape = s;
    const r = Kt(s.length);
    let i6 = `
    int index;`;
    for (let a = 0; a < this.sliceDim; a++)
      i6 += `
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;
    this.userCode = `
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i6}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function PZ(n) {
  const { inputs: t, backend: e } = n, { params: s, indices: o } = t, r = o.shape, i6 = r[r.length - 1], a = O(s.shape), [l, c, u, d] = Bc(s, o), h6 = st({ inputs: { x: o }, backend: e, attrs: { shape: [c, i6] } }), p6 = st({
    inputs: { x: s },
    backend: e,
    attrs: { shape: [O(s.shape) / u, u] }
  });
  if (e.shouldExecuteOnCPU([s, o]) || s.dtype === "string") {
    const b6 = e.readSync(o.dataId), x6 = e.bufferSync(s), w6 = JX(b6, x6, s.dtype, c, i6, u, d, s.shape, a);
    return e.makeTensorInfo(l, s.dtype, w6.values);
  }
  const f = new XZ(i6, d, [c, u], s.shape), m = e.runWebGLProgram(f, [p6, h6], p6.dtype), g6 = st({ inputs: { x: m }, backend: e, attrs: { shape: l } });
  return e.disposeIntermediateTensorInfo(h6), e.disposeIntermediateTensorInfo(p6), e.disposeIntermediateTensorInfo(m), g6;
}
const AZ = {
  kernelName: Hg$1,
  backendName: "webgl",
  kernelFunc: PZ
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class OZ {
  constructor(t, e) {
    this.variableNames = ["A", "indices"], this.outputShape = e, this.rank = e.length;
    const s = Kt(this.rank), o = KZ(t);
    this.userCode = `
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `;
  }
}
function KZ(n, t) {
  const e = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], s = [];
  for (let o = 0; o < n.length; o++)
    o === 2 ? s.push("index") : s.push(`${e[o]}`);
  return s.join();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oI(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, indices: r } = t, { axis: i6, batchDims: a } = s, l = Ct(i6, o.shape)[0];
  if (F().get("DEBUG")) {
    const x6 = e.readSync(r.dataId), w6 = o.shape[l];
    for (let y6 = 0; y6 < x6.length; ++y6) {
      const I = x6[y6];
      v(I <= w6 - 1 && I >= 0, () => `GatherV2: the index value ${I} is not in [0, ${w6 - 1}]`);
    }
  }
  const c = ef$1(o, r, l, a), u = O(r.shape), d = [], h6 = st({
    inputs: { x: o },
    backend: e,
    attrs: {
      shape: [
        c.batchSize,
        c.outerSize,
        c.dimSize,
        c.sliceSize
      ]
    }
  }), p6 = st({
    inputs: { x: r },
    backend: e,
    attrs: { shape: [c.batchSize, u / c.batchSize] }
  });
  d.push(h6), d.push(p6);
  const f = [
    c.batchSize,
    c.outerSize,
    u / c.batchSize,
    c.sliceSize
  ];
  if (e.shouldExecuteOnCPU([o, r]) || o.dtype === "string") {
    const x6 = e.bufferSync(p6), w6 = e.bufferSync(h6), y6 = jX(w6, x6, f);
    return d.forEach((I) => e.disposeIntermediateTensorInfo(I)), e.makeTensorInfo(c.outputShape, y6.dtype, y6.values);
  }
  const m = new OZ(h6.shape, f), g6 = e.runWebGLProgram(m, [h6, p6], h6.dtype);
  d.push(g6);
  const b6 = st({ inputs: { x: g6 }, backend: e, attrs: { shape: c.outputShape } });
  return d.forEach((x6) => e.disposeIntermediateTensorInfo(x6)), b6;
}
const ZZ = {
  kernelName: ec,
  backendName: "webgl",
  kernelFunc: oI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const BZ = "return float(a > b);", HZ = `
  return vec4(greaterThan(a, b));
`, _Z = Ne({
  opSnippet: BZ,
  packedOpSnippet: HZ,
  cpuKernelImpl: qX,
  dtype: "bool"
}), UZ = {
  kernelName: nc,
  backendName: "webgl",
  kernelFunc: _Z
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const YZ = "return float(a >= b);", QZ = `
  return vec4(greaterThanEqual(a, b));
`, JZ = Ne({
  opSnippet: YZ,
  packedOpSnippet: QZ,
  dtype: "bool",
  cpuKernelImpl: tP
}), jZ = {
  kernelName: Gi,
  backendName: "webgl",
  kernelFunc: JZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qZ(n) {
  const { inputs: t, backend: e } = n, { input: s } = t;
  return sI(s, true, e);
}
const tB = {
  kernelName: dh$1,
  backendName: "webgl",
  kernelFunc: qZ
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eB = "return float(!isnan(x) && !isinf(x));", nB = Nt$1({ opSnippet: eB, dtype: "bool" }), sB = {
  kernelName: Li,
  backendName: "webgl",
  kernelFunc: nB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const oB = "return float(isinf(x));", rB = Nt$1({ opSnippet: oB, dtype: "bool" }), iB = {
  kernelName: Mi,
  backendName: "webgl",
  kernelFunc: rB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const aB = "return float(isnan(x));", lB = Nt$1({ opSnippet: aB, dtype: "bool" }), cB = {
  kernelName: Wi,
  backendName: "webgl",
  kernelFunc: lB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uB = "return float(a < b);", dB = `
  return vec4(lessThan(a, b));
`, hB = Ne({
  opSnippet: uB,
  packedOpSnippet: dB,
  cpuKernelImpl: eP,
  dtype: "bool"
}), pB = {
  kernelName: oc,
  backendName: "webgl",
  kernelFunc: hB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fB = "return float(a <= b);", mB = `
  return vec4(lessThanEqual(a, b));
`, gB = Ne({
  opSnippet: fB,
  packedOpSnippet: mB,
  cpuKernelImpl: nP,
  dtype: "bool"
}), bB = {
  kernelName: rc,
  backendName: "webgl",
  kernelFunc: gB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function xB(n) {
  const { backend: t, attrs: e } = n, { start: s, stop: o, num: r } = e, i6 = sP(s, o, r);
  return t.makeTensorInfo([i6.length], "float32", i6);
}
const yB = {
  kernelName: _g$1,
  backendName: "webgl",
  kernelFunc: xB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wB = Gr + `
  return x < 0.0 ? 0./0. : log(x);
`, IB = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`, CB = Nt$1({ opSnippet: wB, packedOpSnippet: IB, cpuKernelImpl: oP }), vB = {
  kernelName: Di,
  backendName: "webgl",
  kernelFunc: CB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SB = Gr + `
  return log(1.0 + x);
`, kB = Nt$1({ opSnippet: SB }), TB = {
  kernelName: Fi,
  backendName: "webgl",
  kernelFunc: kB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NB = "return float(a >= 1.0 && b >= 1.0);", RB = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`, $B = Ne({
  opSnippet: NB,
  packedOpSnippet: RB,
  dtype: "bool"
}), GB = {
  kernelName: ic,
  backendName: "webgl",
  kernelFunc: $B
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EB = "return float(!(x >= 1.0));", LB = Nt$1({ opSnippet: EB }), MB = {
  kernelName: ac,
  backendName: "webgl",
  kernelFunc: LB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WB = "return float(a >= 1.0 || b >= 1.0);", DB = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`, FB = Ne({ opSnippet: WB, packedOpSnippet: DB, dtype: "bool" }), VB = {
  kernelName: lc,
  backendName: "webgl",
  kernelFunc: FB
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class zB {
  constructor(t, e, s, o, r) {
    this.variableNames = ["x"], this.outputShape = [];
    const i6 = e, a = t[3] - 1;
    this.outputShape = t;
    let l;
    const c = `float(${s}) + float(${o}) * sum`;
    r === 0.5 ? l = `inversesqrt(${c})` : r === 1 ? l = `1.0/(${c})` : l = `exp(log(${c}) * float(-${r}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i6}; j <= ${i6}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class XB {
  constructor(t, e, s, o, r) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
    const i6 = e, a = t[3] - 1;
    this.outputShape = t;
    let l;
    const c = `float(${s}) + float(${o}) * sum`;
    r === 0.5 ? l = `inversesqrt(${c})` : r === 1 ? l = `1.0/(${c})` : l = `exp(log(${c}) * float(-${r}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i6};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i6}; j <= ${i6}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PB = (n) => {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { depthRadius: r, bias: i6, alpha: a, beta: l } = s, c = F().getBool("WEBGL_PACK_NORMALIZATION") ? new XB(o.shape, r, i6, a, l) : new zB(o.shape, r, i6, a, l);
  return e.runWebGLProgram(c, [o], o.dtype);
}, AB = {
  kernelName: cc,
  backendName: "webgl",
  kernelFunc: PB
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class OB {
  constructor(t, e, s, o, r) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = s, this.alpha = o, this.beta = r, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KB = (n) => {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, y: r, dy: i6 } = t, { depthRadius: a, bias: l, alpha: c, beta: u } = s, d = new OB(o.shape, a, l, c, u);
  return e.runWebGLProgram(d, [o, r, i6], o.dtype);
}, ZB = {
  kernelName: ph$1,
  backendName: "webgl",
  kernelFunc: KB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function BB(n, t, e, s) {
  const o = O(t), i6 = O(n.shape) / o, a = st({ inputs: { x: n }, attrs: { shape: [i6, o] }, backend: s }), l = Oo(a, n.dtype, "max", s), c = st({ inputs: { x: l }, attrs: { shape: e }, backend: s });
  return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(l), c;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rI(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { reductionIndices: r, keepDims: i6 } = s, a = o.shape.length, l = Ct(r, o.shape);
  let c = l;
  const u = qt$1(c, a), d = u != null, h6 = e.shouldExecuteOnCPU([o]);
  let p6 = o;
  if (d) {
    if (h6) {
      const w6 = e.texData.get(p6.dataId).values, y6 = new Array(a);
      for (let k7 = 0; k7 < y6.length; k7++)
        y6[k7] = o.shape[u[k7]];
      const I = Pf$1(w6, o.shape, o.dtype, u, y6);
      p6 = e.makeTensorInfo(y6, o.dtype);
      const C6 = e.texData.get(p6.dataId);
      C6.values = I;
    } else
      p6 = pu(o, u, e);
    c = ie(c.length, a);
  }
  Te("max", c, a);
  const [f, m] = ye$1(p6.shape, c);
  let g6 = f;
  i6 && (g6 = re$1(f, l));
  let b6;
  if (h6) {
    const w6 = e.texData.get(p6.dataId).values, y6 = rP(w6, O(m), g6, o.dtype);
    b6 = e.makeTensorInfo(g6, o.dtype);
    const I = e.texData.get(b6.dataId);
    I.values = y6;
  } else
    b6 = BB(p6, m, g6, e);
  return d && e.disposeIntermediateTensorInfo(p6), b6;
}
const HB = {
  kernelName: uc,
  backendName: "webgl",
  kernelFunc: rI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _B = Af$1 + `
  return max(a, b);
`, UB = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + $a + `
  return result;
`, YB = Ne({
  opSnippet: _B,
  packedOpSnippet: UB,
  cpuKernelImpl: iP
}), QB = {
  kernelName: Vi,
  backendName: "webgl",
  kernelFunc: YB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JB(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t;
  Na(o, "maxPool");
  const { filterSize: r, strides: i6, pad: a, dimRoundingMode: l } = s, c = 1;
  v(Ee$1(i6, c), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i6} and dilations '${c}'`);
  const u = $n$1(o.shape, r, i6, c, a, l);
  if (u.filterWidth === 1 && u.filterHeight === 1 && Rt$1(u.inShape, u.outShape))
    return tn$1({ inputs: { x: o }, backend: e });
  const d = new li(u, "max", false);
  return e.runWebGLProgram(d, [o], o.dtype);
}
const jB = {
  kernelName: dc,
  backendName: "webgl",
  kernelFunc: JB
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qB(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { filterSize: r, strides: i6, pad: a, dataFormat: l, dimRoundingMode: c } = s, u = [1, 1, 1], d = xs(o.shape, r, i6, u, a, c, l), h6 = new Kf$1(d, "max", false);
  return e.runWebGLProgram(h6, [o], o.dtype);
}
const tH = {
  kernelName: hc,
  backendName: "webgl",
  kernelFunc: qB
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class eH {
  constructor(t) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
    const e = t.strideHeight, s = t.strideWidth, o = t.dilationHeight, r = t.effectiveFilterHeight, i6 = t.effectiveFilterWidth, a = r - 1 - t.padInfo.top, l = i6 - 1 - t.padInfo.left, c = r * i6 - 1;
    this.userCode = `
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i6}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i6} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
class nH {
  constructor(t) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
    const e = t.strideDepth, s = t.strideHeight, o = t.strideWidth, r = t.dilationDepth, i6 = t.dilationHeight, a = t.dilationWidth, l = t.effectiveFilterDepth, c = t.effectiveFilterHeight, u = t.effectiveFilterWidth, d = l - 1 - t.padInfo.front, h6 = c - 1 - t.padInfo.top, p6 = u - 1 - t.padInfo.left, f = l * c * u - 1;
    this.userCode = `
      const ivec3 pads = ivec3(${d}, ${h6}, ${p6});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${i6}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sH(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, input: r } = t, i6 = r, { filterSize: a, strides: l, pad: c, dimRoundingMode: u } = s, d = [1, 1, 1], h6 = xs(i6.shape, a, l, d, c, u), p6 = new Kf$1(
    h6,
    "max",
    true
    /* get positions */
  ), f = e.runWebGLProgram(p6, [i6], i6.dtype), m = new nH(h6), g6 = e.runWebGLProgram(m, [o, f], i6.dtype);
  return e.disposeIntermediateTensorInfo(f), g6;
}
const oH = {
  kernelName: mh$1,
  backendName: "webgl",
  kernelFunc: sH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rH(n) {
  const { inputs: t, backend: e, attrs: s } = n, { dy: o, input: r, output: i6 } = t, a = r;
  Na([r, i6], "maxPoolGrad");
  const { filterSize: l, strides: c, pad: u, dimRoundingMode: d } = s, h6 = $n$1(a.shape, l, c, 1, u, d), p6 = true, f = new li(h6, "max", p6), m = e.runWebGLProgram(f, [a], a.dtype), g6 = new eH(h6), b6 = e.runWebGLProgram(g6, [o, m], a.dtype);
  return e.disposeIntermediateTensorInfo(m), b6;
}
const iH = {
  kernelName: fh$1,
  backendName: "webgl",
  kernelFunc: rH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function aH(n, t, e, s) {
  let o = new li(e, "max", false);
  const r = s.runWebGLProgram(o, [n], "float32");
  o = new li(e, "max", true, true, t);
  const i6 = s.runWebGLProgram(o, [n], "float32");
  return [r, i6];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const lH = {
  kernelName: Ug$1,
  backendName: "webgl",
  kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
    const { x: s } = n, { filterSize: o, strides: r, pad: i6, includeBatchInIndex: a } = t, l = e;
    v(s.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);
    const c = [1, 1];
    v(Ee$1(r, c), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);
    const u = $n$1(s.shape, o, r, c, i6), [d, h6] = aH(s, a, u, l);
    return [d, h6];
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cH(n, t, e, s) {
  const o = O(t), i6 = O(n.shape) / o, a = st({ inputs: { x: n }, attrs: { shape: [i6, o] }, backend: s }), l = Oo(a, "float32", "mean", s), c = st({ inputs: { x: l }, attrs: { shape: e }, backend: s });
  return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(l), c;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uH = {
  kernelName: pc,
  backendName: "webgl",
  kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
    const { x: s } = n, { keepDims: o, axis: r } = t, i6 = e, a = s.shape.length, l = Ct(r, s.shape);
    let c = l;
    const u = qt$1(c, a), d = u != null, h6 = i6.shouldExecuteOnCPU([s]), p6 = [];
    let f = s;
    if (d) {
      if (h6) {
        const y6 = i6.texData.get(f.dataId).values, I = new Array(a);
        for (let S = 0; S < I.length; S++)
          I[S] = s.shape[u[S]];
        const C6 = Pf$1(y6, s.shape, s.dtype, u, I);
        f = i6.makeTensorInfo(I, s.dtype);
        const k7 = i6.texData.get(f.dataId);
        k7.values = C6;
      } else
        f = pu(s, u, i6);
      p6.push(f), c = ie(c.length, a);
    }
    Te("sum", c, a);
    const [m, g6] = ye$1(f.shape, c);
    let b6 = m;
    o && (b6 = re$1(m, l));
    const x6 = cH(f, g6, b6, i6);
    for (const w6 of p6)
      i6.disposeIntermediateTensorInfo(w6);
    return x6;
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dH(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s, a = o.shape.length, l = Ct(r, o.shape);
  let c = l;
  const u = qt$1(c, a);
  let d = o;
  u != null && (d = Fe({ inputs: { x: o }, backend: e, attrs: { perm: u } }), c = ie(c.length, o.shape.length)), Te("min", c, a);
  const [h6, p6] = ye$1(d.shape, c), f = O(p6), m = st({ inputs: { x: d }, backend: e, attrs: { shape: [-1, f] } }), g6 = Oo(m, m.dtype, "min", e);
  let b6;
  if (i6) {
    const x6 = re$1(h6, l);
    b6 = st({ inputs: { x: g6 }, backend: e, attrs: { shape: x6 } });
  } else
    b6 = st({ inputs: { x: g6 }, backend: e, attrs: { shape: h6 } });
  return e.disposeIntermediateTensorInfo(m), e.disposeIntermediateTensorInfo(g6), u != null && e.disposeIntermediateTensorInfo(d), b6;
}
const hH = {
  kernelName: fc,
  backendName: "webgl",
  kernelFunc: dH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pH = Af$1 + `
  return min(a, b);
`, fH = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + $a + `
  return result;
`, mH = Ne({
  opSnippet: pH,
  packedOpSnippet: fH,
  cpuKernelImpl: aP
}), gH = {
  kernelName: zi,
  backendName: "webgl",
  kernelFunc: mH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class bH {
  constructor(t, e, s) {
    this.variableNames = ["x"], this.outputShape = e.map(
      (u, d) => u[0] + t[d] + u[1]
      /* afterPad */
    );
    const o = t.length, r = Kt(o), i6 = e.map((u) => u[0]).join(","), a = e.map((u, d) => u[0] + t[d]).join(","), l = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, o), c = s === "reflect" ? 0 : 1;
    if (o === 1) {
      this.userCode = `
        int start = ${i6};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;
      return;
    }
    this.userCode = `
      ${r} start = ${r}(${i6});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${l}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class xH {
  constructor(t, e, s) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e.map(
      (f, m) => f[0] + t[m] + f[1]
      /* afterPad */
    );
    const o = t.length, r = Kt(o), i6 = e.map((f) => f[0]).join(","), a = e.map((f, m) => f[0] + t[m]).join(","), l = We$1("rc", o), c = We$1("source", o), u = `${l[o - 1]} < ${this.outputShape[o - 1]}`, d = o === 1 ? "source" : `vec2(${c.slice(-2).join()})`, h6 = s === "reflect" ? 0 : 1;
    let p6 = "";
    if (o === 1) {
      const f = `
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h6};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h6};
        }
        source -= start;
      `;
      p6 = `
        ${r} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[o - 1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `;
    } else {
      const f = `
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h6}) +
                gte * ((end - 1) * 2 - source + ${h6});
        source -= start;
      `;
      p6 = `
        ${r} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[o - 1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${l[o - 2]} += 1;
        if(${l[o - 2]} < ${this.outputShape[o - 2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${l[o - 1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `;
    }
    this.userCode = `
      const ${r} start = ${r}(${i6});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p6}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yH = ({ inputs: n, backend: t, attrs: e }) => {
  const { x: s } = n, { paddings: o, mode: r } = e, i6 = F().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new xH(s.shape, o, r) : new bH(s.shape, o, r);
  return t.runWebGLProgram(i6, [s], s.dtype);
}, wH = {
  kernelName: mc,
  backendName: "webgl",
  kernelFunc: yH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const IH = `if (b == 0.0) return NAN;
  return mod(a, b);`, CH = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + $a + `
  return result;
`, vH = Ne({
  opSnippet: IH,
  packedOpSnippet: CH
}), SH = {
  kernelName: Xi,
  backendName: "webgl",
  kernelFunc: vH
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class kH {
  constructor(t, e, s) {
    this.variableNames = ["probs"], this.customUniforms = [{ name: "seed", type: "float" }], this.outputShape = [t, s], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e - 1}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TH = `
if (a == b) {
  return 1.0;
};
return a / b;`, NH = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`, iI = Ne({ opSnippet: TH, packedOpSnippet: NH, checkOutOfBounds: true }), RH = {
  kernelName: vi,
  backendName: "webgl",
  kernelFunc: iI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const yg$1 = "return a - b;", aI = Ne({
  opSnippet: yg$1,
  packedOpSnippet: yg$1,
  supportsComplex: true,
  cpuKernelImpl: NP
}), $H = {
  kernelName: ea,
  backendName: "webgl",
  kernelFunc: aI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lI(n) {
  const { inputs: t, backend: e, attrs: s } = n, { logits: o } = t, { dim: r } = s, i6 = Ct([r], o.shape), a = rI({
    inputs: { x: o },
    backend: e,
    attrs: { reductionIndices: i6, keepDims: false }
  }), l = re$1(a.shape, i6), c = st({ inputs: { x: a }, backend: e, attrs: { shape: l } }), u = aI({ inputs: { a: o, b: c }, backend: e }), d = nI({ inputs: { x: u }, backend: e }), h6 = fu({ inputs: { x: d }, backend: e, attrs: { axis: i6, keepDims: false } }), p6 = st({ inputs: { x: h6 }, backend: e, attrs: { shape: l } }), f = iI({ inputs: { a: d, b: p6 }, backend: e });
  return e.disposeIntermediateTensorInfo(a), e.disposeIntermediateTensorInfo(c), e.disposeIntermediateTensorInfo(u), e.disposeIntermediateTensorInfo(d), e.disposeIntermediateTensorInfo(h6), e.disposeIntermediateTensorInfo(p6), f;
}
const GH = {
  kernelName: Mc,
  backendName: "webgl",
  kernelFunc: lI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function EH(n) {
  const { inputs: t, backend: e, attrs: s } = n, { logits: o } = t, { numSamples: r, seed: i6, normalized: a } = s, l = a ? o : lI({ inputs: { logits: o }, backend: e, attrs: { dim: o.shape.length - 1 } }), c = l.shape[0], u = l.shape[1], d = new kH(c, u, r), h6 = [[i6]], p6 = e.runWebGLProgram(d, [l], "int32", h6);
  return a || e.disposeIntermediateTensorInfo(l), p6;
}
const LH = {
  kernelName: Yg$1,
  backendName: "webgl",
  kernelFunc: EH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const MH = En$1 + `
  return -x;
`, WH = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
function DH(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  if (e.shouldExecuteOnCPU([s])) {
    const r = e.texData.get(s.dataId), [i6, a] = cP(r.values, s.shape, s.dtype);
    return e.makeTensorInfo(a, s.dtype, i6);
  }
  let o;
  return F().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? o = new Ls(s.shape, WH) : o = new qn$1(s.shape, MH), e.runWebGLProgram(o, [s], s.dtype);
}
const FH = {
  kernelName: gc,
  backendName: "webgl",
  kernelFunc: DH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const VH = Tp;
function zH(n) {
  rn$1("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs: t, backend: e, attrs: s } = n, { boxes: o, scores: r } = t, { maxOutputSize: i6, iouThreshold: a, scoreThreshold: l } = s, c = e.readSync(o.dataId), u = e.readSync(r.dataId), { selectedIndices: d } = VH(c, u, i6, a, l);
  return e.makeTensorInfo([d.length], "int32", new Int32Array(d));
}
const XH = {
  kernelName: gh$1,
  backendName: "webgl",
  kernelFunc: zH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PH = Np;
function AH(n) {
  rn$1("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs: t, backend: e, attrs: s } = n, { boxes: o, scores: r } = t, { maxOutputSize: i6, iouThreshold: a, scoreThreshold: l, padToMaxOutputSize: c } = s, u = e.readSync(o.dataId), d = e.readSync(r.dataId), { selectedIndices: h6, validOutputs: p6 } = PH(u, d, i6, a, l, c);
  return [
    e.makeTensorInfo([h6.length], "int32", new Int32Array(h6)),
    e.makeTensorInfo([], "int32", new Int32Array([p6]))
  ];
}
const OH = {
  kernelName: bh$1,
  backendName: "webgl",
  kernelFunc: AH
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const KH = Rp;
function ZH(n) {
  rn$1("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  const { inputs: t, backend: e, attrs: s } = n, { boxes: o, scores: r } = t, { maxOutputSize: i6, iouThreshold: a, scoreThreshold: l, softNmsSigma: c } = s, u = e.readSync(o.dataId), d = e.readSync(r.dataId), h6 = i6, p6 = a, f = l, m = c, { selectedIndices: g6, selectedScores: b6 } = KH(u, d, h6, p6, f, m);
  return [
    e.makeTensorInfo([g6.length], "int32", new Int32Array(g6)),
    e.makeTensorInfo([b6.length], "float32", new Float32Array(b6))
  ];
}
const BH = {
  kernelName: xh$1,
  backendName: "webgl",
  kernelFunc: ZH
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class HH {
  constructor(t, e, s, o) {
    this.variableNames = ["indices"], this.outputShape = [t, e], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${s}),
                      float(index == coords.y)));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _H = (n) => {
  const { inputs: t, backend: e, attrs: s } = n, { indices: o } = t, { dtype: r, depth: i6, onValue: a, offValue: l } = s, c = O(o.shape), u = new HH(c, i6, a, l), d = st({ inputs: { x: o }, backend: e, attrs: { shape: [c] } }), h6 = e.runWebGLProgram(u, [d], r);
  e.disposeIntermediateTensorInfo(d);
  const p6 = [...o.shape, i6], f = st({ inputs: { x: h6 }, backend: e, attrs: { shape: p6 } });
  return e.disposeIntermediateTensorInfo(h6), f;
}, UH = {
  kernelName: yc,
  backendName: "webgl",
  kernelFunc: _H
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ll(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  if (s.dtype === "complex64") {
    const o = Ea({ inputs: { input: s }, backend: e }), r = Ll({ inputs: { x: o }, backend: e }), i6 = mu({ inputs: { input: s }, backend: e }), a = Ll({ inputs: { x: i6 }, backend: e }), l = js({ inputs: { real: r, imag: a }, backend: e });
    return e.disposeIntermediateTensorInfo(o), e.disposeIntermediateTensorInfo(r), e.disposeIntermediateTensorInfo(i6), e.disposeIntermediateTensorInfo(a), l;
  } else
    return La({
      attrs: {
        shape: s.shape,
        dtype: s.dtype,
        value: s.dtype === "string" ? "" : 0
      },
      backend: e
    });
}
const YH = {
  kernelName: Fc,
  backendName: "webgl",
  kernelFunc: Ll
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cI(n) {
  const { inputs: t, backend: e } = n, { x: s } = t;
  if (s.dtype === "string")
    throw new Error("onesLike is not supported under string dtype");
  if (s.dtype === "complex64") {
    const o = Ea({ inputs: { input: s }, backend: e }), r = cI({ inputs: { x: o }, backend: e }), i6 = mu({ inputs: { input: s }, backend: e }), a = Ll({ inputs: { x: i6 }, backend: e }), l = js({ inputs: { real: r, imag: a }, backend: e });
    return e.disposeIntermediateTensorInfo(o), e.disposeIntermediateTensorInfo(r), e.disposeIntermediateTensorInfo(i6), e.disposeIntermediateTensorInfo(a), l;
  } else
    return La({ attrs: { shape: s.shape, dtype: s.dtype, value: 1 }, backend: e });
}
const QH = {
  kernelName: xc,
  backendName: "webgl",
  kernelFunc: cI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function JH(n) {
  const { inputs: t, backend: e, attrs: s } = n, { axis: o } = s;
  if (t.length === 1)
    return Fd$1({ inputs: { input: t[0] }, backend: e, attrs: { dim: o } });
  const r = t[0].shape, i6 = t[0].dtype;
  t.forEach((u) => {
    Ve(r, u.shape, "All tensors passed to stack must have matching shapes"), v(i6 === u.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const a = [], l = t.map((u) => {
    const d = Fd$1({ inputs: { input: u }, backend: e, attrs: { dim: o } });
    return a.push(d), d;
  }), c = Uw({ inputs: l, backend: e, attrs: { axis: o } });
  return a.forEach((u) => e.disposeIntermediateTensorInfo(u)), c;
}
const jH = {
  kernelName: wc,
  backendName: "webgl",
  kernelFunc: JH
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class qH {
  constructor(t, e, s) {
    this.variableNames = ["x"], this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = e.map(
      (c, u) => c[0] + t[u] + c[1]
      /* afterPad */
    );
    const o = t.length, r = Kt(o), i6 = e.map((c) => c[0]).join(","), a = e.map((c, u) => c[0] + t[u]).join(","), l = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, o);
    if (o === 1) {
      this.userCode = `
        int start = ${i6};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
      return;
    }
    this.userCode = `
      ${r} start = ${r}(${i6});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class t9 {
  constructor(t, e, s) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = e.map(
      (m, g6) => m[0] + t[g6] + m[1]
      /* afterPad */
    );
    const o = t.length, r = Kt(o), i6 = e.map((m) => m[0]).join(","), a = e.map((m, g6) => m[0] + t[g6]).join(","), l = We$1("rc", o), c = We$1("source", o), u = `${l[o - 1]} < ${this.outputShape[o - 1]}`, d = o === 1 ? "source" : `vec2(${c.slice(-2).join()})`, h6 = [
      `${r} rc = outputLoc;`,
      `${l[o - 1]} += 1;
       if(${u}) {
      `,
      o === 1 ? "" : `}
       rc = outputLoc;
       ${l[o - 2]} += 1;
       if(${l[o - 2]} < ${this.outputShape[o - 2]}) {`,
      o === 1 ? "" : `  ${l[o - 1]} += 1;
         if(${u}) {`
    ], p6 = o === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
    let f = "";
    for (let m = 0, g6 = o === 1 ? 2 : 4; m < g6; m++)
      f += `
        ${h6[m]}
        if (${p6}) {
          result[${m}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${d});
        }
      `;
    f += o === 1 ? "} " : "}}", this.userCode = `
      const ${r} start = ${r}(${i6});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const uI = (n) => {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { paddings: r, constantValue: i6 } = s;
  if (O(o.shape) === 0) {
    const c = r.map(
      (u, d) => u[0] + o.shape[d] + u[1]
      /* afterPad */
    );
    return La({
      backend: e,
      attrs: { shape: c, value: i6, dtype: o.dtype }
    });
  }
  const a = F().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new t9(o.shape, r, i6) : new qH(o.shape, r, i6), l = [[i6]];
  return e.runWebGLProgram(a, [o], o.dtype, l);
}, e9 = {
  kernelName: Ic,
  backendName: "webgl",
  kernelFunc: uI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const n9 = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`, s9 = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + $a + `
  return result;
`, o9 = Ne({ opSnippet: n9, packedOpSnippet: s9 }), r9 = {
  kernelName: Ai,
  backendName: "webgl",
  kernelFunc: o9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { axis: r, keepDims: i6 } = s, a = o.shape.length, l = [], c = Ct(r, o.shape);
  let u = c;
  const d = qt$1(u, a);
  let h6 = o;
  d != null && (h6 = Fe({ inputs: { x: o }, backend: e, attrs: { perm: d } }), u = ie(u.length, a), l.push(h6)), Te("prod", u, a);
  let p6;
  if (e.shouldExecuteOnCPU([h6])) {
    const f = e.texData.get(h6.dataId).values, { outVals: m, outShape: g6, outDtype: b6 } = dP(h6.shape, h6.dtype, f, u);
    p6 = e.makeTensorInfo(g6, b6, m);
  } else {
    const [f, m] = ye$1(h6.shape, u), g6 = O(m), b6 = st({ inputs: { x: h6 }, backend: e, attrs: { shape: [-1, g6] } }), x6 = zh$1(o.dtype), w6 = Oo(b6, x6, "prod", e);
    p6 = st({ inputs: { x: w6 }, backend: e, attrs: { shape: f } }), l.push(b6), l.push(w6);
  }
  if (i6) {
    l.push(p6);
    const f = re$1(p6.shape, c);
    p6 = st({ inputs: { x: p6 }, backend: e, attrs: { shape: f } });
  }
  return l.forEach((f) => e.disposeIntermediateTensorInfo(f)), p6;
}
const a9 = {
  kernelName: vc,
  backendName: "webgl",
  kernelFunc: i9
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function l9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { paramsNestedSplits: o, paramsDenseValues: r, indices: i6 } = t, { outputRaggedRank: a } = s, l = o.map((b6) => e.readSync(b6.dataId)), c = o.map((b6) => b6.shape), u = e.readSync(r.dataId), d = e.readSync(i6.dataId), [h6, p6, f] = hP(l, c, u, r.shape, r.dtype, d, i6.shape, a), m = h6.map((b6) => e.makeTensorInfo([b6.length], "int32", b6)), g6 = e.makeTensorInfo(f, r.dtype, p6);
  return m.concat([g6]);
}
const c9 = {
  kernelName: Qg$1,
  backendName: "webgl",
  kernelFunc: l9
};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function u9(n) {
  const { inputs: t, backend: e } = n, { starts: s, limits: o, deltas: r } = t, i6 = e.readSync(s.dataId), a = e.readSync(o.dataId), l = e.readSync(r.dataId), [c, u] = pP(i6, s.shape, s.dtype, a, o.shape, l, r.shape), d = e.makeTensorInfo([c.length], "int32", c), h6 = e.makeTensorInfo([u.length], s.dtype, u);
  return [d, h6];
}
const d9 = {
  kernelName: Jg$1,
  backendName: "webgl",
  kernelFunc: u9
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function h9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { shape: o, values: r, defaultValue: i6, rowPartitionTensors: a } = t, { rowPartitionTypes: l } = s, c = e.readSync(o.dataId), u = e.readSync(r.dataId), d = e.readSync(i6.dataId), h6 = a.map((g6) => e.readSync(g6.dataId)), p6 = a.map((g6) => g6.shape), [f, m] = fP(c, o.shape, u, r.shape, r.dtype, d, i6.shape, h6, p6, l);
  return e.makeTensorInfo(f, r.dtype, m);
}
const p9 = {
  kernelName: jg$1,
  backendName: "webgl",
  kernelFunc: h9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const dI = (n) => {
  const { backend: t, attrs: e } = n, { start: s, stop: o, step: r, dtype: i6 } = e, a = mP(s, o, r, i6);
  return t.makeTensorInfo([a.length], i6, a);
}, f9 = {
  kernelName: yh$1,
  backendName: "webgl",
  kernelFunc: dI
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const m9 = "return 1.0 / x;", g9 = Nt$1({ opSnippet: m9 }), b9 = {
  kernelName: Oi,
  backendName: "webgl",
  kernelFunc: g9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const x9 = En$1 + `
  return (x < 0.0) ? 0.0 : x;
`, y9 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, w9 = Nt$1({ opSnippet: x9, packedOpSnippet: y9 }), I9 = {
  kernelName: Ki,
  backendName: "webgl",
  kernelFunc: w9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const C9 = En$1 + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, v9 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, S9 = Nt$1({ opSnippet: C9, packedOpSnippet: v9 }), k9 = {
  kernelName: Zi,
  backendName: "webgl",
  kernelFunc: S9
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class T9 {
  constructor(t, e, s, o, r) {
    this.variableNames = ["A"], this.outputShape = [];
    const [i6, a, l, c] = t;
    this.outputShape = [i6, e, s, c];
    const u = [
      o && e > 1 ? a - 1 : a,
      o && s > 1 ? l - 1 : l
    ], d = [
      o && e > 1 ? e - 1 : e,
      o && s > 1 ? s - 1 : s
    ];
    let h6;
    r ? h6 = "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : h6 = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0] / d[0]},
          ${u[1] / d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h6};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class N9 {
  constructor(t, e, s, o, r) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
    const [i6, a, l, c] = t;
    this.outputShape = [i6, e, s, c];
    const u = [
      o && e > 1 ? a - 1 : a,
      o && s > 1 ? l - 1 : l
    ], d = [
      o && e > 1 ? e - 1 : e,
      o && s > 1 ? s - 1 : s
    ];
    let h6;
    r ? h6 = "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : h6 = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0] / d[0]},
          ${u[1] / d[1]},
          ${u[1] / d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h6};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c - 1};
        bool hasNextRow = coords.z < ${s - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function R9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { images: o } = t, { alignCorners: r, halfPixelCenters: i6, size: a } = s, [l, c] = a, u = F().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new N9(o.shape, l, c, r, i6) : new T9(o.shape, l, c, r, i6);
  return e.runWebGLProgram(u, [o], "float32");
}
const $9 = {
  kernelName: Tc,
  backendName: "webgl",
  kernelFunc: R9
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class G9 {
  constructor(t, e, s) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e;
    const [, o, r] = e, [, i6, a] = t, l = [
      s && i6 > 1 ? o - 1 : o,
      s && a > 1 ? r - 1 : r
    ], c = [
      s && i6 > 1 ? i6 - 1 : i6,
      s && a > 1 ? a - 1 : a
    ], u = l[0] / c[0], d = l[1] / c[1], h6 = 1 / u, p6 = 1 / d, f = Math.ceil(h6) * 2 + 2, m = Math.ceil(p6) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h6});
        const float invWidthScale = float(${p6});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i6}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { images: o, dy: r } = t, { alignCorners: i6 } = s, a = new G9(r.shape, o.shape, i6);
  return e.runWebGLProgram(a, [r], r.dtype);
}
const L9 = {
  kernelName: Ch$1,
  backendName: "webgl",
  kernelFunc: E9
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class M9 {
  constructor(t, e, s, o, r) {
    this.variableNames = ["A"], this.outputShape = [];
    const [i6, a, l, c] = t;
    this.outputShape = [i6, e, s, c];
    const u = [
      o && e > 1 ? a - 1 : a,
      o && s > 1 ? l - 1 : l
    ], d = [
      o && e > 1 ? e - 1 : e,
      o && s > 1 ? s - 1 : s
    ], h6 = o ? "0.5" : "0.0";
    let p6;
    r ? p6 = "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : p6 = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0] / d[0]},
          ${u[1] / d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p6};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h6})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class W9 {
  constructor(t, e, s, o, r) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
    const [i6, a, l, c] = t;
    this.outputShape = [i6, e, s, c];
    const u = [
      o && e > 1 ? a - 1 : a,
      o && s > 1 ? l - 1 : l
    ], d = [
      o && e > 1 ? e - 1 : e,
      o && s > 1 ? s - 1 : s
    ], h6 = o ? "0.5" : "0.0";
    let p6;
    r ? p6 = "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : p6 = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0] / d[0]},
          ${u[1] / d[1]},
          ${u[1] / d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p6};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h6})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c - 1};
        bool hasNextRow = coords.z < ${s - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { images: o } = t, { alignCorners: r, halfPixelCenters: i6, size: a } = s, [l, c] = a, u = F().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new W9(o.shape, l, c, r, i6) : new M9(o.shape, l, c, r, i6);
  return e.runWebGLProgram(u, [o], o.dtype);
}
const F9 = {
  kernelName: kc,
  backendName: "webgl",
  kernelFunc: D9
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class V9 {
  constructor(t, e, s) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e;
    const [, o, r] = e, [, i6, a] = t, l = [
      s && i6 > 1 ? o - 1 : o,
      s && a > 1 ? r - 1 : r
    ], c = [
      s && i6 > 1 ? i6 - 1 : i6,
      s && a > 1 ? a - 1 : a
    ], u = l[0] / c[0], d = l[1] / c[1], h6 = 1 / u, p6 = 1 / d, f = Math.ceil(h6) * 2 + 2, m = Math.ceil(p6) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h6});
        const float invWidthScale = float(${p6});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i6}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function z9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { images: o, dy: r } = t, { alignCorners: i6 } = s, a = new V9(r.shape, o.shape, i6);
  return e.runWebGLProgram(a, [r], r.dtype);
}
const X9 = {
  kernelName: Ih$1,
  backendName: "webgl",
  kernelFunc: z9
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class P9 {
  constructor(t, e) {
    this.variableNames = ["x"];
    const s = t.length;
    if (s > 4)
      throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);
    if (this.outputShape = t, s === 1) {
      this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;
      return;
    }
    const o = (a) => e.indexOf(a) !== -1 && t[a] !== 1 ? `${t[a]} - coords[${a}] - 1` : `coords[${a}]`, r = t.map((a, l) => o(l)).join(","), i6 = Kt(s);
    this.userCode = `
      void main() {
        ${i6} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class A9 {
  constructor(t, e) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
    const s = t.length;
    if (s > 4)
      throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);
    this.outputShape = t;
    const o = We$1("rc", s), r = `${o[s - 1]} + 1 < ${this.outputShape[s - 1]}`, i6 = `${o[s - 2]} + 1 < ${this.outputShape[s - 2]}`, a = Kt(s);
    s === 1 ? this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : this.userCode = `
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(o.slice())};
          if(${r}){
            result.g = ${c(o.slice())};
          }
          if(${i6}) {
            result.b = ${u(o.slice())};
            if(${r}) {
              result.a = ${d(o.slice())};
            }
          }
          setOutput(result);
        }
    `;
    function l(f) {
      return h6(f);
    }
    function c(f) {
      return f[s - 1] = "(" + f[s - 1] + " + 1)", h6(f);
    }
    function u(f) {
      return f[s - 2] = "(" + f[s - 2] + " + 1)", h6(f);
    }
    function d(f) {
      return f[s - 1] = "(" + f[s - 1] + " + 1)", f[s - 2] = "(" + f[s - 2] + " + 1)", h6(f);
    }
    function h6(f) {
      const m = t.map((x6, w6) => p6(w6, f)), g6 = m.join(","), b6 = m.slice(-2).join(",");
      return `getChannel(getX(${g6}), vec2(${b6}))`;
    }
    function p6(f, m) {
      return e.indexOf(f) !== -1 && t[f] !== 1 ? `${t[f]} - ${m[f]} - 1` : `${m[f]}`;
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function O9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { dims: r } = s, i6 = o.shape.length, a = Ct(r, o.shape);
  if (i6 === 0)
    return tn$1({ inputs: { x: o }, backend: e });
  const l = F().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new A9(o.shape, a) : new P9(o.shape, a);
  return e.runWebGLProgram(l, [o], o.dtype);
}
const K9 = {
  kernelName: Nc,
  backendName: "webgl",
  kernelFunc: O9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Z9 {
  constructor(t, e) {
    this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{ name: "params", type: "vec4" }];
    const s = t[1], o = t[2];
    this.outputShape = t;
    let r = "";
    typeof e == "number" ? r = `float outputValue = ${e.toFixed(2)};` : r = `
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const B9 = {
  kernelName: Dh$1,
  backendName: "webgl",
  kernelFunc: ({ inputs: n, attrs: t, backend: e }) => {
    const { image: s } = n, { radians: o, fillValue: r, center: i6 } = t, a = e, l = new Z9(s.shape, r), [c, u] = Xp(i6, s.shape[1], s.shape[2]), d = [[c, u, Math.sin(o), Math.cos(o)]];
    return a.runWebGLProgram(l, [s], s.dtype, d);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const H9 = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`, _9 = Nt$1({ opSnippet: H9 }), U9 = {
  kernelName: Bi,
  backendName: "webgl",
  kernelFunc: _9
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Y9 = "return inversesqrt(x);", Q9 = Nt$1({ opSnippet: Y9, cpuKernelImpl: gP }), J9 = {
  kernelName: Hi,
  backendName: "webgl",
  kernelFunc: Q9
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class hI {
  constructor(t, e, s, o, r, i6, a = true) {
    this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = i6;
    const l = Kt(r.length), c = Kt(i6.length);
    let u = "";
    s === 1 ? u = "i" : s === 2 && (u = "i, j");
    const d = `getIndices(${u})`;
    let h6 = "";
    o === 1 ? h6 = "i" : o === 2 && (h6 = "i, coords[1]");
    const p6 = `getUpdates(${h6})`, f = e > 1 ? "strides[j]" : "strides";
    this.userCode = `
        ${l} strides = ${l}(${r});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p6};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function j9(n) {
  const { inputs: t, backend: e, attrs: s } = n, { indices: o, updates: r } = t, { shape: i6 } = s, { sliceRank: a, numUpdates: l, sliceSize: c, strides: u, outputSize: d } = Ir(r, o, i6), h6 = [d / c, c];
  if (d === 0)
    return e.makeTensorInfo(i6, o.dtype);
  const p6 = st({ inputs: { x: o }, backend: e, attrs: { shape: [l, a] } }), f = st({ inputs: { x: r }, backend: e, attrs: { shape: [l, c] } }), m = e.makeTensorInfo([], "float32", new Float32Array([0])), g6 = new hI(l, a, p6.shape.length, f.shape.length, u, h6), b6 = e.runWebGLProgram(g6, [f, p6, m], f.dtype), x6 = st({ inputs: { x: b6 }, backend: e, attrs: { shape: i6 } });
  return e.disposeIntermediateTensorInfo(p6), e.disposeIntermediateTensorInfo(f), e.disposeIntermediateTensorInfo(b6), e.disposeIntermediateTensorInfo(m), x6;
}
const q9 = {
  kernelName: qg$1,
  backendName: "webgl",
  kernelFunc: j9
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class t_ {
  constructor(t, e, s, o) {
    this.variableNames = ["sortedSequence", "values"], this.customUniforms = [{ name: "numInputs", type: "int" }], this.outputShape = [t, s];
    const r = "while (left < right) {", i6 = `for (int i = 0; i < ${Math.ceil(Math.log2(e + 1))}; ++i) { if (left >= right) break;`, a = F().getNumber("WEBGL_VERSION") === 2 ? r : i6, l = o === "left" ? "<" : "<=";
    this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function e_(n) {
  const { inputs: t, backend: e, attrs: s } = n, { sortedSequence: o, values: r } = t, { side: i6 } = s, a = new t_(o.shape[0], o.shape[1], r.shape[1], i6), l = [[o.shape[1]]];
  return e.runWebGLProgram(a, [o, r], "int32", l);
}
const n_ = {
  kernelName: tb$1,
  backendName: "webgl",
  kernelFunc: e_
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class s_ {
  constructor(t, e, s) {
    this.variableNames = ["c", "a", "b"], this.outputShape = e;
    let o, r;
    if (s > 4)
      throw Error(`Where for rank ${s} is not yet supported`);
    if (s === 1)
      r = "resRC", o = "resRC";
    else {
      const a = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], l = [], c = [];
      for (let u = 0; u < e.length; u++)
        c.push(`${a[u]}`), u < t && l.push(`${a[u]}`);
      o = l.join(), r = c.join();
    }
    const i6 = Kt(s);
    this.userCode = `
      void main() {
        ${i6} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function o_(n) {
  const { inputs: t, backend: e } = n, { condition: s, t: o, e: r } = t, i6 = new s_(s.shape.length, o.shape, o.shape.length);
  return e.runWebGLProgram(i6, [s, o, r], je$1(o.dtype, r.dtype));
}
const r_ = {
  kernelName: Rc,
  backendName: "webgl",
  kernelFunc: o_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const i_ = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Yc};
  float scale = ${Qc};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`, a_ = Nt$1({ opSnippet: i_ }), l_ = {
  kernelName: _i,
  backendName: "webgl",
  kernelFunc: a_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const c_ = Gr + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`, u_ = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, d_ = Nt$1({
  opSnippet: c_,
  packedOpSnippet: u_,
  cpuKernelImpl: xP
}), h_ = {
  kernelName: Ji,
  backendName: "webgl",
  kernelFunc: d_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const p_ = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`, f_ = Nt$1({ opSnippet: p_ }), m_ = {
  kernelName: Qi,
  backendName: "webgl",
  kernelFunc: f_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const g_ = Gr + `
  return sin(x);
`, b_ = Nt$1({ opSnippet: g_ }), x_ = {
  kernelName: Ui,
  backendName: "webgl",
  kernelFunc: b_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const y_ = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`, w_ = Nt$1({ opSnippet: y_ }), I_ = {
  kernelName: Yi,
  backendName: "webgl",
  kernelFunc: w_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const C_ = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`, v_ = Nt$1({ opSnippet: C_ }), S_ = {
  kernelName: ji,
  backendName: "webgl",
  kernelFunc: v_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const k_ = (n) => {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { blockShape: r, paddings: i6 } = s;
  v(o.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
  const a = r.reduce((b6, x6) => b6 * x6), l = [[0, 0]];
  l.push(...i6);
  for (let b6 = 1 + r.length; b6 < o.shape.length; ++b6)
    l.push([0, 0]);
  const c = [], u = uI({
    inputs: { x: o },
    backend: e,
    attrs: { paddings: l, constantValue: 0 }
  }), d = fa(u.shape, r, a, false), h6 = ma(d.length, r.length, false), p6 = ga(u.shape, r, a, false), f = st({ inputs: { x: u }, backend: e, attrs: { shape: d } }), m = Fe({
    inputs: { x: f },
    backend: e,
    attrs: { perm: h6 }
  }), g6 = st({ inputs: { x: m }, backend: e, attrs: { shape: p6 } });
  return c.push(u), c.push(f), c.push(m), c.forEach((b6) => e.disposeIntermediateTensorInfo(b6)), g6;
}, T_ = {
  kernelName: Ec,
  backendName: "webgl",
  kernelFunc: k_
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function N_(n) {
  const { inputs: t, backend: e } = n, { indices: s, values: o, denseShape: r, defaultValue: i6 } = t;
  if (r.shape.length !== 1)
    throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);
  if (s.shape.length !== 2)
    throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);
  if (o.shape.length !== 1)
    throw new Error(`Values must be a vector, saw:
         ${o.shape}`);
  if (i6.shape.length !== 0)
    throw new Error(`Default value must be a scalar, saw:
        ${i6.shape}`);
  const a = e.readSync(s.dataId), l = e.readSync(o.dataId), c = e.readSync(r.dataId), u = e.readSync(i6.dataId)[0], [d, h6, p6, f, m] = wP(a, s.shape, s.dtype, l, o.dtype, c, u);
  return [
    e.makeTensorInfo(h6, s.dtype, d),
    e.makeTensorInfo([h6[0]], o.dtype, p6),
    e.makeTensorInfo([f.length], "bool", new Uint8Array(f.map((g6) => Number(g6)))),
    e.makeTensorInfo([m.length], s.dtype, new Int32Array(m))
  ];
}
const R_ = {
  kernelName: vh$1,
  backendName: "webgl",
  kernelFunc: N_
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $_(n) {
  const { inputs: t, backend: e } = n, { inputIndices: s, inputShape: o, newShape: r } = t;
  if (s.shape.length !== 2)
    throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);
  if (o.shape.length !== 1)
    throw new Error(`Input shape should be a vector but received shape ${o.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Target shape should be a vector but received shape ${r.shape}`);
  const i6 = Array.from(e.readSync(o.dataId)), a = e.readSync(s.dataId), l = Array.from(e.readSync(r.dataId)), [c, u, d] = IP(a, s.shape, s.dtype, i6, l);
  return [
    e.makeTensorInfo(u, s.dtype, c),
    e.makeTensorInfo([d.length], r.dtype, new Int32Array(d))
  ];
}
const G_ = {
  kernelName: Sh$1,
  backendName: "webgl",
  kernelFunc: $_
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function E_(n) {
  const { inputs: t, backend: e } = n, { data: s, indices: o, segmentIds: r } = t;
  if (s.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (o.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);
  const i6 = e.readSync(s.dataId), a = e.readSync(o.dataId), l = e.readSync(r.dataId), [c, u] = Dw(i6, s.shape, s.dtype, a, l, true);
  return e.makeTensorInfo(u, s.dtype, c);
}
const L_ = {
  kernelName: kh$1,
  backendName: "webgl",
  kernelFunc: E_
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function M_(n) {
  const { inputs: t, backend: e } = n, { data: s, indices: o, segmentIds: r } = t;
  if (s.shape.length < 1)
    throw new Error("Data should be at least 1 dimensional but received scalar");
  if (o.shape.length !== 1)
    throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);
  if (r.shape.length !== 1)
    throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);
  const i6 = e.readSync(s.dataId), a = e.readSync(o.dataId), l = e.readSync(r.dataId), [c, u] = Dw(i6, s.shape, s.dtype, a, l);
  return e.makeTensorInfo(u, s.dtype, c);
}
const W_ = {
  kernelName: Th$1,
  backendName: "webgl",
  kernelFunc: M_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function D_(n) {
  const { inputs: t, backend: e, attrs: s } = n, { sparseIndices: o, sparseValues: r, defaultValue: i6 } = t, { outputShape: a } = s, { sliceRank: l, numUpdates: c, sliceSize: u, strides: d, outputSize: h6 } = Ir(r, o, a), p6 = false;
  if (r.dtype === "string") {
    const b6 = e.bufferSync(o), x6 = e.bufferSync(r), w6 = ps(e.readSync(i6.dataId)[0]), y6 = bP(b6, x6, a, h6, u, c, l, d, w6, p6);
    return e.makeTensorInfo(a, y6.dtype, y6.values);
  }
  const f = new hI(c, l, o.shape.length, r.shape.length, d, [h6, 1], p6), m = e.runWebGLProgram(f, [r, o, i6], r.dtype), g6 = st({ inputs: { x: m }, backend: e, attrs: { shape: a } });
  return e.disposeIntermediateTensorInfo(m), g6;
}
const F_ = {
  kernelName: eb$1,
  backendName: "webgl",
  kernelFunc: D_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function V_(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { numOrSizeSplits: r, axis: i6 } = s, a = Ct(i6, o.shape)[0], l = tf$1(o, r, a), c = o.shape.length, u = new Array(c).fill(0), d = o.shape.slice();
  return l.map((h6) => {
    const p6 = [...d];
    p6[a] = h6;
    const f = Er({ inputs: { x: o }, backend: e, attrs: { begin: u, size: p6 } });
    return u[a] += h6, f;
  });
}
const z_ = {
  kernelName: Lc,
  backendName: "webgl",
  kernelFunc: V_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const wg$1 = "return sqrt(x);", X_ = Nt$1({ opSnippet: wg$1, packedOpSnippet: wg$1, cpuKernelImpl: CP }), P_ = {
  kernelName: qi,
  backendName: "webgl",
  kernelFunc: X_
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const A_ = "return x * x;", O_ = Nt$1({ opSnippet: A_ }), K_ = {
  kernelName: Nh$1,
  backendName: "webgl",
  kernelFunc: O_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ig$1 = "return (a - b) * (a - b);", Z_ = Ne({ opSnippet: Ig$1, packedOpSnippet: Ig$1 }), B_ = {
  kernelName: ta,
  backendName: "webgl",
  kernelFunc: Z_
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function H_({ inputs: n, attrs: t, backend: e }) {
  const { x: s } = n, o = En$1 + `
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `, r = new qn$1(s.shape, o);
  return e.runWebGLProgram(r, [s], s.dtype);
}
const __ = {
  kernelName: ra,
  backendName: "webgl",
  kernelFunc: H_
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class U_ {
  constructor(t, e, s) {
    this.variableNames = ["x"], this.outputShape = s;
    const o = s.length, r = Kt(s.length), i6 = Kt(s.length);
    let a = "";
    if (o === 1)
      a = "coords * strides + begin";
    else {
      let l = 0;
      a = s.map((c, u) => (l++, s.length === 1 ? `coords * strides[${u}] + begin[${u}]` : `coords[${l - 1}] * strides[${u}] + begin[${u}]`)).join(",");
    }
    this.userCode = `
      ${r} begin = ${r}(${t});
      ${r} strides = ${r}(${e});

      void main() {
        ${i6} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Y_(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { begin: r, end: i6, strides: a, beginMask: l, endMask: c, ellipsisMask: u, newAxisMask: d, shrinkAxisMask: h6 } = s, { finalShapeSparse: p6, finalShape: f, isIdentity: m, sliceDim0: g6, isSimpleSlice: b6, begin: x6, end: w6, strides: y6 } = Fp(o.shape, r, i6, a, l, c, u, d, h6);
  let I;
  if (m)
    I = st({ inputs: { x: o }, backend: e, attrs: { shape: f } });
  else if (g6 || b6) {
    v(o.shape.length >= 1, () => `Input must have rank at least 1, got: ${o.shape.length}`);
    const k7 = Mp(x6, w6, y6), S = Er({ inputs: { x: o }, backend: e, attrs: { begin: x6, size: k7 } });
    I = st({ inputs: { x: S }, backend: e, attrs: { shape: f } }), e.disposeIntermediateTensorInfo(S);
  } else if (e.shouldExecuteOnCPU([o])) {
    const S = e.readSync(o.dataId), N = vt$1(o.shape, o.dtype, S), R = vP(p6, N, y6, x6);
    I = e.makeTensorInfo(f, o.dtype, R.values);
  } else {
    const S = new U_(x6, y6, p6);
    I = e.runWebGLProgram(S, [o], o.dtype);
  }
  const C6 = st({ inputs: { x: I }, backend: e, attrs: { shape: f } });
  return e.disposeIntermediateTensorInfo(I), C6;
}
const Q_ = {
  kernelName: Rh$1,
  backendName: "webgl",
  kernelFunc: Y_
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function J_(n) {
  const { inputs: t, backend: e, attrs: s } = n, { separator: o, nGramWidths: r, leftPad: i6, rightPad: a, padWidth: l, preserveShortSequences: c } = s, { data: u, dataSplits: d } = t, h6 = e.readSync(u.dataId), p6 = e.readSync(d.dataId), [f, m] = SP(h6, p6, o, r, i6, a, l, c);
  return [
    e.makeTensorInfo([f.length], "string", f),
    e.makeTensorInfo(d.shape, "int32", m)
  ];
}
const j_ = {
  kernelName: $h$1,
  backendName: "webgl",
  kernelFunc: J_
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function q_(n) {
  const { inputs: t, backend: e, attrs: s } = n, { skipEmpty: o } = s, { input: r, delimiter: i6 } = t;
  if (r.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (r.shape.length !== 1)
    throw new Error(`Input must be a vector, got shape: ${r.shape}`);
  if (i6.shape.length !== 0)
    throw new Error(`Delimiter must be a scalar, got shape: ${i6.shape}`);
  const a = e.readSync(r.dataId), l = e.readSync(i6.dataId)[0], [c, u, d] = kP(a, l, o), h6 = u.length;
  return [
    e.makeTensorInfo([h6, 2], "int32", c),
    e.makeTensorInfo([h6], "string", u),
    e.makeTensorInfo([2], "int32", new Int32Array(d))
  ];
}
const tU = {
  kernelName: Gh$1,
  backendName: "webgl",
  kernelFunc: q_
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eU(n) {
  const { inputs: t, backend: e, attrs: s } = n, { numBuckets: o } = s, { input: r } = t;
  if (r.dtype !== "string")
    throw new Error("Input must be of datatype string");
  if (o <= 0)
    throw new Error("Number of buckets must be at least 1");
  const i6 = e.readSync(r.dataId), a = TP(i6, o);
  return e.makeTensorInfo(r.shape, "int32", a);
}
const nU = {
  kernelName: Eh$1,
  backendName: "webgl",
  kernelFunc: eU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sU = "return tan(x);", oU = Nt$1({ opSnippet: sU }), rU = {
  kernelName: na,
  backendName: "webgl",
  kernelFunc: oU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const iU = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`, aU = Nt$1({ opSnippet: iU }), lU = {
  kernelName: sa,
  backendName: "webgl",
  kernelFunc: aU
};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class cU {
  constructor(t, e) {
    this.variableNames = ["A"];
    const s = new Array(t.length);
    for (let i6 = 0; i6 < s.length; i6++)
      s[i6] = t[i6] * e[i6];
    this.outputShape = s, this.rank = s.length;
    const o = Kt(this.rank), r = uU(t);
    this.userCode = `
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `;
  }
}
function uU(n) {
  const t = n.length;
  if (t > 5)
    throw Error(`Tile for rank ${t} is not yet supported`);
  if (t === 1)
    return `imod(resRC, ${n[0]})`;
  const e = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], s = [];
  for (let o = 0; o < n.length; o++)
    s.push(`imod(${e[o]}, ${n[o]})`);
  return s.join();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pI(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { reps: r } = s;
  if (o.dtype === "string" || o.shape.length > 5) {
    const l = e.readSync(o.dataId), c = o.dtype === "string" ? l.map((h6) => ps(h6)) : l, u = vt$1(o.shape, o.dtype, c), d = RP(u, r);
    return e.makeTensorInfo(d.shape, d.dtype, d.values);
  }
  const i6 = new cU(o.shape, r);
  return e.runWebGLProgram(i6, [o], o.dtype);
}
const dU = {
  kernelName: oa,
  backendName: "webgl",
  kernelFunc: pI
};
class hU {
  /**
   * @param shape desired output shape (can be larger than input shape, output
   *                                    will be padded with -Infinity)
   */
  constructor(t) {
    this.variableNames = ["x", "indices"], this.customUniforms = [
      { name: "n", type: "int" },
      { name: "firstPass", type: "int" },
      { name: "negativeInf", type: "float" },
      { name: "dir", type: "int" },
      { name: "inc", type: "int" }
    ], this.outputShape = t, this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
  }
}
class pU {
  /**
   * @param shape desired output shape (must be half of the input size)
   */
  constructor(t) {
    this.variableNames = ["x", "indices"], this.customUniforms = [
      { name: "n", type: "int" },
      { name: "firstPass", type: "int" },
      { name: "k", type: "int" }
    ], this.outputShape = t, this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function no(n, t) {
  t !== null && n.disposeIntermediateTensorInfo(t);
}
function Cg$1(n) {
  let t = 1;
  for (; t < n; )
    t *= 2;
  return t;
}
function fU(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o } = t, { k: r, sorted: i6 } = s, a = F().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), l = F().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), c = o.shape, u = c[c.length - 1];
  if (e.shouldExecuteOnCPU([o]) || u < a || r > l) {
    const R = e.readSync(o.dataId), [M6, V] = $P(R, c, o.dtype, r, i6);
    return [
      e.makeTensorInfo(M6.shape, M6.dtype, M6.values),
      e.makeTensorInfo(V.shape, V.dtype, V.values)
    ];
  }
  if (r === 0)
    return c[c.length - 1] = 0, [
      e.makeTensorInfo(c, o.dtype, []),
      e.makeTensorInfo(c, "int32", [])
    ];
  if (u === 1)
    return [
      o,
      La({ attrs: { shape: c, dtype: "int32", value: 0 }, backend: e })
    ];
  const d = e.texData.get(o.dataId), h6 = d !== null && d.isPacked, p6 = h6 ? e.unpackTensor(o) : o, m = O(c) / u, g6 = st({ inputs: { x: p6 }, attrs: { shape: [m, u] }, backend: e });
  h6 && no(e, p6);
  const b6 = Cg$1(r), x6 = Cg$1(u);
  let w6 = null;
  const y6 = () => w6 === null ? [g6, g6] : [g6, w6], I = (R, M6, V) => {
    const z = y6(), X = new hU(V), A6 = [[u], [w6 === null ? 1 : 0], [Number.NEGATIVE_INFINITY], [R], [M6]], B6 = w6;
    w6 = e.runWebGLProgram(X, z, "int32", A6), no(e, B6);
  };
  for (let R = 1; R < b6; R *= 2) {
    const M6 = R * 2;
    for (let V = R; V >= 1; V /= 2)
      I(M6, V, [m, x6]);
  }
  for (let R = x6; R > b6; R /= 2) {
    const M6 = y6(), V = new pU([m, R / 2]), X = [[u], [w6 === null ? 1 : 0], [b6]], P6 = w6;
    w6 = e.runWebGLProgram(V, M6, "int32", X), no(e, P6);
    const A6 = b6 / 2, B6 = A6 * 2;
    for (let Z = A6; Z >= 1; Z /= 2)
      I(B6, Z, w6.shape);
  }
  let C6 = w6;
  w6 = Er({ inputs: { x: w6 }, backend: e, attrs: { begin: 0, size: [m, r] } }), no(e, C6);
  let k7 = oI({ inputs: { x: g6, indices: w6 }, backend: e, attrs: { axis: 1, batchDims: 1 } });
  no(e, g6);
  const S = c.slice(0, -1);
  S.push(r), C6 = w6, w6 = st({ inputs: { x: w6 }, attrs: { shape: S }, backend: e }), no(e, C6);
  const N = k7;
  return k7 = st({ inputs: { x: k7 }, attrs: { shape: S }, backend: e }), no(e, N), [k7, w6];
}
const mU = {
  kernelName: Lh$1,
  backendName: "webgl",
  kernelFunc: fU
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class gU {
  constructor(t, e, s, o, r, i6) {
    this.variableNames = ["Image", "Transforms"], this.outputShape = i6;
    const a = s === "nearest" ? 1 : 2;
    let l;
    switch (o) {
      case "constant":
        l = 1;
        break;
      case "reflect":
        l = 2;
        break;
      case "wrap":
        l = 3;
        break;
      case "nearest":
        l = 4;
        break;
      default:
        l = 1;
        break;
    }
    this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
  }
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bU(n) {
  const { inputs: t, backend: e, attrs: s } = n, { image: o, transforms: r } = t, { interpolation: i6, fillMode: a, fillValue: l, outputShape: c } = s, [u, d, h6, p6] = o.shape, [f, m] = c ?? [d, h6], g6 = [
    u,
    f,
    m,
    p6
  ], b6 = new gU(d, h6, i6, a, l, g6);
  return e.runWebGLProgram(b6, [o, r], "float32");
}
const xU = {
  kernelName: Mh$1,
  backendName: "webgl",
  kernelFunc: bU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yU(n) {
  const { inputs: t, attrs: e, backend: s } = n, { axis: o } = e, { x: r } = t;
  Na(r, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
  const i6 = s.readSync(r.dataId), { outputValues: a, outputShape: l, indices: c } = GP(i6, o, r.shape, r.dtype);
  return [
    s.makeTensorInfo(l, r.dtype, a),
    s.makeTensorInfo([c.length], "int32", c)
  ];
}
const wU = {
  kernelName: Wh$1,
  backendName: "webgl",
  kernelFunc: yU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function IU(n) {
  const { inputs: t, backend: e, attrs: s } = n, { value: o } = t;
  let { axis: r } = s;
  r < 0 && (r += o.shape.length);
  const i6 = o, a = i6.shape.length, l = o.shape[r], c = new Array(a - 1);
  let u = 0;
  for (let m = 0; m < a; m++)
    m !== r && (c[u++] = i6.shape[m]);
  const d = [], h6 = new Array(a).fill(0), p6 = i6.shape.slice();
  p6[r] = 1;
  const f = new Array(l);
  for (let m = 0; m < f.length; m++) {
    h6[r] = m;
    const g6 = Er({ inputs: { x: i6 }, backend: e, attrs: { begin: h6, size: p6 } }), b6 = st({ inputs: { x: g6 }, backend: e, attrs: { shape: c } });
    f[m] = b6, d.push(g6);
  }
  return d.forEach((m) => e.disposeIntermediateTensorInfo(m)), f;
}
const CU = {
  kernelName: Wc,
  backendName: "webgl",
  kernelFunc: IU
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class vU {
  constructor(t, e) {
    this.variableNames = ["x", "segmentIds"];
    const s = t.windowSize, o = t.batchSize, r = t.inSize, i6 = t.numSegments, a = i6 * Math.ceil(r / s);
    this.outputShape = [o, a];
    const l = "0.0", c = "sumValue", u = Math.floor(s / 4) * 4, d = s % 4, h6 = `
        sumValue += dot(values, segFilter);
    `;
    let p6 = "";
    r % s > 0 && (p6 = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);
    let f = "";
    r % s > 0 && (f = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p6}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i6})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${i6})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h6}
        }

        int inIdx = inOffset + ${u};
        if (${d === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h6}
        } else if (${d === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h6}
        } else if (${d === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h6}
        }
        setOutput(${c});
      }
    `;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function SU(n) {
  const { inputs: t, backend: e, attrs: s } = n, { x: o, segmentIds: r } = t, { numSegments: i6 } = s, a = o.shape.length, l = [];
  let c = 0;
  const u = qt$1([c], a);
  let d = o;
  u != null && (d = Fe({ inputs: { x: o }, backend: e, attrs: { perm: u } }), l.push(d), c = ie(1, a)[0]);
  const h6 = U0(d.shape, c, i6), p6 = O([d.shape[c]]), f = st({ inputs: { x: d }, backend: e, attrs: { shape: [-1, p6] } });
  l.push(f);
  const m = zh$1(o.dtype), g6 = (y6, I, C6, k7, S) => {
    const N = y6.shape[0], R = y6.shape[1], M6 = _0(R, S), V = { windowSize: M6, inSize: R, batchSize: N, numSegments: S }, z = new vU(V, I), X = e.compileAndRun(z, [y6, C6], k7);
    if (l.push(X), X.shape[1] === S)
      return X;
    const P6 = dI({
      backend: e,
      attrs: { start: 0, stop: S, step: 1, dtype: "float32" }
    }), A6 = pI({
      inputs: { x: P6 },
      backend: e,
      attrs: { reps: [R / M6] }
    });
    return l.push(P6), l.push(A6), g6(X, I, A6, k7, S);
  }, b6 = g6(f, "unsortedSegmentSum", r, m, i6), x6 = st({ inputs: { x: b6 }, backend: e, attrs: { shape: h6 } });
  let w6 = x6;
  if (u != null) {
    l.push(x6);
    const y6 = Hs(u);
    w6 = Fe({ inputs: { x: w6 }, backend: e, attrs: { perm: y6 } });
  }
  return l.forEach((y6) => e.disposeIntermediateTensorInfo(y6)), w6;
}
const kU = {
  kernelName: Dc,
  backendName: "webgl",
  kernelFunc: SU
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TU = [
  IA,
  vA,
  TA,
  $A,
  EA,
  WA,
  FA,
  zA,
  OA,
  ZA,
  _A,
  QA,
  qA,
  sO,
  iO,
  lO,
  uO,
  fO,
  gO,
  xO,
  CO,
  $O,
  EO,
  MO,
  XO,
  AO,
  BO,
  oA,
  UO,
  qO,
  sK,
  cK,
  dK,
  pK,
  mK,
  bK,
  wK,
  vK,
  TK,
  RK,
  GK,
  LK,
  DK,
  VK,
  AK,
  KK,
  HK,
  YK,
  JK,
  eZ,
  rZ,
  cZ,
  hZ,
  mZ,
  gZ,
  xZ,
  wZ,
  CZ,
  SZ,
  TZ,
  GZ,
  MZ,
  FZ,
  zZ,
  AZ,
  ZZ,
  UZ,
  jZ,
  sA,
  tB,
  JO,
  sB,
  iB,
  cB,
  iA,
  pB,
  bB,
  yB,
  vB,
  TB,
  GB,
  MB,
  VB,
  AB,
  ZB,
  HB,
  QB,
  jB,
  tH,
  oH,
  iH,
  lH,
  uH,
  hH,
  gH,
  wH,
  SH,
  LH,
  cA,
  FH,
  XH,
  OH,
  BH,
  DO,
  UH,
  QH,
  jH,
  e9,
  r9,
  lA,
  a9,
  c9,
  d9,
  p9,
  f9,
  FO,
  RH,
  b9,
  I9,
  k9,
  dA,
  $9,
  L9,
  F9,
  X9,
  K9,
  B9,
  U9,
  J9,
  q9,
  n_,
  r_,
  l_,
  h_,
  m_,
  x_,
  I_,
  NO,
  GH,
  S_,
  T_,
  R_,
  G_,
  L_,
  W_,
  F_,
  z_,
  P_,
  K_,
  B_,
  __,
  Q_,
  j_,
  tU,
  nU,
  $H,
  xA,
  rU,
  lU,
  dU,
  mU,
  xU,
  yA,
  wU,
  CU,
  kU,
  YH
];
for (const n of TU)
  en$1(n);
const fI = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIFd0e2NvbnN0cnVjdG9yKG49W10sZT1RdCl7aWYodGhpcy5kYXRhPW4sdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aCx0aGlzLmNvbXBhcmU9ZSx0aGlzLmxlbmd0aD4wKWZvcihsZXQgdD0odGhpcy5sZW5ndGg+PjEpLTE7dD49MDt0LS0pdGhpcy5fZG93bih0KX1wdXNoKG4pe3RoaXMuZGF0YS5wdXNoKG4pLHRoaXMubGVuZ3RoKyssdGhpcy5fdXAodGhpcy5sZW5ndGgtMSl9cG9wKCl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybjtjb25zdCBuPXRoaXMuZGF0YVswXSxlPXRoaXMuZGF0YS5wb3AoKTtyZXR1cm4gdGhpcy5sZW5ndGgtLSx0aGlzLmxlbmd0aD4wJiYodGhpcy5kYXRhWzBdPWUsdGhpcy5fZG93bigwKSksbn1wZWVrKCl7cmV0dXJuIHRoaXMuZGF0YVswXX1fdXAobil7Y29uc3R7ZGF0YTplLGNvbXBhcmU6dH09dGhpcyxzPWVbbl07Zm9yKDtuPjA7KXtjb25zdCByPW4tMT4+MSxpPWVbcl07aWYodChzLGkpPj0wKWJyZWFrO2Vbbl09aSxuPXJ9ZVtuXT1zfV9kb3duKG4pe2NvbnN0e2RhdGE6ZSxjb21wYXJlOnR9PXRoaXMscz10aGlzLmxlbmd0aD4+MSxyPWVbbl07Zm9yKDtuPHM7KXtsZXQgaT0objw8MSkrMSxoPWVbaV07Y29uc3QgbD1pKzE7aWYobDx0aGlzLmxlbmd0aCYmdChlW2xdLGgpPDAmJihpPWwsaD1lW2xdKSx0KGgscik+PTApYnJlYWs7ZVtuXT1oLG49aX1lW25dPXJ9fWZ1bmN0aW9uIFF0KG8sbil7cmV0dXJuIG88bj8tMTpvPm4/MTowfWNvbnN0IHl0PW89Pntjb25zdHt2MTpuLHYyOmV9PW87bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9KG5bc11eZVtzXSk+Pj4wO3QrPVp0KHIpfXJldHVybiB0fSxadD1vPT57dmFyIG49by0obz4+MSYxNDMxNjU1NzY1KTtyZXR1cm4gbj0obj4+MiY4NTg5OTM0NTkpKyhuJjg1ODk5MzQ1OSksbj0obj4+NCkrbiYyNTI2NDUxMzUsbj0obj4+OCkrbiYxNjcxMTkzNSxuPShuPj4xNikrbiY2NTUzNSxufSxjdD0xLHZ0PW89Pntjb25zdHtrZXl3aWR0aDpuLGtleWhlaWdodDplLHF1ZXJ5d2lkdGg6dCxxdWVyeWhlaWdodDpzLG1hdGNoZXM6cn09byxpPXQqMS4yLGg9LWksbD1zKjEuMix1PS1sLGY9MTIsZz0xMCxhPS0xLGo9MSx5PTEvTWF0aC5sb2coMTApLG09TWF0aC5tYXgobixlKSxNPU1hdGguZmxvb3Iobi8yKSxUPU1hdGguZmxvb3IoZS8yKSxFPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludC5zY2FsZSxLPXJbTl0ua2V5cG9pbnQuc2NhbGU7Sz09MCYmY29uc29sZS5sb2coIkVSUk9SIGRpdmlkZSB6ZXJvIik7Y29uc3Qgdj0kL0s7RS5wdXNoKHYqbSl9RS5zb3J0KChOLCQpPT5OLSQpO2NvbnN0IFI9LjI1KkVbTWF0aC5mbG9vcihFLmxlbmd0aC8yKS0oRS5sZW5ndGglMj09MD8xOjApLTFdLHE9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGktaCkvUikpLEk9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGwtdSkvUikpLHo9cSpJLEI9eipmLGM9W10scD1bXSxTPXt9O2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludCxLPXJbTl0ua2V5cG9pbnQse3g6dix5OlYsc2NhbGU6TCxhbmdsZTpDfT14dCh7cXVlcnlwb2ludDokLGtleXBvaW50Okssa2V5Y2VudGVyWDpNLGtleWNlbnRlclk6VCxzY2FsZU9uZU92ZXJMb2dLOnl9KTtpZih2PGh8fHY+PWl8fFY8dXx8Vj49bHx8Qzw9LU1hdGguUEl8fEM+TWF0aC5QSXx8TDxhfHxMPj1qKXtjW05dPSExO2NvbnRpbnVlfWxldCBYPXEqKHYtaCkvKGktaCksd3Q9SSooVi11KS8obC11KSxwdD1mKihDK01hdGguUEkpLygyKk1hdGguUEkpLGR0PWcqKEwtYSkvKGotYSk7cFtOXT17YmluWDpYLGJpblk6d3QsYmluQW5nbGU6cHQsYmluU2NhbGU6ZHR9O2xldCBpdD1NYXRoLmZsb29yKFgtLjUpLGx0PU1hdGguZmxvb3Iod3QtLjUpLGh0PU1hdGguZmxvb3IoZHQtLjUpLGp0PShNYXRoLmZsb29yKHB0LS41KStmKSVmO2lmKGl0PDB8fGl0KzE+PXF8fGx0PDB8fGx0KzE+PUl8fGh0PDB8fGh0KzE+PWcpe2NbTl09ITE7Y29udGludWV9Zm9yKGxldCB1dD0wO3V0PDI7dXQrKyl7bGV0IGt0PWl0K3V0O2ZvcihsZXQgYnQ9MDtidDwyO2J0Kyspe2xldCB1bj1sdCtidDtmb3IobGV0IEl0PTA7SXQ8MjtJdCsrKXtsZXQgY249KGp0K0l0KSVmO2ZvcihsZXQgUnQ9MDtSdDwyO1J0Kyspe2xldCBmbj1odCtSdDtjb25zdCBOdD1rdCt1bipxK2NuKnorZm4qQjtTW050XT09PXZvaWQgMCYmKFNbTnRdPTApLFNbTnRdKz0xfX19fWNbTl09ITB9bGV0IGQ9MCxEPS0xO2lmKE9iamVjdC5rZXlzKFMpLmZvckVhY2goTj0+e1NbTl0+ZCYmKGQ9U1tOXSxEPU4pfSksZDwzKXJldHVybltdO2NvbnN0IFU9TWF0aC5mbG9vcihEJUIleiVxKSxGPU1hdGguZmxvb3IoKEQtVSklQiV6L3EpLFA9TWF0aC5mbG9vcigoRC1VLUYqcSklQi96KSxZPU1hdGguZmxvb3IoKEQtVS1GKnEtUCp6KS9CKSxHPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtpZighY1tOXSljb250aW51ZTtjb25zdCAkPXBbTl07aWYoTWF0aC5hYnMoJC5iaW5YLShVKy41KSk+PWN0fHxNYXRoLmFicygkLmJpblktKEYrLjUpKT49Y3R8fE1hdGguYWJzKCQuYmluU2NhbGUtKFkrLjUpKT49Y3QpY29udGludWU7Y29uc3QgTD1NYXRoLmFicygkLmJpbkFuZ2xlLShQKy41KSk7TWF0aC5taW4oTCxmLUwpPj1jdHx8Ry5wdXNoKHJbTl0pfXJldHVybiBHfSx4dD0oe3F1ZXJ5cG9pbnQ6byxrZXlwb2ludDpuLGtleWNlbnRlclg6ZSxrZXljZW50ZXJZOnQsc2NhbGVPbmVPdmVyTG9nSzpzfSk9PntsZXQgcj1vLmFuZ2xlLW4uYW5nbGU7cjw9LU1hdGguUEk/cis9MipNYXRoLlBJOnI+TWF0aC5QSSYmKHItPTIqTWF0aC5QSSk7Y29uc3QgaT1vLnNjYWxlL24uc2NhbGUsaD1pKk1hdGguY29zKHIpLGw9aSpNYXRoLnNpbihyKSx1PVtoLC1sLGwsaF0sZj1bdVswXSpuLngrdVsxXSpuLnksdVsyXSpuLngrdVszXSpuLnldLGc9by54LWZbMF0sYT1vLnktZlsxXTtyZXR1cm57eDp1WzBdKmUrdVsxXSp0K2cseTp1WzJdKmUrdVszXSp0K2EsYW5nbGU6cixzY2FsZTpNYXRoLmxvZyhpKSpzfX0sQXQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBXKG8pe3JldHVybiBBdC5jYWxsKG8pLmVuZHNXaXRoKCJBcnJheV0iKX1mdW5jdGlvbiB0ZShvKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e307aWYoIVcobykpdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBiZSBhbiBhcnJheSIpO2lmKG8ubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eSIpO3ZhciBlPW4uZnJvbUluZGV4LHQ9ZT09PXZvaWQgMD8wOmUscz1uLnRvSW5kZXgscj1zPT09dm9pZCAwP28ubGVuZ3RoOnM7aWYodDwwfHx0Pj1vLmxlbmd0aHx8IU51bWJlci5pc0ludGVnZXIodCkpdGhyb3cgbmV3IEVycm9yKCJmcm9tSW5kZXggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgc21hbGxlciB0aGFuIGxlbmd0aCIpO2lmKHI8PXR8fHI+by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBFcnJvcigidG9JbmRleCBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIGZyb21JbmRleCBhbmQgYXQgbW9zdCBlcXVhbCB0byBsZW5ndGgiKTtmb3IodmFyIGk9b1t0XSxoPXQrMTtoPHI7aCsrKW9baF0+aSYmKGk9b1toXSk7cmV0dXJuIGl9ZnVuY3Rpb24gZWUobyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9O2lmKCFXKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKTt2YXIgZT1uLmZyb21JbmRleCx0PWU9PT12b2lkIDA/MDplLHM9bi50b0luZGV4LHI9cz09PXZvaWQgMD9vLmxlbmd0aDpzO2lmKHQ8MHx8dD49by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHQpKXRocm93IG5ldyBFcnJvcigiZnJvbUluZGV4IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHNtYWxsZXIgdGhhbiBsZW5ndGgiKTtpZihyPD10fHxyPm8ubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihyKSl0aHJvdyBuZXcgRXJyb3IoInRvSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBmcm9tSW5kZXggYW5kIGF0IG1vc3QgZXF1YWwgdG8gbGVuZ3RoIik7Zm9yKHZhciBpPW9bdF0saD10KzE7aDxyO2grKylvW2hdPGkmJihpPW9baF0pO3JldHVybiBpfWZ1bmN0aW9uIHF0KG8pe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7fTtpZihXKG8pKXtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTt2YXIgZTtpZihuLm91dHB1dCE9PXZvaWQgMCl7aWYoIVcobi5vdXRwdXQpKXRocm93IG5ldyBUeXBlRXJyb3IoIm91dHB1dCBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBpZiBzcGVjaWZpZWQiKTtlPW4ub3V0cHV0fWVsc2UgZT1uZXcgQXJyYXkoby5sZW5ndGgpO3ZhciB0PWVlKG8pLHM9dGUobyk7aWYodD09PXMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbmltdW0gYW5kIG1heGltdW0gaW5wdXQgdmFsdWVzIGFyZSBlcXVhbC4gQ2Fubm90IHJlc2NhbGUgYSBjb25zdGFudCBhcnJheSIpO3ZhciByPW4ubWluLGk9cj09PXZvaWQgMD9uLmF1dG9NaW5NYXg/dDowOnIsaD1uLm1heCxsPWg9PT12b2lkIDA/bi5hdXRvTWluTWF4P3M6MTpoO2lmKGk+PWwpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBvcHRpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IG9wdGlvbiIpO2Zvcih2YXIgdT0obC1pKS8ocy10KSxmPTA7ZjxvLmxlbmd0aDtmKyspZVtmXT0ob1tmXS10KSp1K2k7cmV0dXJuIGV9Y29uc3QgZnQ9IiAiLnJlcGVhdCgyKSxfdD0iICIucmVwZWF0KDQpO2Z1bmN0aW9uIG5lKCl7cmV0dXJuIFR0KHRoaXMpfWZ1bmN0aW9uIFR0KG8sbj17fSl7Y29uc3R7bWF4Um93czplPTE1LG1heENvbHVtbnM6dD0xMCxtYXhOdW1TaXplOnM9OCxwYWRNaW51czpyPSJhdXRvIn09bjtyZXR1cm5gJHtvLmNvbnN0cnVjdG9yLm5hbWV9IHsKJHtmdH1bCiR7X3R9JHtzZShvLGUsdCxzLHIpfQoke2Z0fV0KJHtmdH1yb3dzOiAke28ucm93c30KJHtmdH1jb2x1bW5zOiAke28uY29sdW1uc30KfWB9ZnVuY3Rpb24gc2UobyxuLGUsdCxzKXtjb25zdHtyb3dzOnIsY29sdW1uczppfT1vLGg9TWF0aC5taW4ocixuKSxsPU1hdGgubWluKGksZSksdT1bXTtpZihzPT09ImF1dG8iKXtzPSExO3Q6Zm9yKGxldCBmPTA7ZjxoO2YrKylmb3IobGV0IGc9MDtnPGw7ZysrKWlmKG8uZ2V0KGYsZyk8MCl7cz0hMDticmVhayB0fX1mb3IobGV0IGY9MDtmPGg7ZisrKXtsZXQgZz1bXTtmb3IobGV0IGE9MDthPGw7YSsrKWcucHVzaChvZShvLmdldChmLGEpLHQscykpO3UucHVzaChgJHtnLmpvaW4oIiAiKX1gKX1yZXR1cm4gbCE9PWkmJih1W3UubGVuZ3RoLTFdKz1gIC4uLiAke2ktZX0gbW9yZSBjb2x1bW5zYCksaCE9PXImJnUucHVzaChgLi4uICR7ci1ufSBtb3JlIHJvd3NgKSx1LmpvaW4oYAoke190fWApfWZ1bmN0aW9uIG9lKG8sbixlKXtyZXR1cm4obz49MCYmZT9gICR7enQobyxuLTEpfWA6enQobyxuKSkucGFkRW5kKG4pfWZ1bmN0aW9uIHp0KG8sbil7bGV0IGU9by50b1N0cmluZygpO2lmKGUubGVuZ3RoPD1uKXJldHVybiBlO2xldCB0PW8udG9GaXhlZChuKTtpZih0Lmxlbmd0aD5uJiYodD1vLnRvRml4ZWQoTWF0aC5tYXgoMCxuLSh0Lmxlbmd0aC1uKSkpKSx0Lmxlbmd0aDw9biYmIXQuc3RhcnRzV2l0aCgiMC4wMDAiKSYmIXQuc3RhcnRzV2l0aCgiLTAuMDAwIikpcmV0dXJuIHQ7bGV0IHM9by50b0V4cG9uZW50aWFsKG4pO3JldHVybiBzLmxlbmd0aD5uJiYocz1vLnRvRXhwb25lbnRpYWwoTWF0aC5tYXgoMCxuLShzLmxlbmd0aC1uKSkpKSxzLnNsaWNlKDApfWZ1bmN0aW9uIHJlKG8sbil7by5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5hZGRTKHQpOnRoaXMuYWRkTSh0KX0sby5wcm90b3R5cGUuYWRkUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpK3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5hZGRNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSt0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5hZGQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuYWRkKHMpfSxvLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnN1YlModCk6dGhpcy5zdWJNKHQpfSxvLnByb3RvdHlwZS5zdWJTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciktdCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLnN1Yk09ZnVuY3Rpb24odCl7aWYodD1uLmNoZWNrTWF0cml4KHQpLHRoaXMucm93cyE9PXQucm93c3x8dGhpcy5jb2x1bW5zIT09dC5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwiKTtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpLXQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnN1Yj1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5zdWIocyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PW8ucHJvdG90eXBlLnN1YixvLnByb3RvdHlwZS5zdWJ0cmFjdFM9by5wcm90b3R5cGUuc3ViUyxvLnByb3RvdHlwZS5zdWJ0cmFjdE09by5wcm90b3R5cGUuc3ViTSxvLnN1YnRyYWN0PW8uc3ViLG8ucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMubXVsUyh0KTp0aGlzLm11bE0odCl9LG8ucHJvdG90eXBlLm11bFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSp0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubXVsTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikqdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ubXVsPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLm11bChzKX0sby5wcm90b3R5cGUubXVsdGlwbHk9by5wcm90b3R5cGUubXVsLG8ucHJvdG90eXBlLm11bHRpcGx5Uz1vLnByb3RvdHlwZS5tdWxTLG8ucHJvdG90eXBlLm11bHRpcGx5TT1vLnByb3RvdHlwZS5tdWxNLG8ubXVsdGlwbHk9by5tdWwsby5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5kaXZTKHQpOnRoaXMuZGl2TSh0KX0sby5wcm90b3R5cGUuZGl2Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpL3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5kaXZNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKS90LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5kaXY9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuZGl2KHMpfSxvLnByb3RvdHlwZS5kaXZpZGU9by5wcm90b3R5cGUuZGl2LG8ucHJvdG90eXBlLmRpdmlkZVM9by5wcm90b3R5cGUuZGl2UyxvLnByb3RvdHlwZS5kaXZpZGVNPW8ucHJvdG90eXBlLmRpdk0sby5kaXZpZGU9by5kaXYsby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5tb2RTKHQpOnRoaXMubW9kTSh0KX0sby5wcm90b3R5cGUubW9kUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpJXQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5tb2RNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSV0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5tb2Q9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkubW9kKHMpfSxvLnByb3RvdHlwZS5tb2R1bHVzPW8ucHJvdG90eXBlLm1vZCxvLnByb3RvdHlwZS5tb2R1bHVzUz1vLnByb3RvdHlwZS5tb2RTLG8ucHJvdG90eXBlLm1vZHVsdXNNPW8ucHJvdG90eXBlLm1vZE0sby5tb2R1bHVzPW8ubW9kLG8ucHJvdG90eXBlLmFuZD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMuYW5kUyh0KTp0aGlzLmFuZE0odCl9LG8ucHJvdG90eXBlLmFuZFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSZ0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUuYW5kTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikmdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8uYW5kPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLmFuZChzKX0sby5wcm90b3R5cGUub3I9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLm9yUyh0KTp0aGlzLm9yTSh0KX0sby5wcm90b3R5cGUub3JTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLm9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ub3I9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkub3Iocyl9LG8ucHJvdG90eXBlLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMueG9yUyh0KTp0aGlzLnhvck0odCl9LG8ucHJvdG90eXBlLnhvclM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKV50KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUueG9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciledC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ueG9yPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnhvcihzKX0sby5wcm90b3R5cGUubGVmdFNoaWZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5sZWZ0U2hpZnRTKHQpOnRoaXMubGVmdFNoaWZ0TSh0KX0sby5wcm90b3R5cGUubGVmdFNoaWZ0Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpPDx0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubGVmdFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik8PHQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLmxlZnRTaGlmdD1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5sZWZ0U2hpZnQocyl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTKHQpOnRoaXMuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdE0odCl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdChzKX0sby5wcm90b3R5cGUucmlnaHRTaGlmdD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMucmlnaHRTaGlmdFModCk6dGhpcy5yaWdodFNoaWZ0TSh0KX0sby5wcm90b3R5cGUucmlnaHRTaGlmdFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKT4+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5yaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+Pj50LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5yaWdodFNoaWZ0PWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnJpZ2h0U2hpZnQocyl9LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdD1vLnByb3RvdHlwZS5yaWdodFNoaWZ0LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdFM9by5wcm90b3R5cGUucmlnaHRTaGlmdFMsby5wcm90b3R5cGUuemVyb0ZpbGxSaWdodFNoaWZ0TT1vLnByb3RvdHlwZS5yaWdodFNoaWZ0TSxvLnplcm9GaWxsUmlnaHRTaGlmdD1vLnJpZ2h0U2hpZnQsby5wcm90b3R5cGUubm90PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsfnRoaXMuZ2V0KHQscykpO3JldHVybiB0aGlzfSxvLm5vdD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubm90KCl9LG8ucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYWJzKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hYnM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFicygpfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hY29zPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hY29zKCl9LG8ucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zaCh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYWNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFjb3NoKCl9LG8ucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmFzaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFzaW4oKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hc2luaD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXNpbmgoKX0sby5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYXRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXRhbigpfSxvLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmF0YW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hdGFuaCgpfSxvLnByb3RvdHlwZS5jYnJ0PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jYnJ0KHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jYnJ0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5jYnJ0KCl9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNlaWwodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNlaWw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNlaWwoKX0sby5wcm90b3R5cGUuY2x6MzI9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNsejMyKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jbHozMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY2x6MzIoKX0sby5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jb3ModGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvcz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY29zKCl9LG8ucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNvc2godGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNvc2goKX0sby5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHAodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmV4cD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuZXhwKCl9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHBtMSh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZXhwbTE9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmV4cG0xKCl9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5mbG9vcih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZmxvb3I9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZsb29yKCl9LG8ucHJvdG90eXBlLmZyb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguZnJvdW5kKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5mcm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZyb3VuZCgpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZyh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5sb2coKX0sby5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzFwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxcD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMXAoKX0sby5wcm90b3R5cGUubG9nMTA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzEwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxMD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMTAoKX0sby5wcm90b3R5cGUubG9nMj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgubG9nMih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMigpfSxvLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgucm91bmQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnJvdW5kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5yb3VuZCgpfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaWduKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaWduPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaWduKCl9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguc2luKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNpbigpfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaW5oKCl9LG8ucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnNxcnQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNxcnQoKX0sby5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC50YW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudGFuKCl9LG8ucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnRhbmgoKX0sby5wcm90b3R5cGUudHJ1bmM9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRydW5jKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby50cnVuYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudHJ1bmMoKX0sby5wb3c9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkucG93KHMpfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnBvd1ModCk6dGhpcy5wb3dNKHQpfSxvLnByb3RvdHlwZS5wb3dTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLE1hdGgucG93KHRoaXMuZ2V0KHMsciksdCkpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5wb3dNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsTWF0aC5wb3codGhpcy5nZXQocyxyKSx0LmdldChzLHIpKSk7cmV0dXJuIHRoaXN9fWZ1bmN0aW9uIFEobyxuLGUpe2xldCB0PWU/by5yb3dzOm8ucm93cy0xO2lmKG48MHx8bj50KXRocm93IG5ldyBSYW5nZUVycm9yKCJSb3cgaW5kZXggb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gWihvLG4sZSl7bGV0IHQ9ZT9vLmNvbHVtbnM6by5jb2x1bW5zLTE7aWYobjwwfHxuPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkNvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiB0dChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8uY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMiKTtyZXR1cm4gbn1mdW5jdGlvbiBldChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIHJvd3MiKTtyZXR1cm4gbn1mdW5jdGlvbiBpZShvLG4pe2lmKCFXKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoInJvdyBpbmRpY2VzIG11c3QgYmUgYW4gYXJyYXkiKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylpZihuW2VdPDB8fG5bZV0+PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigicm93IGluZGljZXMgYXJlIG91dCBvZiByYW5nZSIpfWZ1bmN0aW9uIGxlKG8sbil7aWYoIVcobikpdGhyb3cgbmV3IFR5cGVFcnJvcigiY29sdW1uIGluZGljZXMgbXVzdCBiZSBhbiBhcnJheSIpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKWlmKG5bZV08MHx8bltlXT49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJjb2x1bW4gaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gRnQobyxuLGUsdCxzKXtpZihhcmd1bWVudHMubGVuZ3RoIT09NSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiZXhwZWN0ZWQgNCBhcmd1bWVudHMiKTtpZihhdCgic3RhcnRSb3ciLG4pLGF0KCJlbmRSb3ciLGUpLGF0KCJzdGFydENvbHVtbiIsdCksYXQoImVuZENvbHVtbiIscyksbj5lfHx0PnN8fG48MHx8bj49by5yb3dzfHxlPDB8fGU+PW8ucm93c3x8dDwwfHx0Pj1vLmNvbHVtbnN8fHM8MHx8cz49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJTdWJtYXRyaXggaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gZ3QobyxuPTApe2xldCBlPVtdO2ZvcihsZXQgdD0wO3Q8bzt0KyspZS5wdXNoKG4pO3JldHVybiBlfWZ1bmN0aW9uIGF0KG8sbil7aWYodHlwZW9mIG4hPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gbXVzdCBiZSBhIG51bWJlcmApfWZ1bmN0aW9uIG50KG8pe2lmKG8uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiRW1wdHkgbWF0cml4IGhhcyBubyBlbGVtZW50cyB0byBpbmRleCIpfWZ1bmN0aW9uIGhlKG8pe2xldCBuPWd0KG8ucm93cyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW2VdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIHVlKG8pe2xldCBuPWd0KG8uY29sdW1ucyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW3RdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGNlKG8pe2xldCBuPTA7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKyluKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGZlKG8pe2xldCBuPWd0KG8ucm93cywxKTtmb3IobGV0IGU9MDtlPG8ucm93czsrK2UpZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7Kyt0KW5bZV0qPW8uZ2V0KGUsdCk7cmV0dXJuIG59ZnVuY3Rpb24gZ2Uobyl7bGV0IG49Z3Qoby5jb2x1bW5zLDEpO2ZvcihsZXQgZT0wO2U8by5yb3dzOysrZSlmb3IobGV0IHQ9MDt0PG8uY29sdW1uczsrK3Qpblt0XSo9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBhZShvKXtsZXQgbj0xO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspbio9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBtZShvLG4sZSl7Y29uc3QgdD1vLnJvd3Mscz1vLmNvbHVtbnMscj1bXTtmb3IobGV0IGk9MDtpPHQ7aSsrKXtsZXQgaD0wLGw9MCx1PTA7Zm9yKGxldCBmPTA7ZjxzO2YrKyl1PW8uZ2V0KGksZiktZVtpXSxoKz11LGwrPXUqdTtuP3IucHVzaCgobC1oKmgvcykvKHMtMSkpOnIucHVzaCgobC1oKmgvcykvcyl9cmV0dXJuIHJ9ZnVuY3Rpb24gd2UobyxuLGUpe2NvbnN0IHQ9by5yb3dzLHM9by5jb2x1bW5zLHI9W107Zm9yKGxldCBpPTA7aTxzO2krKyl7bGV0IGg9MCxsPTAsdT0wO2ZvcihsZXQgZj0wO2Y8dDtmKyspdT1vLmdldChmLGkpLWVbaV0saCs9dSxsKz11KnU7bj9yLnB1c2goKGwtaCpoL3QpLyh0LTEpKTpyLnB1c2goKGwtaCpoL3QpL3QpfXJldHVybiByfWZ1bmN0aW9uIHBlKG8sbixlKXtjb25zdCB0PW8ucm93cyxzPW8uY29sdW1ucyxyPXQqcztsZXQgaT0wLGg9MCxsPTA7Zm9yKGxldCB1PTA7dTx0O3UrKylmb3IobGV0IGY9MDtmPHM7ZisrKWw9by5nZXQodSxmKS1lLGkrPWwsaCs9bCpsO3JldHVybiBuPyhoLWkqaS9yKS8oci0xKTooaC1pKmkvcikvcn1mdW5jdGlvbiBkZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCktbltlXSl9ZnVuY3Rpb24geWUobyxuKXtmb3IobGV0IGU9MDtlPG8ucm93cztlKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKW8uc2V0KGUsdCxvLmdldChlLHQpLW5bdF0pfWZ1bmN0aW9uIE1lKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS1uKX1mdW5jdGlvbiBFZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8uY29sdW1ucztzKyspdCs9TWF0aC5wb3coby5nZXQoZSxzKSwyKS8oby5jb2x1bW5zLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIFNlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW2VdKX1mdW5jdGlvbiBqZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5jb2x1bW5zO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8ucm93cztzKyspdCs9TWF0aC5wb3coby5nZXQocyxlKSwyKS8oby5yb3dzLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIGtlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW3RdKX1mdW5jdGlvbiBiZShvKXtjb25zdCBuPW8uc2l6ZS0xO2xldCBlPTA7Zm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKWZvcihsZXQgcz0wO3M8by5yb3dzO3MrKyllKz1NYXRoLnBvdyhvLmdldChzLHQpLDIpL247cmV0dXJuIE1hdGguc3FydChlKX1mdW5jdGlvbiBJZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCkvbil9Y2xhc3MgX3tzdGF0aWMgZnJvbTFEQXJyYXkobixlLHQpe2lmKG4qZSE9PXQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJkYXRhIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBnaXZlbiBkaW1lbnNpb25zIik7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHRbaSplK2hdKTtyZXR1cm4gcn1zdGF0aWMgcm93VmVjdG9yKG4pe2xldCBlPW5ldyBiKDEsbi5sZW5ndGgpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KDAsdCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgY29sdW1uVmVjdG9yKG4pe2xldCBlPW5ldyBiKG4ubGVuZ3RoLDEpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KHQsMCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgemVyb3MobixlKXtyZXR1cm4gbmV3IGIobixlKX1zdGF0aWMgb25lcyhuLGUpe3JldHVybiBuZXcgYihuLGUpLmZpbGwoMSl9c3RhdGljIHJhbmQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7cmFuZG9tOnM9TWF0aC5yYW5kb219PXQ7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHMoKSk7cmV0dXJuIHJ9c3RhdGljIHJhbmRJbnQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7bWluOnM9MCxtYXg6cj0xZTMscmFuZG9tOmk9TWF0aC5yYW5kb219PXQ7aWYoIU51bWJlci5pc0ludGVnZXIocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWluIG11c3QgYmUgYW4gaW50ZWdlciIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1heCBtdXN0IGJlIGFuIGludGVnZXIiKTtpZihzPj1yKXRocm93IG5ldyBSYW5nZUVycm9yKCJtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Iik7bGV0IGg9ci1zLGw9bmV3IGIobixlKTtmb3IobGV0IHU9MDt1PG47dSsrKWZvcihsZXQgZj0wO2Y8ZTtmKyspe2xldCBnPXMrTWF0aC5yb3VuZChpKCkqaCk7bC5zZXQodSxmLGcpfXJldHVybiBsfXN0YXRpYyBleWUobixlLHQpe2U9PT12b2lkIDAmJihlPW4pLHQ9PT12b2lkIDAmJih0PTEpO2xldCBzPU1hdGgubWluKG4sZSkscj10aGlzLnplcm9zKG4sZSk7Zm9yKGxldCBpPTA7aTxzO2krKylyLnNldChpLGksdCk7cmV0dXJuIHJ9c3RhdGljIGRpYWcobixlLHQpe2xldCBzPW4ubGVuZ3RoO2U9PT12b2lkIDAmJihlPXMpLHQ9PT12b2lkIDAmJih0PWUpO2xldCByPU1hdGgubWluKHMsZSx0KSxpPXRoaXMuemVyb3MoZSx0KTtmb3IobGV0IGg9MDtoPHI7aCsrKWkuc2V0KGgsaCxuW2hdKTtyZXR1cm4gaX1zdGF0aWMgbWluKG4sZSl7bj10aGlzLmNoZWNrTWF0cml4KG4pLGU9dGhpcy5jaGVja01hdHJpeChlKTtsZXQgdD1uLnJvd3Mscz1uLmNvbHVtbnMscj1uZXcgYih0LHMpO2ZvcihsZXQgaT0wO2k8dDtpKyspZm9yKGxldCBoPTA7aDxzO2grKylyLnNldChpLGgsTWF0aC5taW4obi5nZXQoaSxoKSxlLmdldChpLGgpKSk7cmV0dXJuIHJ9c3RhdGljIG1heChuLGUpe249dGhpcy5jaGVja01hdHJpeChuKSxlPXRoaXMuY2hlY2tNYXRyaXgoZSk7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IHRoaXModCxzKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgaD0wO2g8cztoKyspci5zZXQoaSxoLE1hdGgubWF4KG4uZ2V0KGksaCksZS5nZXQoaSxoKSkpO3JldHVybiByfXN0YXRpYyBjaGVja01hdHJpeChuKXtyZXR1cm4gXy5pc01hdHJpeChuKT9uOm5ldyBiKG4pfXN0YXRpYyBpc01hdHJpeChuKXtyZXR1cm4gbiE9bnVsbCYmbi5rbGFzcz09PSJNYXRyaXgifWdldCBzaXplKCl7cmV0dXJuIHRoaXMucm93cyp0aGlzLmNvbHVtbnN9YXBwbHkobil7aWYodHlwZW9mIG4hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyluLmNhbGwodGhpcyxlLHQpO3JldHVybiB0aGlzfXRvMURBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5wdXNoKHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXRvMkRBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKyl7bi5wdXNoKFtdKTtmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspbltlXS5wdXNoKHRoaXMuZ2V0KGUsdCkpfXJldHVybiBufXRvSlNPTigpe3JldHVybiB0aGlzLnRvMkRBcnJheSgpfWlzUm93VmVjdG9yKCl7cmV0dXJuIHRoaXMucm93cz09PTF9aXNDb2x1bW5WZWN0b3IoKXtyZXR1cm4gdGhpcy5jb2x1bW5zPT09MX1pc1ZlY3Rvcigpe3JldHVybiB0aGlzLnJvd3M9PT0xfHx0aGlzLmNvbHVtbnM9PT0xfWlzU3F1YXJlKCl7cmV0dXJuIHRoaXMucm93cz09PXRoaXMuY29sdW1uc31pc0VtcHR5KCl7cmV0dXJuIHRoaXMucm93cz09PTB8fHRoaXMuY29sdW1ucz09PTB9aXNTeW1tZXRyaWMoKXtpZih0aGlzLmlzU3F1YXJlKCkpe2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IGU9MDtlPD1uO2UrKylpZih0aGlzLmdldChuLGUpIT09dGhpcy5nZXQoZSxuKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX1pc0VjaGVsb25Gb3JtKCl7bGV0IG49MCxlPTAsdD0tMSxzPSEwLHI9ITE7Zm9yKDtuPHRoaXMucm93cyYmczspe2ZvcihlPTAscj0hMTtlPHRoaXMuY29sdW1ucyYmcj09PSExOyl0aGlzLmdldChuLGUpPT09MD9lKys6dGhpcy5nZXQobixlKT09PTEmJmU+dD8ocj0hMCx0PWUpOihzPSExLHI9ITApO24rK31yZXR1cm4gc31pc1JlZHVjZWRFY2hlbG9uRm9ybSgpe2xldCBuPTAsZT0wLHQ9LTEscz0hMCxyPSExO2Zvcig7bjx0aGlzLnJvd3MmJnM7KXtmb3IoZT0wLHI9ITE7ZTx0aGlzLmNvbHVtbnMmJnI9PT0hMTspdGhpcy5nZXQobixlKT09PTA/ZSsrOnRoaXMuZ2V0KG4sZSk9PT0xJiZlPnQ/KHI9ITAsdD1lKToocz0hMSxyPSEwKTtmb3IobGV0IGk9ZSsxO2k8dGhpcy5yb3dzO2krKyl0aGlzLmdldChuLGkpIT09MCYmKHM9ITEpO24rK31yZXR1cm4gc31lY2hlbG9uRm9ybSgpe2xldCBuPXRoaXMuY2xvbmUoKSxlPTAsdD0wO2Zvcig7ZTxuLnJvd3MmJnQ8bi5jb2x1bW5zOyl7bGV0IHM9ZTtmb3IobGV0IHI9ZTtyPG4ucm93cztyKyspbi5nZXQocix0KT5uLmdldChzLHQpJiYocz1yKTtpZihuLmdldChzLHQpPT09MCl0Kys7ZWxzZXtuLnN3YXBSb3dzKGUscyk7bGV0IHI9bi5nZXQoZSx0KTtmb3IobGV0IGk9dDtpPG4uY29sdW1ucztpKyspbi5zZXQoZSxpLG4uZ2V0KGUsaSkvcik7Zm9yKGxldCBpPWUrMTtpPG4ucm93cztpKyspe2xldCBoPW4uZ2V0KGksdCkvbi5nZXQoZSx0KTtuLnNldChpLHQsMCk7Zm9yKGxldCBsPXQrMTtsPG4uY29sdW1ucztsKyspbi5zZXQoaSxsLG4uZ2V0KGksbCktbi5nZXQoZSxsKSpoKX1lKyssdCsrfX1yZXR1cm4gbn1yZWR1Y2VkRWNoZWxvbkZvcm0oKXtsZXQgbj10aGlzLmVjaGVsb25Gb3JtKCksZT1uLmNvbHVtbnMsdD1uLnJvd3Mscz10LTE7Zm9yKDtzPj0wOylpZihuLm1heFJvdyhzKT09PTApcy0tO2Vsc2V7bGV0IHI9MCxpPSExO2Zvcig7cjx0JiZpPT09ITE7KW4uZ2V0KHMscik9PT0xP2k9ITA6cisrO2ZvcihsZXQgaD0wO2g8cztoKyspe2xldCBsPW4uZ2V0KGgscik7Zm9yKGxldCB1PXI7dTxlO3UrKyl7bGV0IGY9bi5nZXQoaCx1KS1sKm4uZ2V0KHMsdSk7bi5zZXQoaCx1LGYpfX1zLS19cmV0dXJuIG59c2V0KCl7dGhyb3cgbmV3IEVycm9yKCJzZXQgbWV0aG9kIGlzIHVuaW1wbGVtZW50ZWQiKX1nZXQoKXt0aHJvdyBuZXcgRXJyb3IoImdldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCIpfXJlcGVhdChuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e3Jvd3M6ZT0xLGNvbHVtbnM6dD0xfT1uO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGUpfHxlPD0wKXRocm93IG5ldyBUeXBlRXJyb3IoInJvd3MgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIiKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KXx8dDw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJjb2x1bW5zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIik7bGV0IHM9bmV3IGIodGhpcy5yb3dzKmUsdGhpcy5jb2x1bW5zKnQpO2ZvcihsZXQgcj0wO3I8ZTtyKyspZm9yKGxldCBpPTA7aTx0O2krKylzLnNldFN1Yk1hdHJpeCh0aGlzLHRoaXMucm93cypyLHRoaXMuY29sdW1ucyppKTtyZXR1cm4gc31maWxsKG4pe2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LG4pO3JldHVybiB0aGlzfW5lZygpe3JldHVybiB0aGlzLm11bFMoLTEpfWdldFJvdyhuKXtRKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKWUucHVzaCh0aGlzLmdldChuLHQpKTtyZXR1cm4gZX1nZXRSb3dWZWN0b3Iobil7cmV0dXJuIGIucm93VmVjdG9yKHRoaXMuZ2V0Um93KG4pKX1zZXRSb3cobixlKXtRKHRoaXMsbiksZT10dCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsZVt0XSk7cmV0dXJuIHRoaXN9c3dhcFJvd3MobixlKXtRKHRoaXMsbiksUSh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl7bGV0IHM9dGhpcy5nZXQobix0KTt0aGlzLnNldChuLHQsdGhpcy5nZXQoZSx0KSksdGhpcy5zZXQoZSx0LHMpfXJldHVybiB0aGlzfWdldENvbHVtbihuKXtaKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWUucHVzaCh0aGlzLmdldCh0LG4pKTtyZXR1cm4gZX1nZXRDb2x1bW5WZWN0b3Iobil7cmV0dXJuIGIuY29sdW1uVmVjdG9yKHRoaXMuZ2V0Q29sdW1uKG4pKX1zZXRDb2x1bW4obixlKXtaKHRoaXMsbiksZT1ldCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLnNldCh0LG4sZVt0XSk7cmV0dXJuIHRoaXN9c3dhcENvbHVtbnMobixlKXtaKHRoaXMsbiksWih0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxuKTt0aGlzLnNldCh0LG4sdGhpcy5nZXQodCxlKSksdGhpcy5zZXQodCxlLHMpfXJldHVybiB0aGlzfWFkZFJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KStuW3RdKTtyZXR1cm4gdGhpc31zdWJSb3dWZWN0b3Iobil7bj10dCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCktblt0XSk7cmV0dXJuIHRoaXN9bXVsUm93VmVjdG9yKG4pe249dHQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpKm5bdF0pO3JldHVybiB0aGlzfWRpdlJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KS9uW3RdKTtyZXR1cm4gdGhpc31hZGRDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkrbltlXSk7cmV0dXJuIHRoaXN9c3ViQ29sdW1uVmVjdG9yKG4pe249ZXQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpLW5bZV0pO3JldHVybiB0aGlzfW11bENvbHVtblZlY3RvcihuKXtuPWV0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KSpuW2VdKTtyZXR1cm4gdGhpc31kaXZDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkvbltlXSk7cmV0dXJuIHRoaXN9bXVsUm93KG4sZSl7USh0aGlzLG4pO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KSplKTtyZXR1cm4gdGhpc31tdWxDb2x1bW4obixlKXtaKHRoaXMsbik7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXRoaXMuc2V0KHQsbix0aGlzLmdldCh0LG4pKmUpO3JldHVybiB0aGlzfW1heChuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk+ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1heEluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5uJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1pbihuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk8ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1pbkluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxuJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1heFJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPmUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1heFJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk+ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1pblJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPGUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1pblJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk8ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1heENvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPmUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1heENvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik+ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fW1pbkNvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPGUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1pbkNvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik8ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fWRpYWcoKXtsZXQgbj1NYXRoLm1pbih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKSxlPVtdO2ZvcihsZXQgdD0wO3Q8bjt0KyspZS5wdXNoKHRoaXMuZ2V0KHQsdCkpO3JldHVybiBlfW5vcm0obj0iZnJvYmVuaXVzIil7bGV0IGU9MDtpZihuPT09Im1heCIpcmV0dXJuIHRoaXMubWF4KCk7aWYobj09PSJmcm9iZW5pdXMiKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKWU9ZSt0aGlzLmdldCh0LHMpKnRoaXMuZ2V0KHQscyk7cmV0dXJuIE1hdGguc3FydChlKX1lbHNlIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bmtub3duIG5vcm0gdHlwZTogJHtufWApfWN1bXVsYXRpdmVTdW0oKXtsZXQgbj0wO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbis9dGhpcy5nZXQoZSx0KSx0aGlzLnNldChlLHQsbik7cmV0dXJuIHRoaXN9ZG90KG4pe18uaXNNYXRyaXgobikmJihuPW4udG8xREFycmF5KCkpO2xldCBlPXRoaXMudG8xREFycmF5KCk7aWYoZS5sZW5ndGghPT1uLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9ycyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBzaXplIik7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl0Kz1lW3NdKm5bc107cmV0dXJuIHR9bW11bChuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5yb3dzLHQ9dGhpcy5jb2x1bW5zLHM9bi5jb2x1bW5zLHI9bmV3IGIoZSxzKSxpPW5ldyBGbG9hdDY0QXJyYXkodCk7Zm9yKGxldCBoPTA7aDxzO2grKyl7Zm9yKGxldCBsPTA7bDx0O2wrKylpW2xdPW4uZ2V0KGwsaCk7Zm9yKGxldCBsPTA7bDxlO2wrKyl7bGV0IHU9MDtmb3IobGV0IGY9MDtmPHQ7ZisrKXUrPXRoaXMuZ2V0KGwsZikqaVtmXTtyLnNldChsLGgsdSl9fXJldHVybiByfXN0cmFzc2VuMngyKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigyLDIpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPW4uZ2V0KDAsMCkscj10aGlzLmdldCgwLDEpLGk9bi5nZXQoMCwxKSxoPXRoaXMuZ2V0KDEsMCksbD1uLmdldCgxLDApLHU9dGhpcy5nZXQoMSwxKSxmPW4uZ2V0KDEsMSksZz0odCt1KSoocytmKSxhPShoK3UpKnMsaj10KihpLWYpLHc9dSoobC1zKSx5PSh0K3IpKmYsbT0oaC10KSoocytpKSxNPShyLXUpKihsK2YpLFQ9Zyt3LXkrTSxFPWoreSxrPWErdyxSPWctYStqK207cmV0dXJuIGUuc2V0KDAsMCxUKSxlLnNldCgwLDEsRSksZS5zZXQoMSwwLGspLGUuc2V0KDEsMSxSKSxlfXN0cmFzc2VuM3gzKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigzLDMpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPXRoaXMuZ2V0KDAsMSkscj10aGlzLmdldCgwLDIpLGk9dGhpcy5nZXQoMSwwKSxoPXRoaXMuZ2V0KDEsMSksbD10aGlzLmdldCgxLDIpLHU9dGhpcy5nZXQoMiwwKSxmPXRoaXMuZ2V0KDIsMSksZz10aGlzLmdldCgyLDIpLGE9bi5nZXQoMCwwKSxqPW4uZ2V0KDAsMSksdz1uLmdldCgwLDIpLHk9bi5nZXQoMSwwKSxtPW4uZ2V0KDEsMSksTT1uLmdldCgxLDIpLFQ9bi5nZXQoMiwwKSxFPW4uZ2V0KDIsMSksaz1uLmdldCgyLDIpLFI9KHQrcytyLWktaC1mLWcpKm0scT0odC1pKSooLWorbSksST1oKigtYStqK3ktbS1NLVQrayksej0oLXQraStoKSooYS1qK20pLEI9KGkraCkqKC1hK2opLGM9dCphLHA9KC10K3UrZikqKGEtdytNKSxTPSgtdCt1KSoody1NKSxkPSh1K2YpKigtYSt3KSxEPSh0K3Mrci1oLWwtdS1mKSpNLFU9ZiooLWErdyt5LW0tTS1UK0UpLEY9KC1yK2YrZykqKG0rVC1FKSxQPShyLWcpKihtLUUpLFk9cipULEc9KGYrZykqKC1UK0UpLE49KC1yK2grbCkqKE0rVC1rKSwkPShyLWwpKihNLWspLEs9KGgrbCkqKC1UK2spLHY9cyp5LFY9bCpFLEw9aSp3LEM9dSpqLFg9ZyprLHd0PWMrWSt2LHB0PVIreitCK2MrRitZK0csZHQ9YytwK2QrRCtZK04rSyxpdD1xK0kreitjK1krTiskLGx0PXEreitCK2MrVixodD1ZK04rJCtLK0wsanQ9YytwK1MrVStGK1ArWSx1dD1GK1ArWStHK0Msa3Q9YytwK1MrZCtYO3JldHVybiBlLnNldCgwLDAsd3QpLGUuc2V0KDAsMSxwdCksZS5zZXQoMCwyLGR0KSxlLnNldCgxLDAsaXQpLGUuc2V0KDEsMSxsdCksZS5zZXQoMSwyLGh0KSxlLnNldCgyLDAsanQpLGUuc2V0KDIsMSx1dCksZS5zZXQoMiwyLGt0KSxlfW1tdWxTdHJhc3NlbihuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5jbG9uZSgpLHQ9ZS5yb3dzLHM9ZS5jb2x1bW5zLHI9bi5yb3dzLGk9bi5jb2x1bW5zO3MhPT1yJiZjb25zb2xlLndhcm4oYE11bHRpcGx5aW5nICR7dH0geCAke3N9IGFuZCAke3J9IHggJHtpfSBtYXRyaXg6IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoLmApO2Z1bmN0aW9uIGgoZyxhLGope2xldCB3PWcucm93cyx5PWcuY29sdW1ucztpZih3PT09YSYmeT09PWopcmV0dXJuIGc7e2xldCBtPV8uemVyb3MoYSxqKTtyZXR1cm4gbT1tLnNldFN1Yk1hdHJpeChnLDAsMCksbX19bGV0IGw9TWF0aC5tYXgodCxyKSx1PU1hdGgubWF4KHMsaSk7ZT1oKGUsbCx1KSxuPWgobixsLHUpO2Z1bmN0aW9uIGYoZyxhLGosdyl7aWYoajw9NTEyfHx3PD01MTIpcmV0dXJuIGcubW11bChhKTtqJTI9PT0xJiZ3JTI9PT0xPyhnPWgoZyxqKzEsdysxKSxhPWgoYSxqKzEsdysxKSk6aiUyPT09MT8oZz1oKGcsaisxLHcpLGE9aChhLGorMSx3KSk6dyUyPT09MSYmKGc9aChnLGosdysxKSxhPWgoYSxqLHcrMSkpO2xldCB5PXBhcnNlSW50KGcucm93cy8yLDEwKSxtPXBhcnNlSW50KGcuY29sdW1ucy8yLDEwKSxNPWcuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxUPWEuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxFPWcuc3ViTWF0cml4KDAseS0xLG0sZy5jb2x1bW5zLTEpLGs9YS5zdWJNYXRyaXgoMCx5LTEsbSxhLmNvbHVtbnMtMSksUj1nLnN1Yk1hdHJpeCh5LGcucm93cy0xLDAsbS0xKSxxPWEuc3ViTWF0cml4KHksYS5yb3dzLTEsMCxtLTEpLEk9Zy5zdWJNYXRyaXgoeSxnLnJvd3MtMSxtLGcuY29sdW1ucy0xKSx6PWEuc3ViTWF0cml4KHksYS5yb3dzLTEsbSxhLmNvbHVtbnMtMSksQj1mKF8uYWRkKE0sSSksXy5hZGQoVCx6KSx5LG0pLGM9ZihfLmFkZChSLEkpLFQseSxtKSxwPWYoTSxfLnN1YihrLHopLHksbSksUz1mKEksXy5zdWIocSxUKSx5LG0pLGQ9ZihfLmFkZChNLEUpLHoseSxtKSxEPWYoXy5zdWIoUixNKSxfLmFkZChULGspLHksbSksVT1mKF8uc3ViKEUsSSksXy5hZGQocSx6KSx5LG0pLEY9Xy5hZGQoQixTKTtGLnN1YihkKSxGLmFkZChVKTtsZXQgUD1fLmFkZChwLGQpLFk9Xy5hZGQoYyxTKSxHPV8uc3ViKEIsYyk7Ry5hZGQocCksRy5hZGQoRCk7bGV0IE49Xy56ZXJvcygyKkYucm93cywyKkYuY29sdW1ucyk7cmV0dXJuIE49Ti5zZXRTdWJNYXRyaXgoRiwwLDApLE49Ti5zZXRTdWJNYXRyaXgoUCxGLnJvd3MsMCksTj1OLnNldFN1Yk1hdHJpeChZLDAsRi5jb2x1bW5zKSxOPU4uc2V0U3ViTWF0cml4KEcsRi5yb3dzLEYuY29sdW1ucyksTi5zdWJNYXRyaXgoMCxqLTEsMCx3LTEpfXJldHVybiBmKGUsbixsLHUpfXNjYWxlUm93cyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMucm93cztyKyspe2NvbnN0IGk9dGhpcy5nZXRSb3cocik7aS5sZW5ndGg+MCYmcXQoaSx7bWluOmUsbWF4OnQsb3V0cHV0Oml9KSxzLnNldFJvdyhyLGkpfXJldHVybiBzfXNjYWxlQ29sdW1ucyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspe2NvbnN0IGk9dGhpcy5nZXRDb2x1bW4ocik7aS5sZW5ndGgmJnF0KGkse21pbjplLG1heDp0LG91dHB1dDppfSkscy5zZXRDb2x1bW4ocixpKX1yZXR1cm4gc31mbGlwUm93cygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMuY29sdW1ucy8yKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQoZSx0KSxyPXRoaXMuZ2V0KGUsdGhpcy5jb2x1bW5zLTEtdCk7dGhpcy5zZXQoZSx0LHIpLHRoaXMuc2V0KGUsdGhpcy5jb2x1bW5zLTEtdCxzKX1yZXR1cm4gdGhpc31mbGlwQ29sdW1ucygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMucm93cy8yKTtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxlKSxyPXRoaXMuZ2V0KHRoaXMucm93cy0xLXQsZSk7dGhpcy5zZXQodCxlLHIpLHRoaXMuc2V0KHRoaXMucm93cy0xLXQsZSxzKX1yZXR1cm4gdGhpc31rcm9uZWNrZXJQcm9kdWN0KG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT10aGlzLnJvd3MsdD10aGlzLmNvbHVtbnMscz1uLnJvd3Mscj1uLmNvbHVtbnMsaT1uZXcgYihlKnMsdCpyKTtmb3IobGV0IGg9MDtoPGU7aCsrKWZvcihsZXQgbD0wO2w8dDtsKyspZm9yKGxldCB1PTA7dTxzO3UrKylmb3IobGV0IGY9MDtmPHI7ZisrKWkuc2V0KHMqaCt1LHIqbCtmLHRoaXMuZ2V0KGgsbCkqbi5nZXQodSxmKSk7cmV0dXJuIGl9a3JvbmVja2VyU3VtKG4pe2lmKG49Yi5jaGVja01hdHJpeChuKSwhdGhpcy5pc1NxdWFyZSgpfHwhbi5pc1NxdWFyZSgpKXRocm93IG5ldyBFcnJvcigiS3JvbmVja2VyIFN1bSBuZWVkcyB0d28gU3F1YXJlIE1hdHJpY2VzIik7bGV0IGU9dGhpcy5yb3dzLHQ9bi5yb3dzLHM9dGhpcy5rcm9uZWNrZXJQcm9kdWN0KGIuZXllKHQsdCkpLHI9Yi5leWUoZSxlKS5rcm9uZWNrZXJQcm9kdWN0KG4pO3JldHVybiBzLmFkZChyKX10cmFuc3Bvc2UoKXtsZXQgbj1uZXcgYih0aGlzLmNvbHVtbnMsdGhpcy5yb3dzKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKW4uc2V0KHQsZSx0aGlzLmdldChlLHQpKTtyZXR1cm4gbn1zb3J0Um93cyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspdGhpcy5zZXRSb3coZSx0aGlzLmdldFJvdyhlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zb3J0Q29sdW1ucyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspdGhpcy5zZXRDb2x1bW4oZSx0aGlzLmdldENvbHVtbihlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zdWJNYXRyaXgobixlLHQscyl7RnQodGhpcyxuLGUsdCxzKTtsZXQgcj1uZXcgYihlLW4rMSxzLXQrMSk7Zm9yKGxldCBpPW47aTw9ZTtpKyspZm9yKGxldCBoPXQ7aDw9cztoKyspci5zZXQoaS1uLGgtdCx0aGlzLmdldChpLGgpKTtyZXR1cm4gcn1zdWJNYXRyaXhSb3cobixlLHQpe2lmKGU9PT12b2lkIDAmJihlPTApLHQ9PT12b2lkIDAmJih0PXRoaXMuY29sdW1ucy0xKSxlPnR8fGU8MHx8ZT49dGhpcy5jb2x1bW5zfHx0PDB8fHQ+PXRoaXMuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXJndW1lbnQgb3V0IG9mIHJhbmdlIik7bGV0IHM9bmV3IGIobi5sZW5ndGgsdC1lKzEpO2ZvcihsZXQgcj0wO3I8bi5sZW5ndGg7cisrKWZvcihsZXQgaT1lO2k8PXQ7aSsrKXtpZihuW3JdPDB8fG5bcl0+PXRoaXMucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUm93IGluZGV4IG91dCBvZiByYW5nZTogJHtuW3JdfWApO3Muc2V0KHIsaS1lLHRoaXMuZ2V0KG5bcl0saSkpfXJldHVybiBzfXN1Yk1hdHJpeENvbHVtbihuLGUsdCl7aWYoZT09PXZvaWQgMCYmKGU9MCksdD09PXZvaWQgMCYmKHQ9dGhpcy5yb3dzLTEpLGU+dHx8ZTwwfHxlPj10aGlzLnJvd3N8fHQ8MHx8dD49dGhpcy5yb3dzKXRocm93IG5ldyBSYW5nZUVycm9yKCJBcmd1bWVudCBvdXQgb2YgcmFuZ2UiKTtsZXQgcz1uZXcgYih0LWUrMSxuLmxlbmd0aCk7Zm9yKGxldCByPTA7cjxuLmxlbmd0aDtyKyspZm9yKGxldCBpPWU7aTw9dDtpKyspe2lmKG5bcl08MHx8bltyXT49dGhpcy5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKGBDb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlOiAke25bcl19YCk7cy5zZXQoaS1lLHIsdGhpcy5nZXQoaSxuW3JdKSl9cmV0dXJuIHN9c2V0U3ViTWF0cml4KG4sZSx0KXtpZihuPWIuY2hlY2tNYXRyaXgobiksbi5pc0VtcHR5KCkpcmV0dXJuIHRoaXM7bGV0IHM9ZStuLnJvd3MtMSxyPXQrbi5jb2x1bW5zLTE7RnQodGhpcyxlLHMsdCxyKTtmb3IobGV0IGk9MDtpPG4ucm93cztpKyspZm9yKGxldCBoPTA7aDxuLmNvbHVtbnM7aCsrKXRoaXMuc2V0KGUraSx0K2gsbi5nZXQoaSxoKSk7cmV0dXJuIHRoaXN9c2VsZWN0aW9uKG4sZSl7aWUodGhpcyxuKSxsZSh0aGlzLGUpO2xldCB0PW5ldyBiKG4ubGVuZ3RoLGUubGVuZ3RoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9bltzXTtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyl7bGV0IGg9ZVtpXTt0LnNldChzLGksdGhpcy5nZXQocixoKSl9fXJldHVybiB0fXRyYWNlKCl7bGV0IG49TWF0aC5taW4odGhpcy5yb3dzLHRoaXMuY29sdW1ucyksZT0wO2ZvcihsZXQgdD0wO3Q8bjt0KyspZSs9dGhpcy5nZXQodCx0KTtyZXR1cm4gZX1jbG9uZSgpe2xldCBuPW5ldyBiKHRoaXMucm93cyx0aGlzLmNvbHVtbnMpO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXN1bShuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBoZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIHVlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBjZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19cHJvZHVjdChuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBmZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIGdlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBhZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19bWVhbihuKXtjb25zdCBlPXRoaXMuc3VtKG4pO3N3aXRjaChuKXtjYXNlInJvdyI6e2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyllW3RdLz10aGlzLmNvbHVtbnM7cmV0dXJuIGV9Y2FzZSJjb2x1bW4iOntmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspZVt0XS89dGhpcy5yb3dzO3JldHVybiBlfWNhc2Ugdm9pZCAwOnJldHVybiBlL3RoaXMuc2l6ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19dmFyaWFuY2UobixlPXt9KXtpZih0eXBlb2Ygbj09Im9iamVjdCImJihlPW4sbj12b2lkIDApLHR5cGVvZiBlIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7dW5iaWFzZWQ6dD0hMCxtZWFuOnM9dGhpcy5tZWFuKG4pfT1lO2lmKHR5cGVvZiB0IT0iYm9vbGVhbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigidW5iaWFzZWQgbXVzdCBiZSBhIGJvb2xlYW4iKTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyhzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtZWFuIG11c3QgYmUgYW4gYXJyYXkiKTtyZXR1cm4gbWUodGhpcyx0LHMpfWNhc2UiY29sdW1uIjp7aWYoIVcocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWVhbiBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIHdlKHRoaXMsdCxzKX1jYXNlIHZvaWQgMDp7aWYodHlwZW9mIHMhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIm1lYW4gbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBwZSh0aGlzLHQscyl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXN0YW5kYXJkRGV2aWF0aW9uKG4sZSl7dHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKTtjb25zdCB0PXRoaXMudmFyaWFuY2UobixlKTtpZihuPT09dm9pZCAwKXJldHVybiBNYXRoLnNxcnQodCk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXT1NYXRoLnNxcnQodFtzXSk7cmV0dXJuIHR9Y2VudGVyKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e2NlbnRlcjp0PXRoaXMubWVhbihuKX09ZTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBkZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiB5ZSh0aGlzLHQpLHRoaXN9Y2FzZSB2b2lkIDA6e2lmKHR5cGVvZiB0IT0ibnVtYmVyIil0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBNZSh0aGlzLHQpLHRoaXN9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXNjYWxlKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2xldCB0PWUuc2NhbGU7c3dpdGNoKG4pe2Nhc2Uicm93Ijp7aWYodD09PXZvaWQgMCl0PUVlKHRoaXMpO2Vsc2UgaWYoIVcodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigic2NhbGUgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBTZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZih0PT09dm9pZCAwKXQ9amUodGhpcyk7ZWxzZSBpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJzY2FsZSBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIGtlKHRoaXMsdCksdGhpc31jYXNlIHZvaWQgMDp7aWYodD09PXZvaWQgMCl0PWJlKHRoaXMpO2Vsc2UgaWYodHlwZW9mIHQhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoInNjYWxlIG11c3QgYmUgYSBudW1iZXIiKTtyZXR1cm4gSWUodGhpcyx0KSx0aGlzfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtufWApfX10b1N0cmluZyhuKXtyZXR1cm4gVHQodGhpcyxuKX19Xy5wcm90b3R5cGUua2xhc3M9Ik1hdHJpeCIsdHlwZW9mIFN5bWJvbDwidSImJihfLnByb3RvdHlwZVtTeW1ib2wuZm9yKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpXT1uZSk7ZnVuY3Rpb24gUHQobyxuKXtyZXR1cm4gby1ufWZ1bmN0aW9uIFJlKG8pe3JldHVybiBvLmV2ZXJ5KG49PnR5cGVvZiBuPT0ibnVtYmVyIil9Xy5yYW5kb209Xy5yYW5kLF8ucmFuZG9tSW50PV8ucmFuZEludCxfLmRpYWdvbmFsPV8uZGlhZyxfLnByb3RvdHlwZS5kaWFnb25hbD1fLnByb3RvdHlwZS5kaWFnLF8uaWRlbnRpdHk9Xy5leWUsXy5wcm90b3R5cGUubmVnYXRlPV8ucHJvdG90eXBlLm5lZyxfLnByb3RvdHlwZS50ZW5zb3JQcm9kdWN0PV8ucHJvdG90eXBlLmtyb25lY2tlclByb2R1Y3Q7Y2xhc3MgYiBleHRlbmRzIF97Y29uc3RydWN0b3IobixlKXtpZihzdXBlcigpLGIuaXNNYXRyaXgobikpcmV0dXJuIG4uY2xvbmUoKTtpZihOdW1iZXIuaXNJbnRlZ2VyKG4pJiZuPj0wKWlmKHRoaXMuZGF0YT1bXSxOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wKWZvcihsZXQgdD0wO3Q8bjt0KyspdGhpcy5kYXRhLnB1c2gobmV3IEZsb2F0NjRBcnJheShlKSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJuQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciIpO2Vsc2UgaWYoVyhuKSl7Y29uc3QgdD1uO2lmKG49dC5sZW5ndGgsZT1uP3RbMF0ubGVuZ3RoOjAsdHlwZW9mIGUhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIkRhdGEgbXVzdCBiZSBhIDJEIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQiKTt0aGlzLmRhdGE9W107Zm9yKGxldCBzPTA7czxuO3MrKyl7aWYodFtzXS5sZW5ndGghPT1lKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucyIpO2lmKCFSZSh0W3NdKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnB1dCBkYXRhIGNvbnRhaW5zIG5vbi1udW1lcmljIHZhbHVlcyIpO3RoaXMuZGF0YS5wdXNoKEZsb2F0NjRBcnJheS5mcm9tKHRbc10pKX19ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Iik7dGhpcy5yb3dzPW4sdGhpcy5jb2x1bW5zPWV9c2V0KG4sZSx0KXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdPXQsdGhpc31nZXQobixlKXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdfXJlbW92ZVJvdyhuKXtyZXR1cm4gUSh0aGlzLG4pLHRoaXMuZGF0YS5zcGxpY2UobiwxKSx0aGlzLnJvd3MtPTEsdGhpc31hZGRSb3cobixlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9bixuPXRoaXMucm93cyksUSh0aGlzLG4sITApLGU9RmxvYXQ2NEFycmF5LmZyb20odHQodGhpcyxlKSksdGhpcy5kYXRhLnNwbGljZShuLDAsZSksdGhpcy5yb3dzKz0xLHRoaXN9cmVtb3ZlQ29sdW1uKG4pe1oodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspe2NvbnN0IHQ9bmV3IEZsb2F0NjRBcnJheSh0aGlzLmNvbHVtbnMtMSk7Zm9yKGxldCBzPTA7czxuO3MrKyl0W3NdPXRoaXMuZGF0YVtlXVtzXTtmb3IobGV0IHM9bisxO3M8dGhpcy5jb2x1bW5zO3MrKyl0W3MtMV09dGhpcy5kYXRhW2VdW3NdO3RoaXMuZGF0YVtlXT10fXJldHVybiB0aGlzLmNvbHVtbnMtPTEsdGhpc31hZGRDb2x1bW4obixlKXt0eXBlb2YgZT4idSImJihlPW4sbj10aGlzLmNvbHVtbnMpLFoodGhpcyxuLCEwKSxlPWV0KHRoaXMsZSk7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXtjb25zdCBzPW5ldyBGbG9hdDY0QXJyYXkodGhpcy5jb2x1bW5zKzEpO2xldCByPTA7Zm9yKDtyPG47cisrKXNbcl09dGhpcy5kYXRhW3RdW3JdO2ZvcihzW3IrK109ZVt0XTtyPHRoaXMuY29sdW1ucysxO3IrKylzW3JdPXRoaXMuZGF0YVt0XVtyLTFdO3RoaXMuZGF0YVt0XT1zfXJldHVybiB0aGlzLmNvbHVtbnMrPTEsdGhpc319cmUoXyxiKTtjbGFzcyBzdCBleHRlbmRzIF97Y29uc3RydWN0b3Iobil7c3VwZXIoKSx0aGlzLmRhdGE9bix0aGlzLnJvd3M9bi5sZW5ndGgsdGhpcy5jb2x1bW5zPW5bMF0ubGVuZ3RofXNldChuLGUsdCl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXT10LHRoaXN9Z2V0KG4sZSl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXX19Y2xhc3MgTmV7Y29uc3RydWN0b3Iobil7bj1zdC5jaGVja01hdHJpeChuKTtsZXQgZT1uLmNsb25lKCksdD1lLnJvd3Mscz1lLmNvbHVtbnMscj1uZXcgRmxvYXQ2NEFycmF5KHQpLGk9MSxoLGwsdSxmLGcsYSxqLHcseTtmb3IoaD0wO2g8dDtoKyspcltoXT1oO2Zvcih3PW5ldyBGbG9hdDY0QXJyYXkodCksbD0wO2w8cztsKyspe2ZvcihoPTA7aDx0O2grKyl3W2hdPWUuZ2V0KGgsbCk7Zm9yKGg9MDtoPHQ7aCsrKXtmb3IoeT1NYXRoLm1pbihoLGwpLGc9MCx1PTA7dTx5O3UrKylnKz1lLmdldChoLHUpKndbdV07d1toXS09ZyxlLnNldChoLGwsd1toXSl9Zm9yKGY9bCxoPWwrMTtoPHQ7aCsrKU1hdGguYWJzKHdbaF0pPk1hdGguYWJzKHdbZl0pJiYoZj1oKTtpZihmIT09bCl7Zm9yKHU9MDt1PHM7dSsrKWE9ZS5nZXQoZix1KSxlLnNldChmLHUsZS5nZXQobCx1KSksZS5zZXQobCx1LGEpO2o9cltmXSxyW2ZdPXJbbF0scltsXT1qLGk9LWl9aWYobDx0JiZlLmdldChsLGwpIT09MClmb3IoaD1sKzE7aDx0O2grKyllLnNldChoLGwsZS5nZXQoaCxsKS9lLmdldChsLGwpKX10aGlzLkxVPWUsdGhpcy5waXZvdFZlY3Rvcj1yLHRoaXMucGl2b3RTaWduPWl9aXNTaW5ndWxhcigpe2xldCBuPXRoaXMuTFUsZT1uLmNvbHVtbnM7Zm9yKGxldCB0PTA7dDxlO3QrKylpZihuLmdldCh0LHQpPT09MClyZXR1cm4hMDtyZXR1cm4hMX1zb2x2ZShuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5MVTtpZihlLnJvd3MhPT1uLnJvd3MpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIG1hdHJpeCBkaW1lbnNpb25zIik7aWYodGhpcy5pc1Npbmd1bGFyKCkpdGhyb3cgbmV3IEVycm9yKCJMVSBtYXRyaXggaXMgc2luZ3VsYXIiKTtsZXQgcz1uLmNvbHVtbnMscj1uLnN1Yk1hdHJpeFJvdyh0aGlzLnBpdm90VmVjdG9yLDAscy0xKSxpPWUuY29sdW1ucyxoLGwsdTtmb3IodT0wO3U8aTt1KyspZm9yKGg9dSsxO2g8aTtoKyspZm9yKGw9MDtsPHM7bCsrKXIuc2V0KGgsbCxyLmdldChoLGwpLXIuZ2V0KHUsbCkqZS5nZXQoaCx1KSk7Zm9yKHU9aS0xO3U+PTA7dS0tKXtmb3IobD0wO2w8cztsKyspci5zZXQodSxsLHIuZ2V0KHUsbCkvZS5nZXQodSx1KSk7Zm9yKGg9MDtoPHU7aCsrKWZvcihsPTA7bDxzO2wrKylyLnNldChoLGwsci5nZXQoaCxsKS1yLmdldCh1LGwpKmUuZ2V0KGgsdSkpfXJldHVybiByfWdldCBkZXRlcm1pbmFudCgpe2xldCBuPXRoaXMuTFU7aWYoIW4uaXNTcXVhcmUoKSl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCBtdXN0IGJlIHNxdWFyZSIpO2xldCBlPXRoaXMucGl2b3RTaWduLHQ9bi5jb2x1bW5zO2ZvcihsZXQgcz0wO3M8dDtzKyspZSo9bi5nZXQocyxzKTtyZXR1cm4gZX1nZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI+aT9zLnNldChyLGksbi5nZXQocixpKSk6cj09PWk/cy5zZXQocixpLDEpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI8PWk/cy5zZXQocixpLG4uZ2V0KHIsaSkpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgcGl2b3RQZXJtdXRhdGlvblZlY3Rvcigpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucGl2b3RWZWN0b3IpfX1mdW5jdGlvbiB4KG8sbil7bGV0IGU9MDtyZXR1cm4gTWF0aC5hYnMobyk+TWF0aC5hYnMobik/KGU9bi9vLE1hdGguYWJzKG8pKk1hdGguc3FydCgxK2UqZSkpOm4hPT0wPyhlPW8vbixNYXRoLmFicyhuKSpNYXRoLnNxcnQoMStlKmUpKTowfWNsYXNzIHZle2NvbnN0cnVjdG9yKG4pe249c3QuY2hlY2tNYXRyaXgobik7bGV0IGU9bi5jbG9uZSgpLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IEZsb2F0NjRBcnJheShzKSxpLGgsbCx1O2ZvcihsPTA7bDxzO2wrKyl7bGV0IGY9MDtmb3IoaT1sO2k8dDtpKyspZj14KGYsZS5nZXQoaSxsKSk7aWYoZiE9PTApe2ZvcihlLmdldChsLGwpPDAmJihmPS1mKSxpPWw7aTx0O2krKyllLnNldChpLGwsZS5nZXQoaSxsKS9mKTtmb3IoZS5zZXQobCxsLGUuZ2V0KGwsbCkrMSksaD1sKzE7aDxzO2grKyl7Zm9yKHU9MCxpPWw7aTx0O2krKyl1Kz1lLmdldChpLGwpKmUuZ2V0KGksaCk7Zm9yKHU9LXUvZS5nZXQobCxsKSxpPWw7aTx0O2krKyllLnNldChpLGgsZS5nZXQoaSxoKSt1KmUuZ2V0KGksbCkpfX1yW2xdPS1mfXRoaXMuUVI9ZSx0aGlzLlJkaWFnPXJ9c29sdmUobil7bj1iLmNoZWNrTWF0cml4KG4pO2xldCBlPXRoaXMuUVIsdD1lLnJvd3M7aWYobi5yb3dzIT09dCl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCByb3cgZGltZW5zaW9ucyBtdXN0IGFncmVlIik7aWYoIXRoaXMuaXNGdWxsUmFuaygpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IGlzIHJhbmsgZGVmaWNpZW50Iik7bGV0IHM9bi5jb2x1bW5zLHI9bi5jbG9uZSgpLGk9ZS5jb2x1bW5zLGgsbCx1LGY7Zm9yKHU9MDt1PGk7dSsrKWZvcihsPTA7bDxzO2wrKyl7Zm9yKGY9MCxoPXU7aDx0O2grKylmKz1lLmdldChoLHUpKnIuZ2V0KGgsbCk7Zm9yKGY9LWYvZS5nZXQodSx1KSxoPXU7aDx0O2grKylyLnNldChoLGwsci5nZXQoaCxsKStmKmUuZ2V0KGgsdSkpfWZvcih1PWktMTt1Pj0wO3UtLSl7Zm9yKGw9MDtsPHM7bCsrKXIuc2V0KHUsbCxyLmdldCh1LGwpL3RoaXMuUmRpYWdbdV0pO2ZvcihoPTA7aDx1O2grKylmb3IobD0wO2w8cztsKyspci5zZXQoaCxsLHIuZ2V0KGgsbCktci5nZXQodSxsKSplLmdldChoLHUpKX1yZXR1cm4gci5zdWJNYXRyaXgoMCxpLTEsMCxzLTEpfWlzRnVsbFJhbmsoKXtsZXQgbj10aGlzLlFSLmNvbHVtbnM7Zm9yKGxldCBlPTA7ZTxuO2UrKylpZih0aGlzLlJkaWFnW2VdPT09MClyZXR1cm4hMTtyZXR1cm4hMH1nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4uY29sdW1ucyx0PW5ldyBiKGUsZSkscyxyO2ZvcihzPTA7czxlO3MrKylmb3Iocj0wO3I8ZTtyKyspczxyP3Quc2V0KHMscixuLmdldChzLHIpKTpzPT09cj90LnNldChzLHIsdGhpcy5SZGlhZ1tzXSk6dC5zZXQocyxyLDApO3JldHVybiB0fWdldCBvcnRob2dvbmFsTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCkscixpLGgsbDtmb3IoaD10LTE7aD49MDtoLS0pe2ZvcihyPTA7cjxlO3IrKylzLnNldChyLGgsMCk7Zm9yKHMuc2V0KGgsaCwxKSxpPWg7aTx0O2krKylpZihuLmdldChoLGgpIT09MCl7Zm9yKGw9MCxyPWg7cjxlO3IrKylsKz1uLmdldChyLGgpKnMuZ2V0KHIsaSk7Zm9yKGw9LWwvbi5nZXQoaCxoKSxyPWg7cjxlO3IrKylzLnNldChyLGkscy5nZXQocixpKStsKm4uZ2V0KHIsaCkpfX1yZXR1cm4gc319Y2xhc3MgRHR7Y29uc3RydWN0b3IobixlPXt9KXtpZihuPXN0LmNoZWNrTWF0cml4KG4pLG4uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IG11c3QgYmUgbm9uLWVtcHR5Iik7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zO2NvbnN0e2NvbXB1dGVMZWZ0U2luZ3VsYXJWZWN0b3JzOnI9ITAsY29tcHV0ZVJpZ2h0U2luZ3VsYXJWZWN0b3JzOmk9ITAsYXV0b1RyYW5zcG9zZTpoPSExfT1lO2xldCBsPSEhcix1PSEhaSxmPSExLGc7aWYodDxzKWlmKCFoKWc9bi5jbG9uZSgpLGNvbnNvbGUud2FybigiQ29tcHV0aW5nIFNWRCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgY29sdW1ucyB0aGFuIHJvd3MuIENvbnNpZGVyIGVuYWJsaW5nIGF1dG9UcmFuc3Bvc2UiKTtlbHNle2c9bi50cmFuc3Bvc2UoKSx0PWcucm93cyxzPWcuY29sdW1ucyxmPSEwO2xldCBjPWw7bD11LHU9Y31lbHNlIGc9bi5jbG9uZSgpO2xldCBhPU1hdGgubWluKHQscyksaj1NYXRoLm1pbih0KzEscyksdz1uZXcgRmxvYXQ2NEFycmF5KGopLHk9bmV3IGIodCxhKSxtPW5ldyBiKHMscyksTT1uZXcgRmxvYXQ2NEFycmF5KHMpLFQ9bmV3IEZsb2F0NjRBcnJheSh0KSxFPW5ldyBGbG9hdDY0QXJyYXkoaik7Zm9yKGxldCBjPTA7YzxqO2MrKylFW2NdPWM7bGV0IGs9TWF0aC5taW4odC0xLHMpLFI9TWF0aC5tYXgoMCxNYXRoLm1pbihzLTIsdCkpLHE9TWF0aC5tYXgoayxSKTtmb3IobGV0IGM9MDtjPHE7YysrKXtpZihjPGspe3dbY109MDtmb3IobGV0IHA9YztwPHQ7cCsrKXdbY109eCh3W2NdLGcuZ2V0KHAsYykpO2lmKHdbY10hPT0wKXtnLmdldChjLGMpPDAmJih3W2NdPS13W2NdKTtmb3IobGV0IHA9YztwPHQ7cCsrKWcuc2V0KHAsYyxnLmdldChwLGMpL3dbY10pO2cuc2V0KGMsYyxnLmdldChjLGMpKzEpfXdbY109LXdbY119Zm9yKGxldCBwPWMrMTtwPHM7cCsrKXtpZihjPGsmJndbY10hPT0wKXtsZXQgUz0wO2ZvcihsZXQgZD1jO2Q8dDtkKyspUys9Zy5nZXQoZCxjKSpnLmdldChkLHApO1M9LVMvZy5nZXQoYyxjKTtmb3IobGV0IGQ9YztkPHQ7ZCsrKWcuc2V0KGQscCxnLmdldChkLHApK1MqZy5nZXQoZCxjKSl9TVtwXT1nLmdldChjLHApfWlmKGwmJmM8aylmb3IobGV0IHA9YztwPHQ7cCsrKXkuc2V0KHAsYyxnLmdldChwLGMpKTtpZihjPFIpe01bY109MDtmb3IobGV0IHA9YysxO3A8cztwKyspTVtjXT14KE1bY10sTVtwXSk7aWYoTVtjXSE9PTApe01bYysxXTwwJiYoTVtjXT0wLU1bY10pO2ZvcihsZXQgcD1jKzE7cDxzO3ArKylNW3BdLz1NW2NdO01bYysxXSs9MX1pZihNW2NdPS1NW2NdLGMrMTx0JiZNW2NdIT09MCl7Zm9yKGxldCBwPWMrMTtwPHQ7cCsrKVRbcF09MDtmb3IobGV0IHA9YysxO3A8dDtwKyspZm9yKGxldCBTPWMrMTtTPHM7UysrKVRbcF0rPU1bU10qZy5nZXQocCxTKTtmb3IobGV0IHA9YysxO3A8cztwKyspe2xldCBTPS1NW3BdL01bYysxXTtmb3IobGV0IGQ9YysxO2Q8dDtkKyspZy5zZXQoZCxwLGcuZ2V0KGQscCkrUypUW2RdKX19aWYodSlmb3IobGV0IHA9YysxO3A8cztwKyspbS5zZXQocCxjLE1bcF0pfX1sZXQgST1NYXRoLm1pbihzLHQrMSk7aWYoazxzJiYod1trXT1nLmdldChrLGspKSx0PEkmJih3W0ktMV09MCksUisxPEkmJihNW1JdPWcuZ2V0KFIsSS0xKSksTVtJLTFdPTAsbCl7Zm9yKGxldCBjPWs7YzxhO2MrKyl7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfWZvcihsZXQgYz1rLTE7Yz49MDtjLS0paWYod1tjXSE9PTApe2ZvcihsZXQgcD1jKzE7cDxhO3ArKyl7bGV0IFM9MDtmb3IobGV0IGQ9YztkPHQ7ZCsrKVMrPXkuZ2V0KGQsYykqeS5nZXQoZCxwKTtTPS1TL3kuZ2V0KGMsYyk7Zm9yKGxldCBkPWM7ZDx0O2QrKyl5LnNldChkLHAseS5nZXQoZCxwKStTKnkuZ2V0KGQsYykpfWZvcihsZXQgcD1jO3A8dDtwKyspeS5zZXQocCxjLC15LmdldChwLGMpKTt5LnNldChjLGMsMSt5LmdldChjLGMpKTtmb3IobGV0IHA9MDtwPGMtMTtwKyspeS5zZXQocCxjLDApfWVsc2V7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfX1pZih1KWZvcihsZXQgYz1zLTE7Yz49MDtjLS0pe2lmKGM8UiYmTVtjXSE9PTApZm9yKGxldCBwPWMrMTtwPHM7cCsrKXtsZXQgUz0wO2ZvcihsZXQgZD1jKzE7ZDxzO2QrKylTKz1tLmdldChkLGMpKm0uZ2V0KGQscCk7Uz0tUy9tLmdldChjKzEsYyk7Zm9yKGxldCBkPWMrMTtkPHM7ZCsrKW0uc2V0KGQscCxtLmdldChkLHApK1MqbS5nZXQoZCxjKSl9Zm9yKGxldCBwPTA7cDxzO3ArKyltLnNldChwLGMsMCk7bS5zZXQoYyxjLDEpfWxldCB6PUktMSxCPU51bWJlci5FUFNJTE9OO2Zvcig7ST4wOyl7bGV0IGMscDtmb3IoYz1JLTI7Yz49LTEmJmMhPT0tMTtjLS0pe2NvbnN0IFM9TnVtYmVyLk1JTl9WQUxVRStCKk1hdGguYWJzKHdbY10rTWF0aC5hYnMod1tjKzFdKSk7aWYoTWF0aC5hYnMoTVtjXSk8PVN8fE51bWJlci5pc05hTihNW2NdKSl7TVtjXT0wO2JyZWFrfX1pZihjPT09SS0yKXA9NDtlbHNle2xldCBTO2ZvcihTPUktMTtTPj1jJiZTIT09YztTLS0pe2xldCBkPShTIT09ST9NYXRoLmFicyhNW1NdKTowKSsoUyE9PWMrMT9NYXRoLmFicyhNW1MtMV0pOjApO2lmKE1hdGguYWJzKHdbU10pPD1CKmQpe3dbU109MDticmVha319Uz09PWM/cD0zOlM9PT1JLTE/cD0xOihwPTIsYz1TKX1zd2l0Y2goYysrLHApe2Nhc2UgMTp7bGV0IFM9TVtJLTJdO01bSS0yXT0wO2ZvcihsZXQgZD1JLTI7ZD49YztkLS0pe2xldCBEPXgod1tkXSxTKSxVPXdbZF0vRCxGPVMvRDtpZih3W2RdPUQsZCE9PWMmJihTPS1GKk1bZC0xXSxNW2QtMV09VSpNW2QtMV0pLHUpZm9yKGxldCBQPTA7UDxzO1ArKylEPVUqbS5nZXQoUCxkKStGKm0uZ2V0KFAsSS0xKSxtLnNldChQLEktMSwtRiptLmdldChQLGQpK1UqbS5nZXQoUCxJLTEpKSxtLnNldChQLGQsRCl9YnJlYWt9Y2FzZSAyOntsZXQgUz1NW2MtMV07TVtjLTFdPTA7Zm9yKGxldCBkPWM7ZDxJO2QrKyl7bGV0IEQ9eCh3W2RdLFMpLFU9d1tkXS9ELEY9Uy9EO2lmKHdbZF09RCxTPS1GKk1bZF0sTVtkXT1VKk1bZF0sbClmb3IobGV0IFA9MDtQPHQ7UCsrKUQ9VSp5LmdldChQLGQpK0YqeS5nZXQoUCxjLTEpLHkuc2V0KFAsYy0xLC1GKnkuZ2V0KFAsZCkrVSp5LmdldChQLGMtMSkpLHkuc2V0KFAsZCxEKX1icmVha31jYXNlIDM6e2NvbnN0IFM9TWF0aC5tYXgoTWF0aC5hYnMod1tJLTFdKSxNYXRoLmFicyh3W0ktMl0pLE1hdGguYWJzKE1bSS0yXSksTWF0aC5hYnMod1tjXSksTWF0aC5hYnMoTVtjXSkpLGQ9d1tJLTFdL1MsRD13W0ktMl0vUyxVPU1bSS0yXS9TLEY9d1tjXS9TLFA9TVtjXS9TLFk9KChEK2QpKihELWQpK1UqVSkvMixHPWQqVSooZCpVKTtsZXQgTj0wOyhZIT09MHx8RyE9PTApJiYoWTwwP049MC1NYXRoLnNxcnQoWSpZK0cpOk49TWF0aC5zcXJ0KFkqWStHKSxOPUcvKFkrTikpO2xldCAkPShGK2QpKihGLWQpK04sSz1GKlA7Zm9yKGxldCB2PWM7djxJLTE7disrKXtsZXQgVj14KCQsSyk7Vj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpO2xldCBMPSQvVixDPUsvVjtpZih2IT09YyYmKE1bdi0xXT1WKSwkPUwqd1t2XStDKk1bdl0sTVt2XT1MKk1bdl0tQyp3W3ZdLEs9Qyp3W3YrMV0sd1t2KzFdPUwqd1t2KzFdLHUpZm9yKGxldCBYPTA7WDxzO1grKylWPUwqbS5nZXQoWCx2KStDKm0uZ2V0KFgsdisxKSxtLnNldChYLHYrMSwtQyptLmdldChYLHYpK0wqbS5nZXQoWCx2KzEpKSxtLnNldChYLHYsVik7aWYoVj14KCQsSyksVj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpLEw9JC9WLEM9Sy9WLHdbdl09ViwkPUwqTVt2XStDKndbdisxXSx3W3YrMV09LUMqTVt2XStMKndbdisxXSxLPUMqTVt2KzFdLE1bdisxXT1MKk1bdisxXSxsJiZ2PHQtMSlmb3IobGV0IFg9MDtYPHQ7WCsrKVY9TCp5LmdldChYLHYpK0MqeS5nZXQoWCx2KzEpLHkuc2V0KFgsdisxLC1DKnkuZ2V0KFgsdikrTCp5LmdldChYLHYrMSkpLHkuc2V0KFgsdixWKX1NW0ktMl09JDticmVha31jYXNlIDQ6e2lmKHdbY108PTAmJih3W2NdPXdbY108MD8td1tjXTowLHUpKWZvcihsZXQgUz0wO1M8PXo7UysrKW0uc2V0KFMsYywtbS5nZXQoUyxjKSk7Zm9yKDtjPHomJiEod1tjXT49d1tjKzFdKTspe2xldCBTPXdbY107aWYod1tjXT13W2MrMV0sd1tjKzFdPVMsdSYmYzxzLTEpZm9yKGxldCBkPTA7ZDxzO2QrKylTPW0uZ2V0KGQsYysxKSxtLnNldChkLGMrMSxtLmdldChkLGMpKSxtLnNldChkLGMsUyk7aWYobCYmYzx0LTEpZm9yKGxldCBkPTA7ZDx0O2QrKylTPXkuZ2V0KGQsYysxKSx5LnNldChkLGMrMSx5LmdldChkLGMpKSx5LnNldChkLGMsUyk7YysrfUktLTticmVha319fWlmKGYpe2xldCBjPW07bT15LHk9Y310aGlzLm09dCx0aGlzLm49cyx0aGlzLnM9dyx0aGlzLlU9eSx0aGlzLlY9bX1zb2x2ZShuKXtsZXQgZT1uLHQ9dGhpcy50aHJlc2hvbGQscz10aGlzLnMubGVuZ3RoLHI9Yi56ZXJvcyhzLHMpO2ZvcihsZXQgYT0wO2E8czthKyspTWF0aC5hYnModGhpcy5zW2FdKTw9dD9yLnNldChhLGEsMCk6ci5zZXQoYSxhLDEvdGhpcy5zW2FdKTtsZXQgaT10aGlzLlUsaD10aGlzLnJpZ2h0U2luZ3VsYXJWZWN0b3JzLGw9aC5tbXVsKHIpLHU9aC5yb3dzLGY9aS5yb3dzLGc9Yi56ZXJvcyh1LGYpO2ZvcihsZXQgYT0wO2E8dTthKyspZm9yKGxldCBqPTA7ajxmO2orKyl7bGV0IHc9MDtmb3IobGV0IHk9MDt5PHM7eSsrKXcrPWwuZ2V0KGEseSkqaS5nZXQoaix5KTtnLnNldChhLGosdyl9cmV0dXJuIGcubW11bChlKX1zb2x2ZUZvckRpYWdvbmFsKG4pe3JldHVybiB0aGlzLnNvbHZlKGIuZGlhZyhuKSl9aW52ZXJzZSgpe2xldCBuPXRoaXMuVixlPXRoaXMudGhyZXNob2xkLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IGIodCx0aGlzLnMubGVuZ3RoKTtmb3IobGV0IGY9MDtmPHQ7ZisrKWZvcihsZXQgZz0wO2c8cztnKyspTWF0aC5hYnModGhpcy5zW2ddKT5lJiZyLnNldChmLGcsbi5nZXQoZixnKS90aGlzLnNbZ10pO2xldCBpPXRoaXMuVSxoPWkucm93cyxsPWkuY29sdW1ucyx1PW5ldyBiKHQsaCk7Zm9yKGxldCBmPTA7Zjx0O2YrKylmb3IobGV0IGc9MDtnPGg7ZysrKXtsZXQgYT0wO2ZvcihsZXQgaj0wO2o8bDtqKyspYSs9ci5nZXQoZixqKSppLmdldChnLGopO3Uuc2V0KGYsZyxhKX1yZXR1cm4gdX1nZXQgY29uZGl0aW9uKCl7cmV0dXJuIHRoaXMuc1swXS90aGlzLnNbTWF0aC5taW4odGhpcy5tLHRoaXMubiktMV19Z2V0IG5vcm0yKCl7cmV0dXJuIHRoaXMuc1swXX1nZXQgcmFuaygpe2xldCBuPU1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXSpOdW1iZXIuRVBTSUxPTixlPTAsdD10aGlzLnM7Zm9yKGxldCBzPTAscj10Lmxlbmd0aDtzPHI7cysrKXRbc10+biYmZSsrO3JldHVybiBlfWdldCBkaWFnb25hbCgpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucyl9Z2V0IHRocmVzaG9sZCgpe3JldHVybiBOdW1iZXIuRVBTSUxPTi8yKk1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXX1nZXQgbGVmdFNpbmd1bGFyVmVjdG9ycygpe3JldHVybiB0aGlzLlV9Z2V0IHJpZ2h0U2luZ3VsYXJWZWN0b3JzKCl7cmV0dXJuIHRoaXMuVn1nZXQgZGlhZ29uYWxNYXRyaXgoKXtyZXR1cm4gYi5kaWFnKHRoaXMucyl9fWZ1bmN0aW9uIE10KG8sbj0hMSl7cmV0dXJuIG89c3QuY2hlY2tNYXRyaXgobyksbj9uZXcgRHQobykuaW52ZXJzZSgpOnFlKG8sYi5leWUoby5yb3dzKSl9ZnVuY3Rpb24gcWUobyxuLGU9ITEpe3JldHVybiBvPXN0LmNoZWNrTWF0cml4KG8pLG49c3QuY2hlY2tNYXRyaXgobiksZT9uZXcgRHQobykuc29sdmUobik6by5pc1NxdWFyZSgpP25ldyBOZShvKS5zb2x2ZShuKTpuZXcgdmUobykuc29sdmUobil9Y29uc3QgX2U9MTIzNCxUZT0oKT0+KHtzZWVkOl9lLGFycmF5U2h1ZmZsZShuKXtjb25zdHthcnI6ZSxzYW1wbGVTaXplOnR9PW47Zm9yKGxldCBzPTA7czx0O3MrKyl7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCByPXRoaXMuc2VlZD4+MTYmMzI3Njc7cj1yJWUubGVuZ3RoO2xldCBpPWVbc107ZVtzXT1lW3JdLGVbcl09aX19LG5leHRJbnQobil7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCBlPXRoaXMuc2VlZD4+MTYmMzI3Njc7cmV0dXJuIGU9ZSVuLGV9fSksSj0obyxuLGUpPT4oblswXS1vWzBdKSooZVsxXS1vWzFdKS0oblsxXS1vWzFdKSooZVswXS1vWzBdKSx6ZT0obyxuLGUsdCxzLHIsaSxoKT0+IShKKG8sbixlKT4wIT1KKHMscixpKT4wfHxKKG4sZSx0KT4wIT1KKHIsaSxoKT4wfHxKKGUsdCxvKT4wIT1KKGksaCxzKT4wfHxKKHQsbyxuKT4wIT1KKGgscyxyKT4wKSxGZT0obyxuLGUsdCxzLHIpPT5KKG8sbixlKT4wPT1KKHQscyxyKT4wLFBlPW89Pntjb25zdCBuPW9bNF0qb1s4XS1vWzVdKm9bN10sZT1vWzNdKm9bOF0tb1s1XSpvWzZdLHQ9b1szXSpvWzddLW9bNF0qb1s2XTtyZXR1cm4gb1swXSpuLW9bMV0qZStvWzJdKnR9LEJ0PShvLG4pPT57Y29uc3QgZT1QZShvKTtpZihNYXRoLmFicyhlKTw9bilyZXR1cm4gbnVsbDtjb25zdCB0PTEvZTtyZXR1cm5bKG9bNF0qb1s4XS1vWzVdKm9bN10pKnQsKG9bMl0qb1s3XS1vWzFdKm9bOF0pKnQsKG9bMV0qb1s1XS1vWzJdKm9bNF0pKnQsKG9bNV0qb1s2XS1vWzNdKm9bOF0pKnQsKG9bMF0qb1s4XS1vWzJdKm9bNl0pKnQsKG9bMl0qb1szXS1vWzBdKm9bNV0pKnQsKG9bM10qb1s3XS1vWzRdKm9bNl0pKnQsKG9bMV0qb1s2XS1vWzBdKm9bN10pKnQsKG9bMF0qb1s0XS1vWzFdKm9bM10pKnRdfSxvdD0obyxuKT0+e2NvbnN0IGU9bls2XSpvWzBdK25bN10qb1sxXStuWzhdLHQ9W107cmV0dXJuIHRbMF09KG5bMF0qb1swXStuWzFdKm9bMV0rblsyXSkvZSx0WzFdPShuWzNdKm9bMF0rbls0XSpvWzFdK25bNV0pL2UsdH0sRGU9KG8sbixlLHQpPT57Y29uc3Qgcz1ydChuLG8pLHI9cnQoZSxvKSxpPXJ0KHQsbyksaD1ydChuLGUpLGw9cnQodCxlKSx1PW10KHMsciksZj1tdChyLGkpLGc9bXQocyxpKSxhPW10KGgsbCk7cmV0dXJuIE1hdGgubWluKE1hdGgubWluKE1hdGgubWluKHUsZiksZyksYSl9LEJlPShvLG4sZSx0KT0+e2NvbnN0IHM9SihvLG4sZSk8PTA7cmV0dXJuIShKKG4sZSx0KTw9MCE9PXN8fEooZSx0LG8pPD0wIT09c3x8Sih0LG8sbik8PTAhPT1zKX0scnQ9KG8sbik9PltvWzBdLW5bMF0sb1sxXS1uWzFdXSxtdD0obyxuKT0+e2NvbnN0IGU9b1swXSpuWzFdLW9bMV0qblswXTtyZXR1cm4gTWF0aC5hYnMoZSkqLjV9LFZ0PShvLG4pPT57Y29uc3R7bm9ybVBvaW50czplLHBhcmFtOnR9PVh0KG8pLHtub3JtUG9pbnRzOnMscGFyYW06cn09WHQobiksaT1zLmxlbmd0aCxoPVtdLGw9W107Zm9yKGxldCB1PTA7dTxpO3UrKyl7Y29uc3QgZj1bZVt1XVswXSxlW3VdWzFdLDEsMCwwLDAsLShlW3VdWzBdKnNbdV1bMF0pLC0oZVt1XVsxXSpzW3VdWzBdKV0sZz1bMCwwLDAsZVt1XVswXSxlW3VdWzFdLDEsLShlW3VdWzBdKnNbdV1bMV0pLC0oZVt1XVsxXSpzW3VdWzFdKV07aC5wdXNoKGYpLGgucHVzaChnKSxsLnB1c2goW3NbdV1bMF1dKSxsLnB1c2goW3NbdV1bMV1dKX10cnl7Y29uc3QgdT1uZXcgYihoKSxmPW5ldyBiKGwpLGc9dS50cmFuc3Bvc2UoKSxhPWcubW11bCh1KSxqPWcubW11bChmKSx5PU10KGEpLm1tdWwoaikudG8xREFycmF5KCk7cmV0dXJuIFZlKHksdCxyKX1jYXRjaHtyZXR1cm4gbnVsbH19LFh0PW89PntsZXQgbj0wLGU9MDtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyluKz1vW2xdWzBdLGUrPW9bbF1bMV07bGV0IHQ9bi9vLmxlbmd0aCxzPWUvby5sZW5ndGgscj0wO2ZvcihsZXQgbD0wO2w8by5sZW5ndGg7bCsrKXtjb25zdCB1PW9bbF1bMF0tdCxmPW9bbF1bMV0tcztyKz1NYXRoLnNxcnQodSp1K2YqZil9bGV0IGk9TWF0aC5zcXJ0KDIpKm8ubGVuZ3RoL3I7Y29uc3QgaD1bXTtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyloLnB1c2goWyhvW2xdWzBdLXQpKmksKG9bbF1bMV0tcykqaV0pO3JldHVybntub3JtUG9pbnRzOmgscGFyYW06e21lYW5YOnQsbWVhblk6cyxzOml9fX0sVmU9KG8sbixlKT0+e2NvbnN0IHQ9ZS5zKmUubWVhblgscz1lLnMqZS5tZWFuWSxyPVtvWzBdK3Qqb1s2XSxvWzFdK3Qqb1s3XSwob1swXSt0Km9bNl0pKi1uLm1lYW5YKyhvWzFdK3Qqb1s3XSkqLW4ubWVhblkrKG9bMl0rdCkvbi5zLG9bM10rcypvWzZdLG9bNF0rcypvWzddLChvWzNdK3Mqb1s2XSkqLW4ubWVhblgrKG9bNF0rcypvWzddKSotbi5tZWFuWSsob1s1XStzKS9uLnMsZS5zKm9bNl0sZS5zKm9bN10sZS5zKm9bNl0qLW4ubWVhblgrZS5zKm9bN10qLW4ubWVhblkrZS5zL24uc107Zm9yKGxldCBpPTA7aTw5O2krKylyW2ldPXJbaV0vcls4XTtyZXR1cm4gcn0sWGU9LjAxLFVlPTEwLCRlPTIwLExlPTEwLFV0PW89Pntjb25zdHtzcmNQb2ludHM6bixkc3RQb2ludHM6ZSxrZXlmcmFtZTp0LHF1aWNrTW9kZTpzfT1vLHI9W1swLDBdLFt0LndpZHRoLDBdLFt0LndpZHRoLHQuaGVpZ2h0XSxbMCx0LmhlaWdodF1dLGk9NDtpZihuLmxlbmd0aDxpKXJldHVybiBudWxsO2NvbnN0IGg9WGUsbD0xLyhoKmgpLHU9TWF0aC5taW4oVWUsbi5sZW5ndGgpLGY9VGUoKSxnPVtdO2ZvcihsZXQgRT0wO0U8bi5sZW5ndGg7RSsrKWdbRV09RTtmLmFycmF5U2h1ZmZsZSh7YXJyOmcsc2FtcGxlU2l6ZTpnLmxlbmd0aH0pO2NvbnN0IGE9cz9MZTokZSxqPWEqMjtsZXQgdz0wO2NvbnN0IHk9W107Zm9yKDt3PGomJnkubGVuZ3RoPGE7KXtpZih3Kz0xLGYuYXJyYXlTaHVmZmxlKHthcnI6ZyxzYW1wbGVTaXplOml9KSwhemUobltnWzBdXSxuW2dbMV1dLG5bZ1syXV0sbltnWzNdXSxlW2dbMF1dLGVbZ1sxXV0sZVtnWzJdXSxlW2dbM11dKSljb250aW51ZTtjb25zdCBFPVZ0KFtuW2dbMF1dLG5bZ1sxXV0sbltnWzJdXSxuW2dbM11dXSxbZVtnWzBdXSxlW2dbMV1dLGVbZ1syXV0sZVtnWzNdXV0pO0UhPT1udWxsJiZIZSh7SDpFLHRlc3RQb2ludHM6cn0pJiZ5LnB1c2goRSl9aWYoeS5sZW5ndGg9PT0wKXJldHVybiBudWxsO2NvbnN0IG09W107Zm9yKGxldCBFPTA7RTx5Lmxlbmd0aDtFKyspbS5wdXNoKHtIOnlbRV0sY29zdDowfSk7bGV0IE09dTtmb3IobGV0IEU9MDtFPG4ubGVuZ3RoJiZtLmxlbmd0aD4yO0UrPU0pe009TWF0aC5taW4odSxuLmxlbmd0aC1FKTtsZXQgaz1FK007Zm9yKGxldCBSPTA7UjxtLmxlbmd0aDtSKyspZm9yKGxldCBxPUU7cTxrO3ErKyl7Y29uc3QgST1DZSh7SDptW1JdLkgsc3JjUG9pbnQ6bltxXSxkc3RQb2ludDplW3FdLG9uZU92ZXJTY2FsZTI6bH0pO21bUl0uY29zdCs9SX1tLnNvcnQoKFIscSk9PlIuY29zdC1xLmNvc3QpLG0uc3BsaWNlKC1NYXRoLmZsb29yKChtLmxlbmd0aCsxKS8yKSl9bGV0IFQ9bnVsbDtmb3IobGV0IEU9MDtFPG0ubGVuZ3RoO0UrKyl7Y29uc3Qgaz1ZZSh7aW5IOm1bRV0uSH0pO2lmKE9lKHtIOmssdGVzdFBvaW50czpyLGtleWZyYW1lOnR9KSl7VD1rO2JyZWFrfX1yZXR1cm4gVH0sT2U9KHtIOm8sdGVzdFBvaW50czpuLGtleWZyYW1lOmV9KT0+e2NvbnN0IHQ9QnQobywxZS01KTtpZih0PT09bnVsbClyZXR1cm4hMTtjb25zdCBzPVtdO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKXMucHVzaChvdChuW2ldLHQpKTtyZXR1cm4hKERlKHNbMF0sc1sxXSxzWzJdLHNbM10pPGUud2lkdGgqZS5oZWlnaHQqMWUtNHx8IUJlKHNbMF0sc1sxXSxzWzJdLHNbM10pKX0sWWU9KHtpbkg6b30pPT57Y29uc3Qgbj0xL29bOF0sZT1bXTtmb3IobGV0IHQ9MDt0PDg7dCsrKWVbdF09b1t0XSpuO3JldHVybiBlWzhdPTEsZX0sQ2U9KHtIOm8sc3JjUG9pbnQ6bixkc3RQb2ludDplLG9uZU92ZXJTY2FsZTI6dH0pPT57Y29uc3Qgcz1vdChuLG8pLHI9W3NbMF0tZVswXSxzWzFdLWVbMV1dO3JldHVybiBNYXRoLmxvZygxKyhyWzBdKnJbMF0rclsxXSpyWzFdKSp0KX0sSGU9KHtIOm8sdGVzdFBvaW50czpufSk9Pntjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWVbdF09b3Qoblt0XSxvKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3Qgcz10LHI9KHQrMSklbi5sZW5ndGgsaT0odCsyKSVuLmxlbmd0aDtpZighRmUobltzXSxuW3JdLG5baV0sZVtzXSxlW3JdLGVbaV0pKXJldHVybiExfXJldHVybiEwfSwkdD0zLEx0PTYsS2U9OCxPdD0uNyxKZT0oe2tleWZyYW1lOm8scXVlcnlwb2ludHM6bixxdWVyeXdpZHRoOmUscXVlcnloZWlnaHQ6dCxkZWJ1Z01vZGU6c30pPT57bGV0IHI9e307Y29uc3QgaT1bXTtmb3IobGV0IG09MDttPG4ubGVuZ3RoO20rKyl7Y29uc3QgTT1uW21dLFQ9TS5tYXhpbWE/by5tYXhpbWFQb2ludHM6by5taW5pbWFQb2ludHM7aWYoVC5sZW5ndGg9PT0wKWNvbnRpbnVlO2NvbnN0IEU9TS5tYXhpbWE/by5tYXhpbWFQb2ludHNDbHVzdGVyLnJvb3ROb2RlOm8ubWluaW1hUG9pbnRzQ2x1c3Rlci5yb290Tm9kZSxrPVtdLFI9bmV3IFd0KFtdLChCLGMpPT5CLmQtYy5kKTtFdCh7bm9kZTpFLGtleXBvaW50czpULHF1ZXJ5cG9pbnQ6TSxxdWV1ZTpSLGtleXBvaW50SW5kZXhlczprLG51bVBvcDowfSk7bGV0IHE9LTEsST1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUix6PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2ZvcihsZXQgQj0wO0I8ay5sZW5ndGg7QisrKXtjb25zdCBjPVRba1tCXV0scD15dCh7djE6Yy5kZXNjcmlwdG9ycyx2MjpNLmRlc2NyaXB0b3JzfSk7cDxJPyh6PUksST1wLHE9a1tCXSk6cDx6JiYoej1wKX1xIT09LTEmJih6PT09TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ8fDEqSS96PE90KSYmaS5wdXNoKHtxdWVyeXBvaW50Ok0sa2V5cG9pbnQ6VFtxXX0pfWlmKHMmJihyLm1hdGNoZXM9aSksaS5sZW5ndGg8THQpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgaD12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczppfSk7cyYmKHIuaG91Z2hNYXRjaGVzPWgpO2NvbnN0IGw9VXQoe3NyY1BvaW50czpoLm1hcChtPT5bbS5rZXlwb2ludC54LG0ua2V5cG9pbnQueV0pLGRzdFBvaW50czpoLm1hcChtPT5bbS5xdWVyeXBvaW50LngsbS5xdWVyeXBvaW50LnldKSxrZXlmcmFtZTpvfSk7aWYobD09PW51bGwpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgdT1ZdCh7SDpsLG1hdGNoZXM6aCx0aHJlc2hvbGQ6JHR9KTtpZihzJiYoci5pbmxpZXJNYXRjaGVzPXUpLHUubGVuZ3RoPEx0KXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IGY9QnQobCwxZS01KSxnPTEwKjEwLGE9W107Zm9yKGxldCBtPTA7bTxuLmxlbmd0aDttKyspe2NvbnN0IE09blttXSxUPW90KFtNLngsTS55XSxmKTtsZXQgRT0tMSxrPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFI9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Y29uc3QgcT1NLm1heGltYT9vLm1heGltYVBvaW50czpvLm1pbmltYVBvaW50cztmb3IobGV0IEk9MDtJPHEubGVuZ3RoO0krKyl7Y29uc3Qgej1xW0ldO2lmKCh6LngtVFswXSkqKHoueC1UWzBdKSsoei55LVRbMV0pKih6LnktVFsxXSk+Zyljb250aW51ZTtjb25zdCBjPXl0KHt2MTp6LmRlc2NyaXB0b3JzLHYyOk0uZGVzY3JpcHRvcnN9KTtjPGs/KFI9ayxrPWMsRT1JKTpjPFImJihSPWMpfUUhPT0tMSYmKFI9PT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUnx8MSprL1I8T3QpJiZhLnB1c2goe3F1ZXJ5cG9pbnQ6TSxrZXlwb2ludDpxW0VdfSl9cyYmKHIubWF0Y2hlczI9YSk7Y29uc3Qgaj12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczphfSk7cyYmKHIuaG91Z2hNYXRjaGVzMj1qKTtjb25zdCB3PVV0KHtzcmNQb2ludHM6ai5tYXAobT0+W20ua2V5cG9pbnQueCxtLmtleXBvaW50LnldKSxkc3RQb2ludHM6ai5tYXAobT0+W20ucXVlcnlwb2ludC54LG0ucXVlcnlwb2ludC55XSksa2V5ZnJhbWU6b30pO2lmKHc9PT1udWxsKXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IHk9WXQoe0g6dyxtYXRjaGVzOmosdGhyZXNob2xkOiR0fSk7cmV0dXJuIHMmJihyLmlubGllck1hdGNoZXMyPXkpLHtIOncsbWF0Y2hlczp5LGRlYnVnRXh0cmE6cn19LEV0PSh7bm9kZTpvLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSk9PntpZihvLmxlYWYpe2ZvcihsZXQgbD0wO2w8by5wb2ludEluZGV4ZXMubGVuZ3RoO2wrKylzLnB1c2goby5wb2ludEluZGV4ZXNbbF0pO3JldHVybn1jb25zdCBpPVtdO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKXtjb25zdCBmPW8uY2hpbGRyZW5bbF0uY2VudGVyUG9pbnRJbmRleCxnPXl0KHt2MTpuW2ZdLmRlc2NyaXB0b3JzLHYyOmUuZGVzY3JpcHRvcnN9KTtpLnB1c2goZyl9bGV0IGg9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Zm9yKGxldCBsPTA7bDxvLmNoaWxkcmVuLmxlbmd0aDtsKyspaD1NYXRoLm1pbihoLGlbbF0pO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKWlbbF0hPT1oJiZ0LnB1c2goe25vZGU6by5jaGlsZHJlbltsXSxkOmlbbF19KTtmb3IobGV0IGw9MDtsPG8uY2hpbGRyZW4ubGVuZ3RoO2wrKylpW2xdPT09aCYmRXQoe25vZGU6by5jaGlsZHJlbltsXSxrZXlwb2ludHM6bixxdWVyeXBvaW50OmUscXVldWU6dCxrZXlwb2ludEluZGV4ZXM6cyxudW1Qb3A6cn0pO2lmKHI8S2UmJnQubGVuZ3RoPjApe2NvbnN0e25vZGU6bCxkOnV9PXQucG9wKCk7cis9MSxFdCh7bm9kZTpsLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSl9fSxZdD1vPT57Y29uc3R7SDpuLG1hdGNoZXM6ZSx0aHJlc2hvbGQ6dH09byxzPXQqdCxyPVtdO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKXtjb25zdCBoPWVbaV0ucXVlcnlwb2ludCxsPWVbaV0ua2V5cG9pbnQsdT1vdChbbC54LGwueV0sbik7KHVbMF0taC54KSoodVswXS1oLngpKyh1WzFdLWgueSkqKHVbMV0taC55KTw9cyYmci5wdXNoKGVbaV0pfXJldHVybiByfTtjbGFzcyBHZXtjb25zdHJ1Y3RvcihuLGUsdD0hMSl7dGhpcy5xdWVyeVdpZHRoPW4sdGhpcy5xdWVyeUhlaWdodD1lLHRoaXMuZGVidWdNb2RlPXR9bWF0Y2hEZXRlY3Rpb24obixlKXtsZXQgdD17ZnJhbWVzOltdfSxzPW51bGw7Zm9yKGxldCBsPTA7bDxuLmxlbmd0aDtsKyspe2NvbnN0e0g6dSxtYXRjaGVzOmYsZGVidWdFeHRyYTpnfT1KZSh7a2V5ZnJhbWU6bltsXSxxdWVyeXBvaW50czplLHF1ZXJ5d2lkdGg6dGhpcy5xdWVyeVdpZHRoLHF1ZXJ5aGVpZ2h0OnRoaXMucXVlcnlIZWlnaHQsZGVidWdNb2RlOnRoaXMuZGVidWdNb2RlfSk7dC5mcmFtZXMucHVzaChnKSx1JiYocz09PW51bGx8fHMubWF0Y2hlcy5sZW5ndGg8Zi5sZW5ndGgpJiYocz17a2V5ZnJhbWVJbmRleDpsLEg6dSxtYXRjaGVzOmZ9KX1pZihzPT09bnVsbClyZXR1cm57a2V5ZnJhbWVJbmRleDotMSxkZWJ1Z0V4dHJhOnR9O2NvbnN0IHI9W10saT1bXSxoPW5bcy5rZXlmcmFtZUluZGV4XTtmb3IobGV0IGw9MDtsPHMubWF0Y2hlcy5sZW5ndGg7bCsrKXtjb25zdCB1PXMubWF0Y2hlc1tsXS5xdWVyeXBvaW50LGY9cy5tYXRjaGVzW2xdLmtleXBvaW50O3IucHVzaCh7eDp1LngseTp1Lnl9KSxpLnB1c2goe3g6KGYueCsuNSkvaC5zY2FsZSx5OihmLnkrLjUpL2guc2NhbGUsejowfSl9cmV0dXJue3NjcmVlbkNvb3JkczpyLHdvcmxkQ29vcmRzOmksa2V5ZnJhbWVJbmRleDpzLmtleWZyYW1lSW5kZXgsZGVidWdFeHRyYTp0fX19Y29uc3QgV2U9KHtzY3JlZW5Db29yZHM6byx3b3JsZENvb3JkczpuLHByb2plY3Rpb25UcmFuc2Zvcm06ZX0pPT57Y29uc3QgdD1WdChuLm1hcChtPT5bbS54LG0ueV0pLG8ubWFwKG09PlttLngsbS55XSkpLHM9bmV3IGIoW1t0WzBdLHRbMV0sdFsyXV0sW3RbM10sdFs0XSx0WzVdXSxbdFs2XSx0WzddLHRbOF1dXSkscj1uZXcgYihlKSxsPU10KHIpLm1tdWwocykudG8xREFycmF5KCksdT1NYXRoLnNxcnQobFswXSpsWzBdK2xbM10qbFszXStsWzZdKmxbNl0pLGY9TWF0aC5zcXJ0KGxbMV0qbFsxXStsWzRdKmxbNF0rbFs3XSpsWzddKSxnPSh1K2YpLzIsYT1bXTthWzBdPWxbMF0vdSxhWzNdPWxbM10vdSxhWzZdPWxbNl0vdSxhWzFdPWxbMV0vZixhWzRdPWxbNF0vZixhWzddPWxbN10vZixhWzJdPWFbM10qYVs3XS1hWzZdKmFbNF0sYVs1XT1hWzZdKmFbMV0tYVswXSphWzddLGFbOF09YVswXSphWzRdLWFbMV0qYVszXTtjb25zdCBqPU1hdGguc3FydChhWzJdKmFbMl0rYVs1XSphWzVdK2FbOF0qYVs4XSk7YVsyXS89aixhWzVdLz1qLGFbOF0vPWo7Y29uc3Qgdz1bXTtyZXR1cm4gd1swXT1sWzJdL2csd1sxXT1sWzVdL2csd1syXT1sWzhdL2csW1thWzBdLGFbMV0sYVsyXSx3WzBdXSxbYVszXSxhWzRdLGFbNV0sd1sxXV0sW2FbNl0sYVs3XSxhWzhdLHdbMl1dXX0sUWU9KG8sbik9Pltbb1swXVswXSpuWzBdWzBdK29bMF1bMl0qblsyXVswXSxvWzBdWzBdKm5bMF1bMV0rb1swXVsyXSpuWzJdWzFdLG9bMF1bMF0qblswXVsyXStvWzBdWzJdKm5bMl1bMl0sb1swXVswXSpuWzBdWzNdK29bMF1bMl0qblsyXVszXV0sW29bMV1bMV0qblsxXVswXStvWzFdWzJdKm5bMl1bMF0sb1sxXVsxXSpuWzFdWzFdK29bMV1bMl0qblsyXVsxXSxvWzFdWzFdKm5bMV1bMl0rb1sxXVsyXSpuWzJdWzJdLG9bMV1bMV0qblsxXVszXStvWzFdWzJdKm5bMl1bM11dLFtuWzJdWzBdLG5bMl1bMV0sblsyXVsyXSxuWzJdWzNdXV0sQ3Q9KG8sbixlLHQpPT57Y29uc3Qgcz1vWzBdWzBdKm4rb1swXVsxXSplK29bMF1bM10scj1vWzFdWzBdKm4rb1sxXVsxXSplK29bMV1bM10saT1vWzJdWzBdKm4rb1syXVsxXSplK29bMl1bM107cmV0dXJue3g6cyx5OnIsejppfX0sWmU9KG8sbixlLHQpPT57Y29uc3R7eDpzLHk6cix6Oml9PUN0KG8sbixlKTtyZXR1cm57eDpzL2kseTpyL2l9fSx4ZT01LEFlPTQsSHQ9MTAsdG49LjEsZW49Ljk5O2xldCBIPVtbXSxbXSxbXV0sQT1bW10sW11dLE89W1tdLFtdLFtdXTtjb25zdCBubj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dH0pPT57bGV0IHM9MCxyPTA7Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDtnKyspcys9ZVtnXS54LHIrPWVbZ10ueTtzLz1lLmxlbmd0aCxyLz1lLmxlbmd0aDtjb25zdCBpPVtdO2ZvcihsZXQgZz0wO2c8ZS5sZW5ndGg7ZysrKWkucHVzaCh7eDplW2ddLngtcyx5OmVbZ10ueS1yLHo6ZVtnXS56fSk7Y29uc3QgaD1bW10sW10sW11dO2ZvcihsZXQgZz0wO2c8MztnKyspZm9yKGxldCBhPTA7YTwzO2ErKyloW2ddW2FdPW9bZ11bYV07aFswXVszXT1vWzBdWzBdKnMrb1swXVsxXSpyK29bMF1bM10saFsxXVszXT1vWzFdWzBdKnMrb1sxXVsxXSpyK29bMV1bM10saFsyXVszXT1vWzJdWzBdKnMrb1syXVsxXSpyK29bMl1bM107Y29uc3QgbD1bMSwuOCwuNiwuNCwwXTtsZXQgdT1oLGY9bnVsbDtmb3IobGV0IGc9MDtnPGwubGVuZ3RoO2crKyl7Y29uc3QgYT1zbih7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTp1LHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkczppLHNjcmVlbkNvb3Jkczp0LGlubGllclByb2I6bFtnXX0pO2lmKHU9YS5tb2RlbFZpZXdUcmFuc2Zvcm0sYS5lcnI8eGUpe2Y9dTticmVha319cmV0dXJuIGY9PT1udWxsP251bGw6KGZbMF1bM109ZlswXVszXS1mWzBdWzBdKnMtZlswXVsxXSpyLGZbMV1bM109ZlsxXVszXS1mWzFdWzBdKnMtZlsxXVsxXSpyLGZbMl1bM109ZlsyXVszXS1mWzJdWzBdKnMtZlsyXVsxXSpyLGYpfSxzbj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dCxpbmxpZXJQcm9iOnN9KT0+e2NvbnN0IHI9czwxO2xldCBpPW8saD0wLGw9MCx1PW5ldyBBcnJheShlLmxlbmd0aCksZj1uZXcgQXJyYXkoZS5sZW5ndGgpLGc9bmV3IEFycmF5KGUubGVuZ3RoKSxhPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBqPTA7ajw9SHQ7aisrKXtjb25zdCB3PVFlKG4saSk7Zm9yKGxldCBFPTA7RTxlLmxlbmd0aDtFKyspe2NvbnN0IGs9WmUodyxlW0VdLngsZVtFXS55LGVbRV0ueiksUj10W0VdLngtay54LHE9dFtFXS55LWsueTtnW0VdPVIsYVtFXT1xLHVbRV09UipSK3EqcX1sZXQgeTtpZihsPTAscil7Y29uc3QgRT1NYXRoLm1heCgzLE1hdGguZmxvb3IoZS5sZW5ndGgqcyktMSk7Zm9yKGxldCBrPTA7azxlLmxlbmd0aDtrKyspZltrXT11W2tdO2Yuc29ydCgoayxSKT0+ay1SKSx5PU1hdGgubWF4KGZbRV0qQWUsMTYpO2ZvcihsZXQgaz0wO2s8ZS5sZW5ndGg7aysrKWZba10+eT9sKz15LzY6bCs9eS82KigxLSgxLWZba10veSkqKDEtZltrXS95KSooMS1mW2tdL3kpKX1lbHNlIGZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKWwrPXVbRV07aWYobC89ZS5sZW5ndGgsbDx0bnx8aj4wJiZsL2g+ZW58fGo9PT1IdClicmVhaztoPWw7Y29uc3QgbT1bXSxNPVtdO2ZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKXtpZihyJiZ1W0VdPnkpY29udGludWU7Y29uc3Qgaz1sbih7bW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybTp3LG1vZGVsVmlld1RyYW5zZm9ybTppLHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkOmVbRV19KTtpZihyKXtjb25zdCBSPSgxLXVbRV0veSkqKDEtdVtFXS95KTtmb3IobGV0IHE9MDtxPDI7cSsrKWZvcihsZXQgST0wO0k8NjtJKyspa1txXVtJXSo9UjttLnB1c2goW2dbRV0qUl0pLG0ucHVzaChbYVtFXSpSXSl9ZWxzZSBtLnB1c2goW2dbRV1dKSxtLnB1c2goW2FbRV1dKTtmb3IobGV0IFI9MDtSPGsubGVuZ3RoO1IrKylNLnB1c2goa1tSXSl9Y29uc3QgVD1ybih7ZFU6bSxKX1VfUzpNfSk7aWYoVD09PW51bGwpYnJlYWs7aT1vbih7bW9kZWxWaWV3VHJhbnNmb3JtOmksZFM6VH0pfXJldHVybnttb2RlbFZpZXdUcmFuc2Zvcm06aSxlcnI6bH19LG9uPSh7bW9kZWxWaWV3VHJhbnNmb3JtOm8sZFM6bn0pPT57bGV0IGU9blswXSpuWzBdK25bMV0qblsxXStuWzJdKm5bMl0sdCxzLHI7ZTwxZS02Pyh0PTEscz0wLHI9MCxlPTApOihlPU1hdGguc3FydChlKSx0PW5bMF0vZSxzPW5bMV0vZSxyPW5bMl0vZSk7Y29uc3QgaT1NYXRoLmNvcyhlKSxoPU1hdGguc2luKGUpLGw9MS1pO0hbMF1bMF09dCp0KmwraSxIWzBdWzFdPXQqcypsLXIqaCxIWzBdWzJdPXQqcipsK3MqaCxIWzBdWzNdPW5bM10sSFsxXVswXT1zKnQqbCtyKmgsSFsxXVsxXT1zKnMqbCtpLEhbMV1bMl09cypyKmwtdCpoLEhbMV1bM109bls0XSxIWzJdWzBdPXIqdCpsLXMqaCxIWzJdWzFdPXIqcypsK3QqaCxIWzJdWzJdPXIqcipsK2ksSFsyXVszXT1uWzVdO2NvbnN0IHU9W1tdLFtdLFtdXTtmb3IobGV0IGY9MDtmPDM7ZisrKXtmb3IobGV0IGc9MDtnPDQ7ZysrKXVbZl1bZ109b1tmXVswXSpIWzBdW2ddK29bZl1bMV0qSFsxXVtnXStvW2ZdWzJdKkhbMl1bZ107dVtmXVszXSs9b1tmXVszXX1yZXR1cm4gdX0scm49KHtkVTpvLEpfVV9TOm59KT0+e2NvbnN0IGU9bmV3IGIobiksdD1uZXcgYihvKSxzPWUudHJhbnNwb3NlKCkscj1zLm1tdWwoZSksaT1zLm1tdWwodCk7bGV0IGg7dHJ5e2g9TXQocil9Y2F0Y2h7cmV0dXJuIG51bGx9cmV0dXJuIGgubW11bChpKS50bzFEQXJyYXkoKX0sbG49KHttb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtOm8sbW9kZWxWaWV3VHJhbnNmb3JtOm4scHJvamVjdGlvblRyYW5zZm9ybTplLHdvcmxkQ29vcmQ6dH0pPT57Y29uc3Qgcz1uLHt4OnIseTppLHo6aH09dCxsPUN0KG8scixpKSx1PWwueipsLno7QVswXVswXT1lWzBdWzBdKmwuei91LEFbMF1bMV09ZVswXVsxXSpsLnovdSxBWzBdWzJdPShlWzBdWzJdKmwuei1lWzJdWzJdKmwueCkvdSxBWzFdWzBdPWVbMV1bMF0qbC56L3UsQVsxXVsxXT1lWzFdWzFdKmwuei91LEFbMV1bMl09KGVbMV1bMl0qbC56LWVbMl1bMl0qbC55KS91LE9bMF1bMF09c1swXVsyXSppLE9bMF1bMV09LXNbMF1bMl0qcixPWzBdWzJdPXNbMF1bMV0qci1zWzBdWzBdKmksT1swXVszXT1zWzBdWzBdLE9bMF1bNF09c1swXVsxXSxPWzBdWzVdPXNbMF1bMl0sT1sxXVswXT1zWzFdWzJdKmksT1sxXVsxXT0tc1sxXVsyXSpyLE9bMV1bMl09c1sxXVsxXSpyLXNbMV1bMF0qaSxPWzFdWzNdPXNbMV1bMF0sT1sxXVs0XT1zWzFdWzFdLE9bMV1bNV09c1sxXVsyXSxPWzJdWzBdPXNbMl1bMl0qaSxPWzJdWzFdPS1zWzJdWzJdKnIsT1syXVsyXT1zWzJdWzFdKnItc1syXVswXSppLE9bMl1bM109c1syXVswXSxPWzJdWzRdPXNbMl1bMV0sT1syXVs1XT1zWzJdWzJdO2NvbnN0IGY9W1tdLFtdXTtmb3IobGV0IGc9MDtnPDI7ZysrKWZvcihsZXQgYT0wO2E8NjthKyspe2ZbZ11bYV09MDtmb3IobGV0IGo9MDtqPDM7aisrKWZbZ11bYV0rPUFbZ11bal0qT1tqXVthXX1yZXR1cm4gZn07Y2xhc3MgaG57Y29uc3RydWN0b3Iobil7dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtPW59ZXN0aW1hdGUoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmV9KXtyZXR1cm4gV2Uoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmUscHJvamVjdGlvblRyYW5zZm9ybTp0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm19KX1yZWZpbmVFc3RpbWF0ZSh7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTpuLHdvcmxkQ29vcmRzOmUsc2NyZWVuQ29vcmRzOnR9KXtyZXR1cm4gbm4oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06bix3b3JsZENvb3JkczplLHNjcmVlbkNvb3Jkczp0LHByb2plY3Rpb25UcmFuc2Zvcm06dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtfSl9fWxldCBLdD1udWxsLEp0PSExLEd0PW51bGwsU3Q9bnVsbDtvbm1lc3NhZ2U9bz0+e2NvbnN0e2RhdGE6bn09bztzd2l0Y2gobi50eXBlKXtjYXNlInNldHVwIjpuLnByb2plY3Rpb25UcmFuc2Zvcm0sS3Q9bi5tYXRjaGluZ0RhdGFMaXN0LEp0PW4uZGVidWdNb2RlLEd0PW5ldyBHZShuLmlucHV0V2lkdGgsbi5pbnB1dEhlaWdodCxKdCksU3Q9bmV3IGhuKG4ucHJvamVjdGlvblRyYW5zZm9ybSk7YnJlYWs7Y2FzZSJtYXRjaCI6Y29uc3QgZT1uLnRhcmdldEluZGV4ZXM7bGV0IHQ9LTEscz1udWxsLHI9bnVsbDtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrKyl7Y29uc3QgZz1lW2ZdLHtrZXlmcmFtZUluZGV4OmEsc2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6dyxkZWJ1Z0V4dHJhOnl9PUd0Lm1hdGNoRGV0ZWN0aW9uKEt0W2ddLG4uZmVhdHVyZVBvaW50cyk7aWYocj15LGEhPT0tMSl7Y29uc3QgbT1TdC5lc3RpbWF0ZSh7c2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6d30pO20mJih0PWcscz1tKTticmVha319cG9zdE1lc3NhZ2Uoe3R5cGU6Im1hdGNoRG9uZSIsdGFyZ2V0SW5kZXg6dCxtb2RlbFZpZXdUcmFuc2Zvcm06cyxkZWJ1Z0V4dHJhOnJ9KTticmVhaztjYXNlInRyYWNrVXBkYXRlIjpjb25zdHttb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfT1uLHU9U3QucmVmaW5lRXN0aW1hdGUoe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfSk7cG9zdE1lc3NhZ2Uoe3R5cGU6InRyYWNrVXBkYXRlRG9uZSIsbW9kZWxWaWV3VHJhbnNmb3JtOnV9KTticmVhaztjYXNlImRpc3Bvc2UiOmNsb3NlKCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSB0eXBlICcke24udHlwZX0nYCl9fX0pKCk7Cg==", vg$1 = typeof window < "u" && window.Blob && new Blob([atob(fI)], { type: "text/javascript;charset=utf-8" });
function NU() {
  let n;
  try {
    if (n = vg$1 && (window.URL || window.webkitURL).createObjectURL(vg$1), !n)
      throw "";
    return new Worker(n);
  } catch {
    return new Worker("data:application/javascript;base64," + fI);
  } finally {
    n && (window.URL || window.webkitURL).revokeObjectURL(n);
  }
}
const RU = (n, t) => [
  [
    n[0][0] * t[0][0] + n[0][2] * t[2][0],
    n[0][0] * t[0][1] + n[0][2] * t[2][1],
    n[0][0] * t[0][2] + n[0][2] * t[2][2],
    n[0][0] * t[0][3] + n[0][2] * t[2][3]
  ],
  [
    n[1][1] * t[1][0] + n[1][2] * t[2][0],
    n[1][1] * t[1][1] + n[1][2] * t[2][1],
    n[1][1] * t[1][2] + n[1][2] * t[2][2],
    n[1][1] * t[1][3] + n[1][2] * t[2][3]
  ],
  [
    t[2][0],
    t[2][1],
    t[2][2],
    t[2][3]
  ]
], $U = (n, t, e, s) => {
  const o = n[0][0] * t + n[0][1] * e + n[0][3], r = n[1][0] * t + n[1][1] * e + n[1][3], i6 = n[2][0] * t + n[2][1] * e + n[2][3];
  return { x: o, y: r, z: i6 };
}, GU = (n, t, e, s) => {
  const { x: o, y: r, z: i6 } = $U(n, t, e);
  return { x: o / i6, y: r / i6 };
}, EU = 6, LU = 1, MU = 10, WU = 1, DU = 0.8, FU = 1, _n$1 = 1e3;
class VU {
  constructor(t, e, s, o, r, i6 = false) {
    this.markerDimensions = t, this.trackingDataList = e, this.projectionTransform = s, this.debugMode = i6, this.trackingKeyframeList = [];
    for (let l = 0; l < e.length; l++)
      this.trackingKeyframeList.push(e[l][FU]);
    let a = 0;
    for (let l = 0; l < this.trackingKeyframeList.length; l++)
      a = Math.max(a, this.trackingKeyframeList[l].points.length);
    this.featurePointsListT = [], this.imagePixelsListT = [], this.imagePropertiesListT = [];
    for (let l = 0; l < this.trackingKeyframeList.length; l++) {
      const { featurePoints: c, imagePixels: u, imageProperties: d } = this._prebuild(this.trackingKeyframeList[l], a);
      this.featurePointsListT[l] = c, this.imagePixelsListT[l] = u, this.imagePropertiesListT[l] = d;
    }
    this.kernelCaches = {};
  }
  dummyRun(t) {
    let e = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]];
    for (let s = 0; s < this.featurePointsListT.length; s++)
      this.track(t, e, s);
  }
  track(t, e, s) {
    let o = {};
    const r = RU(this.projectionTransform, e), i6 = this._buildAdjustedModelViewTransform(r);
    this.markerDimensions[s][0], this.markerDimensions[s][1], this.trackingKeyframeList[s].width, this.trackingKeyframeList[s].height;
    const a = this.featurePointsListT[s], l = this.imagePixelsListT[s], c = this.imagePropertiesListT[s], u = this._computeProjection(i6, t, s), { matchingPointsT: d, simT: h6 } = this._computeMatching(a, l, c, u), p6 = d.arraySync(), f = h6.arraySync(), m = this.trackingKeyframeList[s], g6 = [], b6 = [], x6 = [];
    for (let w6 = 0; w6 < p6.length; w6++)
      if (f[w6] > DU && w6 < m.points.length) {
        x6.push(w6);
        const y6 = GU(r, p6[w6][0], p6[w6][1]);
        b6.push(y6), g6.push({ x: m.points[w6].x / m.scale, y: m.points[w6].y / m.scale, z: 0 });
      }
    return this.debugMode && (o = {
      projectedImage: u.arraySync(),
      matchingPoints: d.arraySync(),
      goodTrack: x6,
      trackedPoints: b6
    }), i6.dispose(), u.dispose(), d.dispose(), h6.dispose(), { worldCoords: g6, screenCoords: b6, debugExtra: o };
  }
  _computeMatching(t, e, s, o) {
    const r = EU, i6 = r * 2 + 1, l = MU * LU, c = WU, u = l * 2 + 1, d = o.shape[0], h6 = o.shape[1], p6 = t.shape[0];
    if (!this.kernelCaches.computeMatching) {
      const f = {
        variableNames: ["features", "markerPixels", "markerProperties", "targetPixels"],
        outputShape: [p6, u * u],
        userCode: `
	  void main() {
	    ivec2 coords = getOutputCoords();

	    int featureIndex = coords[0];
	    int searchOffsetIndex = coords[1];

	    int markerWidth = int(getMarkerProperties(0));
	    int markerHeight = int(getMarkerProperties(1));
	    float markerScale = getMarkerProperties(2);

	    int searchOffsetX = imod(searchOffsetIndex, ${u}) * ${c};
	    int searchOffsetY = searchOffsetIndex / ${u} * ${c};

	    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);
	    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);

	    int sx = sCenterX + searchOffsetX - ${l};
	    int sy = sCenterY + searchOffsetY - ${l};

	    if (sx < ${r} || sx >= (${h6} - ${r}) || sy < ${r} || sy >= (${d} - ${r})) {
	      setOutput(-2.);
	    } 
	    else {
	      float sumPoint = 0.;
	      float sumPointSquare = 0.;
	      float sumTemplate = 0.;
	      float sumTemplateSquare = 0.;
	      float sumPointTemplate = 0.;

	      for (int templateOffsetY = 0; templateOffsetY < ${i6}; templateOffsetY++) {
		for (int templateOffsetX = 0; templateOffsetX < ${i6}; templateOffsetX++) {
		  int fx2 = sCenterX + templateOffsetX - ${r};
		  int fy2 = sCenterY + templateOffsetY - ${r};

		  int sx2 = sx + templateOffsetX - ${r};
		  int sy2 = sy + templateOffsetY - ${r};

		  int markerPixelIndex = fy2 * markerWidth + fx2;
		  float markerPixel = getMarkerPixels(markerPixelIndex);
		  float targetPixel = getTargetPixels(sy2, sx2);

		  sumTemplate += markerPixel;
		  sumTemplateSquare += markerPixel * markerPixel;
		  sumPoint += targetPixel;
		  sumPointSquare += targetPixel * targetPixel;
		  sumPointTemplate += targetPixel * markerPixel;
		}
	      }

	      // Normalized cross-correlation
	      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)
	      float count = float(${i6} * ${i6});
	      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);
	      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);

	      if (pointVariance < 0.0000001) {
		setOutput(-3.);
	      } else if (templateVariance < 0.0000001) {
		//setOutput(sumTemplate);
		setOutput(-4.);
	      } else {
		sumPointTemplate -= sumPoint / count * sumTemplate;
		float sim = sumPointTemplate / pointVariance / templateVariance;  
		setOutput(sim);
	      }
	    }
	  }
	`
      }, m = {
        variableNames: ["featurePoints", "markerProperties", "maxIndex"],
        outputShape: [p6, 2],
        // [x, y]
        userCode: `
	  void main() {
	    ivec2 coords = getOutputCoords();

	    float markerScale = getMarkerProperties(2);

	    int featureIndex = coords[0];

	    int maxIndex = int(getMaxIndex(featureIndex));
	    int searchLocationIndex = maxIndex / ${u * u};
	    int searchOffsetIndex = imod(maxIndex, ${u * u});

	    if (coords[1] == 0) {
	      int searchOffsetX = imod(searchOffsetIndex, ${u}) * ${c};
	      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - ${l}) / markerScale);
	    }
	    else if (coords[1] == 1) {
	      int searchOffsetY = searchOffsetIndex / ${u} * ${c};
	      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - ${l}) / markerScale);
	    }
	  }
	`
      }, g6 = {
        variableNames: ["sims", "maxIndex"],
        outputShape: [p6],
        userCode: `
	  void main() {
	    int featureIndex = getOutputCoords();
	    int maxIndex = int(getMaxIndex(featureIndex));
	    setOutput(getSims(featureIndex, maxIndex));
	  }
	`
      };
      this.kernelCaches.computeMatching = [f, m, g6];
    }
    return D(() => {
      const f = this.kernelCaches.computeMatching, m = this._compileAndRun(f[0], [t, e, s, o]), g6 = m.argMax(1), b6 = this._compileAndRun(f[1], [t, s, g6]), x6 = this._compileAndRun(f[2], [m, g6]);
      return { matchingPointsT: b6, simT: x6 };
    });
  }
  _computeProjection(t, e, s) {
    const o = this.trackingKeyframeList[s].width, r = this.trackingKeyframeList[s].height, i6 = this.trackingKeyframeList[s].scale, a = o + "-" + r + "-" + i6;
    if (this.kernelCaches.computeProjection || (this.kernelCaches.computeProjection = {}), !this.kernelCaches.computeProjection[a]) {
      const l = {
        variableNames: ["M", "pixel"],
        outputShape: [r, o],
        userCode: `
	  void main() {
	      ivec2 coords = getOutputCoords();

	      float m00 = getM(0, 0) * ${_n$1}.;
	      float m01 = getM(0, 1) * ${_n$1}.;
	      float m03 = getM(0, 3) * ${_n$1}.;
	      float m10 = getM(1, 0) * ${_n$1}.;
	      float m11 = getM(1, 1) * ${_n$1}.;
	      float m13 = getM(1, 3) * ${_n$1}.;
	      float m20 = getM(2, 0) * ${_n$1}.;
	      float m21 = getM(2, 1) * ${_n$1}.;
	      float m23 = getM(2, 3) * ${_n$1}.;

	      float y = float(coords[0]) / float(${i6});
	      float x = float(coords[1]) / float(${i6});
	      float uz = (x * m20) + (y * m21) + m23;
	      float oneOverUz = 1. / uz;

	      float ux = (x * m00) + (y * m01) + m03;
	      float uy = (x * m10) + (y * m11) + m13;

	      ux = floor(ux * oneOverUz + 0.5);
	      uy = floor(uy * oneOverUz + 0.5);
	      setOutput(getPixel(int(uy), int(ux)));
	    }
	`
      };
      this.kernelCaches.computeProjection[a] = l;
    }
    return D(() => {
      const l = this.kernelCaches.computeProjection[a];
      return this._compileAndRun(l, [t, e]);
    });
  }
  _buildAdjustedModelViewTransform(t) {
    return D(() => {
      let e = [];
      for (let o = 0; o < t.length; o++) {
        e.push([]);
        for (let r = 0; r < t[o].length; r++)
          e[o].push(t[o][r] / _n$1);
      }
      return Re$1(e, [3, 4]);
    });
  }
  _prebuild(t, e) {
    return D(() => {
      const s = t.scale, o = [];
      for (let l = 0; l < e; l++)
        l < t.points.length ? o.push([t.points[l].x / s, t.points[l].y / s]) : o.push([-1, -1]);
      const r = Re$1(t.data, [t.width * t.height]), i6 = Re$1([t.width, t.height, t.scale], [3]);
      return {
        featurePoints: Re$1(o, [o.length, 2], "float32"),
        imagePixels: r,
        imageProperties: i6
      };
    });
  }
  _compileAndRun(t, e) {
    const s = $s().compileAndRun(t, e);
    return Xt().makeTensorFromDataId(s.dataId, s.shape, s.dtype);
  }
}
const _a = [
  // ring 5
  {
    sigma: 0.55,
    points: [
      [-1, 0],
      [-0.5, -0.866025],
      [0.5, -0.866025],
      [1, -0],
      [0.5, 0.866025],
      [-0.5, 0.866025]
    ]
  },
  // ring 4
  {
    sigma: 0.475,
    points: [
      [0, 0.930969],
      [-0.806243, 0.465485],
      [-0.806243, -0.465485],
      [-0, -0.930969],
      [0.806243, -0.465485],
      [0.806243, 0.465485]
    ]
  },
  // ring 3
  {
    sigma: 0.4,
    points: [
      [0.847306, -0],
      [0.423653, 0.733789],
      [-0.423653, 0.733789],
      [-0.847306, 0],
      [-0.423653, -0.733789],
      [0.423653, -0.733789]
    ]
  },
  // ring 2
  {
    sigma: 0.325,
    points: [
      [-0, -0.741094],
      [0.641806, -0.370547],
      [0.641806, 0.370547],
      [0, 0.741094],
      [-0.641806, 0.370547],
      [-0.641806, -0.370547]
    ]
  },
  // ring 1
  {
    sigma: 0.25,
    points: [
      [-0.595502, 0],
      [-0.297751, -0.51572],
      [0.297751, -0.51572],
      [0.595502, -0],
      [0.297751, 0.51572],
      [-0.297751, 0.51572]
    ]
  },
  // ring 0
  {
    sigma: 0.175,
    points: [
      [0, 0.362783],
      [-0.314179, 0.181391],
      [-0.314179, -0.181391],
      [-0, -0.362783],
      [0.314179, -0.181391],
      [0.314179, 0.181391]
    ]
  },
  // center
  {
    sigma: 0.1,
    points: [
      [0, 0]
    ]
  }
], Eo = [];
for (let n = 0; n < _a.length; n++) {
  const t = _a[n].sigma;
  for (let e = 0; e < _a[n].points.length; e++) {
    const s = _a[n].points[e];
    Eo.push([t, s[0], s[1]]);
  }
}
const Fu = {};
function zU(n) {
  const t = n.shape[1], e = n.shape[0], s = "w" + t + "h" + e;
  if (!Fu.hasOwnProperty(s)) {
    const o = {
      variableNames: ["p"],
      outputShape: [e, t],
      userCode: `
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0], coords[1]-2);
          sum += getP(coords[0], coords[1]-1) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0], coords[1]+1) * 4.;
          sum += getP(coords[0], coords[1]+2);
          setOutput(sum);
        }
      `
    }, r = {
      variableNames: ["p"],
      outputShape: [e, t],
      userCode: `
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0]-2, coords[1]);
          sum += getP(coords[0]-1, coords[1]) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0]+1, coords[1]) * 4.;
          sum += getP(coords[0]+2, coords[1]);
          sum /= 256.;
          setOutput(sum);
        }
      `
    };
    Fu[s] = [o, r];
  }
  return Fu[s];
}
const XU = (n) => {
  const t = n.inputs.image, e = n.backend, [s, o] = zU(t), r = e.runWebGLProgram(s, [t], t.dtype), i6 = e.runWebGLProgram(o, [r], t.dtype);
  return e.disposeIntermediateTensorInfo(r), i6;
}, PU = {
  //: KernelConfig
  kernelName: "BinomialFilter",
  backendName: "webgl",
  kernelFunc: XU
  // as {} as KernelFunc,
}, Ua = 7, Sg$1 = 3, AU = Sg$1 * Sg$1, Vu = 4, OU = (Vu + 1) * (Vu + 1) / Vu, zu = {};
function KU(n) {
  const t = n.shape[1], e = n.shape[0], s = "w" + t + "h" + e;
  if (!zu.hasOwnProperty(s)) {
    const o = {
      variableNames: ["image0", "image1", "image2"],
      outputShape: [e, t],
      userCode: `
        void main() {
          ivec2 coords = getOutputCoords();
    
          int y = coords[0];
          int x = coords[1];
    
          float value = getImage1(y, x);
    
          // Step 1: find local maxima/minima
          if (value * value < ${AU}.) {
            setOutput(0.);
            return;
          }
          if (y < ${Ua} || y > ${e - 1 - Ua}) {
            setOutput(0.);
            return;
          }
          if (x < ${Ua} || x > ${t - 1 - Ua}) {
            setOutput(0.);
            return;
          }
    
          bool isMax = true;
          bool isMin = true;
          for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
              float value0 = getImage0(y+dy, x+dx);
              float value1 = getImage1(y+dy, x+dx);
              float value2 = getImage2(y+dy, x+dx);
    
        if (value < value0 || value < value1 || value < value2) {
          isMax = false;
        }
        if (value > value0 || value > value1 || value > value2) {
          isMin = false;
        }
            }
          }
    
          if (!isMax && !isMin) {
            setOutput(0.);
            return;
          }
    
          // compute edge score and reject based on threshold
          float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);
          float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);
          float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));
    
          float det = (dxx * dyy) - (dxy * dxy);
    
          if (abs(det) < 0.0001) { // determinant undefined. no solution
            setOutput(0.);
            return;
          }
    
          float edgeScore = (dxx + dyy) * (dxx + dyy) / det;
    
          if (abs(edgeScore) >= ${OU} ) {
            setOutput(0.);
            return;
          }
          setOutput(getImage1(y,x));
        }
      `
    };
    zu[s] = o;
  }
  return zu[s];
}
const ZU = (n) => {
  let { image0: t, image1: e, image2: s } = n.inputs;
  const o = n.backend, r = KU(e);
  return t = Xt().runKernel("DownsampleBilinear", { image: t }), s = Xt().runKernel("UpsampleBilinear", { image: s, targetImage: e }), o.runWebGLProgram(r, [t, e, s], e.dtype);
}, BU = {
  //: KernelConfig
  kernelName: "BuildExtremas",
  backendName: "webgl",
  kernelFunc: ZU
  // as {} as KernelFunc,
}, Fr = 36, Xu = {};
function HU(n) {
  const t = n.shape[0];
  if (!Xu.hasOwnProperty(t)) {
    const e = {
      variableNames: ["histogram"],
      outputShape: [n.shape[0]],
      userCode: `
            void main() {
                int featureIndex = getOutputCoords();

                int maxIndex = 0;
                for (int i = 1; i < ${Fr}; i++) {
                    if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {
                        maxIndex = i;
                    }
                }

                int prev = imod(maxIndex - 1 + ${Fr}, ${Fr});
                int next = imod(maxIndex + 1, ${Fr});

                /**
                 * Fit a quatratic to 3 points. The system of equations is:
                 *
                 * y0 = A*x0^2 + B*x0 + C
                 * y1 = A*x1^2 + B*x1 + C
                 * y2 = A*x2^2 + B*x2 + C
                 *
                 * This system of equations is solved for A,B,C.
                 */
                float p10 = float(maxIndex - 1);
                float p11 = getHistogram(featureIndex, prev); 
                float p20 = float(maxIndex);
                float p21 = getHistogram(featureIndex, maxIndex); 
                float p30 = float(maxIndex + 1);
                float p31 = getHistogram(featureIndex, next); 

                float d1 = (p30-p20)*(p30-p10);
                float d2 = (p10-p20)*(p30-p10);
                float d3 = p10-p20;

                // If any of the denominators are zero then, just use maxIndex.
                    float fbin = float(maxIndex);
                if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {
                float a = p10*p10;
                float b = p20*p20;

                // Solve for the coefficients A,B,C
                float A = ((p31-p21)/d1)-((p11-p21)/d2);
                float B = ((p11-p21)+(A*(b-a)))/d3;
                float C = p11-(A*a)-(B*p10);
                fbin = -B / (2. * A);
                }

                float an = 2.0 *${Math.PI} * (fbin + 0.5) / ${Fr}. - ${Math.PI};
                setOutput(an);
            }
            `
    };
    Xu[t] = e;
  }
  return Xu[t];
}
const _U = (n) => {
  const { histograms: t } = n.inputs, e = n.backend, s = HU(t);
  return e.runWebGLProgram(s, [t], t.dtype);
}, UU = {
  //: KernelConfig
  kernelName: "ComputeExtremaAngles",
  backendName: "webgl",
  kernelFunc: _U
  // as {} as KernelFunc,
}, kg$1 = 7, Pu = {};
function YU(n, t) {
  const e = `${n}|${t.shape[0]}`;
  if (!Pu.hasOwnProperty(e)) {
    const s = [];
    for (let i6 = 1; i6 < n; i6++)
      s.push("image" + i6);
    let o = "float getPixel(int octave, int y, int x) {";
    for (let i6 = 1; i6 < n; i6++)
      o += `
  if (octave == ${i6}) {
	return getImage${i6}(y, x);
  }
`;
    o += "}";
    const r = {
      variableNames: [...s, "extrema", "angles", "freakPoints"],
      outputShape: [t.shape[0], Eo.length],
      userCode: `
  ${o}
  void main() {
	ivec2 coords = getOutputCoords();
	int featureIndex = coords[0];
	int freakIndex = coords[1];

	float freakSigma = getFreakPoints(freakIndex, 0);
	float freakX = getFreakPoints(freakIndex, 1);
	float freakY = getFreakPoints(freakIndex, 2);

	int octave = int(getExtrema(featureIndex, 1));
	float inputY = getExtrema(featureIndex, 2);
	float inputX = getExtrema(featureIndex, 3);
	float inputAngle = getAngles(featureIndex);
	float cos = ${kg$1}. * cos(inputAngle);
	float sin = ${kg$1}. * sin(inputAngle);

	float yp = inputY + freakX * sin + freakY * cos;
	float xp = inputX + freakX * cos + freakY * -sin;

	int x0 = int(floor(xp));
	int x1 = x0 + 1;
	int y0 = int(floor(yp));
	int y1 = y0 + 1;

	float f1 = getPixel(octave, y0, x0);
	float f2 = getPixel(octave, y0, x1);
	float f3 = getPixel(octave, y1, x0);
	float f4 = getPixel(octave, y1, x1);

	float x1f = float(x1);
	float y1f = float(y1);
	float x0f = float(x0);
	float y0f = float(y0);

	// ratio for interpolation between four neighbouring points
	float value = (x1f - xp) * (y1f - yp) * f1
		+ (xp - x0f) * (y1f - yp) * f2
		+ (x1f - xp) * (yp - y0f) * f3
		+ (xp - x0f) * (yp - y0f) * f4;

	setOutput(value);
  }
`
    };
    Pu[e] = r;
  }
  return Pu[e];
}
const QU = (n) => {
  const { gaussianImagesT: t, prunedExtremas: e, prunedExtremasAngles: s, freakPointsT: o, pyramidImagesLength: r } = n.inputs, i6 = n.backend, a = YU(r, e);
  return i6.runWebGLProgram(a, [...t, e, s, o], "float32");
}, JU = {
  //: KernelConfig
  kernelName: "ComputeExtremaFreak",
  backendName: "webgl",
  kernelFunc: QU
  // as {} as KernelFunc,
}, mI = (Eo.length - 1) * Eo.length / 2, jU = Math.ceil(mI / 8), Au = {};
function qU(n) {
  const t = `${n.shape[0]}`;
  if (!Au.hasOwnProperty(t)) {
    const e = {
      variableNames: ["freak", "p"],
      outputShape: [n.shape[0], jU],
      userCode: `
  void main() {
    ivec2 coords = getOutputCoords();
    int featureIndex = coords[0];
    int descIndex = coords[1] * 8;

    int sum = 0;
    for (int i = 0; i < 8; i++) {
      if (descIndex + i >= ${mI}) {
        continue;
      }

      int p1 = int(getP(descIndex + i, 0));
      int p2 = int(getP(descIndex + i, 1));

      float v1 = getFreak(featureIndex, p1);
      float v2 = getFreak(featureIndex, p2);

      if (v1 < v2 + 0.01) {
        sum += int(pow(2.0, float(7 - i)));
      }
    }
    setOutput(float(sum));
  }
`
    };
    Au[t] = e;
  }
  return Au[t];
}
const t5 = (n) => {
  const { extremaFreaks: t, positionT: e } = n.inputs, { backend: s } = n, o = qU(t);
  return s.runWebGLProgram(o, [t, e], "int32");
}, e5 = {
  //: KernelConfig
  kernelName: "ComputeFreakDescriptors",
  backendName: "webgl",
  kernelFunc: t5
  // as {} as KernelFunc,
}, Ou = {};
function n5(n, t) {
  const e = `${n}|${t}`;
  if (!Ou.hasOwnProperty(e)) {
    const s = [];
    let o = "float getPixel(int octave, int y, int x) {";
    for (let r = 1; r < n; r++)
      s.push("image" + r), o += `
				if (octave == ${r}) {
					return getImage${r}(y, x);
				}
			`;
    o += "}", Ou[e] = {
      variableNames: [...s, "extrema"],
      outputShape: [t, 3, 3],
      // 3x3 pixels around the extrema
      userCode: `
			${o}
		
			void main() {
				ivec3 coords = getOutputCoords();
				int featureIndex = coords[0];
				float score = getExtrema(featureIndex, 0);
				if (score == 0.0) {
					return;
				}
		
				int dy = coords[1]-1;
				int dx = coords[2]-1;
				int octave = int(getExtrema(featureIndex, 1));
				int y = int(getExtrema(featureIndex, 2));
				int x = int(getExtrema(featureIndex, 3));
				setOutput(getPixel(octave, y+dy, x+dx));
			}
			`
    };
  }
  return Ou[e];
}
const s5 = (n) => {
  const { prunedExtremasList: t, dogPyramidImagesT: e } = n.inputs, s = n.backend, o = n5(e.length, t.length), r = Re$1(t, [t.length, t[0].length], "int32");
  return s.runWebGLProgram(o, [...e.slice(1), r], e[0].dtype);
}, o5 = {
  //: KernelConfig
  kernelName: "ComputeLocalization",
  backendName: "webgl",
  kernelFunc: s5
  // as {} as KernelFunc,
}, r5 = 0.159154943091895, Ho = 36, Ku = {};
function i5(n, t, e) {
  const s = `${e}|${n.shape[0]}|${t.shape[0]}`;
  if (!Ku.hasOwnProperty(s)) {
    const o = [];
    for (let l = 1; l < e; l++)
      o.push("image" + l);
    let r = "float getPixel(int octave, int y, int x) {";
    for (let l = 1; l < e; l++)
      r += `
            if (octave == ${l}) {
                return getImage${l}(y, x);
            }
            `;
    r += "}";
    const i6 = {
      variableNames: [...o, "extrema", "radial"],
      outputShape: [n.shape[0], t.shape[0], 2],
      // last dimension: [fbin, magnitude]
      userCode: `
                ${r}

                void main() {
                    ivec3 coords = getOutputCoords();
                    int featureIndex = coords[0];
                    int radialIndex = coords[1];
                    int propertyIndex = coords[2];

                    int radialY = int(getRadial(radialIndex, 0));
                    int radialX = int(getRadial(radialIndex, 1));
                    float radialW = getRadial(radialIndex, 2);

                    int octave = int(getExtrema(featureIndex, 1));
                    int y = int(getExtrema(featureIndex, 2));
                    int x = int(getExtrema(featureIndex, 3));

                    int xp = x + radialX;
                    int yp = y + radialY;

                    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);
                    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);

                    if (propertyIndex == 0) {
                    // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0
                    
                    float angle = atan(dy, dx) + ${Math.PI};
                    float fbin = angle * ${Ho}. * ${r5};
                    setOutput(fbin);
                    return;
                    }

                    if (propertyIndex == 1) {
                        float mag = sqrt(dx * dx + dy * dy);
                        float magnitude = radialW * mag;
                        setOutput(magnitude);
                        return;
                    }
                }

                `
    }, a = {
      variableNames: ["fbinMag"],
      outputShape: [n.shape[0], Ho],
      userCode: `
            void main() {
                ivec2 coords = getOutputCoords();
                int featureIndex = coords[0];
                int binIndex = coords[1];

                float sum = 0.;
                for (int i = 0; i < ${t.shape[0]}; i++) {
                    float fbin = getFbinMag(featureIndex, i, 0);
                    int bin = int(floor(fbin - 0.5));
                    int b1 = imod(bin + ${Ho}, ${Ho});
                    int b2 = imod(bin + 1 + ${Ho}, ${Ho});

                    if (b1 == binIndex || b2 == binIndex) {
                        float magnitude = getFbinMag(featureIndex, i, 1);
                        float w2 = fbin - float(bin) - 0.5;
                        float w1 = w2 * -1. + 1.;

                        if (b1 == binIndex) {
                            sum += w1 * magnitude;
                        }
                        if (b2 == binIndex) {
                            sum += w2 * magnitude;
                        }
                    }
                }
                setOutput(sum);
            }
            `
    };
    Ku[s] = [i6, a];
  }
  return Ku[s];
}
const a5 = (n) => {
  const { gaussianImagesT: t, prunedExtremasT: e, radialPropertiesT: s, pyramidImagesLength: o } = n.inputs, r = n.backend, [i6, a] = i5(e, s, o), l = r.runWebGLProgram(i6, [...t, e, s], s.dtype), c = r.runWebGLProgram(a, [l], s.dtype);
  return r.disposeIntermediateTensorInfo(l), c;
}, l5 = {
  kernelName: "ComputeOrientationHistograms",
  backendName: "webgl",
  kernelFunc: a5
  // as {} as KernelFunc,
}, Zu = {};
function c5(n) {
  const t = n.shape[1], e = n.shape[0], s = "w" + t + "h" + e;
  if (!Zu.hasOwnProperty(s)) {
    const o = {
      variableNames: ["p"],
      outputShape: [Math.floor(e / 2), Math.floor(t / 2)],
      userCode: `
            void main() {
                ivec2 coords = getOutputCoords();
                int y = coords[0] * 2;
                int x = coords[1] * 2;
        
                float sum = getP(y, x) * 0.25;
                sum += getP(y+1,x) * 0.25; 
                sum += getP(y, x+1) * 0.25; 
                sum += getP(y+1,x+1) * 0.25;
                setOutput(sum);
            }
            `
    };
    Zu[s] = o;
  }
  return Zu[s];
}
const u5 = (n) => {
  const t = n.inputs.image, e = n.backend, s = c5(t);
  return e.runWebGLProgram(s, [t], t.dtype);
}, d5 = {
  //: KernelConfig
  kernelName: "DownsampleBilinear",
  backendName: "webgl",
  kernelFunc: u5
  // as {} as KernelFunc,
}, h5 = (n) => {
  const { extremasResultT: t } = n.inputs, e = n.backend, s = t.shape[0], o = t.shape[1], r = {
    variableNames: ["extrema"],
    outputShape: [Math.floor(s / 2), Math.floor(o / 2)],
    userCode: `
		  void main() {
			ivec2 coords = getOutputCoords();
			int y = coords[0] * 2;
			int x = coords[1] * 2;
  
			float location = 0.0;
			float values = getExtrema(y, x);
  
			if (getExtrema(y+1, x) != 0.0) {
			  location = 1.0;
		  values = getExtrema(y+1, x);
			}
			else if (getExtrema(y, x+1) != 0.0) {
			  location = 2.0;
		  values = getExtrema(y, x+1);
			}
			else if (getExtrema(y+1, x+1) != 0.0) {
			  location = 3.0;
		  values = getExtrema(y+1, x+1);
			}
  
			if (values < 0.0) {
			  setOutput(location * -1000.0 + values);
			} else {
			  setOutput(location * 1000.0 + values);
			}
		  }
		`
  };
  return e.runWebGLProgram(r, [t], t.dtype);
}, p5 = {
  //: KernelConfig
  kernelName: "ExtremaReduction",
  backendName: "webgl",
  kernelFunc: h5
  // as {} as KernelFunc,
}, Ya = 36, f5 = 5, Bu = {};
function m5(n) {
  const t = `h${n.shape[0]}`;
  if (!Bu.hasOwnProperty(t)) {
    const e = {
      variableNames: ["histogram"],
      outputShape: [n.shape[0], Ya],
      userCode: `
            void main() {
                ivec2 coords = getOutputCoords();

                int featureIndex = coords[0];
                int binIndex = coords[1];

                int prevBin = imod(binIndex - 1 + ${Ya}, ${Ya});
                int nextBin = imod(binIndex + 1, ${Ya});
                float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);

                setOutput(result);
            }
            `
    };
    Bu[t] = e;
  }
  return Bu[t];
}
const g5 = (n) => {
  let { histograms: t } = n.inputs;
  const e = n.backend, s = m5(t);
  for (let o = 0; o < f5; o++) {
    const r = t;
    t = e.runWebGLProgram(s, [t], t.dtype), o > 0 && e.disposeIntermediateTensorInfo(r);
  }
  return t;
}, b5 = {
  //: KernelConfig
  kernelName: "SmoothHistograms",
  backendName: "webgl",
  kernelFunc: g5
  // as {} as KernelFunc,
}, Hu = {};
function x5(n, t) {
  const e = t.shape[1], s = t.shape[0], o = "w" + e + "h" + s;
  if (!Hu.hasOwnProperty(o)) {
    const r = {
      variableNames: ["p"],
      outputShape: [s, e],
      userCode: `
              void main() {
                ivec2 coords = getOutputCoords();
                int j = coords[0];
                int i = coords[1];
        
                float sj = 0.5 * float(j) - 0.25; 
                float si = 0.5 * float(i) - 0.25;
        
                float sj0 = floor(sj);
                float sj1 = ceil(sj);
                float si0 = floor(si);
                float si1 = ceil(si);
        
                int sj0I = int(sj0);
                int sj1I = int(sj1);
                int si0I = int(si0);
                int si1I = int(si1);
        
                float sum = 0.0;
                sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);
                sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);
                sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);
                sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);
                setOutput(sum);
              }
            `
    };
    Hu[o] = r;
  }
  return Hu[o];
}
const y5 = (n) => {
  const { image: t, targetImage: e } = n.inputs, s = n.backend, o = x5(t, e);
  return s.runWebGLProgram(o, [t], t.dtype);
}, w5 = {
  //: KernelConfig
  kernelName: "UpsampleBilinear",
  backendName: "webgl",
  kernelFunc: y5
  // as {} as KernelFunc,
};
en$1(PU);
en$1(BU);
en$1(UU);
en$1(JU);
en$1(e5);
en$1(o5);
en$1(l5);
en$1(d5);
en$1(p5);
en$1(b5);
en$1(w5);
const Tg$1 = 8, I5 = 5, Vr = 10, C5 = 5, _u = 3, v5 = 1.5;
(Eo.length - 1) * Eo.length / 2;
class gI {
  constructor(t, e, s = false) {
    this.debugMode = s, this.width = t, this.height = e;
    let o = 0;
    for (; t >= Tg$1 && e >= Tg$1 && (t /= 2, e /= 2, o++, o !== I5); )
      ;
    this.numOctaves = o, this.tensorCaches = {}, this.kernelCaches = {};
  }
  // used in compiler
  detectImageData(t) {
    const e = new Uint8ClampedArray(4 * t.length);
    for (let o = 0; o < t.length; o++)
      e[4 * o] = t[o], e[4 * o + 1] = t[o], e[4 * o + 2] = t[o], e[4 * o + 3] = 255;
    const s = new ImageData(e, this.width, this.height);
    return this.detect(s);
  }
  /**
   * 
   * @param {tf.Tensor<tf.Rank>} inputImageT 
   * @returns 
   */
  detect(t) {
    let e = null;
    const s = [];
    for (let b6 = 0; b6 < this.numOctaves; b6++) {
      let x6, w6;
      b6 === 0 ? x6 = this._applyFilter(t) : x6 = this._downsampleBilinear(s[b6 - 1][s[b6 - 1].length - 1]), w6 = this._applyFilter(x6), s.push([x6, w6]);
    }
    const o = [];
    for (let b6 = 0; b6 < this.numOctaves; b6++) {
      let x6 = this._differenceImageBinomial(s[b6][0], s[b6][1]);
      o.push(x6);
    }
    const r = [];
    for (let b6 = 1; b6 < this.numOctaves - 1; b6++) {
      const x6 = this._buildExtremas(o[b6 - 1], o[b6], o[b6 + 1]);
      r.push(x6);
    }
    const i6 = this._applyPrune(r), a = this._computeLocalization(i6, o), l = this._computeOrientationHistograms(a, s), c = this._smoothHistograms(l), u = this._computeExtremaAngles(c), d = this._computeExtremaFreak(s, a, u), h6 = this._computeFreakDescriptors(d), p6 = a.arraySync(), f = u.arraySync(), m = h6.arraySync();
    this.debugMode && (e = {
      pyramidImages: s.map((b6) => b6.map((x6) => x6.arraySync())),
      dogPyramidImages: o.map((b6) => b6 ? b6.arraySync() : null),
      extremasResults: r.map((b6) => b6.arraySync()),
      extremaAngles: u.arraySync(),
      prunedExtremas: i6,
      localizedExtremas: a.arraySync()
    }), s.forEach((b6) => b6.forEach((x6) => x6.dispose())), o.forEach((b6) => b6 && b6.dispose()), r.forEach((b6) => b6.dispose()), a.dispose(), l.dispose(), c.dispose(), u.dispose(), d.dispose(), h6.dispose();
    const g6 = [];
    for (let b6 = 0; b6 < p6.length; b6++) {
      if (p6[b6][0] == 0)
        continue;
      const x6 = [];
      for (let N = 0; N < m[b6].length; N += 4) {
        const R = m[b6][N], M6 = m[b6][N + 1], V = m[b6][N + 2], z = m[b6][N + 3];
        let X = R * 16777216 + M6 * 65536 + V * 256 + z;
        x6.push(X);
      }
      const w6 = p6[b6][1], y6 = p6[b6][2], C6 = p6[b6][3] * Math.pow(2, w6) + Math.pow(2, w6 - 1) - 0.5, k7 = y6 * Math.pow(2, w6) + Math.pow(2, w6 - 1) - 0.5, S = Math.pow(2, w6);
      g6.push({
        maxima: p6[b6][0] > 0,
        x: C6,
        y: k7,
        scale: S,
        angle: f[b6],
        descriptors: x6
      });
    }
    return { featurePoints: g6, debugExtra: e };
  }
  _computeFreakDescriptors(t) {
    if (!this.tensorCaches.computeFreakDescriptors) {
      const s = [], o = [];
      for (let a = 0; a < t.shape[1]; a++)
        for (let l = a + 1; l < t.shape[1]; l++)
          s.push(a), o.push(l);
      const r = Re$1(s, [s.length]).cast("int32"), i6 = Re$1(o, [o.length]).cast("int32");
      this.tensorCaches.computeFreakDescriptors = {
        positionT: cn$1(os([r, i6], 1))
      };
    }
    const { positionT: e } = this.tensorCaches.computeFreakDescriptors;
    return D(() => Xt().runKernel("ComputeFreakDescriptors", { extremaFreaks: t, positionT: e }));
  }
  _computeExtremaFreak(t, e, s) {
    this.tensorCaches._computeExtremaFreak || D(() => {
      const i6 = Re$1(Eo);
      this.tensorCaches._computeExtremaFreak = {
        freakPointsT: cn$1(i6)
      };
    });
    const { freakPointsT: o } = this.tensorCaches._computeExtremaFreak, r = [];
    for (let i6 = 1; i6 < t.length; i6++)
      r.push(t[i6][1]);
    return D(() => Xt().runKernel("ComputeExtremaFreak", { gaussianImagesT: r, prunedExtremas: e, prunedExtremasAngles: s, freakPointsT: o, pyramidImagesLength: t.length }));
  }
  /**
   * 
   * @param {tf.Tensor<tf.Rank>} histograms 
   * @returns 
   */
  _computeExtremaAngles(t) {
    return D(() => Xt().runKernel("ComputeExtremaAngles", { histograms: t }));
  }
  // TODO: maybe can try just using average momentum, instead of histogram method. histogram might be overcomplicated
  /**
   * 
   * @param {tf.Tensor<tf.Rank>} prunedExtremasT 
   * @param {tf.Tensor<tf.Rank>[]} pyramidImagesT 
   * @returns 
   */
  _computeOrientationHistograms(t, e) {
    const s = [];
    for (let r = 1; r < e.length; r++)
      s.push(e[r][1]);
    this.tensorCaches.orientationHistograms || D(() => {
      const r = -1 / (2 * _u * _u), i6 = _u * v5, a = Math.ceil(i6), l = [];
      for (let c = -a; c <= a; c++)
        for (let u = -a; u <= a; u++) {
          const d = u * u + c * c;
          if (d <= i6 * i6) {
            const h6 = d * r;
            let p6 = (720 + h6 * (720 + h6 * (360 + h6 * (120 + h6 * (30 + h6 * (6 + h6)))))) * 0.0013888888;
            l.push([c, u, p6]);
          }
        }
      this.tensorCaches.orientationHistograms = {
        radialPropertiesT: cn$1(Re$1(l, [l.length, 3]))
      };
    });
    const { radialPropertiesT: o } = this.tensorCaches.orientationHistograms;
    return D(() => Xt().runKernel("ComputeOrientationHistograms", { gaussianImagesT: s, prunedExtremasT: t, radialPropertiesT: o, pyramidImagesLength: e.length }));
  }
  // The histogram is smoothed with a Gaussian, with sigma = 1
  _smoothHistograms(t) {
    return D(() => Xt().runKernel("SmoothHistograms", { histograms: t }));
  }
  /**
   * 
   * @param {number[][]} prunedExtremasList 
   * @param {tf.Tensor<tf.Rank>[]} dogPyramidImagesT 
   * @returns 
   */
  _computeLocalization(t, e) {
    return D(() => {
      const o = Xt().runKernel("ComputeLocalization", { prunedExtremasList: t, dogPyramidImagesT: e }).arraySync(), r = [];
      for (let a = 0; a < o.length; a++) {
        r.push([]);
        for (let l = 0; l < o[a].length; l++)
          r[a].push([]);
      }
      const i6 = [];
      for (let a = 0; a < t.length; a++)
        i6[a] = [
          t[a][0],
          t[a][1],
          t[a][2],
          t[a][3]
        ];
      for (let a = 0; a < i6.length; a++) {
        if (i6[a][0] === 0)
          continue;
        const l = o[a], c = 0.5 * (l[1][2] - l[1][0]), u = 0.5 * (l[2][1] - l[0][1]), d = l[1][2] + l[1][0] - 2 * l[1][1], h6 = l[2][1] + l[0][1] - 2 * l[1][1], p6 = 0.25 * (l[0][0] + l[2][2] - l[0][2] - l[2][0]), f = d * h6 - p6 * p6, m = (h6 * -c + -p6 * -u) / f, g6 = (-p6 * -c + d * -u) / f, b6 = i6[a][2] + g6, x6 = i6[a][3] + m;
        Math.abs(f) < 1e-4 || (i6[a][2] = b6, i6[a][3] = x6);
      }
      return Re$1(i6, [i6.length, i6[0].length], "float32");
    });
  }
  // faster to do it in CPU
  // if we do in gpu, we probably need to use tf.topk(), which seems to be run in CPU anyway (no gpu operation for that)
  //  TODO: research adapative maximum supression method
  /**
   * 
   * @param {tf.Tensor<tf.Rank>[]} extremasResultsT 
   * @returns 
   */
  _applyPrune(t) {
    const e = Vr * Vr, s = C5, o = [], r = [];
    for (let a = 0; a < e; a++) {
      r.push([]), o.push([]);
      for (let l = 0; l < s; l++)
        r[a].push([0, 0, 0, 0]), o[a].push(0);
    }
    D(() => {
      for (let a = 0; a < t.length; a++) {
        const l = Xt().runKernel("ExtremaReduction", { extremasResultT: t[a] }), c = a + 1, u = l.arraySync(), d = l.shape[0], h6 = l.shape[1], p6 = h6 * 2 / Vr, f = d * 2 / Vr;
        for (let m = 0; m < d; m++)
          for (let g6 = 0; g6 < h6; g6++) {
            const b6 = u[m][g6];
            if (b6 == 0)
              continue;
            const x6 = b6 % 1e3, w6 = Math.floor(Math.abs(b6) / 1e3), y6 = g6 * 2 + (w6 === 2 || w6 === 3 ? 1 : 0), I = m * 2 + (w6 === 1 || w6 === 3 ? 1 : 0), C6 = Math.floor(y6 / p6), S = Math.floor(I / f) * Vr + C6, N = Math.abs(x6);
            let R = s;
            for (; R >= 1 && N > o[S][R - 1]; )
              R -= 1;
            if (R < s) {
              for (let M6 = s - 1; M6 >= R + 1; M6--)
                o[S][M6] = o[S][M6 - 1], r[S][M6][0] = r[S][M6 - 1][0], r[S][M6][1] = r[S][M6 - 1][1], r[S][M6][2] = r[S][M6 - 1][2], r[S][M6][3] = r[S][M6 - 1][3];
              o[S][R] = N, r[S][R][0] = x6, r[S][R][1] = c, r[S][R][2] = I, r[S][R][3] = y6;
            }
          }
      }
    });
    const i6 = [];
    for (let a = 0; a < e; a++)
      for (let l = 0; l < s; l++)
        i6.push(r[a][l]);
    return i6;
  }
  _buildExtremas(t, e, s) {
    return D(() => Xt().runKernel("BuildExtremas", { image0: t, image1: e, image2: s }));
  }
  /**
   * 
   * @param {tf.Tensor<tf.Rank>} image1 
   * @param {tf.Tensor<tf.Rank>} image2 
   * @returns 
   */
  _differenceImageBinomial(t, e) {
    return D(() => t.sub(e));
  }
  // 4th order binomail filter [1,4,6,4,1] X [1,4,6,4,1]
  _applyFilter(t) {
    return D(() => Xt().runKernel("BinomialFilter", { image: t }));
  }
  /* _upsampleBilinear(image, targetImage) {
  		const imageHeight = image.shape[0];
  		const imageWidth = image.shape[1];
  
  		const kernelKey = 'w' + imageWidth;
  		if (!this.kernelCaches.upsampleBilinear) {
  			this.kernelCaches.upsampleBilinear = {};
  		}
  
  		if (!this.kernelCaches.upsampleBilinear[kernelKey]) {
  			const kernel = {
  				variableNames: ['p'],
  				outputShape: [targetImage.shape[0], targetImage.shape[1]],
  				userCode: `
  	  void main() {
  		ivec2 coords = getOutputCoords();
  		int j = coords[0];
  		int i = coords[1];
  
  		float sj = 0.5 * float(j) - 0.25; 
  		float si = 0.5 * float(i) - 0.25;
  
  		float sj0 = floor(sj);
  		float sj1 = ceil(sj);
  		float si0 = floor(si);
  		float si1 = ceil(si);
  
  		int sj0I = int(sj0);
  		int sj1I = int(sj1);
  		int si0I = int(si0);
  		int si1I = int(si1);
  
  		float sum = 0.0;
  		sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);
  		sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);
  		sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);
  		sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);
  		setOutput(sum);
  	  }
  	`
  			};
  			this.kernelCaches.upsampleBilinear[kernelKey] = kernel;
  		}
  
  		return tf.tidy(() => {
  			const program = this.kernelCaches.upsampleBilinear[kernelKey];
  			return tf.engine().runKernel("UpsampleBilinear", { x: image, width: image.shape[1], height: image.shape[0] });//this._compileAndRun(program, [image]);
  		});
  	} */
  _downsampleBilinear(t) {
    return D(() => Xt().runKernel("DownsampleBilinear", { image: t }));
  }
  /**
   * 
   * @param {tf.MathBackendWebGL.GPGPUProgram} program 
   * @param {*} inputs 
   * @returns 
   */
  _compileAndRun(t, e) {
    const s = $s().compileAndRun(t, e);
    return Xt().makeTensorFromDataId(s.dataId, s.shape, s.dtype);
  }
  _runWebGLProgram(t, e, s) {
    const o = $s().runWebGLProgram(t, e, s);
    return Xt().makeTensorFromDataId(o.dataId, o.shape, o.dtype);
  }
}
class S5 {
  constructor(t, e, s = false) {
    this.debugMode = s, this.width = t, this.height = e;
    let o = Math.min(t, e) / 2, r = Math.pow(2, Math.round(Math.log(o) / Math.log(2)));
    this.cropSize = r, this.detector = new gI(r, r, s), this.kernelCaches = {}, this.lastRandomIndex = 4;
  }
  detect(t) {
    const e = Math.floor(this.height / 2 - this.cropSize / 2), s = Math.floor(this.width / 2 - this.cropSize / 2), o = this._detect(t, s, e);
    return this.debugMode && (o.debugExtra.crop = { startX: s, startY: e, cropSize: this.cropSize }), o;
  }
  detectMoving(t) {
    const e = this.lastRandomIndex % 3, s = Math.floor(this.lastRandomIndex / 3);
    let o = Math.floor(this.height / 2 - this.cropSize + s * this.cropSize / 2), r = Math.floor(this.width / 2 - this.cropSize + e * this.cropSize / 2);
    return r < 0 && (r = 0), o < 0 && (o = 0), r >= this.width - this.cropSize && (r = this.width - this.cropSize - 1), o >= this.height - this.cropSize && (o = this.height - this.cropSize - 1), this.lastRandomIndex = (this.lastRandomIndex + 1) % 9, this._detect(t, r, o);
  }
  _detect(t, e, s) {
    const o = t.slice([s, e], [this.cropSize, this.cropSize]), { featurePoints: r, debugExtra: i6 } = this.detector.detect(o);
    return r.forEach((a) => {
      a.x += e, a.y += s;
    }), this.debugMode && (i6.projectedImage = o.arraySync()), o.dispose(), { featurePoints: r, debugExtra: i6 };
  }
}
const bI = ({ image: n, ratio: t }) => {
  const e = Math.round(n.width * t), s = Math.round(n.height * t), o = new Uint8Array(e * s);
  for (let r = 0; r < e; r++) {
    let i6 = Math.round(1 * r / t), a = Math.round(1 * (r + 1) / t) - 1;
    a >= n.width && (a = n.width - 1);
    for (let l = 0; l < s; l++) {
      let c = Math.round(1 * l / t), u = Math.round(1 * (l + 1) / t) - 1;
      u >= n.height && (u = n.height - 1);
      let d = 0, h6 = 0;
      for (let p6 = i6; p6 <= a; p6++)
        for (let f = c; f <= u; f++)
          d += 1 * n.data[f * n.width + p6], h6 += 1;
      o[l * e + r] = Math.floor(d / h6);
    }
  }
  return { data: o, width: e, height: s };
}, k5 = 100, T5 = (n) => {
  const t = k5 / Math.min(n.width, n.height), e = [];
  let s = t;
  for (; ; )
    if (e.push(s), s *= Math.pow(2, 1 / 3), s >= 0.95) {
      s = 1;
      break;
    }
  e.push(s), e.reverse();
  const o = [];
  for (let r = 0; r < e.length; r++)
    n.width * e[r], n.height * e[r], o.push(Object.assign(bI({ image: n, ratio: e[r] }), { scale: e[r] }));
  return o;
}, N5 = (n) => {
  const t = Math.min(n.width, n.height), e = [], s = [];
  e.push(256 / t), e.push(128 / t);
  for (let o = 0; o < e.length; o++)
    s.push(Object.assign(bI({ image: n, ratio: e[o] }), { scale: e[o] }));
  return s;
}, R5 = (n) => {
  const { v1: t, v2: e } = n;
  let s = 0;
  for (let o = 0; o < t.length; o++) {
    let r = (t[o] ^ e[o]) >>> 0;
    s += $5(r);
  }
  return s;
}, $5 = (n) => {
  var t = n - (n >> 1 & 1431655765);
  return t = (t >> 2 & 858993459) + (t & 858993459), t = (t >> 4) + t & 252645135, t = (t >> 8) + t & 16711935, t = (t >> 16) + t & 65535, t;
}, G5 = 1234, E5 = () => ({
  seed: G5,
  arrayShuffle(t) {
    const { arr: e, sampleSize: s } = t;
    for (let o = 0; o < s; o++) {
      this.seed = (214013 * this.seed + 2531011) % -2147483648;
      let r = this.seed >> 16 & 32767;
      r = r % e.length;
      let i6 = e[o];
      e[o] = e[r], e[r] = i6;
    }
  },
  nextInt(t) {
    this.seed = (214013 * this.seed + 2531011) % -2147483648;
    let e = this.seed >> 16 & 32767;
    return e = e % t, e;
  }
}), L5 = 16, M5 = 128, Vd$1 = 8, W5 = (n) => {
  const { points: t, pointIndexes: e, randomizer: s } = n, o = [];
  for (let l = 0; l < e.length; l++)
    o.push(l);
  let r = Number.MAX_SAFE_INTEGER, i6 = -1;
  const a = [];
  for (let l = 0; l < M5; l++) {
    s.arrayShuffle({ arr: o, sampleSize: Vd$1 });
    let c = 0;
    const u = [];
    for (let d = 0; d < e.length; d++) {
      let h6 = Number.MAX_SAFE_INTEGER;
      for (let p6 = 0; p6 < Vd$1; p6++) {
        const f = e[o[p6]], m = R5({ v1: t[e[d]].descriptors, v2: t[f].descriptors });
        m < h6 && (u[d] = o[p6], h6 = m);
      }
      c += h6;
    }
    a.push(u), c < r && (r = c, i6 = l);
  }
  return a[i6];
}, Ng$1 = ({ points: n }) => {
  const t = [];
  for (let o = 0; o < n.length; o++)
    t.push(o);
  const e = E5();
  return { rootNode: xI({ points: n, pointIndexes: t, centerPointIndex: null, randomizer: e }) };
}, xI = (n) => {
  const { points: t, pointIndexes: e, centerPointIndex: s, randomizer: o } = n;
  let r = false;
  (e.length <= Vd$1 || e.length <= L5) && (r = true);
  const i6 = {};
  if (!r) {
    const l = W5({ points: t, pointIndexes: e, randomizer: o });
    for (let c = 0; c < l.length; c++)
      i6[e[l[c]]] === void 0 && (i6[e[l[c]]] = []), i6[e[l[c]]].push(e[c]);
  }
  Object.keys(i6).length === 1 && (r = true);
  const a = {
    centerPointIndex: s
  };
  if (r) {
    a.leaf = true, a.pointIndexes = [];
    for (let l = 0; l < e.length; l++)
      a.pointIndexes.push(e[l]);
    return a;
  }
  return a.leaf = false, a.children = [], Object.keys(i6).forEach((l) => {
    a.children.push(xI({ points: t, pointIndexes: i6[l], centerPointIndex: l, randomizer: o }));
  }), a;
};
var ao = 4294967295;
function D5(n, t, e) {
  var s = e / 4294967296, o = e;
  n.setUint32(t, s), n.setUint32(t + 4, o);
}
function yI(n, t, e) {
  var s = Math.floor(e / 4294967296), o = e;
  n.setUint32(t, s), n.setUint32(t + 4, o);
}
function wI(n, t) {
  var e = n.getInt32(t), s = n.getUint32(t + 4);
  return e * 4294967296 + s;
}
function F5(n, t) {
  var e = n.getUint32(t), s = n.getUint32(t + 4);
  return e * 4294967296 + s;
}
var Uu, Yu, Qu, gu = (typeof dist.process > "u" || ((Uu = dist.process == null ? void 0 : dist.process.env) === null || Uu === void 0 ? void 0 : Uu.TEXT_ENCODING) !== "never") && typeof TextEncoder < "u" && typeof TextDecoder < "u";
function Rg$1(n) {
  for (var t = n.length, e = 0, s = 0; s < t; ) {
    var o = n.charCodeAt(s++);
    if (o & 4294967168)
      if (!(o & 4294965248))
        e += 2;
      else {
        if (o >= 55296 && o <= 56319 && s < t) {
          var r = n.charCodeAt(s);
          (r & 64512) === 56320 && (++s, o = ((o & 1023) << 10) + (r & 1023) + 65536);
        }
        o & 4294901760 ? e += 4 : e += 3;
      }
    else {
      e++;
      continue;
    }
  }
  return e;
}
function V5(n, t, e) {
  for (var s = n.length, o = e, r = 0; r < s; ) {
    var i6 = n.charCodeAt(r++);
    if (i6 & 4294967168)
      if (!(i6 & 4294965248))
        t[o++] = i6 >> 6 & 31 | 192;
      else {
        if (i6 >= 55296 && i6 <= 56319 && r < s) {
          var a = n.charCodeAt(r);
          (a & 64512) === 56320 && (++r, i6 = ((i6 & 1023) << 10) + (a & 1023) + 65536);
        }
        i6 & 4294901760 ? (t[o++] = i6 >> 18 & 7 | 240, t[o++] = i6 >> 12 & 63 | 128, t[o++] = i6 >> 6 & 63 | 128) : (t[o++] = i6 >> 12 & 15 | 224, t[o++] = i6 >> 6 & 63 | 128);
      }
    else {
      t[o++] = i6;
      continue;
    }
    t[o++] = i6 & 63 | 128;
  }
}
var _r = gu ? new TextEncoder() : void 0, z5 = gu ? typeof dist.process < "u" && ((Yu = dist.process == null ? void 0 : dist.process.env) === null || Yu === void 0 ? void 0 : Yu.TEXT_ENCODING) !== "force" ? 200 : 0 : ao;
function X5(n, t, e) {
  t.set(_r.encode(n), e);
}
function P5(n, t, e) {
  _r.encodeInto(n, t.subarray(e));
}
var A5 = _r != null && _r.encodeInto ? P5 : X5, O5 = 4096;
function II(n, t, e) {
  for (var s = t, o = s + e, r = [], i6 = ""; s < o; ) {
    var a = n[s++];
    if (!(a & 128))
      r.push(a);
    else if ((a & 224) === 192) {
      var l = n[s++] & 63;
      r.push((a & 31) << 6 | l);
    } else if ((a & 240) === 224) {
      var l = n[s++] & 63, c = n[s++] & 63;
      r.push((a & 31) << 12 | l << 6 | c);
    } else if ((a & 248) === 240) {
      var l = n[s++] & 63, c = n[s++] & 63, u = n[s++] & 63, d = (a & 7) << 18 | l << 12 | c << 6 | u;
      d > 65535 && (d -= 65536, r.push(d >>> 10 & 1023 | 55296), d = 56320 | d & 1023), r.push(d);
    } else
      r.push(a);
    r.length >= O5 && (i6 += String.fromCharCode.apply(String, r), r.length = 0);
  }
  return r.length > 0 && (i6 += String.fromCharCode.apply(String, r)), i6;
}
var K5 = gu ? new TextDecoder() : null, Z5 = gu ? typeof dist.process < "u" && ((Qu = dist.process == null ? void 0 : dist.process.env) === null || Qu === void 0 ? void 0 : Qu.TEXT_DECODER) !== "force" ? 200 : 0 : ao;
function B5(n, t, e) {
  var s = n.subarray(t, t + e);
  return K5.decode(s);
}
var Qa = (
  /** @class */
  function() {
    function n(t, e) {
      this.type = t, this.data = e;
    }
    return n;
  }()
), H5 = globalThis && globalThis.__extends || function() {
  var n = function(t, e) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, o) {
      s.__proto__ = o;
    } || function(s, o) {
      for (var r in o)
        Object.prototype.hasOwnProperty.call(o, r) && (s[r] = o[r]);
    }, n(t, e);
  };
  return function(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    n(t, e);
    function s() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (s.prototype = e.prototype, new s());
  };
}(), Un$1 = (
  /** @class */
  function(n) {
    H5(t, n);
    function t(e) {
      var s = n.call(this, e) || this, o = Object.create(t.prototype);
      return Object.setPrototypeOf(s, o), Object.defineProperty(s, "name", {
        configurable: true,
        enumerable: false,
        value: t.name
      }), s;
    }
    return t;
  }(Error)
), _5 = -1, U5 = 4294967296 - 1, Y5 = 17179869184 - 1;
function Q5(n) {
  var t = n.sec, e = n.nsec;
  if (t >= 0 && e >= 0 && t <= Y5)
    if (e === 0 && t <= U5) {
      var s = new Uint8Array(4), o = new DataView(s.buffer);
      return o.setUint32(0, t), s;
    } else {
      var r = t / 4294967296, i6 = t & 4294967295, s = new Uint8Array(8), o = new DataView(s.buffer);
      return o.setUint32(0, e << 2 | r & 3), o.setUint32(4, i6), s;
    }
  else {
    var s = new Uint8Array(12), o = new DataView(s.buffer);
    return o.setUint32(0, e), yI(o, 4, t), s;
  }
}
function J5(n) {
  var t = n.getTime(), e = Math.floor(t / 1e3), s = (t - e * 1e3) * 1e6, o = Math.floor(s / 1e9);
  return {
    sec: e + o,
    nsec: s - o * 1e9
  };
}
function j5(n) {
  if (n instanceof Date) {
    var t = J5(n);
    return Q5(t);
  } else
    return null;
}
function q5(n) {
  var t = new DataView(n.buffer, n.byteOffset, n.byteLength);
  switch (n.byteLength) {
    case 4: {
      var e = t.getUint32(0), s = 0;
      return { sec: e, nsec: s };
    }
    case 8: {
      var o = t.getUint32(0), r = t.getUint32(4), e = (o & 3) * 4294967296 + r, s = o >>> 2;
      return { sec: e, nsec: s };
    }
    case 12: {
      var e = wI(t, 4), s = t.getUint32(0);
      return { sec: e, nsec: s };
    }
    default:
      throw new Un$1("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(n.length));
  }
}
function t4(n) {
  var t = q5(n);
  return new Date(t.sec * 1e3 + t.nsec / 1e6);
}
var e4 = {
  type: _5,
  encode: j5,
  decode: t4
}, CI = (
  /** @class */
  function() {
    function n() {
      this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(e4);
    }
    return n.prototype.register = function(t) {
      var e = t.type, s = t.encode, o = t.decode;
      if (e >= 0)
        this.encoders[e] = s, this.decoders[e] = o;
      else {
        var r = 1 + e;
        this.builtInEncoders[r] = s, this.builtInDecoders[r] = o;
      }
    }, n.prototype.tryToEncode = function(t, e) {
      for (var s = 0; s < this.builtInEncoders.length; s++) {
        var o = this.builtInEncoders[s];
        if (o != null) {
          var r = o(t, e);
          if (r != null) {
            var i6 = -1 - s;
            return new Qa(i6, r);
          }
        }
      }
      for (var s = 0; s < this.encoders.length; s++) {
        var o = this.encoders[s];
        if (o != null) {
          var r = o(t, e);
          if (r != null) {
            var i6 = s;
            return new Qa(i6, r);
          }
        }
      }
      return t instanceof Qa ? t : null;
    }, n.prototype.decode = function(t, e, s) {
      var o = e < 0 ? this.builtInDecoders[-1 - e] : this.decoders[e];
      return o ? o(t, e, s) : new Qa(e, t);
    }, n.defaultCodec = new n(), n;
  }()
);
function Ml(n) {
  return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : n instanceof ArrayBuffer ? new Uint8Array(n) : Uint8Array.from(n);
}
function n4(n) {
  if (n instanceof ArrayBuffer)
    return new DataView(n);
  var t = Ml(n);
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
var s4 = 100, o4 = 2048, r4 = (
  /** @class */
  function() {
    function n(t, e, s, o, r, i6, a, l) {
      t === void 0 && (t = CI.defaultCodec), e === void 0 && (e = void 0), s === void 0 && (s = s4), o === void 0 && (o = o4), r === void 0 && (r = false), i6 === void 0 && (i6 = false), a === void 0 && (a = false), l === void 0 && (l = false), this.extensionCodec = t, this.context = e, this.maxDepth = s, this.initialBufferSize = o, this.sortKeys = r, this.forceFloat32 = i6, this.ignoreUndefined = a, this.forceIntegerToFloat = l, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
    }
    return n.prototype.reinitializeState = function() {
      this.pos = 0;
    }, n.prototype.encodeSharedRef = function(t) {
      return this.reinitializeState(), this.doEncode(t, 1), this.bytes.subarray(0, this.pos);
    }, n.prototype.encode = function(t) {
      return this.reinitializeState(), this.doEncode(t, 1), this.bytes.slice(0, this.pos);
    }, n.prototype.doEncode = function(t, e) {
      if (e > this.maxDepth)
        throw new Error("Too deep objects in depth ".concat(e));
      t == null ? this.encodeNil() : typeof t == "boolean" ? this.encodeBoolean(t) : typeof t == "number" ? this.encodeNumber(t) : typeof t == "string" ? this.encodeString(t) : this.encodeObject(t, e);
    }, n.prototype.ensureBufferSizeToWrite = function(t) {
      var e = this.pos + t;
      this.view.byteLength < e && this.resizeBuffer(e * 2);
    }, n.prototype.resizeBuffer = function(t) {
      var e = new ArrayBuffer(t), s = new Uint8Array(e), o = new DataView(e);
      s.set(this.bytes), this.view = o, this.bytes = s;
    }, n.prototype.encodeNil = function() {
      this.writeU8(192);
    }, n.prototype.encodeBoolean = function(t) {
      t === false ? this.writeU8(194) : this.writeU8(195);
    }, n.prototype.encodeNumber = function(t) {
      Number.isSafeInteger(t) && !this.forceIntegerToFloat ? t >= 0 ? t < 128 ? this.writeU8(t) : t < 256 ? (this.writeU8(204), this.writeU8(t)) : t < 65536 ? (this.writeU8(205), this.writeU16(t)) : t < 4294967296 ? (this.writeU8(206), this.writeU32(t)) : (this.writeU8(207), this.writeU64(t)) : t >= -32 ? this.writeU8(224 | t + 32) : t >= -128 ? (this.writeU8(208), this.writeI8(t)) : t >= -32768 ? (this.writeU8(209), this.writeI16(t)) : t >= -2147483648 ? (this.writeU8(210), this.writeI32(t)) : (this.writeU8(211), this.writeI64(t)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(t)) : (this.writeU8(203), this.writeF64(t));
    }, n.prototype.writeStringHeader = function(t) {
      if (t < 32)
        this.writeU8(160 + t);
      else if (t < 256)
        this.writeU8(217), this.writeU8(t);
      else if (t < 65536)
        this.writeU8(218), this.writeU16(t);
      else if (t < 4294967296)
        this.writeU8(219), this.writeU32(t);
      else
        throw new Error("Too long string: ".concat(t, " bytes in UTF-8"));
    }, n.prototype.encodeString = function(t) {
      var e = 5, s = t.length;
      if (s > z5) {
        var o = Rg$1(t);
        this.ensureBufferSizeToWrite(e + o), this.writeStringHeader(o), A5(t, this.bytes, this.pos), this.pos += o;
      } else {
        var o = Rg$1(t);
        this.ensureBufferSizeToWrite(e + o), this.writeStringHeader(o), V5(t, this.bytes, this.pos), this.pos += o;
      }
    }, n.prototype.encodeObject = function(t, e) {
      var s = this.extensionCodec.tryToEncode(t, this.context);
      if (s != null)
        this.encodeExtension(s);
      else if (Array.isArray(t))
        this.encodeArray(t, e);
      else if (ArrayBuffer.isView(t))
        this.encodeBinary(t);
      else if (typeof t == "object")
        this.encodeMap(t, e);
      else
        throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(t)));
    }, n.prototype.encodeBinary = function(t) {
      var e = t.byteLength;
      if (e < 256)
        this.writeU8(196), this.writeU8(e);
      else if (e < 65536)
        this.writeU8(197), this.writeU16(e);
      else if (e < 4294967296)
        this.writeU8(198), this.writeU32(e);
      else
        throw new Error("Too large binary: ".concat(e));
      var s = Ml(t);
      this.writeU8a(s);
    }, n.prototype.encodeArray = function(t, e) {
      var s = t.length;
      if (s < 16)
        this.writeU8(144 + s);
      else if (s < 65536)
        this.writeU8(220), this.writeU16(s);
      else if (s < 4294967296)
        this.writeU8(221), this.writeU32(s);
      else
        throw new Error("Too large array: ".concat(s));
      for (var o = 0, r = t; o < r.length; o++) {
        var i6 = r[o];
        this.doEncode(i6, e + 1);
      }
    }, n.prototype.countWithoutUndefined = function(t, e) {
      for (var s = 0, o = 0, r = e; o < r.length; o++) {
        var i6 = r[o];
        t[i6] !== void 0 && s++;
      }
      return s;
    }, n.prototype.encodeMap = function(t, e) {
      var s = Object.keys(t);
      this.sortKeys && s.sort();
      var o = this.ignoreUndefined ? this.countWithoutUndefined(t, s) : s.length;
      if (o < 16)
        this.writeU8(128 + o);
      else if (o < 65536)
        this.writeU8(222), this.writeU16(o);
      else if (o < 4294967296)
        this.writeU8(223), this.writeU32(o);
      else
        throw new Error("Too large map object: ".concat(o));
      for (var r = 0, i6 = s; r < i6.length; r++) {
        var a = i6[r], l = t[a];
        this.ignoreUndefined && l === void 0 || (this.encodeString(a), this.doEncode(l, e + 1));
      }
    }, n.prototype.encodeExtension = function(t) {
      var e = t.data.length;
      if (e === 1)
        this.writeU8(212);
      else if (e === 2)
        this.writeU8(213);
      else if (e === 4)
        this.writeU8(214);
      else if (e === 8)
        this.writeU8(215);
      else if (e === 16)
        this.writeU8(216);
      else if (e < 256)
        this.writeU8(199), this.writeU8(e);
      else if (e < 65536)
        this.writeU8(200), this.writeU16(e);
      else if (e < 4294967296)
        this.writeU8(201), this.writeU32(e);
      else
        throw new Error("Too large extension object: ".concat(e));
      this.writeI8(t.type), this.writeU8a(t.data);
    }, n.prototype.writeU8 = function(t) {
      this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, t), this.pos++;
    }, n.prototype.writeU8a = function(t) {
      var e = t.length;
      this.ensureBufferSizeToWrite(e), this.bytes.set(t, this.pos), this.pos += e;
    }, n.prototype.writeI8 = function(t) {
      this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, t), this.pos++;
    }, n.prototype.writeU16 = function(t) {
      this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, t), this.pos += 2;
    }, n.prototype.writeI16 = function(t) {
      this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, t), this.pos += 2;
    }, n.prototype.writeU32 = function(t) {
      this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, t), this.pos += 4;
    }, n.prototype.writeI32 = function(t) {
      this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, t), this.pos += 4;
    }, n.prototype.writeF32 = function(t) {
      this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, t), this.pos += 4;
    }, n.prototype.writeF64 = function(t) {
      this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, t), this.pos += 8;
    }, n.prototype.writeU64 = function(t) {
      this.ensureBufferSizeToWrite(8), D5(this.view, this.pos, t), this.pos += 8;
    }, n.prototype.writeI64 = function(t) {
      this.ensureBufferSizeToWrite(8), yI(this.view, this.pos, t), this.pos += 8;
    }, n;
  }()
), i4 = {};
function a4(n, t) {
  t === void 0 && (t = i4);
  var e = new r4(t.extensionCodec, t.context, t.maxDepth, t.initialBufferSize, t.sortKeys, t.forceFloat32, t.ignoreUndefined, t.forceIntegerToFloat);
  return e.encodeSharedRef(n);
}
function Ju(n) {
  return "".concat(n < 0 ? "-" : "", "0x").concat(Math.abs(n).toString(16).padStart(2, "0"));
}
var l4 = 16, c4 = 16, u4 = (
  /** @class */
  function() {
    function n(t, e) {
      t === void 0 && (t = l4), e === void 0 && (e = c4), this.maxKeyLength = t, this.maxLengthPerKey = e, this.hit = 0, this.miss = 0, this.caches = [];
      for (var s = 0; s < this.maxKeyLength; s++)
        this.caches.push([]);
    }
    return n.prototype.canBeCached = function(t) {
      return t > 0 && t <= this.maxKeyLength;
    }, n.prototype.find = function(t, e, s) {
      var o = this.caches[s - 1];
      t:
        for (var r = 0, i6 = o; r < i6.length; r++) {
          for (var a = i6[r], l = a.bytes, c = 0; c < s; c++)
            if (l[c] !== t[e + c])
              continue t;
          return a.str;
        }
      return null;
    }, n.prototype.store = function(t, e) {
      var s = this.caches[t.length - 1], o = { bytes: t, str: e };
      s.length >= this.maxLengthPerKey ? s[Math.random() * s.length | 0] = o : s.push(o);
    }, n.prototype.decode = function(t, e, s) {
      var o = this.find(t, e, s);
      if (o != null)
        return this.hit++, o;
      this.miss++;
      var r = II(t, e, s), i6 = Uint8Array.prototype.slice.call(t, e, e + s);
      return this.store(i6, r), r;
    }, n;
  }()
), d4 = globalThis && globalThis.__awaiter || function(n, t, e, s) {
  function o(r) {
    return r instanceof e ? r : new e(function(i6) {
      i6(r);
    });
  }
  return new (e || (e = Promise))(function(r, i6) {
    function a(u) {
      try {
        c(s.next(u));
      } catch (d) {
        i6(d);
      }
    }
    function l(u) {
      try {
        c(s.throw(u));
      } catch (d) {
        i6(d);
      }
    }
    function c(u) {
      u.done ? r(u.value) : o(u.value).then(a, l);
    }
    c((s = s.apply(n, t || [])).next());
  });
}, ju = globalThis && globalThis.__generator || function(n, t) {
  var e = { label: 0, sent: function() {
    if (r[0] & 1)
      throw r[1];
    return r[1];
  }, trys: [], ops: [] }, s, o, r, i6;
  return i6 = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (i6[Symbol.iterator] = function() {
    return this;
  }), i6;
  function a(c) {
    return function(u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (s)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (s = 1, o && (r = c[0] & 2 ? o.return : c[0] ? o.throw || ((r = o.return) && r.call(o), 0) : o.next) && !(r = r.call(o, c[1])).done)
          return r;
        switch (o = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
          case 0:
          case 1:
            r = c;
            break;
          case 4:
            return e.label++, { value: c[1], done: false };
          case 5:
            e.label++, o = c[1], c = [0];
            continue;
          case 7:
            c = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (r = e.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              e = 0;
              continue;
            }
            if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
              e.label = c[1];
              break;
            }
            if (c[0] === 6 && e.label < r[1]) {
              e.label = r[1], r = c;
              break;
            }
            if (r && e.label < r[2]) {
              e.label = r[2], e.ops.push(c);
              break;
            }
            r[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        c = t.call(n, e);
      } catch (u) {
        c = [6, u], o = 0;
      } finally {
        s = r = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
}, $g$1 = globalThis && globalThis.__asyncValues || function(n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = n[Symbol.asyncIterator], e;
  return t ? t.call(n) : (n = typeof __values == "function" ? __values(n) : n[Symbol.iterator](), e = {}, s("next"), s("throw"), s("return"), e[Symbol.asyncIterator] = function() {
    return this;
  }, e);
  function s(r) {
    e[r] = n[r] && function(i6) {
      return new Promise(function(a, l) {
        i6 = n[r](i6), o(a, l, i6.done, i6.value);
      });
    };
  }
  function o(r, i6, a, l) {
    Promise.resolve(l).then(function(c) {
      r({ value: c, done: a });
    }, i6);
  }
}, nr = globalThis && globalThis.__await || function(n) {
  return this instanceof nr ? (this.v = n, this) : new nr(n);
}, h4 = globalThis && globalThis.__asyncGenerator || function(n, t, e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var s = e.apply(n, t || []), o, r = [];
  return o = {}, i6("next"), i6("throw"), i6("return"), o[Symbol.asyncIterator] = function() {
    return this;
  }, o;
  function i6(h6) {
    s[h6] && (o[h6] = function(p6) {
      return new Promise(function(f, m) {
        r.push([h6, p6, f, m]) > 1 || a(h6, p6);
      });
    });
  }
  function a(h6, p6) {
    try {
      l(s[h6](p6));
    } catch (f) {
      d(r[0][3], f);
    }
  }
  function l(h6) {
    h6.value instanceof nr ? Promise.resolve(h6.value.v).then(c, u) : d(r[0][2], h6);
  }
  function c(h6) {
    a("next", h6);
  }
  function u(h6) {
    a("throw", h6);
  }
  function d(h6, p6) {
    h6(p6), r.shift(), r.length && a(r[0][0], r[0][1]);
  }
}, p4 = function(n) {
  var t = typeof n;
  return t === "string" || t === "number";
}, zr = -1, Zf$1 = new DataView(new ArrayBuffer(0)), f4 = new Uint8Array(Zf$1.buffer), zd$1 = function() {
  try {
    Zf$1.getInt8(0);
  } catch (n) {
    return n.constructor;
  }
  throw new Error("never reached");
}(), Gg$1 = new zd$1("Insufficient data"), m4 = new u4(), g4 = (
  /** @class */
  function() {
    function n(t, e, s, o, r, i6, a, l) {
      t === void 0 && (t = CI.defaultCodec), e === void 0 && (e = void 0), s === void 0 && (s = ao), o === void 0 && (o = ao), r === void 0 && (r = ao), i6 === void 0 && (i6 = ao), a === void 0 && (a = ao), l === void 0 && (l = m4), this.extensionCodec = t, this.context = e, this.maxStrLength = s, this.maxBinLength = o, this.maxArrayLength = r, this.maxMapLength = i6, this.maxExtLength = a, this.keyDecoder = l, this.totalPos = 0, this.pos = 0, this.view = Zf$1, this.bytes = f4, this.headByte = zr, this.stack = [];
    }
    return n.prototype.reinitializeState = function() {
      this.totalPos = 0, this.headByte = zr, this.stack.length = 0;
    }, n.prototype.setBuffer = function(t) {
      this.bytes = Ml(t), this.view = n4(this.bytes), this.pos = 0;
    }, n.prototype.appendBuffer = function(t) {
      if (this.headByte === zr && !this.hasRemaining(1))
        this.setBuffer(t);
      else {
        var e = this.bytes.subarray(this.pos), s = Ml(t), o = new Uint8Array(e.length + s.length);
        o.set(e), o.set(s, e.length), this.setBuffer(o);
      }
    }, n.prototype.hasRemaining = function(t) {
      return this.view.byteLength - this.pos >= t;
    }, n.prototype.createExtraByteError = function(t) {
      var e = this, s = e.view, o = e.pos;
      return new RangeError("Extra ".concat(s.byteLength - o, " of ").concat(s.byteLength, " byte(s) found at buffer[").concat(t, "]"));
    }, n.prototype.decode = function(t) {
      this.reinitializeState(), this.setBuffer(t);
      var e = this.doDecodeSync();
      if (this.hasRemaining(1))
        throw this.createExtraByteError(this.pos);
      return e;
    }, n.prototype.decodeMulti = function(t) {
      return ju(this, function(e) {
        switch (e.label) {
          case 0:
            this.reinitializeState(), this.setBuffer(t), e.label = 1;
          case 1:
            return this.hasRemaining(1) ? [4, this.doDecodeSync()] : [3, 3];
          case 2:
            return e.sent(), [3, 1];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    }, n.prototype.decodeAsync = function(t) {
      var e, s, o, r;
      return d4(this, void 0, void 0, function() {
        var i6, a, l, c, u, d, h6, p6;
        return ju(this, function(f) {
          switch (f.label) {
            case 0:
              i6 = false, f.label = 1;
            case 1:
              f.trys.push([1, 6, 7, 12]), e = $g$1(t), f.label = 2;
            case 2:
              return [4, e.next()];
            case 3:
              if (s = f.sent(), !!s.done)
                return [3, 5];
              if (l = s.value, i6)
                throw this.createExtraByteError(this.totalPos);
              this.appendBuffer(l);
              try {
                a = this.doDecodeSync(), i6 = true;
              } catch (m) {
                if (!(m instanceof zd$1))
                  throw m;
              }
              this.totalPos += this.pos, f.label = 4;
            case 4:
              return [3, 2];
            case 5:
              return [3, 12];
            case 6:
              return c = f.sent(), o = { error: c }, [3, 12];
            case 7:
              return f.trys.push([7, , 10, 11]), s && !s.done && (r = e.return) ? [4, r.call(e)] : [3, 9];
            case 8:
              f.sent(), f.label = 9;
            case 9:
              return [3, 11];
            case 10:
              if (o)
                throw o.error;
              return [
                7
                /*endfinally*/
              ];
            case 11:
              return [
                7
                /*endfinally*/
              ];
            case 12:
              if (i6) {
                if (this.hasRemaining(1))
                  throw this.createExtraByteError(this.totalPos);
                return [2, a];
              }
              throw u = this, d = u.headByte, h6 = u.pos, p6 = u.totalPos, new RangeError("Insufficient data in parsing ".concat(Ju(d), " at ").concat(p6, " (").concat(h6, " in the current buffer)"));
          }
        });
      });
    }, n.prototype.decodeArrayStream = function(t) {
      return this.decodeMultiAsync(t, true);
    }, n.prototype.decodeStream = function(t) {
      return this.decodeMultiAsync(t, false);
    }, n.prototype.decodeMultiAsync = function(t, e) {
      return h4(this, arguments, function() {
        var o, r, i6, a, l, c, u, d, h6;
        return ju(this, function(p6) {
          switch (p6.label) {
            case 0:
              o = e, r = -1, p6.label = 1;
            case 1:
              p6.trys.push([1, 13, 14, 19]), i6 = $g$1(t), p6.label = 2;
            case 2:
              return [4, nr(i6.next())];
            case 3:
              if (a = p6.sent(), !!a.done)
                return [3, 12];
              if (l = a.value, e && r === 0)
                throw this.createExtraByteError(this.totalPos);
              this.appendBuffer(l), o && (r = this.readArraySize(), o = false, this.complete()), p6.label = 4;
            case 4:
              p6.trys.push([4, 9, , 10]), p6.label = 5;
            case 5:
              return [4, nr(this.doDecodeSync())];
            case 6:
              return [4, p6.sent()];
            case 7:
              return p6.sent(), --r === 0 ? [3, 8] : [3, 5];
            case 8:
              return [3, 10];
            case 9:
              if (c = p6.sent(), !(c instanceof zd$1))
                throw c;
              return [3, 10];
            case 10:
              this.totalPos += this.pos, p6.label = 11;
            case 11:
              return [3, 2];
            case 12:
              return [3, 19];
            case 13:
              return u = p6.sent(), d = { error: u }, [3, 19];
            case 14:
              return p6.trys.push([14, , 17, 18]), a && !a.done && (h6 = i6.return) ? [4, nr(h6.call(i6))] : [3, 16];
            case 15:
              p6.sent(), p6.label = 16;
            case 16:
              return [3, 18];
            case 17:
              if (d)
                throw d.error;
              return [
                7
                /*endfinally*/
              ];
            case 18:
              return [
                7
                /*endfinally*/
              ];
            case 19:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, n.prototype.doDecodeSync = function() {
      t:
        for (; ; ) {
          var t = this.readHeadByte(), e = void 0;
          if (t >= 224)
            e = t - 256;
          else if (t < 192)
            if (t < 128)
              e = t;
            else if (t < 144) {
              var s = t - 128;
              if (s !== 0) {
                this.pushMapState(s), this.complete();
                continue t;
              } else
                e = {};
            } else if (t < 160) {
              var s = t - 144;
              if (s !== 0) {
                this.pushArrayState(s), this.complete();
                continue t;
              } else
                e = [];
            } else {
              var o = t - 160;
              e = this.decodeUtf8String(o, 0);
            }
          else if (t === 192)
            e = null;
          else if (t === 194)
            e = false;
          else if (t === 195)
            e = true;
          else if (t === 202)
            e = this.readF32();
          else if (t === 203)
            e = this.readF64();
          else if (t === 204)
            e = this.readU8();
          else if (t === 205)
            e = this.readU16();
          else if (t === 206)
            e = this.readU32();
          else if (t === 207)
            e = this.readU64();
          else if (t === 208)
            e = this.readI8();
          else if (t === 209)
            e = this.readI16();
          else if (t === 210)
            e = this.readI32();
          else if (t === 211)
            e = this.readI64();
          else if (t === 217) {
            var o = this.lookU8();
            e = this.decodeUtf8String(o, 1);
          } else if (t === 218) {
            var o = this.lookU16();
            e = this.decodeUtf8String(o, 2);
          } else if (t === 219) {
            var o = this.lookU32();
            e = this.decodeUtf8String(o, 4);
          } else if (t === 220) {
            var s = this.readU16();
            if (s !== 0) {
              this.pushArrayState(s), this.complete();
              continue t;
            } else
              e = [];
          } else if (t === 221) {
            var s = this.readU32();
            if (s !== 0) {
              this.pushArrayState(s), this.complete();
              continue t;
            } else
              e = [];
          } else if (t === 222) {
            var s = this.readU16();
            if (s !== 0) {
              this.pushMapState(s), this.complete();
              continue t;
            } else
              e = {};
          } else if (t === 223) {
            var s = this.readU32();
            if (s !== 0) {
              this.pushMapState(s), this.complete();
              continue t;
            } else
              e = {};
          } else if (t === 196) {
            var s = this.lookU8();
            e = this.decodeBinary(s, 1);
          } else if (t === 197) {
            var s = this.lookU16();
            e = this.decodeBinary(s, 2);
          } else if (t === 198) {
            var s = this.lookU32();
            e = this.decodeBinary(s, 4);
          } else if (t === 212)
            e = this.decodeExtension(1, 0);
          else if (t === 213)
            e = this.decodeExtension(2, 0);
          else if (t === 214)
            e = this.decodeExtension(4, 0);
          else if (t === 215)
            e = this.decodeExtension(8, 0);
          else if (t === 216)
            e = this.decodeExtension(16, 0);
          else if (t === 199) {
            var s = this.lookU8();
            e = this.decodeExtension(s, 1);
          } else if (t === 200) {
            var s = this.lookU16();
            e = this.decodeExtension(s, 2);
          } else if (t === 201) {
            var s = this.lookU32();
            e = this.decodeExtension(s, 4);
          } else
            throw new Un$1("Unrecognized type byte: ".concat(Ju(t)));
          this.complete();
          for (var r = this.stack; r.length > 0; ) {
            var i6 = r[r.length - 1];
            if (i6.type === 0)
              if (i6.array[i6.position] = e, i6.position++, i6.position === i6.size)
                r.pop(), e = i6.array;
              else
                continue t;
            else if (i6.type === 1) {
              if (!p4(e))
                throw new Un$1("The type of key must be string or number but " + typeof e);
              if (e === "__proto__")
                throw new Un$1("The key __proto__ is not allowed");
              i6.key = e, i6.type = 2;
              continue t;
            } else if (i6.map[i6.key] = e, i6.readCount++, i6.readCount === i6.size)
              r.pop(), e = i6.map;
            else {
              i6.key = null, i6.type = 1;
              continue t;
            }
          }
          return e;
        }
    }, n.prototype.readHeadByte = function() {
      return this.headByte === zr && (this.headByte = this.readU8()), this.headByte;
    }, n.prototype.complete = function() {
      this.headByte = zr;
    }, n.prototype.readArraySize = function() {
      var t = this.readHeadByte();
      switch (t) {
        case 220:
          return this.readU16();
        case 221:
          return this.readU32();
        default: {
          if (t < 160)
            return t - 144;
          throw new Un$1("Unrecognized array type byte: ".concat(Ju(t)));
        }
      }
    }, n.prototype.pushMapState = function(t) {
      if (t > this.maxMapLength)
        throw new Un$1("Max length exceeded: map length (".concat(t, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
      this.stack.push({
        type: 1,
        size: t,
        key: null,
        readCount: 0,
        map: {}
      });
    }, n.prototype.pushArrayState = function(t) {
      if (t > this.maxArrayLength)
        throw new Un$1("Max length exceeded: array length (".concat(t, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
      this.stack.push({
        type: 0,
        size: t,
        array: new Array(t),
        position: 0
      });
    }, n.prototype.decodeUtf8String = function(t, e) {
      var s;
      if (t > this.maxStrLength)
        throw new Un$1("Max length exceeded: UTF-8 byte length (".concat(t, ") > maxStrLength (").concat(this.maxStrLength, ")"));
      if (this.bytes.byteLength < this.pos + e + t)
        throw Gg$1;
      var o = this.pos + e, r;
      return this.stateIsMapKey() && (!((s = this.keyDecoder) === null || s === void 0) && s.canBeCached(t)) ? r = this.keyDecoder.decode(this.bytes, o, t) : t > Z5 ? r = B5(this.bytes, o, t) : r = II(this.bytes, o, t), this.pos += e + t, r;
    }, n.prototype.stateIsMapKey = function() {
      if (this.stack.length > 0) {
        var t = this.stack[this.stack.length - 1];
        return t.type === 1;
      }
      return false;
    }, n.prototype.decodeBinary = function(t, e) {
      if (t > this.maxBinLength)
        throw new Un$1("Max length exceeded: bin length (".concat(t, ") > maxBinLength (").concat(this.maxBinLength, ")"));
      if (!this.hasRemaining(t + e))
        throw Gg$1;
      var s = this.pos + e, o = this.bytes.subarray(s, s + t);
      return this.pos += e + t, o;
    }, n.prototype.decodeExtension = function(t, e) {
      if (t > this.maxExtLength)
        throw new Un$1("Max length exceeded: ext length (".concat(t, ") > maxExtLength (").concat(this.maxExtLength, ")"));
      var s = this.view.getInt8(this.pos + e), o = this.decodeBinary(
        t,
        e + 1
        /* extType */
      );
      return this.extensionCodec.decode(o, s, this.context);
    }, n.prototype.lookU8 = function() {
      return this.view.getUint8(this.pos);
    }, n.prototype.lookU16 = function() {
      return this.view.getUint16(this.pos);
    }, n.prototype.lookU32 = function() {
      return this.view.getUint32(this.pos);
    }, n.prototype.readU8 = function() {
      var t = this.view.getUint8(this.pos);
      return this.pos++, t;
    }, n.prototype.readI8 = function() {
      var t = this.view.getInt8(this.pos);
      return this.pos++, t;
    }, n.prototype.readU16 = function() {
      var t = this.view.getUint16(this.pos);
      return this.pos += 2, t;
    }, n.prototype.readI16 = function() {
      var t = this.view.getInt16(this.pos);
      return this.pos += 2, t;
    }, n.prototype.readU32 = function() {
      var t = this.view.getUint32(this.pos);
      return this.pos += 4, t;
    }, n.prototype.readI32 = function() {
      var t = this.view.getInt32(this.pos);
      return this.pos += 4, t;
    }, n.prototype.readU64 = function() {
      var t = F5(this.view, this.pos);
      return this.pos += 8, t;
    }, n.prototype.readI64 = function() {
      var t = wI(this.view, this.pos);
      return this.pos += 8, t;
    }, n.prototype.readF32 = function() {
      var t = this.view.getFloat32(this.pos);
      return this.pos += 4, t;
    }, n.prototype.readF64 = function() {
      var t = this.view.getFloat64(this.pos);
      return this.pos += 8, t;
    }, n;
  }()
), b4 = {};
function x4(n, t) {
  t === void 0 && (t = b4);
  var e = new g4(t.extensionCodec, t.context, t.maxStrLength, t.maxBinLength, t.maxArrayLength, t.maxMapLength, t.maxExtLength);
  return e.decode(n);
}
const Eg$1 = 2;
class y4 {
  constructor() {
    this.data = null;
  }
  // input html Images
  compileImageTargets(t, e) {
    return new Promise(async (s, o) => {
      const r = [];
      for (let c = 0; c < t.length; c++) {
        const u = t[c], h6 = this.createProcessCanvas(u).getContext("2d");
        h6.drawImage(u, 0, 0, u.width, u.height);
        const p6 = h6.getImageData(0, 0, u.width, u.height), f = new Uint8Array(u.width * u.height);
        for (let g6 = 0; g6 < f.length; g6++) {
          const b6 = g6 * 4;
          f[g6] = Math.floor((p6.data[b6] + p6.data[b6 + 1] + p6.data[b6 + 2]) / 3);
        }
        const m = { data: f, height: u.height, width: u.width };
        r.push(m);
      }
      const i6 = 50 / r.length;
      let a = 0;
      this.data = [];
      for (let c = 0; c < r.length; c++) {
        const u = r[c], d = T5(u), h6 = i6 / d.length, p6 = await w4(d, () => {
          a += h6, e(a);
        });
        this.data.push({
          targetImage: u,
          imageList: d,
          matchingData: p6
        });
      }
      for (let c = 0; c < r.length; c++) {
        const u = N5(r[c]);
        this.data[c].trackingImageList = u;
      }
      const l = await this.compileTrack({ progressCallback: e, targetImages: r, basePercent: 50 });
      for (let c = 0; c < r.length; c++)
        this.data[c].trackingData = l[c];
      s(this.data);
    });
  }
  // not exporting imageList because too large. rebuild this using targetImage
  exportData() {
    const t = [];
    for (let s = 0; s < this.data.length; s++)
      t.push({
        //targetImage: this.data[i].targetImage,
        targetImage: {
          width: this.data[s].targetImage.width,
          height: this.data[s].targetImage.height
        },
        trackingData: this.data[s].trackingData,
        matchingData: this.data[s].matchingData
      });
    return a4({
      v: Eg$1,
      dataList: t
    });
  }
  importData(t) {
    const e = x4(new Uint8Array(t));
    if (!e.v || e.v !== Eg$1)
      return console.error("Your compiled .mind might be outdated. Please recompile"), [];
    const { dataList: s } = e;
    this.data = [];
    for (let o = 0; o < s.length; o++)
      this.data.push({
        targetImage: s[o].targetImage,
        trackingData: s[o].trackingData,
        matchingData: s[o].matchingData
      });
    return this.data;
  }
  createProcessCanvas(t) {
    console.warn("missing createProcessCanvas implementation");
  }
  compileTrack({ progressCallback: t, targetImages: e, basePercent: s }) {
    console.warn("missing compileTrack implementation");
  }
}
const w4 = async (n, t) => {
  const e = [];
  for (let s = 0; s < n.length; s++) {
    const o = n[s], r = new gI(o.width, o.height);
    await _c(), D(() => {
      const i6 = Re$1(o.data, [o.data.length], "float32").reshape([o.height, o.width]), { featurePoints: a } = r.detect(i6), l = a.filter((h6) => h6.maxima), c = a.filter((h6) => !h6.maxima), u = Ng$1({ points: l }), d = Ng$1({ points: c });
      e.push({
        maximaPoints: l,
        minimaPoints: c,
        maximaPointsCluster: u,
        minimaPointsCluster: d,
        width: o.width,
        height: o.height,
        scale: o.scale
      }), t(s);
    });
  }
  return e;
}, vI = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHp7Y29uc3RydWN0b3Iocyx0LG8pe3RoaXMuY3Vtc3VtPVtdO2ZvcihsZXQgZT0wO2U8bztlKyspe3RoaXMuY3Vtc3VtLnB1c2goW10pO2ZvcihsZXQgbj0wO248dDtuKyspdGhpcy5jdW1zdW1bZV0ucHVzaCgwKX10aGlzLmN1bXN1bVswXVswXT1zWzBdO2ZvcihsZXQgZT0xO2U8dDtlKyspdGhpcy5jdW1zdW1bMF1bZV09dGhpcy5jdW1zdW1bMF1bZS0xXStzW2VdO2ZvcihsZXQgZT0xO2U8bztlKyspdGhpcy5jdW1zdW1bZV1bMF09dGhpcy5jdW1zdW1bZS0xXVswXStzW2UqdF07Zm9yKGxldCBlPTE7ZTxvO2UrKylmb3IobGV0IG49MTtuPHQ7bisrKXRoaXMuY3Vtc3VtW2VdW25dPXNbZSp0K25dK3RoaXMuY3Vtc3VtW2UtMV1bbl0rdGhpcy5jdW1zdW1bZV1bbi0xXS10aGlzLmN1bXN1bVtlLTFdW24tMV19cXVlcnkocyx0LG8sZSl7bGV0IG49dGhpcy5jdW1zdW1bZV1bb107cmV0dXJuIHQ+MCYmKG4tPXRoaXMuY3Vtc3VtW3QtMV1bb10pLHM+MCYmKG4tPXRoaXMuY3Vtc3VtW2VdW3MtMV0pLHM+MCYmdD4wJiYobis9dGhpcy5jdW1zdW1bdC0xXVtzLTFdKSxufX1jb25zdCBDPTEwLGI9MixNPTYsRj01LEk9Ljk1LEw9LjksTz0uMixaPTgsTj0yNCoyLzMsVT1yPT57Y29uc3R7ZGF0YTpzLHdpZHRoOnQsaGVpZ2h0Om8sc2NhbGU6ZX09cixuPVt0Km9dO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKW5baV09ITE7Y29uc3QgYT1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWFbaV09LTEsYVt0KihvLTEpK2ldPS0xO2ZvcihsZXQgaT0wO2k8bztpKyspYVtpKnRdPS0xLGFbaSp0K3QtMV09LTE7Zm9yKGxldCBpPTE7aTx0LTE7aSsrKWZvcihsZXQgcD0xO3A8by0xO3ArKyl7bGV0IGY9aSt0KnAsaD0wLGM9MDtmb3IobGV0IHU9LTE7dTw9MTt1KyspaCs9c1tmK3QqdSsxXS1zW2YrdCp1LTFdLGMrPXNbZit0K3VdLXNbZi10K3VdO2gvPTMqMjU2LGMvPTMqMjU2LGFbZl09TWF0aC5zcXJ0KChoKmgrYypjKS8yKX1jb25zdCBnPW5ldyBVaW50MzJBcnJheSgxZTMpO2ZvcihsZXQgaT0wO2k8MWUzO2krKylnW2ldPTA7Y29uc3QgZD1bLTEsMSwtdCx0XTtmb3IobGV0IGk9MTtpPHQtMTtpKyspZm9yKGxldCBwPTE7cDxvLTE7cCsrKXtsZXQgZj1pK3QqcCxoPSEwO2ZvcihsZXQgYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGFbZl08PWFbZitkW2NdXSl7aD0hMTticmVha31pZihoKXtsZXQgYz1NYXRoLmZsb29yKGFbZl0qMWUzKTtjPjk5OSYmKGM9OTk5KSxjPDAmJihjPTApLGdbY10rPTEsbltmXT0hMH19Y29uc3Qgdz0uMDIqdCpvO2xldCBqPTk5OSxFPTA7Zm9yKDtqPj0wJiYoRSs9Z1tqXSwhKEU+dykpOylqLS07Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDtpKyspbltpXSYmYVtpXSoxZTM8aiYmKG5baV09ITEpO2NvbnN0IGw9W107Zm9yKGxldCBpPTA7aTxzLmxlbmd0aDtpKyspbFtpXT1zW2ldKnNbaV07Y29uc3QgUz1uZXcgeihzLHQsbyksRD1uZXcgeihsLHQsbyksaz1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgcD0wO3A8bztwKyspe2NvbnN0IGY9cCp0K2k7aWYoIW5bZl0pe2tbZl09MTtjb250aW51ZX1jb25zdCBoPVAoe2ltYWdlOnIsY3g6aSxjeTpwLHNkVGhyZXNoOkYsaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KTtpZihoPT09bnVsbCl7a1tmXT0xO2NvbnRpbnVlfWxldCBjPS0xO2ZvcihsZXQgdT0tQzt1PD1DO3UrKyl7Zm9yKGxldCBtPS1DO208PUM7bSsrKXtpZihtKm0rdSp1PD1iKmIpY29udGludWU7Y29uc3QgeD1SKHtpbWFnZTpyLGN4OmkrbSxjeTpwK3UsdmxlbjpoLHR4OmksdHk6cCxpbWFnZURhdGFDdW1zdW06UyxpbWFnZURhdGFTcXJDdW1zdW06RH0pO2lmKHghPT1udWxsJiZ4PmMmJihjPXgsYz5JKSlicmVha31pZihjPkkpYnJlYWt9a1tmXT1jfXJldHVybiBWKHtpbWFnZTpyLGZlYXR1cmVNYXA6ayx0ZW1wbGF0ZVNpemU6TSxzZWFyY2hTaXplOmIsb2NjU2l6ZTpOLG1heFNpbVRocmVzaDpMLG1pblNpbVRocmVzaDpPLHNkVGhyZXNoOlosaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KX0sVj1yPT57bGV0e2ltYWdlOnMsZmVhdHVyZU1hcDp0LHRlbXBsYXRlU2l6ZTpvLHNlYXJjaFNpemU6ZSxvY2NTaXplOm4sbWF4U2ltVGhyZXNoOmEsbWluU2ltVGhyZXNoOmcsc2RUaHJlc2g6ZCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an09cjtjb25zdHtkYXRhOkUsd2lkdGg6bCxoZWlnaHQ6UyxzY2FsZTpEfT1zO249TWF0aC5mbG9vcihNYXRoLm1pbihzLndpZHRoLHMuaGVpZ2h0KS8xMCk7Y29uc3Qgaz0obyoyKzEpKjMsQT1NYXRoLmZsb29yKGwvayksaT1NYXRoLmZsb29yKFMvayk7bGV0IHA9TWF0aC5mbG9vcihsL24pKk1hdGguZmxvb3IoUy9uKStBKmk7Y29uc3QgZj1bXSxoPW5ldyBGbG9hdDMyQXJyYXkoRS5sZW5ndGgpO2ZvcihsZXQgdT0wO3U8aC5sZW5ndGg7dSsrKWhbdV09dFt1XTtsZXQgYz0wO2Zvcig7YzxwOyl7bGV0IHU9YSxtPS0xLHg9LTE7Zm9yKGxldCB5PTA7eTxTO3krKylmb3IobGV0IFQ9MDtUPGw7VCsrKWhbeSpsK1RdPHUmJih1PWhbeSpsK1RdLG09VCx4PXkpO2lmKG09PT0tMSlicmVhaztjb25zdCB2PVAoe2ltYWdlOnMsY3g6bSxjeTp4LHNkVGhyZXNoOjAsaW1hZ2VEYXRhQ3Vtc3VtOncsaW1hZ2VEYXRhU3FyQ3Vtc3VtOmp9KTtpZih2PT09bnVsbCl7aFt4KmwrbV09MTtjb250aW51ZX1pZih2LyhvKjIrMSk8ZCl7aFt4KmwrbV09MTtjb250aW51ZX1sZXQgcT0xLF89LTE7Zm9yKGxldCB5PS1lO3k8PWU7eSsrKXtmb3IobGV0IFQ9LWU7VDw9ZTtUKyspe2lmKFQqVCt5Knk+ZSplfHxUPT09MCYmeT09PTApY29udGludWU7Y29uc3QgSD1SKHtpbWFnZTpzLHZsZW46dixjeDptK1QsY3k6eCt5LHR4Om0sdHk6eCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an0pO2lmKEghPT1udWxsJiYoSDxxJiYocT1ILHE8ZyYmcTx1KXx8SD5fJiYoXz1ILF8+Ljk5KSkpYnJlYWt9aWYocTxnJiZxPHV8fF8+Ljk5KWJyZWFrfWlmKHE8ZyYmcTx1fHxfPi45OSl7aFt4KmwrbV09MTtjb250aW51ZX1mLnB1c2goe3g6bSx5Onh9KSxjKz0xO2ZvcihsZXQgeT0tbjt5PD1uO3krKylmb3IobGV0IFQ9LW47VDw9bjtUKyspeCt5PDB8fHgreT49U3x8bStUPDB8fG0rVD49bHx8KGhbKHgreSkqbCsobStUKV09MSl9cmV0dXJuIGZ9LFA9KHtpbWFnZTpyLGN4OnMsY3k6dCxzZFRocmVzaDpvLGltYWdlRGF0YUN1bXN1bTplLGltYWdlRGF0YVNxckN1bXN1bTpufSk9PntpZihzLU08MHx8cytNPj1yLndpZHRofHx0LU08MHx8dCtNPj1yLmhlaWdodClyZXR1cm4gbnVsbDtjb25zdCBhPTIqTSsxLGc9YSphO2xldCBkPWUucXVlcnkocy1NLHQtTSxzK00sdCtNKTtkLz1nO2xldCB3PW4ucXVlcnkocy1NLHQtTSxzK00sdCtNKTtyZXR1cm4gdy09MipkKmUucXVlcnkocy1NLHQtTSxzK00sdCtNKSx3Kz1nKmQqZCx3L2c8bypvP251bGw6KHc9TWF0aC5zcXJ0KHcpLHcpfSxSPXI9Pntjb25zdHtpbWFnZTpzLGN4OnQsY3k6byx2bGVuOmUsdHg6bix0eTphLGltYWdlRGF0YUN1bXN1bTpnLGltYWdlRGF0YVNxckN1bXN1bTpkfT1yLHtkYXRhOncsd2lkdGg6aixoZWlnaHQ6RX09cyxsPU07aWYodC1sPDB8fHQrbD49anx8by1sPDB8fG8rbD49RSlyZXR1cm4gbnVsbDtjb25zdCBTPTIqbCsxO2xldCBEPWcucXVlcnkodC1sLG8tbCx0K2wsbytsKSxrPWQucXVlcnkodC1sLG8tbCx0K2wsbytsKSxBPTAsaT0oby1sKSpqKyh0LWwpLHA9KGEtbCkqaisobi1sKSxmPWotUztmb3IobGV0IG09MDttPFM7bSsrKXtmb3IobGV0IHg9MDt4PFM7eCsrKUErPXdbaV0qd1twXSxpKz0xLHArPTE7aSs9ZixwKz1mfWxldCBoPWcucXVlcnkobi1sLGEtbCxuK2wsYStsKTtoLz1TKlMsQS09aCpEO2xldCBjPWstRCpELyhTKlMpO3JldHVybiBjPT0wP251bGw6KGM9TWF0aC5zcXJ0KGMpLDEqQS8oZSpjKSl9LFc9KHIscyk9Pntjb25zdCB0PVtdO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdCBlPXJbb10sbj1VKGUpLGE9e2RhdGE6ZS5kYXRhLHNjYWxlOmUuc2NhbGUsd2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHQscG9pbnRzOm59O3QucHVzaChhKSxzKG8pfXJldHVybiB0fSxYPSh7aW1hZ2U6cixyYXRpbzpzfSk9Pntjb25zdCB0PU1hdGgucm91bmQoci53aWR0aCpzKSxvPU1hdGgucm91bmQoci5oZWlnaHQqcyksZT1uZXcgVWludDhBcnJheSh0Km8pO2ZvcihsZXQgbj0wO248dDtuKyspe2xldCBhPU1hdGgucm91bmQoMSpuL3MpLGc9TWF0aC5yb3VuZCgxKihuKzEpL3MpLTE7Zz49ci53aWR0aCYmKGc9ci53aWR0aC0xKTtmb3IobGV0IGQ9MDtkPG87ZCsrKXtsZXQgdz1NYXRoLnJvdW5kKDEqZC9zKSxqPU1hdGgucm91bmQoMSooZCsxKS9zKS0xO2o+PXIuaGVpZ2h0JiYoaj1yLmhlaWdodC0xKTtsZXQgRT0wLGw9MDtmb3IobGV0IFM9YTtTPD1nO1MrKylmb3IobGV0IEQ9dztEPD1qO0QrKylFKz0xKnIuZGF0YVtEKnIud2lkdGgrU10sbCs9MTtlW2QqdCtuXT1NYXRoLmZsb29yKEUvbCl9fXJldHVybntkYXRhOmUsd2lkdGg6dCxoZWlnaHQ6b319LFk9cj0+e2NvbnN0IHM9TWF0aC5taW4oci53aWR0aCxyLmhlaWdodCksdD1bXSxvPVtdO3QucHVzaCgyNTYvcyksdC5wdXNoKDEyOC9zKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylvLnB1c2goT2JqZWN0LmFzc2lnbihYKHtpbWFnZTpyLHJhdGlvOnRbZV19KSx7c2NhbGU6dFtlXX0pKTtyZXR1cm4gb307b25tZXNzYWdlPXI9Pntjb25zdHtkYXRhOnN9PXI7aWYocy50eXBlPT09ImNvbXBpbGUiKXtjb25zdHt0YXJnZXRJbWFnZXM6dH09cyxvPTEwMC90Lmxlbmd0aDtsZXQgZT0wO2NvbnN0IG49W107Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspe2NvbnN0IGc9dFthXSxkPVkoZyksdz1vL2QubGVuZ3RoLGo9VyhkLEU9PntlKz13LHBvc3RNZXNzYWdlKHt0eXBlOiJwcm9ncmVzcyIscGVyY2VudDplfSl9KTtuLnB1c2goail9cG9zdE1lc3NhZ2Uoe3R5cGU6ImNvbXBpbGVEb25lIixsaXN0Om59KX19fSkoKTsK", Lg$1 = typeof window < "u" && window.Blob && new Blob([atob(vI)], { type: "text/javascript;charset=utf-8" });
function I4() {
  let n;
  try {
    if (n = Lg$1 && (window.URL || window.webkitURL).createObjectURL(Lg$1), !n)
      throw "";
    return new Worker(n);
  } catch {
    return new Worker("data:application/javascript;base64," + vI);
  } finally {
    n && (window.URL || window.webkitURL).revokeObjectURL(n);
  }
}
class C4 extends y4 {
  createProcessCanvas(t) {
    const e = document.createElement("canvas");
    return e.width = t.width, e.height = t.height, e;
  }
  compileTrack({ progressCallback: t, targetImages: e, basePercent: s }) {
    return new Promise((o, r) => {
      const i6 = new I4();
      i6.onmessage = (a) => {
        a.data.type === "progress" ? t(s + a.data.percent * s / 100) : a.data.type === "compileDone" && o(a.data.list);
      }, i6.postMessage({ type: "compile", targetImages: e });
    });
  }
}
class v4 {
  constructor(t, e) {
    this.width = t, this.height = e, this.texShape = [e, t];
    const s = document.createElement("canvas").getContext("2d");
    s.canvas.width = t, s.canvas.height = e, this.context = s, this.program = this.buildProgram(t, e);
    const o = $s();
    this.tempPixelHandle = o.makeTensorInfo(this.texShape, "float32"), o.texData.get(this.tempPixelHandle.dataId).usage = 2;
  }
  // old method
  _loadInput(t) {
    return D(() => {
      let e = b0(t);
      return e = e.mean(2), e;
    });
  }
  // input is instance of HTMLVideoElement or HTMLImageElement
  loadInput(t) {
    const e = this.context;
    if (e.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height), t.width === this.height && t.height === this.width) {
      let i6 = this.context.canvas.width / 2, a = this.context.canvas.height / 2, l = 90;
      e.save(), e.translate(i6, a), e.rotate(l * Math.PI / 180), e.drawImage(t, -t.width / 2, -t.height / 2), e.restore();
    } else
      this.context.drawImage(t, 0, 0, t.width, t.height);
    const o = $s();
    return o.gpgpu.uploadPixelDataToTexture(o.getTexture(this.tempPixelHandle.dataId), this.context.canvas), this._compileAndRun(this.program, [this.tempPixelHandle]);
  }
  buildProgram(t, e) {
    const s = F().getNumber("WEBGL_VERSION") === 2 ? "texture" : "texture2D";
    return {
      variableNames: ["A"],
      outputShape: this.texShape,
      userCode: `
	void main() {
	  ivec2 coords = getOutputCoords();
	  int texR = coords[0];
	  int texC = coords[1];
	  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}.0, ${e}.0);

	  vec4 values = ${s}(A, uv);
	  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);
	}
      `
    };
  }
  _compileAndRun(t, e) {
    const s = $s().compileAndRun(t, e);
    return Xt().makeTensorFromDataId(s.dataId, s.shape, s.dtype);
  }
  _runWebGLProgram(t, e, s) {
    const o = $s().runWebGLProgram(t, e, s);
    return Xt().makeTensorFromDataId(o.dataId, o.shape, o.dtype);
  }
}
const qu = { memory: cl, nextFrame: _c }, S4 = 1e-3, k4 = 1e3, T4 = 5, N4 = 5;
class MY {
  constructor({
    inputWidth: t,
    inputHeight: e,
    onUpdate: s = null,
    debugMode: o = false,
    maxTrack: r = 1,
    warmupTolerance: i6 = null,
    missTolerance: a = null,
    filterMinCF: l = null,
    filterBeta: c = null
  }) {
    this.inputWidth = t, this.inputHeight = e, this.maxTrack = r, this.filterMinCF = l === null ? S4 : l, this.filterBeta = c === null ? k4 : c, this.warmupTolerance = i6 === null ? T4 : i6, this.missTolerance = a === null ? N4 : a, this.cropDetector = new S5(this.inputWidth, this.inputHeight, o), this.inputLoader = new v4(this.inputWidth, this.inputHeight), this.markerDimensions = null, this.onUpdate = s, this.debugMode = o, this.processingVideo = false, this.interestedTargetIndex = -1, this.trackingStates = [];
    const u = 10, d = 1e5, h6 = 45 * Math.PI / 180, p6 = this.inputHeight / 2 / Math.tan(h6 / 2);
    this.projectionTransform = [
      [p6, 0, this.inputWidth / 2],
      [0, p6, this.inputHeight / 2],
      [0, 0, 1]
    ], this.projectionMatrix = this._glProjectionMatrix({
      projectionTransform: this.projectionTransform,
      width: this.inputWidth,
      height: this.inputHeight,
      near: u,
      far: d
    }), this.worker = new NU(), this.workerMatchDone = null, this.workerTrackDone = null, this.worker.onmessage = (f) => {
      f.data.type === "matchDone" && this.workerMatchDone !== null && this.workerMatchDone(f.data), f.data.type === "trackUpdateDone" && this.workerTrackDone !== null && this.workerTrackDone(f.data);
    };
  }
  showTFStats() {
    console.log(qu.memory().numTensors), console.table(qu.memory());
  }
  addImageTargets(t) {
    return new Promise(async (e, s) => {
      const r = await (await fetch(t)).arrayBuffer(), i6 = this.addImageTargetsFromBuffer(r);
      e(i6);
    });
  }
  addImageTargetsFromBuffer(t) {
    const s = new C4().importData(t), o = [], r = [], i6 = [];
    for (let a = 0; a < s.length; a++)
      r.push(s[a].matchingData), o.push(s[a].trackingData), i6.push([s[a].targetImage.width, s[a].targetImage.height]);
    return this.tracker = new VU(i6, o, this.projectionTransform, this.inputWidth, this.inputHeight, this.debugMode), this.worker.postMessage({
      type: "setup",
      inputWidth: this.inputWidth,
      inputHeight: this.inputHeight,
      projectionTransform: this.projectionTransform,
      debugMode: this.debugMode,
      matchingDataList: r
    }), this.markerDimensions = i6, { dimensions: i6, matchingDataList: r, trackingDataList: o };
  }
  dispose() {
    this.stopProcessVideo(), this.worker.postMessage({
      type: "dispose"
    });
  }
  // warm up gpu - build kernels is slow
  dummyRun(t) {
    const e = this.inputLoader.loadInput(t);
    this.cropDetector.detect(e), this.tracker.dummyRun(e), e.dispose();
  }
  getProjectionMatrix() {
    return this.projectionMatrix;
  }
  getRotatedZ90Matrix(t) {
    return [
      -t[1],
      t[0],
      t[2],
      t[3],
      -t[5],
      t[4],
      t[6],
      t[7],
      -t[9],
      t[8],
      t[10],
      t[11],
      -t[13],
      t[12],
      t[14],
      t[15]
    ];
  }
  getWorldMatrix(t, e) {
    return this._glModelViewMatrix(t, e);
  }
  async _detectAndMatch(t, e) {
    const { featurePoints: s } = this.cropDetector.detectMoving(t), { targetIndex: o, modelViewTransform: r } = await this._workerMatch(s, e);
    return { targetIndex: o, modelViewTransform: r };
  }
  async _trackAndUpdate(t, e, s) {
    const { worldCoords: o, screenCoords: r } = this.tracker.track(t, e, s);
    return o.length < 4 ? null : await this._workerTrackUpdate(e, { worldCoords: o, screenCoords: r });
  }
  processVideo(t) {
    if (this.processingVideo)
      return;
    this.processingVideo = true, this.trackingStates = [];
    for (let s = 0; s < this.markerDimensions.length; s++)
      this.trackingStates.push({
        showing: false,
        isTracking: false,
        currentModelViewTransform: null,
        trackCount: 0,
        trackMiss: 0,
        filter: new P({ minCutOff: this.filterMinCF, beta: this.filterBeta })
      });
    (async () => {
      for (; this.processingVideo; ) {
        const s = this.inputLoader.loadInput(t);
        if (this.trackingStates.reduce((r, i6) => r + (i6.isTracking ? 1 : 0), 0) < this.maxTrack) {
          const r = [];
          for (let l = 0; l < this.trackingStates.length; l++)
            this.trackingStates[l].isTracking !== true && (this.interestedTargetIndex !== -1 && this.interestedTargetIndex !== l || r.push(l));
          const { targetIndex: i6, modelViewTransform: a } = await this._detectAndMatch(s, r);
          i6 !== -1 && (this.trackingStates[i6].isTracking = true, this.trackingStates[i6].currentModelViewTransform = a);
        }
        for (let r = 0; r < this.trackingStates.length; r++) {
          const i6 = this.trackingStates[r];
          if (i6.isTracking) {
            let a = await this._trackAndUpdate(s, i6.currentModelViewTransform, r);
            a === null ? i6.isTracking = false : i6.currentModelViewTransform = a;
          }
          if (i6.showing || i6.isTracking && (i6.trackMiss = 0, i6.trackCount += 1, i6.trackCount > this.warmupTolerance && (i6.showing = true, i6.trackingMatrix = null, i6.filter.reset())), i6.showing && (i6.isTracking ? i6.trackMiss = 0 : (i6.trackCount = 0, i6.trackMiss += 1, i6.trackMiss > this.missTolerance && (i6.showing = false, i6.trackingMatrix = null, this.onUpdate && this.onUpdate({ type: "updateMatrix", targetIndex: r, worldMatrix: null })))), i6.showing) {
            const a = this._glModelViewMatrix(i6.currentModelViewTransform, r);
            i6.trackingMatrix = i6.filter.filter(Date.now(), a);
            let l = [];
            for (let u = 0; u < i6.trackingMatrix.length; u++)
              l[u] = i6.trackingMatrix[u];
            t.width === this.inputHeight && t.height === this.inputWidth && (l = this.getRotatedZ90Matrix(l)), this.onUpdate && this.onUpdate({ type: "updateMatrix", targetIndex: r, worldMatrix: l });
          }
        }
        s.dispose(), this.onUpdate && this.onUpdate({ type: "processDone" }), await qu.nextFrame();
      }
    })();
  }
  stopProcessVideo() {
    this.processingVideo = false;
  }
  async detect(t) {
    const e = this.inputLoader.loadInput(t), { featurePoints: s, debugExtra: o } = await this.cropDetector.detect(e);
    return e.dispose(), { featurePoints: s, debugExtra: o };
  }
  async match(t, e) {
    const { modelViewTransform: s, debugExtra: o } = await this._workerMatch(t, [e]);
    return { modelViewTransform: s, debugExtra: o };
  }
  async track(t, e, s) {
    const o = this.inputLoader.loadInput(t), r = this.tracker.track(o, e, s);
    return o.dispose(), r;
  }
  async trackUpdate(t, e) {
    return e.worldCoords.length < 4 ? null : await this._workerTrackUpdate(t, e);
  }
  _workerMatch(t, e) {
    return new Promise(async (s, o) => {
      this.workerMatchDone = (r) => {
        s({ targetIndex: r.targetIndex, modelViewTransform: r.modelViewTransform, debugExtra: r.debugExtra });
      }, this.worker.postMessage({ type: "match", featurePoints: t, targetIndexes: e });
    });
  }
  _workerTrackUpdate(t, e) {
    return new Promise(async (s, o) => {
      this.workerTrackDone = (a) => {
        s(a.modelViewTransform);
      };
      const { worldCoords: r, screenCoords: i6 } = e;
      this.worker.postMessage({ type: "trackUpdate", modelViewTransform: t, worldCoords: r, screenCoords: i6 });
    });
  }
  _glModelViewMatrix(t, e) {
    const s = this.markerDimensions[e][1];
    return [
      t[0][0],
      -t[1][0],
      -t[2][0],
      0,
      -t[0][1],
      t[1][1],
      t[2][1],
      0,
      -t[0][2],
      t[1][2],
      t[2][2],
      0,
      t[0][1] * s + t[0][3],
      -(t[1][1] * s + t[1][3]),
      -(t[2][1] * s + t[2][3]),
      1
    ];
  }
  // build openGL projection matrix
  // ref: https://strawlab.org/2011/11/05/augmented-reality-with-OpenGL/
  _glProjectionMatrix({ projectionTransform: t, width: e, height: s, near: o, far: r }) {
    const i6 = [
      [2 * t[0][0] / e, 0, -(2 * t[0][2] / e - 1), 0],
      [0, 2 * t[1][1] / s, -(2 * t[1][2] / s - 1), 0],
      [0, 0, -(r + o) / (r - o), -2 * r * o / (r - o)],
      [0, 0, -1, 0]
    ], a = [];
    for (let l = 0; l < 4; l++)
      for (let c = 0; c < 4; c++)
        a.push(i6[c][l]);
    return a;
  }
}
const _position = new Vector3();
const _quaternion = new Quaternion();
const _scale = new Vector3();
const _matrix = new Matrix4();
const _matrix2 = new Matrix4();
class CSS3DRenderer {
  constructor(parameters = {}) {
    const _this = this;
    let _width, _height;
    let _widthHalf, _heightHalf;
    const cache = {
      camera: { style: "" },
      objects: /* @__PURE__ */ new WeakMap()
    };
    const domElement = parameters.element !== void 0 ? parameters.element : document.createElement("div");
    domElement.style.overflow = "hidden";
    this.domElement = domElement;
    const viewElement = document.createElement("div");
    viewElement.style.transformOrigin = "0 0";
    viewElement.style.pointerEvents = "none";
    domElement.appendChild(viewElement);
    const cameraElement = document.createElement("div");
    cameraElement.style.transformStyle = "preserve-3d";
    viewElement.appendChild(cameraElement);
    this.getSize = function() {
      return {
        width: _width,
        height: _height
      };
    };
    this.render = function(scene, camera) {
      const fov2 = camera.projectionMatrix.elements[5] * _heightHalf;
      if (camera.view && camera.view.enabled) {
        viewElement.style.transform = `translate( ${-camera.view.offsetX * (_width / camera.view.width)}px, ${-camera.view.offsetY * (_height / camera.view.height)}px )`;
        viewElement.style.transform += `scale( ${camera.view.fullWidth / camera.view.width}, ${camera.view.fullHeight / camera.view.height} )`;
      } else {
        viewElement.style.transform = "";
      }
      if (scene.matrixWorldAutoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
        camera.updateMatrixWorld();
      let tx2, ty3;
      if (camera.isOrthographicCamera) {
        tx2 = -(camera.right + camera.left) / 2;
        ty3 = (camera.top + camera.bottom) / 2;
      }
      const scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1;
      const cameraCSSMatrix = camera.isOrthographicCamera ? `scale( ${scaleByViewOffset} )scale(` + fov2 + ")translate(" + epsilon(tx2) + "px," + epsilon(ty3) + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse) : `scale( ${scaleByViewOffset} )translateZ(` + fov2 + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse);
      const perspective = camera.isPerspectiveCamera ? "perspective(" + fov2 + "px) " : "";
      const style2 = perspective + cameraCSSMatrix + "translate(" + _widthHalf + "px," + _heightHalf + "px)";
      if (cache.camera.style !== style2) {
        cameraElement.style.transform = style2;
        cache.camera.style = style2;
      }
      renderObject(scene, scene, camera);
    };
    this.setSize = function(width, height) {
      _width = width;
      _height = height;
      _widthHalf = _width / 2;
      _heightHalf = _height / 2;
      domElement.style.width = width + "px";
      domElement.style.height = height + "px";
      viewElement.style.width = width + "px";
      viewElement.style.height = height + "px";
      cameraElement.style.width = width + "px";
      cameraElement.style.height = height + "px";
    };
    function epsilon(value) {
      return Math.abs(value) < 1e-10 ? 0 : value;
    }
    function getCameraCSSMatrix(matrix) {
      const elements = matrix.elements;
      return "matrix3d(" + epsilon(elements[0]) + "," + epsilon(-elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(elements[6]) + "," + epsilon(elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(-elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(-elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
    }
    function getObjectCSSMatrix(matrix) {
      const elements = matrix.elements;
      const matrix3d = "matrix3d(" + epsilon(elements[0]) + "," + epsilon(elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(-elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(-elements[6]) + "," + epsilon(-elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
      return "translate(-50%,-50%)" + matrix3d;
    }
    function renderObject(object, scene, camera, cameraCSSMatrix) {
      if (object.isCSS3DObject) {
        const visible = object.visible === true && object.layers.test(camera.layers) === true;
        object.element.style.display = visible === true ? "" : "none";
        if (visible === true) {
          object.onBeforeRender(_this, scene, camera);
          let style2;
          if (object.isCSS3DSprite) {
            _matrix.copy(camera.matrixWorldInverse);
            _matrix.transpose();
            if (object.rotation2D !== 0)
              _matrix.multiply(_matrix2.makeRotationZ(object.rotation2D));
            object.matrixWorld.decompose(_position, _quaternion, _scale);
            _matrix.setPosition(_position);
            _matrix.scale(_scale);
            _matrix.elements[3] = 0;
            _matrix.elements[7] = 0;
            _matrix.elements[11] = 0;
            _matrix.elements[15] = 1;
            style2 = getObjectCSSMatrix(_matrix);
          } else {
            style2 = getObjectCSSMatrix(object.matrixWorld);
          }
          const element = object.element;
          const cachedObject = cache.objects.get(object);
          if (cachedObject === void 0 || cachedObject.style !== style2) {
            element.style.transform = style2;
            const objectData = { style: style2 };
            cache.objects.set(object, objectData);
          }
          if (element.parentNode !== cameraElement) {
            cameraElement.appendChild(element);
          }
          object.onAfterRender(_this, scene, camera);
        }
      }
      for (let i6 = 0, l = object.children.length; i6 < l; i6++) {
        renderObject(object.children[i6], scene, camera);
      }
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hd(s) {
  v(Array.isArray(s), () => "The argument passed to tf.addN() must be a list of tensors"), v(s.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${s.length}`);
  const e = s.map((r, n) => T(r, `tensors${n}`, "addN")), t = e[0];
  e.forEach((r) => {
    if (r.dtype !== t.dtype)
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), e.forEach((r) => {
    if (!Rt$1(r.shape, t.shape))
      throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  const a = e;
  return $$1.runKernel(Bd$1, a);
}
const Yr = /* @__PURE__ */ L({ addN_: hd });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fd(s, e, t, a, r, n) {
  const o = T(s, "forgetBias", "basicLSTMCell"), u = T(e, "lstmKernel", "basicLSTMCell"), l = T(t, "lstmBias", "basicLSTMCell"), p6 = T(a, "data", "basicLSTMCell"), m = T(r, "c", "basicLSTMCell"), c = T(n, "h", "basicLSTMCell"), d = Ge$1([p6, c], 1), h6 = Gt(d, u), b6 = U(h6, l), f = b6.shape[0], y6 = b6.shape[1] / 4, T$1 = [f, y6], _6 = Dt(b6, [0, 0], T$1), w6 = Dt(b6, [0, y6], T$1), I = Dt(b6, [0, y6 * 2], T$1), E6 = Dt(b6, [0, y6 * 3], T$1), D6 = U(G(xr(_6), Hh$1(w6)), G(m, xr(U(o, I)))), V = G(Hh$1(D6), xr(E6));
  return [D6, V];
}
const Mr = /* @__PURE__ */ L({ basicLSTMCell_: fd });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yd(s, e) {
  const t = T(s, "s0", "broadcastArgs", "int32"), a = T(e, "s1", "broadcastArgs", "int32");
  if (t.rank !== 1)
    throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);
  if (a.rank !== 1)
    throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);
  const r = { s0: t, s1: a };
  return $$1.runKernel(Kg$1, r);
}
const en = /* @__PURE__ */ L({ broadcastArgs_: yd });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gd(s) {
  const t = { x: T(s, "x", "diag") };
  return $$1.runKernel(Zg$1, t);
}
const tn = /* @__PURE__ */ L({ diag_: gd });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bd(s, ...e) {
  const t = e.map((r, n) => T(r, `tensors${n}`, "einsum")), a = { equation: s };
  return $$1.runKernel(Bg$1, t, a);
}
const sn = /* @__PURE__ */ L({ einsum_: bd });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function an2(s, e, t) {
  if (t <= 0)
    throw new Error("The number of values should be positive.");
  const a = { start: s, stop: e, num: t };
  return $$1.runKernel(_g$1, {}, a);
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const he = 2147483648;
function Nd(s, e, t = "left") {
  const a = T(s, "sortedSequence", "searchSorted"), r = T(e, "values", "searchSorted"), n = a.shape[a.shape.length - 1], o = r.shape[r.shape.length - 1], u = W(a, [-1, n]), l = W(r, [-1, o]);
  if (u.rank < 2)
    throw new Error("Sorted input argument must be at least 2-dimensional");
  if (u.shape[0] !== l.shape[0])
    throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
  if (O(l.shape) >= he)
    throw new Error(`values tensor size must less than ${he}`);
  if (u.shape[1] >= he)
    throw new Error(`trailing dim_size must less than ${he} for int32 output type, was ${u.shape[1]}`);
  const p6 = {
    sortedSequence: u,
    values: l
  }, m = { side: t };
  return $$1.runKernel(tb$1, p6, m);
}
const De = /* @__PURE__ */ L({ searchSorted_: Nd });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rn(s, e) {
  return De(s, e, "left");
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function wd(s, e, t, a, r = false) {
  const o = { x: T(s, "x", "maxPoolWithArgmax") }, u = { filterSize: e, strides: t, pad: a, includeBatchInIndex: r }, l = $$1.runKernel(Ug$1, o, u);
  return { result: l[0], indexes: l[1] };
}
const nn = /* @__PURE__ */ L({ maxPoolWithArgmax_: wd });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function on(s, e, { indexing: t = "xy" } = {}) {
  if (t !== "xy" && t !== "ij")
    throw new TypeError(`${t} is not a valid third argument to meshgrid`);
  if (s === void 0)
    return [];
  let a = T(s, "x", "meshgrid", s instanceof Lt$1 ? s.dtype : "float32");
  if (e === void 0)
    return [a];
  let r = T(e, "y", "meshgrid", e instanceof Lt$1 ? e.dtype : "float32");
  const n = O(a.shape), o = O(r.shape);
  return t === "xy" ? (a = W(a, [1, -1]), r = W(r, [-1, 1]), [
    Gt(Us([o, 1], a.dtype), a),
    Gt(r, Us([1, n], r.dtype))
  ]) : (a = W(a, [-1, 1]), r = W(r, [1, -1]), [
    Gt(a, Us([1, o], a.dtype)),
    Gt(Us([n, 1], r.dtype), r)
  ]);
}
function Td(s, e, t, a) {
  const r = T(e, "data", "multiRNNCell"), n = Ah$1(t, "c", "multiRNNCell"), o = Ah$1(a, "h", "multiRNNCell");
  let u = r;
  const l = [];
  for (let c = 0; c < s.length; c++) {
    const d = s[c](u, n[c], o[c]);
    l.push(d[0]), l.push(d[1]), u = d[1];
  }
  const p6 = [], m = [];
  for (let c = 0; c < l.length; c += 2)
    p6.push(l[c]), m.push(l[c + 1]);
  return [p6, m];
}
const un = /* @__PURE__ */ L({ multiRNNCell_: Td });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Sd(s, e, t, a = false) {
  const r = T(s, "logits", "multinomial"), n = r.size, o = r.rank;
  if (n < 2)
    throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${n}.`);
  if (o > 2)
    throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);
  t = t || Math.random();
  const l = { logits: o === 1 ? W(r, [1, -1]) : r }, p6 = { numSamples: e, seed: t, normalized: a }, m = $$1.runKernel(Yg$1, l, p6);
  return o === 1 ? W(m, [m.size]) : m;
}
const ln = /* @__PURE__ */ L({ multinomial_: Sd });
function vd(s, e) {
  const t = T(s, "v1", "outerProduct"), a = T(e, "v2", "outerProduct");
  v(t.rank === 1 && a.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${a.rank}.`);
  const r = W(t, [-1, 1]), n = W(a, [1, -1]);
  return Gt(r, n);
}
const pn = /* @__PURE__ */ L({ outerProduct_: vd });
function Od(s, e, t = 0) {
  return v(e.length === 2, () => "Invalid number of paddings. Must be length of 2."), rp(s, [e], t);
}
const mn = /* @__PURE__ */ L({ pad1d_: Od });
function _d(s, e, t = 0) {
  return v(e.length === 2 && e[0].length === 2 && e[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), rp(s, e, t);
}
const cn = /* @__PURE__ */ L({ pad2d_: _d });
function Ad(s, e, t = 0) {
  return v(e.length === 3 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), rp(s, e, t);
}
const dn = /* @__PURE__ */ L({ pad3d_: Ad });
function Ed(s, e, t = 0) {
  return v(e.length === 4 && e[0].length === 2 && e[1].length === 2 && e[2].length === 2 && e[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), rp(s, e, t);
}
const hn = /* @__PURE__ */ L({ pad4d_: Ed });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kd(s, e, t, a) {
  const r = s.map((m, c) => T(m, `tensors${c}`, "raggedGather", "int32")), n = T(e, "paramsDenseValues", "raggedGather"), o = T(t, "indices", "raggedGather", "int32"), u = {
    paramsNestedSplits: r,
    paramsDenseValues: n,
    indices: o
  }, l = { outputRaggedRank: a }, p6 = $$1.runKernel(Qg$1, u, l);
  return {
    outputNestedSplits: p6.slice(0, p6.length - 1),
    outputDenseValues: p6[p6.length - 1]
  };
}
const fn = /* @__PURE__ */ L({ raggedGather_: kd });
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Id(s, e, t) {
  const a = T(s, "starts", "raggedRange"), r = T(e, "limits", "raggedRange", a.dtype), n = T(t, "deltas", "raggedRange", a.dtype), o = {
    starts: a,
    limits: r,
    deltas: n
  }, u = $$1.runKernel(Jg$1, o);
  return {
    rtNestedSplits: u[0],
    rtDenseValues: u[1]
  };
}
const yn = /* @__PURE__ */ L({ raggedRange_: Id });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dd(s, e, t, a, r) {
  const n = T(s, "shape", "raggedTensorToTensor", "int32"), o = T(e, "values", "raggedTensorToTensor"), u = T(t, "defaultValue", "raggedTensorToTensor", o.dtype), l = a.map((c, d) => T(c, `tensors${d}`, "raggedTensorToTensor", "int32")), p6 = {
    shape: n,
    values: o,
    defaultValue: u,
    rowPartitionTensors: l
  }, m = { rowPartitionTypes: r };
  return $$1.runKernel(jg$1, p6, m);
}
const gn = /* @__PURE__ */ L({ raggedTensorToTensor_: Dd });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $d(s, e, t) {
  is(s);
  const a = O(s);
  let r = null;
  if (t == null || t === "float32")
    r = new Float32Array(a);
  else if (t === "int32")
    r = new Int32Array(a);
  else if (t === "bool")
    r = new Uint8Array(a);
  else
    throw new Error(`Unknown data type ${t}`);
  for (let n = 0; n < a; n++)
    r[n] = e();
  return $$1.makeTensor(r, s, t);
}
const bn = /* @__PURE__ */ L({ rand_: $d });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Cd = 1e-3, Nn = 0.1;
function zd(s, e, t) {
  return t == null && (t = ft()), Pe(s, e, (a, r) => yt(a, r, t));
}
function ft() {
  return $$1.backend.floatPrecision() === 32 ? Cd : Nn;
}
function Pe(s, e, t) {
  let a = true;
  if ((dn$1(s) || dn$1(e)) && (a = false), dn$1(s) && dn$1(e) && (a = true), a) {
    const o = s.constructor.name, u = e.constructor.name;
    if (o !== u)
      throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${u}`);
  }
  if (Array.isArray(s) && Array.isArray(e)) {
    const o = aa(s), u = aa(e);
    if (!Rt$1(o, u))
      throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${u}]`);
  }
  const r = dn$1(s) ? s : zs(s), n = dn$1(e) ? e : zs(e);
  if (r.length !== n.length)
    throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${n.length}.
Actual:   ${r}.
Expected: ${n}.`);
  for (let o = 0; o < n.length; ++o) {
    const u = r[o], l = n[o];
    if (!t(u, l))
      throw new Error(`Arrays differ: actual[${o}] = ${u}, expected[${o}] = ${l}.
Actual:   ${r}.
Expected: ${n}.`);
  }
  typeof expect < "u" && expect().nothing();
}
function xd(s, e) {
  s().then(() => e.fail(), () => e()), typeof expect < "u" && expect().nothing();
}
function Ld(s, e) {
  const t = typeof e == "string" || typeof e == "number" || typeof e == "boolean" ? [e] : e;
  return mr(s) || mr(s[0]) || mr(e) || mr(e[0]) ? Pe(s, t, (a, r) => a == r) : Pe(s, e, (a, r) => yt(a, r, 0));
}
function Vd(s, e, t) {
  if (t == null && (t = ft()), !yt(s, e, t))
    throw new Error(`Numbers differ: actual === ${s}, expected === ${e}`);
  typeof expect < "u" && expect().nothing();
}
function yt(s, e, t) {
  return !isFinite(s) && !isFinite(e) ? true : !(isNaN(s) || isNaN(e) || Math.abs(s - e) > t);
}
function Fd(s, e, t) {
  for (let a = 0; a < s.length; a++)
    if (s[a] < e || s[a] > t)
      throw new Error(`Value out of range:${s[a]} low: ${e}, high: ${t}`);
}
function Pd(s, e) {
  const t = new Float32Array(s), a = new Float32Array(e);
  if (t.length !== a.length)
    throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${t.length}`);
  for (let r = 0; r < a.length; r++)
    if (t[r] !== a[r])
      throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${t[r]} instead`);
}
function wn(s) {
  for (let e = 0; e < s.length; e++) {
    const t = s[e];
    Array.isArray(t) ? wn(t) : s[e] = hs(t);
  }
  return s;
}
function Rd(s) {
  const e = document.createElement("video");
  return "playsInline" in e && (e.playsInline = true), e.muted = true, e.loop = true, e.style.position = "fixed", e.style.left = "0px", e.style.top = "0px", e.preload = "auto", e.appendChild(s), new Promise((t) => {
    e.addEventListener("loadeddata", (a) => t(e)), e.load();
  });
}
async function jd(s) {
  await s.play(), "requestVideoFrameCallback" in s && await new Promise((e) => {
    s.requestVideoFrameCallback(e);
  });
}
const Bd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TEST_EPSILON_FLOAT16: Nn,
  createVideoElement: Rd,
  encodeStrings: wn,
  expectArrayBuffersEqual: Pd,
  expectArraysClose: zd,
  expectArraysEqual: Ld,
  expectNumbersClose: Vd,
  expectPromiseToFail: xd,
  expectValuesInRange: Fd,
  play: jd,
  testEpsilon: ft
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Hd(s, e, t = 1, a = "float32", r) {
  if (is(s), t == null && (t = 1), a == null && (a = "float32"), a !== "float32" && a !== "int32")
    throw new Error(`Unsupported data type ${a}`);
  const n = new dY(e, t, a, r), o = vt$1(s, a);
  for (let u = 0; u < o.values.length; u++)
    o.values[u] = n.nextValue();
  return o.toTensor();
}
const Tn = /* @__PURE__ */ L({ randomGamma_: Hd });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Wd(s, e, t) {
  if (e != null && e === "bool")
    throw new Error(`Unsupported data type ${e}`);
  return hk(s, 0, 1, e, t);
}
const Sn = /* @__PURE__ */ L({ randomStandardNormal_: Wd });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qd(s) {
  const e = T(s, "x", "reverse");
  return v(e.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`), ko(e, 0);
}
const vn = /* @__PURE__ */ L({ reverse1d_: qd });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ud(s, e) {
  const t = T(s, "x", "reverse");
  return v(t.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`), ko(t, e);
}
const On = /* @__PURE__ */ L({ reverse2d_: Ud });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Gd(s, e) {
  const t = T(s, "x", "reverse");
  return v(t.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`), ko(t, e);
}
const _n = /* @__PURE__ */ L({ reverse3d_: Gd });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Kd(s, e) {
  const t = T(s, "x", "reverse");
  return v(t.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`), ko(t, e);
}
const An = /* @__PURE__ */ L({ reverse4d_: Kd });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function Jd(s, e) {
  const t = T(s, "x", "setdiff1d"), a = T(e, "y", "setdiff1d");
  v(t.dtype === a.dtype, () => `x and y should have the same dtype, but got x (${t.dtype}) and y (${a.dtype}).`), v(t.rank === 1, () => `x should be 1D tensor, but got x (${t.shape}).`), v(a.rank === 1, () => `y should be 1D tensor, but got y (${a.shape}).`);
  const r = await t.data(), n = await a.data(), o = new Set(n);
  let u = 0;
  for (let m = 0; m < r.length; m++)
    o.has(r[m]) || u++;
  const l = new $e([u], t.dtype), p6 = new $e([u], "int32");
  for (let m = 0, c = 0; m < r.length; m++)
    o.has(r[m]) || (l.values[c] = r[m], p6.values[c] = m, c++);
  return [l.toTensor(), p6.toTensor()];
}
const En = Jd;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function kn(s, e, t) {
  if (Dl(s), e != null && e.length !== 4)
    throw new Error("tensor4d() requires shape to have four numbers");
  const a = aa(s, t);
  if (a.length !== 4 && a.length !== 1)
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (a.length === 1 && e == null)
    throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return la(s, e, a, t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function In(s, e, t) {
  if (Dl(s), e != null && e.length !== 5)
    throw new Error("tensor5d() requires shape to have five numbers");
  const a = aa(s, t);
  if (a.length !== 5 && a.length !== 1)
    throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (a.length === 1 && e == null)
    throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return la(s, e, a, t);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Dn(s, e, t) {
  if (Dl(s), e != null && e.length !== 6)
    throw new Error("tensor6d() requires shape to have six numbers");
  const a = aa(s, t);
  if (a.length !== 6 && a.length !== 1)
    throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (a.length === 1 && e == null)
    throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return e = e || a, la(s, e, a, t);
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function $n(s, e) {
  return De(s, e, "right");
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function Qd(s) {
  const e = T(s, "condition", "whereAsync", "bool"), t = await e.data(), a = t0(e.shape, t);
  return s !== e && e.dispose(), a;
}
const gt = Qd;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function Xd2(s, e, t) {
  const a = T(s, "tensor", "boolMask"), r = T(e, "mask", "boolMask", "bool"), n = t ?? 0, o = r.rank, u = a.shape;
  v(o > 0, () => "mask cannot be scalar"), Ve(u.slice(n, n + o), r.shape, "mask's shape must match the first K dimensions of tensor's shape,");
  let l = 1;
  for (let f = n; f < n + o; f++)
    l *= u[f];
  const p6 = u.slice(0, n).concat([l], u.slice(n + o)), m = W(a, p6), c = W(r, [-1]), d = await gt(c), h6 = ha(d, [1]), b6 = jh$1(m, h6, n);
  return s !== a && a.dispose(), e !== r && r.dispose(), h6.dispose(), m.dispose(), c.dispose(), d.dispose(), b6;
}
const Cn2 = Xd2;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Zd(s, e, t, a, r = true) {
  const n = T(s, "v", "movingAverage"), o = T(e, "x", "movingAverage"), u = T(t, "decay", "movingAverage");
  pC(n, o), v(Rt$1(n.shape, o.shape), () => "Shape mismatch in v and x");
  const l = gt$1(1), p6 = lt(l, u);
  let m = G(lt(o, n), p6);
  if (r) {
    v(a != null, () => "When using zeroDebias: true, step is required.");
    const c = T(a, "step", "movingAverage");
    m = ut(m, lt(l, ir(u, c)));
  }
  return U(n, m);
}
const zn = /* @__PURE__ */ L({ movingAverage_: Zd });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Yd(s, e, t) {
  is(t);
  const a = T(s, "indices", "scatterND", "int32"), r = T(e, "updates", "scatterND");
  e0(r, a, t);
  const n = { indices: a, updates: r }, o = { shape: t };
  return $$1.runKernel(qg$1, n, o);
}
const xn2 = /* @__PURE__ */ L({ scatterND_: Yd });
function Md(s, e, t, a) {
  if (s.dtype !== "int32")
    throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${s.dtype}.`);
  if (s.rank > 2)
    throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${s.shape}.`);
  const r = s.rank > 0 ? s.shape[0] : 1, n = s.rank > 1 ? s.shape[1] : 1;
  if (t.length !== n)
    throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${n}.`);
  const o = e.size;
  if (!(e.rank === 0 || e.rank === 1 && o === r))
    throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);
  if (e.dtype !== a.dtype)
    throw new Error("sparseValues.dtype must match defaultValues.dtype");
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eh(s, e, t, a = 0) {
  is(t);
  const r = T(s, "sparseIndices", "sparseToDense", "int32"), n = T(e, "sparseValues", "sparseToDense", "string_or_numeric"), o = T(a, "defaultValue", "sparseToDense", n.dtype);
  Md(r, n, t, o);
  const u = {
    sparseIndices: r,
    sparseValues: n,
    defaultValue: o
  }, l = { outputShape: t };
  return $$1.runKernel(eb$1, u, l);
}
const Ln = /* @__PURE__ */ L({ sparseToDense_: eh });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function th(s, e) {
  const t = T(e, "indices", "gatherND", "int32"), r = { params: T(s, "x", "gatherND", "string_or_numeric"), indices: t };
  return $$1.runKernel(Hg$1, r);
}
const Vn = /* @__PURE__ */ L({ gatherND_: th });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function sh(s, e, t = 1) {
  const a = T(s, "predictions", "inTopK"), r = T(e, "targets", "inTopK");
  v(a.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`), v(a.rank - 1 === r.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`), Ve(a.shape.slice(0, a.shape.length - 1), r.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
  const n = a.shape[a.shape.length - 1];
  v(t > 0 && t <= n, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${n}), but got ${t}`);
  const o = await a.data(), u = await r.data(), [l, p6] = [o.length / n, n], m = xe$1("bool", l);
  for (let c = 0; c < l; c++) {
    const d = c * p6, h6 = o.subarray(d, d + p6), b6 = [];
    for (let f = 0; f < h6.length; f++)
      b6.push({ value: h6[f], index: f });
    b6.sort((f, y6) => y6.value - f.value), m[c] = 0;
    for (let f = 0; f < t; f++)
      if (b6[f].index === u[c]) {
        m[c] = 1;
        break;
      }
  }
  return s !== a && a.dispose(), e !== r && r.dispose(), Re$1(m, r.shape, "bool");
}
const Fn = sh;
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ah({ x: s, filter: e, strides: t, pad: a, dataFormat: r = "NHWC", dilations: n = [1, 1], dimRoundingMode: o, bias: u, activation: l = "linear", preluActivationWeights: p6, leakyreluAlpha: m }) {
  if (kp($$1.state.gradientDepth, l) === false) {
    let E6 = Qh$1(s, e, t, a, r, n, o);
    return u != null && (E6 = U(E6, u)), Sp(E6, l, p6, m);
  }
  const c = T(s, "x", "depthwiseConv2d", "float32"), d = T(e, "filter", "depthwiseConv2d", "float32");
  let h6 = c, b6 = false;
  c.rank === 3 && (b6 = true, h6 = W(c, [1, c.shape[0], c.shape[1], c.shape[2]])), v(h6.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h6.rank}.`), v(d.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`), v(h6.shape[3] === d.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${h6.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`), n == null && (n = [1, 1]), v(Ee$1(t, n), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${n}'`), Be$1("fused depthwiseConv2d", a, o);
  const f = ke(
    h6.shape,
    d.shape,
    t,
    n,
    a,
    o,
    true
    /* depthwise */
  );
  let y6;
  u != null && (y6 = T(u, "bias", "fused conv2d"), [y6] = ne$1(y6, c), bt$1(f.outShape, y6.shape));
  let T$1;
  p6 != null && (T$1 = T(p6, "prelu weights", "fused depthwiseConv2d"));
  const _6 = (E6, D6) => {
    v(wo(n), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${n}'`);
    const [V, Q, L6, j] = D6, $e2 = Cp(E6, L6, l), Et = hT(Q.shape, $e2, V, t, a, n, o), kt2 = uT(Q, $e2, V.shape, t, a, n, o);
    if (j != null) {
      const li2 = vp(y6, $e2);
      return [Et, kt2, li2];
    }
    return [Et, kt2];
  }, w6 = {
    x: h6,
    filter: d,
    bias: y6,
    preluActivationWeights: T$1
  }, I = {
    strides: t,
    pad: a,
    dataFormat: r,
    dilations: n,
    dimRoundingMode: o,
    activation: l,
    leakyreluAlpha: m
  };
  return u == null ? So((D6, V, Q) => {
    let L6 = $$1.runKernel(nb$1, w6, I);
    return Q([V, D6, L6]), b6 && (L6 = W(L6, [L6.shape[1], L6.shape[2], L6.shape[3]])), { value: L6, gradFunc: _6 };
  })(h6, d) : So((D6, V, Q, L6) => {
    let j = $$1.runKernel(nb$1, w6, I);
    return L6([V, D6, j, Q]), b6 && (j = W(j, [j.shape[1], j.shape[2], j.shape[3]])), { value: j, gradFunc: _6 };
  })(h6, d, y6);
}
const rh = /* @__PURE__ */ L({ fusedDepthwiseConv2d_: ah });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Pn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  conv2d: lT,
  depthwiseConv2d: rh,
  matMul: im
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const nh = "model", ih = ".json", oh = ".weights.bin";
function xt2(s) {
  return new Promise((e) => setTimeout(e)).then(s);
}
class K {
  constructor(e) {
    if (!F().getBool("IS_BROWSER"))
      throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(K.URL_SCHEME) && (e = e.slice(K.URL_SCHEME.length)), (e == null || e.length === 0) && (e = nh), this.modelJsonFileName = e + ih, this.weightDataFileName = e + oh;
  }
  async save(e) {
    if (typeof document > "u")
      throw new Error("Browser downloads are not supported in this environment since `document` is not present");
    const t = window.URL.createObjectURL(new Blob([e.weightData], { type: "application/octet-stream" }));
    if (e.modelTopology instanceof ArrayBuffer)
      throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
    {
      const a = [{
        paths: ["./" + this.weightDataFileName],
        weights: e.weightSpecs
      }], r = SC(e, a), n = window.URL.createObjectURL(new Blob([JSON.stringify(r)], { type: "application/json" })), o = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
      if (o.download = this.modelJsonFileName, o.href = n, await xt2(() => o.dispatchEvent(new MouseEvent("click"))), e.weightData != null) {
        const u = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
        u.download = this.weightDataFileName, u.href = t, await xt2(() => u.dispatchEvent(new MouseEvent("click")));
      }
      return { modelArtifactsInfo: Kh$1(e) };
    }
  }
}
K.URL_SCHEME = "downloads://";
class uh {
  constructor(e) {
    if (e == null || e.length < 1)
      throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);
    this.jsonFile = e[0], this.weightsFiles = e.slice(1);
  }
  async load() {
    return new Promise((e, t) => {
      const a = new FileReader();
      a.onload = (r) => {
        const n = JSON.parse(r.target.result), o = n.modelTopology;
        if (o == null) {
          t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (n.weightsManifest == null) {
          t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (this.weightsFiles.length === 0) {
          e({ modelTopology: o });
          return;
        }
        const l = TC(n, (p6) => this.loadWeights(p6));
        e(l);
      }, a.onerror = (r) => t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`), a.readAsText(this.jsonFile);
    });
  }
  loadWeights(e) {
    const t = [], a = [];
    for (const o of e)
      t.push(...o.weights), a.push(...o.paths);
    const r = this.checkManifestAndWeightFiles(e), n = a.map((o) => this.loadWeightsFile(o, r[o]));
    return Promise.all(n).then((o) => [t, bb$1(o)]);
  }
  loadWeightsFile(e, t) {
    return new Promise((a, r) => {
      const n = new FileReader();
      n.onload = (o) => {
        const u = o.target.result;
        a(u);
      }, n.onerror = (o) => r(`Failed to weights data from file of path '${e}'.`), n.readAsArrayBuffer(t);
    });
  }
  /**
   * Check the compatibility between weights manifest and weight files.
   */
  checkManifestAndWeightFiles(e) {
    const t = [], a = this.weightsFiles.map((n) => X4(n.name)), r = {};
    for (const n of e)
      n.paths.forEach((o) => {
        const u = X4(o);
        if (t.indexOf(u) !== -1)
          throw new Error(`Duplicate file basename found in weights manifest: '${u}'`);
        if (t.push(u), a.indexOf(u) === -1)
          throw new Error(`Weight file with basename '${u}' is not provided.`);
        r[o] = this.weightsFiles[a.indexOf(u)];
      });
    if (t.length !== this.weightsFiles.length)
      throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
    return r;
  }
}
const lh = (s) => F().getBool("IS_BROWSER") && !Array.isArray(s) && s.startsWith(K.URL_SCHEME) ? ph(s.slice(K.URL_SCHEME.length)) : null;
ee.registerSaveRouter(lh);
function ph(s = "model") {
  return new K(s);
}
function mh(s) {
  return new uh(s);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Ce {
  constructor(e) {
    this.modelArtifacts = e;
  }
  load() {
    return this.modelArtifacts;
  }
}
class Rn {
  constructor(e) {
    this.saveHandler = e;
  }
  save(e) {
    return this.saveHandler(e);
  }
}
class ch {
  constructor(e) {
    e.load && (this.load = () => Promise.resolve(e.load())), e.save && (this.save = (t) => Promise.resolve(e.save(t)));
  }
}
function dh(s, e, t, a) {
  const r = arguments;
  return new ch(_e(...r));
}
function _e(s, e, t, a) {
  return arguments.length === 1 ? s.modelTopology != null || s.weightSpecs != null ? new Ce(s) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Ce({ modelTopology: s })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Ce({
    modelTopology: s,
    weightSpecs: e,
    weightData: t,
    trainingConfig: a
  }));
}
function hh(s) {
  return new Rn(s);
}
function fh(s) {
  return new Rn(s);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  browserFiles: mh,
  browserHTTPRequest: HN,
  concatenateArrayBuffers: bb$1,
  copyModel: Z4,
  decodeWeights: gb$1,
  encodeWeights: sm,
  fromMemory: dh,
  fromMemorySync: _e,
  getLoadHandlers: MC,
  getModelArtifactsForJSON: TC,
  getModelArtifactsForJSONSync: kC,
  getModelArtifactsInfoForJSON: Kh$1,
  getSaveHandlers: LC,
  getWeightSpecs: NC,
  http: m0,
  isHTTPScheme: um,
  listModels: O4,
  loadWeights: AN,
  moveModel: B4,
  registerLoadRouter: A4,
  registerSaveRouter: P4,
  removeModel: K4,
  weightsLoaderFactory: ON,
  withSaveHandler: hh,
  withSaveHandlerSync: fh
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function yh(s, e, t) {
  const a = T(s, "labels", "confusionMatrix"), r = T(e, "predictions", "confusionMatrix");
  v(t == null || t > 0 && Number.isInteger(t), () => `If provided, numClasses must be a positive integer, but got ${t}`), v(a.rank === 1, () => `Expected the rank of labels to be 1, but got ${a.rank}`), v(r.rank === 1, () => `Expected the rank of predictions to be 1, but got ${r.rank}`), v(a.shape[0] === r.shape[0], () => `Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`), v(t > 0 && Number.isInteger(t), () => `numClasses is required to be a positive integer, but got ${t}`);
  const n = Pb(et(a, "int32"), t), o = Pb(et(r, "int32"), t), u = kt(n), l = Gt(u, o);
  return et(l, "int32");
}
const gh = /* @__PURE__ */ L({ confusionMatrix_: yh });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  confusionMatrix: gh
}, Symbol.toStringTag, { value: "Module" }));
/** @license See the LICENSE file. */
const jn2 = "4.2.0";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Nh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nonMaxSuppressionV3Impl: Tp,
  nonMaxSuppressionV4Impl: Np,
  nonMaxSuppressionV5Impl: Rp,
  whereImpl: t0
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function wh(s) {
  return new gx(s);
}
function Th(s) {
  return new bx(s);
}
function Sh() {
  return new xx();
}
function vh(s) {
  return new yx(s);
}
const Oh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  maxNorm: wh,
  minMaxNorm: vh,
  nonNeg: Sh,
  unitNorm: Th
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function _h() {
  return new lx();
}
function Ah() {
  return new af$1();
}
function Eh(s) {
  return new cx(s);
}
function kh(s) {
  return new ux(s);
}
function Ih(s) {
  return new dx(s);
}
function Dh(s) {
  return new hx(s);
}
function $h(s) {
  return new px(s);
}
function Ch(s) {
  return new qe$1(s);
}
function zh(s) {
  return new lf$1(s);
}
function xh(s) {
  return new cf$1(s);
}
function Lh(s) {
  return new uf$1(s);
}
function Vh(s) {
  return new df$1(s);
}
function Fh(s) {
  return new hf$1(s);
}
function Ph(s) {
  return new pf$1(s);
}
function Rh(s) {
  return new fx(s);
}
const jh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  constant: Eh,
  glorotNormal: xh,
  glorotUniform: zh,
  heNormal: Lh,
  heUniform: Vh,
  identity: $h,
  leCunNormal: Fh,
  leCunUniform: Ph,
  ones: Ah,
  orthogonal: Rh,
  randomNormal: Ih,
  randomUniform: kh,
  truncatedNormal: Dh,
  varianceScaling: Ch,
  zeros: _h
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function Bh(s) {
  return new tr(s);
}
function Hh(s) {
  return new oi$1(s);
}
function Bn(s) {
  return ZG(s);
}
function Wh(s, e) {
  xn$1.registerCallbackConstructor(s, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function qh(s) {
  return new Ia(s);
}
function Uh(s) {
  return new qx(s);
}
function Gh(s) {
  return new Qx(s);
}
function Kh(s) {
  return new Jx(s);
}
function Jh(s) {
  return new jx(s);
}
function Qh(s) {
  return new ey$1(s);
}
function Xh(s) {
  return new ty$1(s);
}
function Zh(s) {
  return new ou(s);
}
function Yh(s) {
  return new va(s);
}
function Mh(s) {
  return new sy$1(s);
}
function ef(s) {
  return new Sa(s);
}
function tf(s) {
  return new oy$1(s);
}
function sf(s) {
  return new iy$1(s);
}
function af2(s) {
  return new ay$1(s);
}
function rf(s) {
  return new ly$1(s);
}
function nf2(s) {
  return new cy$1(s);
}
function of(s) {
  return new wy$1(s);
}
function uf2(s) {
  return new xy$1(s);
}
function lf2(s) {
  return new kf$1(s);
}
function pf2(s) {
  return new by$1(s);
}
function mf(s) {
  return new yy$1(s);
}
function cf2(s) {
  return new Iy$1(s);
}
function df2(s) {
  return new Cy$1(s);
}
function hf2(s) {
  return new vy$1(s);
}
function ff(s) {
  return new ky$1(s);
}
function yf(s) {
  return new Ty$1(s);
}
function gf(s) {
  return new Ry$1(s);
}
function bf(s) {
  return new Ey$1(s);
}
function Nf(s) {
  return new $y$1(s);
}
function wf(s) {
  return new Gy$1(s);
}
function Tf2(s) {
  return new Ny$1(s);
}
function Sf2(s) {
  return new Ly$1(s);
}
function vf2(s) {
  return new Fy$1(s);
}
function Of(s) {
  return new Vy$1(s);
}
function _f(s) {
  return new zy$1(s);
}
function Nt(s) {
  return new Oy$1(s);
}
function Af(s) {
  return Nt(s);
}
function Ef(s) {
  return Nt(s);
}
function wt(s) {
  return new By$1(s);
}
function kf2(s) {
  return wt(s);
}
function If2(s) {
  return wt(s);
}
function Tt(s) {
  return new Uy$1(s);
}
function Df(s) {
  return Tt(s);
}
function $f(s) {
  return Tt(s);
}
function Cf2(s) {
  return new Qy$1(s);
}
function zf(s) {
  return new qy$1(s);
}
function Hn(s) {
  return new Jy$1(s);
}
function Wn2(s) {
  return new t1(s);
}
function qn2(s) {
  return new Ay$1(s);
}
function Un(s) {
  return new Zy$1(s);
}
function xf2(s) {
  return new _y$1(s);
}
function Lf(s) {
  return new py$1(s);
}
function Vf(s) {
  return new Cf$1(s);
}
function Ff(s) {
  return new fy$1(s);
}
function Pf(s) {
  return new iu(s);
}
function Rf(s) {
  return new hy$1(s);
}
function jf(s) {
  return new If$1(s);
}
function Bf(s) {
  return new gy$1(s);
}
function Hf(s) {
  return new Sf$1(s);
}
function Wf(s) {
  return new Qs(s);
}
function qf(s) {
  return new vf$1(s);
}
function Uf(s) {
  return new s1(s);
}
function Gf(s) {
  return new n1(s);
}
const Kf2 = Hn, Jf = Wn2, Qf = qn2, Xf = Un;
function Zf(s) {
  return new My$1(s);
}
function Yf(s) {
  return new Wy$1(s);
}
function Mf(s) {
  return new Dy$1(s);
}
function ey2(s) {
  return new Sy$1(s);
}
function ty2(s) {
  return new o1(s);
}
function sy2(s) {
  return new r1(s);
}
function ay2(s) {
  return new a1(s);
}
function ry2(s) {
  return new i1(s);
}
const ny = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Layer: St$1,
  RNN: Qs,
  RNNCell: ru,
  activation: of,
  add: yf,
  alphaDropout: Mf,
  average: gf,
  averagePooling1d: Nt,
  averagePooling2d: wt,
  averagePooling3d: Tt,
  avgPool1d: Af,
  avgPool2d: kf2,
  avgPool3d: Df,
  avgPooling1d: Ef,
  avgPooling2d: If2,
  avgPooling3d: $f,
  batchNormalization: vf2,
  bidirectional: Uf,
  categoryEncoding: ry2,
  centerCrop: sy2,
  concatenate: bf,
  conv1d: Zh,
  conv2d: Yh,
  conv2dTranspose: Mh,
  conv3d: ef,
  conv3dTranspose: tf,
  convLstm2d: Bf,
  convLstm2dCell: Hf,
  cropping2D: af2,
  dense: uf2,
  depthwiseConv2d: nf2,
  dot: Sf2,
  dropout: lf2,
  elu: Uh,
  embedding: ff,
  flatten: mf,
  gaussianDropout: Yf,
  gaussianNoise: Zf,
  globalAveragePooling1d: Cf2,
  globalAveragePooling2d: zf,
  globalMaxPool1d: Kf2,
  globalMaxPool2d: Jf,
  globalMaxPooling1d: Hn,
  globalMaxPooling2d: Wn2,
  gru: Lf,
  gruCell: Vf,
  input: Bn,
  inputLayer: qh,
  layerNormalization: Of,
  leakyReLU: Kh,
  lstm: Ff,
  lstmCell: Pf,
  masking: ey2,
  maxPool1d: Qf,
  maxPool2d: Xf,
  maxPooling1d: qn2,
  maxPooling2d: Un,
  maxPooling3d: xf2,
  maximum: Nf,
  minimum: wf,
  multiply: Tf2,
  permute: hf2,
  prelu: Jh,
  reLU: Gh,
  repeatVector: cf2,
  rescaling: ty2,
  reshape: df2,
  resizing: ay2,
  rnn: Wf,
  separableConv2d: sf,
  simpleRNN: Rf,
  simpleRNNCell: jf,
  softmax: Qh,
  spatialDropout1d: pf2,
  stackedRNNCells: qf,
  thresholdedReLU: Xh,
  timeDistributed: Gf,
  upSampling2d: rf,
  zeroPadding2d: _f
}, Symbol.toStringTag, { value: "Module" }));
function iy2(s, e) {
  return Sx(s, e);
}
function oy2(s, e) {
  return pE(s, e);
}
function uy(s, e) {
  return fE(s, e);
}
function ly2(s, e) {
  return kx(s, e);
}
function py2(s, e) {
  return Nx(s, e);
}
function my2(s, e) {
  return hE(s, e);
}
function cy2(s, e) {
  return IY(s, e);
}
function dy(s, e) {
  return vx(s, e);
}
function hy2(s, e) {
  return gf$1(s, e);
}
function fy2(s, e) {
  return bf$1(s, e);
}
function yy2(s, e) {
  return bf$1(s, e);
}
function gy2(s, e) {
  return bf$1(s, e);
}
function by2(s, e) {
  return tu(s, e);
}
function Ny2(s, e) {
  return tu(s, e);
}
function wy2(s, e) {
  return tu(s, e);
}
const Ty2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MAPE: yy2,
  MSE: Ny2,
  binaryAccuracy: iy2,
  binaryCrossentropy: oy2,
  categoricalAccuracy: ly2,
  categoricalCrossentropy: py2,
  cosineProximity: dy,
  mape: gy2,
  meanAbsoluteError: hy2,
  meanAbsolutePercentageError: fy2,
  meanSquaredError: by2,
  mse: wy2,
  precision: my2,
  recall: cy2,
  sparseCategoricalAccuracy: uy
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
const Sy2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  modelFromJSON: CY
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
function vy2(s) {
  return new nu(s);
}
function Oy2(s) {
  return TY(s);
}
function _y2(s) {
  return NY(s);
}
const Ay2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  l1: Oy2,
  l1l2: vy2,
  l2: _y2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
class Gn2 extends ei$1 {
  constructor() {
    super(...arguments), this.model = null;
  }
  setModel(e) {
    if (!(e instanceof tr))
      throw new Error("model must be a LayersModel, not some other Container");
    this.model = e;
  }
}
function fe(s, e) {
  return s < e;
}
function Lt2(s, e) {
  return s > e;
}
class Kn extends Gn2 {
  constructor(e) {
    if (super(), e == null && (e = {}), e.restoreBestWeights)
      throw new xt$1("restoreBestWeights = True is not implemented in EarlyStopping yet.");
    this.monitor = e.monitor || "val_loss", this.minDelta = Math.abs(e.minDelta || 0), this.patience = e.patience || 0, this.verbose = e.verbose || 0, this.mode = e.mode || "auto", this.baseline = e.baseline, ["auto", "min", "max"].indexOf(this.mode) === -1 && (console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`), this.mode = "auto"), this.mode === "min" ? this.monitorFunc = fe : this.mode === "max" ? this.monitorFunc = Lt2 : this.monitor.indexOf("acc") !== -1 ? this.monitorFunc = Lt2 : this.monitorFunc = fe, this.monitorFunc === fe && (this.minDelta *= -1);
  }
  async onTrainBegin(e) {
    this.wait = 0, this.stoppedEpoch = 0, this.baseline != null ? this.best = this.baseline : this.best = this.monitorFunc === fe ? 1 / 0 : -1 / 0;
  }
  async onEpochEnd(e, t) {
    await eo(t);
    const a = this.getMonitorValue(t);
    a != null && (this.monitorFunc(a - this.minDelta, this.best) ? (this.best = a, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = e, this.model.stopTraining = true)));
  }
  async onTrainEnd(e) {
    this.stoppedEpoch > 0 && this.verbose && console.log(`Epoch ${this.stoppedEpoch}: early stopping.`);
  }
  getMonitorValue(e) {
    e == null && (e = {});
    const t = e[this.monitor];
    return t == null && console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`), t;
  }
}
function Ey2(s) {
  return new Kn(s);
}
const ky2 = { earlyStopping: Ey2 };
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const St2 = {};
function Iy2(s, e) {
  const t = {
    tfOpName: s,
    category: "custom",
    inputs: [],
    attrs: [],
    customExecutor: e
  };
  St2[s] = t;
}
function Jn(s) {
  return St2[s];
}
function Dy2(s) {
  delete St2[s];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function i(s, e, t, a, r) {
  const n = e.inputParams[s];
  if (n && n.inputIndexStart !== void 0) {
    const u = n.inputIndexStart, l = n.inputIndexEnd === 0 ? void 0 : n.inputIndexEnd === void 0 ? u + 1 : n.inputIndexEnd;
    if (n.type === "tensor")
      return k6(e.inputNames[n.inputIndexStart], t, a, r);
    if (n.type === "tensors")
      return e.inputNames.slice(u, l).map((d) => k6(d, t, a, r));
    const p6 = k6(e.inputNames.slice(u)[0], t, a, r), m = p6.dataSync();
    return n.type === "number" ? m[0] : Sn$1(p6.shape, m);
  }
  const o = e.attrParams[s];
  return o && o.value;
}
function k6(s, e, t, a) {
  const [r, n] = $(s);
  if (a != null) {
    const u = a.getHashTableHandleByName(r);
    if (u != null)
      return u;
  }
  const o = t.currentContextIds.find((u) => !!e[Ae(r, u)]);
  return o !== void 0 ? e[Ae(r, o)][n] : void 0;
}
function $y2(s, e, t) {
  return e[Ae(s, t.currentContextId)];
}
function B(s, e) {
  const [t, a, r] = $(s);
  return [
    Ae(t, e && e.currentContextId),
    a,
    r
  ];
}
function Ae(s, e) {
  return e ? `${s}-${e}` : s;
}
function $(s) {
  const e = s.split(":");
  if (e.length === 1)
    return [s, 0, void 0];
  const t = e[0], a = e.length === 3 ? e[1] : void 0, r = Number(e[e.length - 1]);
  return [t, r, a];
}
function be(s, e, t) {
  let a = i("pad", s, e, t);
  if (a === "explicit") {
    a = i("explicitPaddings", s, e, t);
    const r = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let n = 0; n < 4; n++)
      r[n][0] = a[n * 2], r[n][1] = a[n * 2 + 1];
    return r;
  }
  return a;
}
function H(s) {
  return s.kept ? s : po(s);
}
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Cy2 = [
  {
    tfOpName: "Add",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "AddV2",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "AddN",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "BiasAdd",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Sub",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "RealDiv",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Div",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "DivNoNan",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "FloorDiv",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Mul",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Maximum",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Minimum",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Pow",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "SquaredDifference",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Mod",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "FloorMod",
    category: "arithmetic",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  }
], zy2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: Cy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xy2 = [
  {
    tfOpName: "Abs",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Acos",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Asin",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Atan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Atan2",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "y",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Ceil",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "ClipByValue",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "clipValueMin",
        type: "number"
      },
      {
        start: 2,
        name: "clipValueMax",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Complex",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "real",
        type: "tensor"
      },
      {
        start: 1,
        name: "imag",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "ComplexAbs",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Cos",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Cosh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Elu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Exp",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Floor",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Log",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Imag",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Neg",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Real",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Prelu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "alpha",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Relu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Relu6",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Selu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Sigmoid",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Sin",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Sinh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Sqrt",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Rsqrt",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Square",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Tan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Tanh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Sign",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Round",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Expm1",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Log1p",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Reciprocal",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Softplus",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Asinh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Acosh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Atanh",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Erf",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Prod",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axes",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool",
        notSupported: true
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LeakyRelu",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 0.2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "IsNan",
    category: "basic_math",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  }
], Ly2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: xy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Vy2 = [
  {
    tfOpName: "EmptyTensorList",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 1,
        name: "maxNumElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LoopCond",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "pred",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Switch",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "pred",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Merge",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Enter",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "frame_name",
        name: "frameName",
        type: "string"
      },
      {
        tfName: "is_constant",
        name: "isConstant",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Exit",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "NextIteration",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "TensorArrayV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "size",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "dynamic_size",
        name: "dynamicSize",
        type: "bool"
      },
      {
        tfName: "clear_after_read",
        name: "clearAfterRead",
        type: "bool"
      },
      {
        tfName: "identical_element_shapes",
        name: "identicalElementShapes",
        type: "bool"
      },
      {
        tfName: "tensor_array_name",
        name: "name",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "TensorArrayWriteV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "TensorArrayReadV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "TensorArrayGatherV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      }
    ]
  },
  {
    tfOpName: "TensorArrayScatterV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorArrayConcatV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "element_shape_except0",
        name: "elementShapeExcept0",
        type: "shape",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "TensorArraySplitV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 2,
        name: "lengths",
        type: "number[]"
      },
      {
        start: 3,
        name: "flowIn",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorArraySizeV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      },
      {
        start: 1,
        name: "flowIn",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "TensorArrayCloseV3",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "StatelessIf",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "cond",
        type: "tensor"
      },
      {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
      },
      {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "If",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "cond",
        type: "tensor"
      },
      {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
      },
      {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "StatelessWhile",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "cond",
        name: "cond",
        type: "func"
      },
      {
        tfName: "body",
        name: "body",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "While",
    category: "control",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "cond",
        name: "cond",
        type: "func"
      },
      {
        tfName: "body",
        name: "body",
        type: "func"
      }
    ]
  },
  {
    tfOpName: "TensorListScatter",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListScatterV2",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 3,
        name: "numElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListGather",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "number[]"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListGetItem",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListSetItem",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "index",
        type: "number"
      },
      {
        start: 2,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListReserve",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 1,
        name: "numElements",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListFromTensor",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListStack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      },
      {
        tfName: "num_elements",
        name: "numElements",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListSplit",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      },
      {
        start: 2,
        name: "lengths",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListConcat",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListConcatV2",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      },
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListPopBack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "elementShape",
        type: "shape"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListPushBack",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TensorListLength",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "TensorListResize",
    category: "control",
    inputs: [
      {
        start: 0,
        name: "tensorListId",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      }
    ]
  }
], Fy2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: Vy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Py2 = [
  {
    tfOpName: "AvgPool",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "MaxPool",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: [],
        notSupported: true
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "MaxPoolWithArgmax",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "include_batch_in_index",
        name: "includeBatchInIndex",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "AvgPool3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "MaxPool3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      },
      {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Conv1D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "stride",
        name: "stride",
        type: "number"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NWC"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "dilation",
        name: "dilation",
        type: "number",
        defaultValue: 1
      }
    ]
  },
  {
    tfOpName: "Conv2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "useCudnnOnGpu",
        name: "useCudnnOnGpu",
        type: "bool"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "_FusedConv2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "use_cudnn_on_gpu",
        name: "useCudnnOnGpu",
        type: "bool",
        defaultValue: true
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [
          1,
          1,
          1,
          1
        ]
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
      },
      {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: 0.2
      }
    ]
  },
  {
    tfOpName: "Conv2DBackpropInput",
    category: "convolution",
    inputs: [
      {
        start: 2,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 0,
        name: "outputShape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "DepthwiseConv2d",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "DepthwiseConv2dNative",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "FusedDepthwiseConv2dNative",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [
          1,
          1,
          1,
          1
        ]
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }
    ]
  },
  {
    tfOpName: "Conv3D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      },
      {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Dilation2D",
    category: "convolution",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "filter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      },
      {
        tfName: "rates",
        name: "dilations",
        type: "number[]"
      },
      {
        tfName: "padding",
        name: "pad",
        type: "string"
      }
    ]
  }
], Ry2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: Py2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jy2 = [
  {
    tfOpName: "Fill",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      },
      {
        start: 1,
        name: "value",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LinSpace",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "start",
        type: "number"
      },
      {
        start: 1,
        name: "stop",
        type: "number"
      },
      {
        start: 2,
        name: "num",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "OneHot",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "depth",
        type: "number"
      },
      {
        start: 2,
        name: "onValue",
        type: "number",
        defaultValue: 1
      },
      {
        start: 3,
        name: "offValue",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        notSupported: true
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Ones",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "OnesLike",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "RandomStandardNormal",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: true
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "RandomUniform",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "minval",
        name: "minval",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "maxval",
        name: "maxval",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: true
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Range",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "start",
        type: "number"
      },
      {
        start: 1,
        name: "stop",
        type: "number"
      },
      {
        start: 2,
        name: "step",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "Tidx",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "TruncatedNormal",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "means",
        name: "mean",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "stddev",
        name: "stdDev",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "seed",
        name: "seed",
        type: "number"
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: true
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Zeros",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "ZerosLike",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Multinomial",
    category: "creation",
    inputs: [
      {
        start: 0,
        name: "logits",
        type: "tensor"
      },
      {
        start: 1,
        name: "numSamples",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "seed",
        name: "seed",
        type: "number"
      },
      {
        tfName: "seed2",
        name: "seed2",
        type: "number"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      },
      {
        tfName: "output_dtype",
        name: "output_dtype",
        type: "dtype"
      }
    ]
  }
], By2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: jy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Hy2 = [
  {
    tfOpName: "NonMaxSuppressionV2",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV3",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV4",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "T_threshold",
        name: "threshold",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "pad_to_max_output_size",
        name: "padToMaxOutputSize",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "NonMaxSuppressionV5",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 1,
        name: "scores",
        type: "tensor"
      },
      {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      },
      {
        start: 3,
        name: "iouThreshold",
        type: "number"
      },
      {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      },
      {
        start: 5,
        name: "softNmsSigma",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "Where",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "ListDiff",
    category: "dynamic",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "y",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  }
], Wy2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: Hy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const qy2 = [
  {
    tfOpName: "LowerBound",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "sortedSequence",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "TopKV2",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "k",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "sorted",
        name: "sorted",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "UpperBound",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "sortedSequence",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Unique",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "UniqueV2",
    category: "evaluation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  }
], Uy2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: qy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Gy2 = [
  {
    tfOpName: "PlaceholderWithDefault",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "default",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "shape",
        name: "shape",
        type: "shape"
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Placeholder",
    category: "graph",
    attrs: [
      {
        tfName: "shape",
        name: "shape",
        type: "shape"
      },
      {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "Const",
    category: "graph"
  },
  {
    tfOpName: "Identity",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "IdentityN",
    category: "graph",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Snapshot",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Rank",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Size",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "Shape",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "ShapeN",
    category: "graph",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
      }
    ]
  },
  {
    tfOpName: "Print",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "data",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "message",
        name: "message",
        type: "string"
      },
      {
        tfName: "first_n",
        name: "firstN",
        type: "number",
        notSupported: true
      },
      {
        tfName: "summarize",
        name: "summarize",
        type: "number",
        defaultValue: 3
      }
    ]
  },
  {
    tfOpName: "NoOp",
    category: "graph",
    inputs: []
  },
  {
    tfOpName: "StopGradient",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "FakeQuantWithMinMaxVars",
    category: "graph",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "min",
        name: "min",
        type: "number"
      },
      {
        tfName: "max",
        name: "max",
        type: "number"
      }
    ]
  }
], Ky2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: Gy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Jy2 = [
  {
    tfOpName: "HashTable",
    category: "hash_table",
    inputs: [],
    attrs: [
      {
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
      },
      {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
      },
      {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
      },
      {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "HashTableV2",
    category: "hash_table",
    inputs: [],
    attrs: [
      {
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
      },
      {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
      },
      {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
      },
      {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "LookupTableImport",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LookupTableImportV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LookupTableFind",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LookupTableFindV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LookupTableSize",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "LookupTableSizeV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "InitializeTable",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "InitializeTableV2",
    category: "hash_table",
    inputs: [
      {
        start: 0,
        name: "tableHandle",
        type: "tensor"
      },
      {
        start: 1,
        name: "keys",
        type: "tensor"
      },
      {
        start: 2,
        name: "values",
        type: "tensor"
      }
    ]
  }
], Qy2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: Jy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Xy = [
  {
    tfOpName: "ResizeBilinear",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
      },
      {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "ResizeNearestNeighbor",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
      },
      {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "CropAndResize",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "image",
        type: "tensor"
      },
      {
        start: 1,
        name: "boxes",
        type: "tensor"
      },
      {
        start: 2,
        name: "boxInd",
        type: "tensor"
      },
      {
        start: 3,
        name: "cropSize",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "method",
        name: "method",
        type: "string"
      },
      {
        tfName: "extrapolation_value",
        name: "extrapolationValue",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "ImageProjectiveTransformV3",
    category: "image",
    inputs: [
      {
        start: 0,
        name: "images",
        type: "tensor"
      },
      {
        start: 1,
        name: "transforms",
        type: "tensor"
      },
      {
        start: 2,
        name: "outputShape",
        type: "number[]"
      },
      {
        start: 3,
        name: "fillValue",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "interpolation",
        name: "interpolation",
        type: "string"
      },
      {
        tfName: "fill_mode",
        name: "fillMode",
        type: "string"
      }
    ]
  }
], Zy2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: Xy
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Yy2 = [
  {
    tfOpName: "Equal",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "NotEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Greater",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "GreaterEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Less",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LessEqual",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LogicalAnd",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LogicalNot",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LogicalOr",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Select",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      },
      {
        start: 1,
        name: "a",
        type: "tensor"
      },
      {
        start: 2,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "SelectV2",
    category: "logical",
    inputs: [
      {
        start: 0,
        name: "condition",
        type: "tensor"
      },
      {
        start: 1,
        name: "a",
        type: "tensor"
      },
      {
        start: 2,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  }
], My2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: Yy2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const eg = [
  {
    tfOpName: "_FusedMatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      },
      {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      },
      {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      },
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
      },
      {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: false
      },
      {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: false
      },
      {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: 0.2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "MatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: false
      },
      {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: false
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "BatchMatMul",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: false
      },
      {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: false
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "BatchMatMulV2",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "a",
        type: "tensor"
      },
      {
        start: 1,
        name: "b",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: false
      },
      {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: false
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Transpose",
    category: "matrices",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "perm",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Einsum",
    category: "matrices",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "equation",
        name: "equation",
        type: "string"
      },
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      },
      {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }
    ]
  }
], tg2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: eg
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sg = [
  {
    tfOpName: "EuclideanNorm",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool",
        defaultValue: false
      }
    ]
  },
  {
    tfOpName: "FusedBatchNorm",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "FusedBatchNormV2",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "FusedBatchNormV3",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "scale",
        type: "tensor"
      },
      {
        start: 2,
        name: "offset",
        type: "tensor"
      },
      {
        start: 3,
        name: "mean",
        type: "tensor"
      },
      {
        start: 4,
        name: "variance",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-3
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "LRN",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "depth_radius",
        name: "radius",
        type: "number",
        defaultValue: 5
      },
      {
        tfName: "bias",
        name: "bias",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 1
      },
      {
        tfName: "beta",
        name: "beta",
        type: "number",
        defaultValue: 0.5
      }
    ]
  },
  {
    tfOpName: "Softmax",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "LogSoftmax",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseToDense",
    category: "normalization",
    inputs: [
      {
        start: 0,
        name: "sparseIndices",
        type: "tensor"
      },
      {
        start: 1,
        name: "outputShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "sparseValues",
        type: "tensor"
      },
      {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        defaultValue: true,
        notSupported: true
      }
    ]
  }
], ag = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: sg
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rg = [
  {
    tfOpName: "Bincount",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      },
      {
        start: 2,
        name: "weights",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "DenseBincount",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "size",
        type: "number"
      },
      {
        start: 2,
        name: "weights",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "binary_output",
        name: "binaryOutput",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Max",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Mean",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Min",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Sum",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "All",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Any",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "ArgMax",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "ArgMin",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "Prod",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Cumprod",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
      },
      {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
      }
    ]
  },
  {
    tfOpName: "Cumsum",
    category: "reduction",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
      },
      {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
      }
    ]
  }
], ng = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: rg
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ig2 = [
  {
    tfOpName: "ConcatV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        end: -1,
        name: "tensors",
        type: "tensors"
      },
      {
        start: -1,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }
    ]
  },
  {
    tfOpName: "Concat",
    category: "slice_join",
    inputs: [
      {
        start: 1,
        end: 0,
        name: "tensors",
        type: "tensors"
      },
      {
        start: 0,
        name: "axis",
        type: "number"
      }
    ],
    attrs: [
      {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }
    ]
  },
  {
    tfOpName: "GatherV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ],
    attrs: [
      {
        tfName: "batch_dims",
        name: "batchDims",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Gather",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Reverse",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "dims",
        type: "bool[]"
      }
    ]
  },
  {
    tfOpName: "ReverseV2",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Slice",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "begin",
        type: "number[]"
      },
      {
        start: 2,
        name: "size",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "StridedSlice",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "begin",
        type: "number[]"
      },
      {
        start: 2,
        name: "end",
        type: "number[]"
      },
      {
        start: 3,
        name: "strides",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "begin_mask",
        name: "beginMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "end_mask",
        name: "endMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "new_axis_mask",
        name: "newAxisMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "ellipsis_mask",
        name: "ellipsisMask",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "shrink_axis_mask",
        name: "shrinkAxisMask",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Pack",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Unpack",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "tensor",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
      },
      {
        tfName: "num",
        name: "num",
        type: "number",
        defaultValue: 0,
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "Tile",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "reps",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Split",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "axis",
        type: "number",
        defaultValue: 0
      },
      {
        start: 1,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "num_split",
        name: "numOrSizeSplits",
        type: "number",
        defaultValue: 1
      }
    ]
  },
  {
    tfOpName: "SplitV",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "numOrSizeSplits",
        type: "number[]"
      },
      {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "ScatterNd",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      },
      {
        start: 2,
        name: "shape",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "GatherNd",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseToDense",
    category: "slice_join",
    inputs: [
      {
        start: 0,
        name: "sparseIndices",
        type: "tensor"
      },
      {
        start: 1,
        name: "outputShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "sparseValues",
        type: "tensor"
      },
      {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        defaultValue: false,
        notSupported: true
      }
    ]
  }
], og = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: ig2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ug = [
  {
    tfOpName: "SparseFillEmptyRows",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "indices",
        type: "tensor"
      },
      {
        start: 1,
        name: "values",
        type: "tensor"
      },
      {
        start: 2,
        name: "denseShape",
        type: "tensor"
      },
      {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseReshape",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "inputIndices",
        type: "tensor"
      },
      {
        start: 1,
        name: "inputShape",
        type: "tensor"
      },
      {
        start: 2,
        name: "newShape",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "SparseSegmentMean",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "segmentIds",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "SparseSegmentSum",
    category: "sparse",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "indices",
        type: "tensor"
      },
      {
        start: 2,
        name: "segmentIds",
        type: "tensor"
      }
    ]
  }
], lg2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: ug
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const pg2 = [
  {
    tfOpName: "FFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "IFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ]
  },
  {
    tfOpName: "RFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: true
      }
    ]
  },
  {
    tfOpName: "IRFFT",
    category: "spectral",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: true
      }
    ]
  }
], mg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: pg2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cg = [
  {
    tfOpName: "StringNGrams",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "data",
        type: "tensor"
      },
      {
        start: 1,
        name: "dataSplits",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "separator",
        name: "separator",
        type: "string"
      },
      {
        tfName: "ngram_widths",
        name: "nGramWidths",
        type: "number[]"
      },
      {
        tfName: "left_pad",
        name: "leftPad",
        type: "string"
      },
      {
        tfName: "right_pad",
        name: "rightPad",
        type: "string"
      },
      {
        tfName: "pad_width",
        name: "padWidth",
        type: "number"
      },
      {
        tfName: "preserve_short_sequences",
        name: "preserveShortSequences",
        type: "bool"
      }
    ],
    outputs: [
      "ngrams",
      "ngrams_splits"
    ]
  },
  {
    tfOpName: "StringSplit",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      },
      {
        start: 1,
        name: "delimiter",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "skip_empty",
        name: "skipEmpty",
        type: "bool"
      }
    ],
    outputs: [
      "indices",
      "values",
      "shape"
    ]
  },
  {
    tfOpName: "StringToHashBucketFast",
    category: "string",
    inputs: [
      {
        start: 0,
        name: "input",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "num_buckets",
        name: "numBuckets",
        type: "number"
      }
    ]
  }
], dg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: cg
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hg = [
  {
    tfOpName: "Cast",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "SrcT",
        name: "sdtype",
        type: "dtype",
        notSupported: true
      },
      {
        tfName: "DstT",
        name: "dtype",
        type: "dtype"
      }
    ]
  },
  {
    tfOpName: "ExpandDims",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "axis",
        type: "number"
      }
    ]
  },
  {
    tfOpName: "MirrorPad",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "mode",
        name: "mode",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "Pad",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      }
    ],
    attrs: [
      {
        tfName: "constant_value",
        name: "constantValue",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "PadV2",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "padding",
        type: "number[]"
      },
      {
        start: 2,
        name: "constantValue",
        type: "number",
        defaultValue: 0
      }
    ]
  },
  {
    tfOpName: "Reshape",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "shape",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "Squeeze",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "axis",
        tfDeprecatedName: "squeeze_dims",
        name: "axis",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "SpaceToBatchND",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "blockShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "paddings",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "BatchToSpaceND",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "blockShape",
        type: "number[]"
      },
      {
        start: 2,
        name: "crops",
        type: "number[]"
      }
    ]
  },
  {
    tfOpName: "DepthToSpace",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      }
    ],
    attrs: [
      {
        tfName: "block_size",
        name: "blockSize",
        type: "number"
      },
      {
        tfName: "data_format",
        name: "dataFormat",
        type: "string"
      }
    ]
  },
  {
    tfOpName: "BroadcastTo",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "x",
        type: "tensor"
      },
      {
        start: 1,
        name: "shape",
        type: "number[]"
      }
    ],
    attrs: []
  },
  {
    tfOpName: "BroadcastArgs",
    category: "transformation",
    inputs: [
      {
        start: 0,
        name: "s0",
        type: "tensor"
      },
      {
        start: 1,
        name: "s1",
        type: "tensor"
      }
    ],
    attrs: []
  }
], fg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: hg
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Vt {
  // Loads the op mapping from the JSON file.
  constructor() {
    const e = [
      zy2,
      Ly2,
      Fy2,
      Ry2,
      By2,
      Wy2,
      Uy2,
      Ky2,
      Qy2,
      Zy2,
      My2,
      tg2,
      ag,
      ng,
      og,
      lg2,
      mg,
      dg,
      fg
    ], t = [].concat(...e.map((a) => a.json));
    this.opMappers = t.reduce((a, r) => (a[r.tfOpName] = r, a), {});
  }
  // Singleton instance for the mapper
  static get Instance() {
    return this._instance || (this._instance = new this());
  }
  // Converts the model inference graph from Tensorflow GraphDef to local
  // representation for TensorFlow.js API
  transformGraph(e, t = {}) {
    const a = e.node, r = [], n = [], o = [], u = a.reduce((f, y6) => (f[y6.name] = this.mapNode(y6), y6.op.startsWith("Placeholder") ? r.push(f[y6.name]) : y6.op === "Const" ? n.push(f[y6.name]) : (y6.input == null || y6.input.length === 0) && o.push(f[y6.name]), f), {});
    let l = [];
    const p6 = [];
    let m = {}, c = {};
    t != null && (m = this.mapSignatureEntries(t.inputs), c = this.mapSignatureEntries(t.outputs));
    const d = Object.keys(u);
    d.forEach((f) => {
      const y6 = u[f];
      y6.inputNames.forEach((T6, _6) => {
        const [w6, , I] = B(T6), E6 = u[w6];
        if (E6.outputs != null) {
          const D6 = E6.outputs.indexOf(I);
          if (D6 !== -1) {
            const V = `${w6}:${D6}`;
            y6.inputNames[_6] = V;
          }
        }
        y6.inputs.push(E6), E6.children.push(y6);
      });
    }), Object.keys(c).length === 0 ? d.forEach((f) => {
      const y6 = u[f];
      y6.children.length === 0 && p6.push(y6);
    }) : Object.keys(c).forEach((f) => {
      const [y6] = B(f), T6 = u[y6];
      T6 != null && (T6.signatureKey = c[f], p6.push(T6));
    }), Object.keys(m).length > 0 ? Object.keys(m).forEach((f) => {
      const [y6] = B(f), T6 = u[y6];
      T6 && (T6.signatureKey = m[f], l.push(T6));
    }) : l = r;
    let h6 = {};
    e.library != null && e.library.function != null && (h6 = e.library.function.reduce((f, y6) => (f[y6.signature.name] = this.mapFunction(y6), f), {}));
    const b6 = { nodes: u, inputs: l, outputs: p6, weights: n, placeholders: r, signature: t, functions: h6 };
    return o.length > 0 && (b6.initNodes = o), b6;
  }
  mapSignatureEntries(e) {
    return Object.keys(e || {}).reduce((t, a) => (t[e[a].name] = a, t), {});
  }
  mapNode(e) {
    const t = Jn(e.op) || this.opMappers[e.op] || {};
    e.attr == null && (e.attr = {});
    const a = {
      name: e.name,
      op: e.op,
      category: t.category,
      inputNames: (e.input || []).map((r) => r.startsWith("^") ? r.slice(1) : r),
      inputs: [],
      children: [],
      inputParams: {},
      attrParams: {},
      rawAttrs: e.attr,
      outputs: t.outputs
    };
    return t.inputs != null && (a.inputParams = t.inputs.reduce((r, n) => (r[n.name] = {
      type: n.type,
      inputIndexStart: n.start,
      inputIndexEnd: n.end
    }, r), {})), t.attrs != null && (a.attrParams = t.attrs.reduce((r, n) => {
      const o = n.type;
      let u;
      switch (n.type) {
        case "string":
          u = Re(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = Re(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "string[]":
          u = Ge(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = Ge(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "number":
          u = Be(e.attr, n.tfName, n.defaultValue || 0), u === void 0 && n.tfDeprecatedName && (u = Be(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "number[]":
          u = Ue(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = Ue(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "bool":
          u = je(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = je(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "bool[]":
          u = Je(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = Je(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "shape":
          u = qe2(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = qe2(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "shape[]":
          u = Ke2(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = Ke2(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "dtype":
          u = He2(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = He2(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "dtype[]":
          u = We(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = We(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "func":
          u = Ft(e.attr, n.tfName, n.defaultValue), u === void 0 && n.tfDeprecatedName && (u = Ft(e.attr, n.tfDeprecatedName, n.defaultValue));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`);
      }
      return r[n.name] = { value: u, type: o }, r;
    }, {})), a;
  }
  // map the TFunctionDef to TFJS graph object
  mapFunction(e) {
    const t = e.nodeDef, a = [], r = [];
    let n = {};
    t != null && (n = t.reduce((c, d) => (c[d.name] = this.mapNode(d), d.op === "Const" && r.push(c[d.name]), c), {}));
    const o = [], u = [];
    e.signature.inputArg.forEach((c) => {
      const [d] = B(c.name), h6 = {
        name: d,
        op: "Placeholder",
        inputs: [],
        inputNames: [],
        category: "graph",
        inputParams: {},
        attrParams: { dtype: { value: vt(c.type), type: "dtype" } },
        children: []
      };
      h6.signatureKey = c.name, o.push(h6), n[d] = h6;
    }), Object.keys(n).forEach((c) => {
      const d = n[c];
      d.inputNames.forEach((h6, b6) => {
        const [f, , y6] = B(h6), T6 = n[f];
        if (T6.outputs != null) {
          const _6 = T6.outputs.indexOf(y6);
          if (_6 !== -1) {
            const w6 = `${f}:${_6}`;
            d.inputNames[b6] = w6;
          }
        }
        d.inputs.push(T6), T6.children.push(d);
      });
    });
    const p6 = e.ret;
    e.signature.outputArg.forEach((c) => {
      const [d, h6] = B(p6[c.name]), b6 = n[d];
      b6 != null && (b6.defaultOutput = h6, u.push(b6));
    });
    const m = this.mapArgsToSignature(e);
    return { nodes: n, inputs: o, outputs: u, weights: r, placeholders: a, signature: m };
  }
  mapArgsToSignature(e) {
    return {
      methodName: e.signature.name,
      inputs: e.signature.inputArg.reduce((t, a) => (t[a.name] = this.mapArgToTensorInfo(a), t), {}),
      outputs: e.signature.outputArg.reduce((t, a) => (t[a.name] = this.mapArgToTensorInfo(a, e.ret), t), {})
    };
  }
  mapArgToTensorInfo(e, t) {
    let a = e.name;
    return t != null && (a = t[a]), { name: a, dtype: e.type };
  }
}
function yg(s) {
  const e = F().global;
  if (typeof e.atob < "u")
    return e.atob(s);
  if (typeof dist.Buffer < "u")
    return new dist.Buffer(s, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function Qn(s, e) {
  const t = Array.isArray(s) ? String.fromCharCode.apply(null, s) : yg(s);
  return e ? t : t.toLowerCase();
}
function Re(s, e, t, a = false) {
  const r = s[e];
  return r != null ? Qn(r.s, a) : t;
}
function je(s, e, t) {
  const a = s[e];
  return a ? a.b : t;
}
function Be(s, e, t) {
  const a = s[e] || {}, r = a.i != null ? a.i : a.f != null ? a.f : t;
  return typeof r == "number" ? r : parseInt(r, 10);
}
function vt(s) {
  switch (typeof s == "string" && (s = Am[s]), s) {
    case Am.DT_FLOAT:
    case Am.DT_HALF:
      return "float32";
    case Am.DT_INT32:
    case Am.DT_INT64:
    case Am.DT_INT8:
    case Am.DT_UINT8:
      return "int32";
    case Am.DT_BOOL:
      return "bool";
    case Am.DT_DOUBLE:
      return "float32";
    case Am.DT_STRING:
      return "string";
    default:
      return null;
  }
}
function Ft(s, e, t) {
  const a = s[e];
  return a && a.func ? a.func.name : t;
}
function He2(s, e, t) {
  const a = s[e];
  return a && a.type ? vt(a.type) : t;
}
function We(s, e, t) {
  const a = s[e];
  return a && a.list && a.list.type ? a.list.type.map((r) => vt(r)) : t;
}
function Xn(s) {
  if (!s.unknownRank)
    return s.dim != null ? s.dim.map((e) => typeof e.size == "number" ? e.size : parseInt(e.size, 10)) : [];
}
function qe2(s, e, t) {
  const a = s[e];
  return a && a.shape ? Xn(a.shape) : t;
}
function Ue(s, e, t) {
  const a = s[e];
  return a ? ((a.list.f && a.list.f.length ? a.list.f : a.list.i) || []).map((r) => typeof r == "number" ? r : parseInt(r, 10)) : t;
}
function Ge(s, e, t, a = false) {
  const r = s[e];
  return r && r.list && r.list.s ? r.list.s.map((n) => Qn(n, a)) : t;
}
function Ke2(s, e, t) {
  const a = s[e];
  return a && a.list && a.list.shape ? a.list.shape.map((r) => Xn(r)) : t;
}
function Je(s, e, t) {
  const a = s[e];
  return a && a.list && a.list.b ? a.list.b : t;
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class gg {
  constructor(e, t, a) {
    this.node = e, this.tensorMap = t, this.context = a, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map((r) => this.getInput(r)), e.rawAttrs != null && (this.attrs = Object.keys(e.rawAttrs).reduce((r, n) => (r[n] = this.getAttr(n), r), {}));
  }
  /**
   * Return the value of the attribute or input param.
   * @param name String: name of attribute or input param.
   */
  getInput(e) {
    return k6(e, this.tensorMap, this.context);
  }
  /**
   * Return the value of the attribute or input param.
   * @param name String: name of attribute or input param.
   */
  getAttr(e, t) {
    const a = this.node.rawAttrs[e];
    if (a.tensor != null)
      return k6(e, this.tensorMap, this.context);
    if (a.i != null || a.f != null)
      return Be(this.node.rawAttrs, e, t);
    if (a.s != null)
      return Re(this.node.rawAttrs, e, t);
    if (a.b != null)
      return je(this.node.rawAttrs, e, t);
    if (a.shape != null)
      return qe2(this.node.rawAttrs, e, t);
    if (a.type != null)
      return He2(this.node.rawAttrs, e, t);
    if (a.list != null) {
      if (a.list.i != null || a.list.f != null)
        return Ue(this.node.rawAttrs, e, t);
      if (a.list.s != null)
        return Ge(this.node.rawAttrs, e, t);
      if (a.list.shape != null)
        return Ke2(this.node.rawAttrs, e, t);
      if (a.list.b != null)
        return Je(this.node.rawAttrs, e, t);
      if (a.list.type != null)
        return We(this.node.rawAttrs, e, t);
    }
    return t;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const A = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OP_SCOPE_SUFFIX: yC,
  abs: fe$1,
  acos: o2,
  acosh: i2,
  add: U,
  addN: Yr,
  all: Nb$1,
  any: bd$1,
  argMax: Qr,
  argMin: d2,
  asin: p2,
  asinh: m2,
  atan: b2,
  atan2: y2,
  atanh: I2,
  avgPool: Bh$1,
  avgPool3d: $2,
  basicLSTMCell: Mr,
  batchNorm: zc,
  batchNorm2d: X2,
  batchNorm3d: A2,
  batchNorm4d: K2,
  batchToSpaceND: _h$1,
  bincount: B2,
  booleanMaskAsync: Cn2,
  broadcastArgs: en,
  broadcastTo: Br,
  buffer: vt$1,
  cast: et,
  ceil: U2,
  clipByValue: pn$1,
  clone: po,
  complex: bo,
  concat: Ge$1,
  concat1d: J2,
  concat2d: q2,
  concat3d: ev,
  concat4d: sv,
  conv1d: Rb,
  conv2d: Co,
  conv2dTranspose: $b,
  conv3d: cv,
  conv3dTranspose: hv,
  cos: Yh$1,
  cosh: Eb,
  cosineWindow: n0,
  cumprod: yd$1,
  cumsum: Lb,
  denseBincount: rm,
  depthToSpace: yv,
  depthwiseConv2d: Qh$1,
  diag: tn,
  dilation2d: Cv,
  div: ut,
  divNoNan: Nv,
  dot: $v,
  dropout: oT,
  einsum: sn,
  elu: Xc,
  enclosingPowerOfTwo: rT,
  equal: kn$1,
  erf: Lv,
  euclideanNorm: Av,
  exp: Tn$1,
  expandDims: Ue$1,
  expm1: Bv,
  eye: Db,
  fft: xp,
  fill: ua,
  floor: Ac,
  floorDiv: Tb$1,
  fused: Pn,
  gather: jh$1,
  gatherND: Vn,
  greater: sn$1,
  greaterEqual: Do,
  ifft: pl,
  imag: qh$1,
  image: uo,
  inTopKAsync: Fn,
  irfft: Qb,
  isFinite: tS,
  isInf: nS,
  isNaN: oS,
  leakyRelu: tp,
  less: Fb,
  lessEqual: yr,
  linalg: zN,
  linspace: an2,
  localResponseNormalization: cS,
  log: Nn$1,
  log1p: ep,
  logSigmoid: gS,
  logSoftmax: Vb,
  logSumExp: zb,
  logicalAnd: ss,
  logicalNot: np,
  logicalOr: Xb,
  logicalXor: SS,
  losses: mY,
  lowerBound: rn,
  matMul: Gt,
  max: Xn$1,
  maxPool: sp,
  maxPool3d: NS,
  maxPoolWithArgmax: nn,
  maximum: _s,
  mean: se,
  meshgrid: on,
  min: ul,
  minimum: Kc,
  mirrorPad: LS,
  mod: WS,
  moments: op,
  movingAverage: zn,
  mul: G,
  multiRNNCell: un,
  multinomial: ln,
  neg: jt$1,
  norm: Pc,
  notEqual: qr,
  oneHot: Pb,
  ones: Us,
  onesLike: Rn$1,
  op: L,
  outerProduct: pn,
  pad: rp,
  pad1d: mn,
  pad2d: cn,
  pad3d: dn,
  pad4d: hn,
  pool: ZS,
  pow: ir,
  prelu: ap,
  print: QC,
  prod: _S,
  raggedGather: fn,
  raggedRange: yn,
  raggedTensorToTensor: gn,
  rand: bn,
  randomGamma: Tn,
  randomNormal: hk,
  randomStandardNormal: Sn,
  randomUniform: Zc,
  range: ti$1,
  real: dl,
  reciprocal: gk,
  relu: ws,
  relu6: Ob,
  reshape: W,
  reverse: ko,
  reverse1d: vn,
  reverse2d: On,
  reverse3d: _n,
  reverse4d: An,
  rfft: yp,
  round: Kb,
  rsqrt: Zb,
  scalar: gt$1,
  scatterND: xn2,
  searchSorted: De,
  selu: Bb,
  separableConv2d: Hb,
  setdiff1dAsync: En,
  sigmoid: xr,
  sign: kk,
  signal: fY,
  sin: _b,
  sinh: Ub,
  slice: Dt,
  slice1d: mp,
  slice2d: Yb,
  slice3d: gp,
  slice4d: hl,
  softmax: bp,
  softplus: da,
  spaceToBatchND: ip,
  sparse: gY,
  sparseToDense: Ln,
  spectral: pY,
  split: un$1,
  sqrt: De$1,
  square: At$1,
  squaredDifference: Jb,
  squeeze: ha,
  stack: os,
  step: pa,
  stridedSlice: Kk,
  string: bY,
  sub: lt,
  sum: at,
  tan: Bk,
  tanh: Hh$1,
  tensor: Re$1,
  tensor1d: Je$1,
  tensor2d: qa,
  tensor3d: Hk,
  tensor4d: kn,
  tensor5d: In,
  tensor6d: Dn,
  tile: Vn$1,
  topk: Uk,
  transpose: kt,
  truncatedNormal: jb,
  unique: Jk,
  unsortedSegmentSum: qb,
  unstack: To,
  upperBound: $n,
  variable: tT,
  where: Oe,
  whereAsync: gt,
  zeros: ge$1,
  zerosLike: Tt$1
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bg2 = (s, e, t, a = A) => {
  switch (s.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [a.add(i("a", s, e, t), i("b", s, e, t))];
    case "AddN":
      return [a.addN(i("tensors", s, e, t))];
    case "FloorMod":
    case "Mod":
      return [a.mod(i("a", s, e, t), i("b", s, e, t))];
    case "Mul":
      return [a.mul(i("a", s, e, t), i("b", s, e, t))];
    case "RealDiv":
    case "Div":
      return [a.div(i("a", s, e, t), i("b", s, e, t))];
    case "DivNoNan":
      return [a.divNoNan(i("a", s, e, t), i("b", s, e, t))];
    case "FloorDiv":
      return [a.floorDiv(i("a", s, e, t), i("b", s, e, t))];
    case "Sub":
      return [a.sub(i("a", s, e, t), i("b", s, e, t))];
    case "Minimum":
      return [a.minimum(i("a", s, e, t), i("b", s, e, t))];
    case "Maximum":
      return [a.maximum(i("a", s, e, t), i("b", s, e, t))];
    case "Pow":
      return [a.pow(i("a", s, e, t), i("b", s, e, t))];
    case "SquaredDifference":
      return [a.squaredDifference(i("a", s, e, t), i("b", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ng = (s, e, t, a = A) => {
  switch (s.op) {
    case "Abs":
    case "ComplexAbs":
      return [a.abs(i("x", s, e, t))];
    case "Acos":
      return [a.acos(i("x", s, e, t))];
    case "Acosh":
      return [a.acosh(i("x", s, e, t))];
    case "Asin":
      return [a.asin(i("x", s, e, t))];
    case "Asinh":
      return [a.asinh(i("x", s, e, t))];
    case "Atan":
      return [a.atan(i("x", s, e, t))];
    case "Atan2":
      return [a.atan2(i("x", s, e, t), i("y", s, e, t))];
    case "Atanh":
      return [a.atanh(i("x", s, e, t))];
    case "Ceil":
      return [a.ceil(i("x", s, e, t))];
    case "Complex":
      return [a.complex(i("real", s, e, t), i("imag", s, e, t))];
    case "Cos":
      return [a.cos(i("x", s, e, t))];
    case "Cosh":
      return [a.cosh(i("x", s, e, t))];
    case "Elu":
      return [a.elu(i("x", s, e, t))];
    case "Erf":
      return [a.erf(i("x", s, e, t))];
    case "Exp":
      return [a.exp(i("x", s, e, t))];
    case "Expm1":
      return [a.expm1(i("x", s, e, t))];
    case "Floor":
      return [a.floor(i("x", s, e, t))];
    case "Log":
      return [a.log(i("x", s, e, t))];
    case "Log1p":
      return [a.log1p(i("x", s, e, t))];
    case "Imag":
      return [a.imag(i("x", s, e, t))];
    case "Neg":
      return [a.neg(i("x", s, e, t))];
    case "Reciprocal":
      return [a.reciprocal(i("x", s, e, t))];
    case "Real":
      return [a.real(i("x", s, e, t))];
    case "Relu":
      return [a.relu(i("x", s, e, t))];
    case "Round":
      return [a.round(i("x", s, e, t))];
    case "Selu":
      return [a.selu(i("x", s, e, t))];
    case "Sigmoid":
      return [a.sigmoid(i("x", s, e, t))];
    case "Sin":
      return [a.sin(i("x", s, e, t))];
    case "Sign":
      return [a.sign(i("x", s, e, t))];
    case "Sinh":
      return [a.sinh(i("x", s, e, t))];
    case "Softplus":
      return [a.softplus(i("x", s, e, t))];
    case "Sqrt":
      return [a.sqrt(i("x", s, e, t))];
    case "Square":
      return [a.square(i("x", s, e, t))];
    case "Tanh":
      return [a.tanh(i("x", s, e, t))];
    case "Tan":
      return [a.tan(i("x", s, e, t))];
    case "ClipByValue":
      return [a.clipByValue(i("x", s, e, t), i("clipValueMin", s, e, t), i("clipValueMax", s, e, t))];
    case "Relu6":
      return [a.relu6(i("x", s, e, t))];
    case "Rsqrt":
      return [a.rsqrt(k6(s.inputNames[0], e, t))];
    case "Prod":
      return [a.prod(i("x", s, e, t), i("axes", s, e, t))];
    case "LeakyRelu":
      return [a.leakyRelu(i("x", s, e, t), i("alpha", s, e, t))];
    case "Prelu":
      return [a.prelu(i("x", s, e, t), i("alpha", s, e, t))];
    case "IsNan":
      return [a.isNaN(k6(s.inputNames[0], e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function C(s, e, t = "") {
  if (!(typeof s == "number" || typeof e == "number")) {
    v(s.length === e.length, () => t + ` Shapes ${s} and ${e} must match`);
    for (let a = 0; a < s.length; a++) {
      const r = s[a], n = e[a];
      v(r < 0 || n < 0 || r === n, () => t + ` Shapes ${s} and ${e} must match`);
    }
  }
}
function Pt(s) {
  return !(typeof s == "number" || s.some((e) => e < 0));
}
function re(s, e, t) {
  let a = Qe(s, t);
  const r = !Pt(a);
  if (r && e.length === 0)
    throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);
  if (r && e.forEach((n) => {
    a = Qe(n.shape, a);
  }), !Pt(a))
    throw new Error(`Non-fully-defined elementShape: ${a}`);
  return a;
}
function Qe(s, e) {
  if (typeof s == "number")
    return e;
  if (typeof e == "number")
    return s;
  if (s.length !== e.length)
    throw new Error(`Incompatible ranks during merge: ${s} vs. ${e}`);
  const t = [];
  for (let a = 0; a < s.length; ++a) {
    const r = s[a], n = e[a];
    if (r >= 0 && n >= 0 && r !== n)
      throw new Error(`Incompatible shape during merge: ${s} vs. ${e}`);
    t[a] = r >= 0 ? r : n;
  }
  return t;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class wg {
  constructor(e, t, a, r, n, o, u) {
    this.name = e, this.dtype = t, this.maxSize = a, this.elementShape = r, this.identicalElementShapes = n, this.dynamicSize = o, this.clearAfterRead = u, this.tensors = [], this.closed_ = false, this.idTensor = gt$1(0), cn$1(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  get closed() {
    return this.closed_;
  }
  /**
   * Dispose the tensors and idTensor and mark the TensoryArray as closed.
   */
  clearAndClose(e) {
    this.tensors.forEach((t) => {
      (e == null || !e.has(t.tensor.id)) && t.tensor.dispose();
    }), this.tensors = [], this.closed_ = true, this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  /**
   * Read the value at location index in the TensorArray.
   * @param index Number the index to read from.
   */
  read(e) {
    if (this.closed_)
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    if (e < 0 || e >= this.size())
      throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);
    const t = this.tensors[e];
    if (t.cleared)
      throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
    return this.clearAfterRead && (t.cleared = true), t.read = true, t.tensor;
  }
  /**
   * Helper method to read multiple tensors from the specified indices.
   */
  readMany(e) {
    return e.map((t) => this.read(t));
  }
  /**
   * Write value into the index of the TensorArray.
   * @param index number the index to write to.
   * @param tensor
   */
  write(e, t) {
    if (this.closed_)
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    if (e < 0 || !this.dynamicSize && e >= this.maxSize)
      throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);
    const a = this.tensors[e] || {};
    if (t.dtype !== this.dtype)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);
    if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0) && (this.elementShape = t.shape), C(this.elementShape, t.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e}.`), a.read)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);
    if (a.written)
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);
    a.tensor = t, cn$1(t), a.written = true, this.tensors[e] = a;
  }
  /**
   * Helper method to write multiple tensors to the specified indices.
   */
  writeMany(e, t) {
    if (e.length !== t.length)
      throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);
    e.forEach((a, r) => this.write(a, t[r]));
  }
  /**
   * Return selected values in the TensorArray as a packed Tensor. All of
   * selected values must have been written and their shapes must all match.
   * @param [indices] number[] Optional. Taking values in [0, max_value). If the
   *    TensorArray is not dynamic, max_value=size(). If not specified returns
   *    all tensors in the original order.
   * @param [dtype]
   */
  gather(e, t) {
    if (t && t !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);
    if (e)
      e = e.slice(0, this.size());
    else {
      e = [];
      for (let r = 0; r < this.size(); r++)
        e.push(r);
    }
    if (e.length === 0)
      return Re$1([], [0].concat(this.elementShape));
    const a = this.readMany(e);
    return C(this.elementShape, a[0].shape, "TensorArray shape mismatch: "), os(a, 0);
  }
  /**
   * Return the values in the TensorArray as a concatenated Tensor.
   */
  concat(e) {
    if (e && e !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);
    if (this.size() === 0)
      return Re$1([], [0].concat(this.elementShape));
    const t = [];
    for (let r = 0; r < this.size(); r++)
      t.push(r);
    const a = this.readMany(t);
    return C(this.elementShape, a[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`), Ge$1(a, 0);
  }
  /**
   * Scatter the values of a Tensor in specific indices of a TensorArray.
   * @param indices nummber[] values in [0, max_value). If the
   *    TensorArray is not dynamic, max_value=size().
   * @param tensor Tensor input tensor.
   */
  scatter(e, t) {
    if (t.dtype !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
    if (e.length !== t.shape[0])
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);
    const a = Math.max(...e);
    if (!this.dynamicSize && a >= this.maxSize)
      throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);
    this.writeMany(e, To(t, 0));
  }
  /**
   * Split the values of a Tensor into the TensorArray.
   * @param length number[] with the lengths to use when splitting value along
   *    its first dimension.
   * @param tensor Tensor, the tensor to split.
   */
  split(e, t) {
    if (t.dtype !== this.dtype)
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
    let a = 0;
    const r = e.map((l) => (a += l, a));
    if (a !== t.shape[0])
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${t.shape}`);
    if (!this.dynamicSize && e.length !== this.maxSize)
      throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);
    const n = a === 0 ? 0 : t.size / a, o = [];
    D(() => {
      t = W(t, [1, a, n]);
      for (let l = 0; l < e.length; ++l) {
        const m = [0, l === 0 ? 0 : r[l - 1], 0], c = [1, e[l], n];
        o[l] = W(Dt(t, m, c), this.elementShape);
      }
      return o;
    });
    const u = [];
    for (let l = 0; l < e.length; l++)
      u[l] = l;
    this.writeMany(u, o);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class J {
  /**
   *
   * @param tensors list of tensors
   * @param elementShape shape of each tensor, this can be a single number (any
   * shape is allowed) or partial shape (dim = -1).
   * @param elementDtype data type of each tensor
   * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1
   *   meaning that the size of `tensors` is unbounded.
   */
  constructor(e, t, a, r = -1) {
    this.tensors = e, this.elementShape = t, this.elementDtype = a, e != null && e.forEach((n) => {
      if (a !== n.dtype)
        throw new Error(`Invalid data types; op elements ${a}, but list elements ${n.dtype}`);
      C(t, n.shape, "TensorList shape mismatch: "), cn$1(n);
    }), this.idTensor = gt$1(0), this.maxNumElements = r, cn$1(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  /**
   * Get a new TensorList containing a copy of the underlying tensor container.
   */
  copy() {
    return new J([...this.tensors], this.elementShape, this.elementDtype);
  }
  /**
   * Dispose the tensors and idTensor and clear the tensor list.
   */
  clearAndClose(e) {
    this.tensors.forEach((t) => {
      (e == null || !e.has(t.id)) && t.dispose();
    }), this.tensors.length = 0, this.idTensor.dispose();
  }
  /**
   * The size of the tensors in the tensor list.
   */
  size() {
    return this.tensors.length;
  }
  /**
   * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)
   * tf.Tensor.
   * @param elementShape shape of each tensor
   * @param elementDtype data type of each tensor
   * @param numElements the number of elements to stack
   */
  stack(e, t, a = -1) {
    if (t !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
    if (a !== -1 && this.tensors.length !== a)
      throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);
    C(e, this.elementShape, "TensorList shape mismatch: ");
    const r = re(this.elementShape, this.tensors, e);
    return D(() => {
      const n = this.tensors.map((o) => W(o, r));
      return os(n, 0);
    });
  }
  /**
   * Pop a tensor from the end of the list.
   * @param elementShape shape of the tensor
   * @param elementDtype data type of the tensor
   */
  popBack(e, t) {
    if (t !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
    if (this.size() === 0)
      throw new Error("Trying to pop from an empty list.");
    const a = re(this.elementShape, this.tensors, e), r = this.tensors.pop();
    return r.kept = false, C(r.shape, e, "TensorList shape mismatch: "), W(r, a);
  }
  /**
   * Push a tensor to the end of the list.
   * @param tensor Tensor to be pushed.
   */
  pushBack(e) {
    if (e.dtype !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);
    if (C(e.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size())
      throw new Error("Trying to push element into a full list.");
    cn$1(e), this.tensors.push(e);
  }
  /**
   * Update the size of the list.
   * @param size the new size of the list.
   */
  resize(e) {
    if (e < 0)
      throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);
    if (this.maxNumElements !== -1 && e > this.maxNumElements)
      throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);
    const t = new J([], this.elementShape, this.elementDtype, this.maxNumElements);
    t.tensors.length = e;
    for (let a = 0; a < Math.min(this.tensors.length, e); ++a)
      t.tensors[a] = this.tensors[a];
    return t;
  }
  /**
   * Retrieve the element at the provided index
   * @param elementShape shape of the tensor
   * @param elementDtype dtype of the tensor
   * @param elementIndex index of the tensor
   */
  getItem(e, t, a) {
    if (a !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);
    if (e < 0 || e > this.tensors.length)
      throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);
    if (this.tensors[e] == null)
      throw new Error(`element at index ${e} is null.`);
    C(this.tensors[e].shape, t, "TensorList shape mismatch: ");
    const r = re(this.elementShape, this.tensors, t);
    return W(this.tensors[e], r);
  }
  /**
   * Set the tensor at the index
   * @param elementIndex index of the tensor
   * @param tensor the tensor to be inserted into the list
   */
  setItem(e, t) {
    if (t.dtype !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);
    if (e < 0 || this.maxNumElements !== -1 && e >= this.maxNumElements)
      throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);
    C(this.elementShape, t.shape, "TensorList shape mismatch: "), cn$1(t), this.tensors[e] != null && (this.tensors[e].kept = false), this.tensors[e] = t;
  }
  /**
   * Return selected values in the TensorList as a stacked Tensor. All of
   * selected values must have been written and their shapes must all match.
   * @param indices indices of tensors to gather
   * @param elementDtype output tensor dtype
   * @param elementShape output tensor element shape
   */
  gather(e, t, a) {
    if (t !== this.elementDtype)
      throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
    C(this.elementShape, a, "TensorList shape mismatch: "), e = e.slice(0, this.size());
    const r = re(this.elementShape, this.tensors, a);
    return e.length === 0 ? Re$1([], [0].concat(r)) : D(() => {
      const n = e.map((o) => W(this.tensors[o], r));
      return os(n, 0);
    });
  }
  /**
   * Return the values in the TensorList as a concatenated Tensor.
   * @param elementDtype output tensor dtype
   * @param elementShape output tensor element shape
   */
  concat(e, t) {
    if (e && e !== this.elementDtype)
      throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);
    C(this.elementShape, t, "TensorList shape mismatch: ");
    const a = re(this.elementShape, this.tensors, t);
    return this.size() === 0 ? Re$1([], [0].concat(a)) : D(() => {
      const r = this.tensors.map((n) => W(n, a));
      return Ge$1(r, 0);
    });
  }
}
function Tg(s, e, t) {
  const a = s.dtype;
  if (s.shape.length < 1)
    throw new Error(`Tensor must be at least a vector, but saw shape: ${s.shape}`);
  if (s.dtype !== t)
    throw new Error(`Invalid data types; op elements ${s.dtype}, but list elements ${t}`);
  const r = s.shape.slice(1);
  C(r, e, "TensorList shape mismatch: ");
  const n = To(s);
  return new J(n, e, a);
}
function Sg(s, e, t, a) {
  return new J([], s, e, a);
}
function vg(s, e, t, a) {
  if (e.length !== s.shape[0])
    throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${s.shape[0]}`);
  const r = Math.max(...e);
  if (a != null && a !== -1 && r >= a)
    throw new Error(`Max index must be < array size (${r}  vs. ${a})`);
  const n = new J([], t, s.dtype, a), o = To(s, 0);
  return e.forEach((u, l) => {
    n.setItem(u, o[l]);
  }), n;
}
function Og(s, e, t) {
  let a = 0;
  const r = e.map((m) => (a += m, a));
  if (a !== s.shape[0])
    throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${s.shape}`);
  const n = s.shape.slice(1), o = Qe(n, t), u = a === 0 ? 0 : s.size / a, l = D(() => {
    const m = [];
    s = W(s, [1, a, u]);
    for (let c = 0; c < e.length; ++c) {
      const h6 = [0, c === 0 ? 0 : r[c - 1], 0], b6 = [1, e[c], u];
      m[c] = W(Dt(s, h6, b6), o);
    }
    return s.dispose(), m;
  }), p6 = new J([], t, s.dtype, e.length);
  for (let m = 0; m < l.length; m++)
    p6.setItem(m, l[m]);
  return p6;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const _g = async (s, e, t) => {
  switch (s.op) {
    case "If":
    case "StatelessIf": {
      const a = i("thenBranch", s, e, t), r = i("elseBranch", s, e, t), n = i("cond", s, e, t), o = i("args", s, e, t);
      return (await n.data())[0] ? t.functionMap[a].executeFunctionAsync(o, t.tensorArrayMap, t.tensorListMap) : t.functionMap[r].executeFunctionAsync(o, t.tensorArrayMap, t.tensorListMap);
    }
    case "While":
    case "StatelessWhile": {
      const a = i("body", s, e, t), r = i("cond", s, e, t), n = i("args", s, e, t), o = await t.functionMap[r].executeFunctionAsync(n, t.tensorArrayMap, t.tensorListMap), u = n.map((m) => m.id);
      let l = await o[0].data();
      o.forEach((m) => {
        !m.kept && u.indexOf(m.id) === -1 && m.dispose();
      });
      let p6 = n;
      for (; l[0]; ) {
        const m = p6;
        p6 = await t.functionMap[a].executeFunctionAsync(p6, t.tensorArrayMap, t.tensorListMap);
        const c = p6.map((h6) => h6.id);
        m.forEach((h6) => {
          !h6.kept && u.indexOf(h6.id) === -1 && c.indexOf(h6.id) === -1 && h6.dispose();
        });
        const d = await t.functionMap[r].executeFunctionAsync(p6, t.tensorArrayMap, t.tensorListMap);
        l = await d[0].data(), d.forEach((h6) => {
          !h6.kept && u.indexOf(h6.id) === -1 && c.indexOf(h6.id) === -1 && h6.dispose();
        });
      }
      return p6;
    }
    case "LoopCond": {
      const a = i("pred", s, e, t);
      return [H(a)];
    }
    case "Switch": {
      const a = i("pred", s, e, t);
      let r = i("data", s, e, t);
      return r.kept || (r = H(r)), (await a.data())[0] ? [void 0, r] : [r, void 0];
    }
    case "Merge": {
      const a = s.inputNames.find((r) => k6(r, e, t) !== void 0);
      if (a) {
        const r = k6(a, e, t);
        return [H(r)];
      }
      return;
    }
    case "Enter": {
      const a = i("frameName", s, e, t), r = i("tensor", s, e, t);
      return t.enterFrame(a), [H(r)];
    }
    case "Exit": {
      const a = i("tensor", s, e, t);
      return t.exitFrame(), [H(a)];
    }
    case "NextIteration": {
      const a = i("tensor", s, e, t);
      return t.nextIteration(), [H(a)];
    }
    case "TensorArrayV3": {
      const a = i("size", s, e, t), r = i("dtype", s, e, t), n = i("elementShape", s, e, t), o = i("dynamicSize", s, e, t), u = i("clearAfterRead", s, e, t), l = i("identicalElementShapes", s, e, t), p6 = i("name", s, e, t), m = new wg(p6, r, a, n, l, o, u);
      return t.addTensorArray(m), [m.idTensor, gt$1(1)];
    }
    case "TensorArrayWriteV3": {
      const a = i("tensorArrayId", s, e, t), r = i("index", s, e, t), n = i("tensor", s, e, t), o = t.getTensorArray(a.id);
      return o.write(r, n), [o.idTensor];
    }
    case "TensorArrayReadV3": {
      const a = i("tensorArrayId", s, e, t), r = i("index", s, e, t);
      return [t.getTensorArray(a.id).read(r)];
    }
    case "TensorArrayGatherV3": {
      const a = i("tensorArrayId", s, e, t), r = i("indices", s, e, t), n = i("dtype", s, e, t);
      return [t.getTensorArray(a.id).gather(r, n)];
    }
    case "TensorArrayScatterV3": {
      const a = i("tensorArrayId", s, e, t), r = i("indices", s, e, t), n = i("tensor", s, e, t), o = t.getTensorArray(a.id);
      return o.scatter(r, n), [o.idTensor];
    }
    case "TensorArrayConcatV3": {
      const a = i("tensorArrayId", s, e, t), r = t.getTensorArray(a.id), n = i("dtype", s, e, t);
      return [r.concat(n)];
    }
    case "TensorArraySplitV3": {
      const a = i("tensorArrayId", s, e, t), r = i("tensor", s, e, t), n = i("lengths", s, e, t), o = t.getTensorArray(a.id);
      return o.split(n, r), [o.idTensor];
    }
    case "TensorArraySizeV3": {
      const a = i("tensorArrayId", s, e, t), r = t.getTensorArray(a.id);
      return [gt$1(r.size(), "int32")];
    }
    case "TensorArrayCloseV3": {
      const a = i("tensorArrayId", s, e, t), r = t.getTensorArray(a.id);
      return r.clearAndClose(), [r.idTensor];
    }
    case "TensorListSetItem": {
      const a = i("tensorListId", s, e, t), r = i("index", s, e, t), n = i("tensor", s, e, t), o = t.getTensorList(a.id);
      return o.setItem(r, n), [o.idTensor];
    }
    case "TensorListGetItem": {
      const a = i("tensorListId", s, e, t), r = i("index", s, e, t), n = i("elementShape", s, e, t), o = i("elementDType", s, e, t);
      return [t.getTensorList(a.id).getItem(r, n, o)];
    }
    case "TensorListScatterV2":
    case "TensorListScatter": {
      const a = i("indices", s, e, t), r = i("tensor", s, e, t), n = i("elementShape", s, e, t), o = i("numElements", s, e, t), u = vg(r, a, n, o);
      return t.addTensorList(u), [u.idTensor];
    }
    case "TensorListReserve":
    case "EmptyTensorList": {
      const a = i("elementShape", s, e, t), r = i("elementDType", s, e, t);
      let n;
      s.op === "TensorListReserve" ? n = "numElements" : n = "maxNumElements";
      const o = i(n, s, e, t), u = s.op === "TensorListReserve" ? -1 : o, l = Sg(a, r, o, u);
      return t.addTensorList(l), [l.idTensor];
    }
    case "TensorListGather": {
      const a = i("tensorListId", s, e, t), r = i("indices", s, e, t), n = i("elementShape", s, e, t), o = i("elementDType", s, e, t);
      return [t.getTensorList(a.id).gather(r, o, n)];
    }
    case "TensorListStack": {
      const a = i("tensorListId", s, e, t), r = i("elementShape", s, e, t), n = i("elementDType", s, e, t), o = i("numElements", s, e, t);
      return [t.getTensorList(a.id).stack(r, n, o)];
    }
    case "TensorListFromTensor": {
      const a = i("tensor", s, e, t), r = i("elementShape", s, e, t), n = i("elementDType", s, e, t), o = Tg(a, r, n);
      return t.addTensorList(o), [o.idTensor];
    }
    case "TensorListConcat":
    case "TensorListConcatV2": {
      const a = i("tensorListId", s, e, t), r = t.getTensorList(a.id), n = i("dtype", s, e, t), o = i("elementShape", s, e, t);
      return [r.concat(n, o)];
    }
    case "TensorListPushBack": {
      const a = i("tensorListId", s, e, t), r = i("tensor", s, e, t), n = t.getTensorList(a.id);
      return n.pushBack(r), [n.idTensor];
    }
    case "TensorListPopBack": {
      const a = i("tensorListId", s, e, t), r = i("elementShape", s, e, t), n = i("elementDType", s, e, t);
      return [t.getTensorList(a.id).popBack(r, n)];
    }
    case "TensorListSplit": {
      const a = i("tensor", s, e, t), r = i("elementShape", s, e, t), n = i("lengths", s, e, t), o = Og(a, n, r);
      return t.addTensorList(o), [o.idTensor];
    }
    case "TensorListLength": {
      const a = i("tensorListId", s, e, t), r = t.getTensorList(a.id);
      return [gt$1(r.size(), "int32")];
    }
    case "TensorListResize": {
      const a = i("tensorListId", s, e, t), r = i("size", s, e, t), o = t.getTensorList(a.id).resize(r);
      return t.addTensorList(o), [o.idTensor];
    }
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Rt(s, e, t) {
  const [a, r] = i("fusedOps", s, e, t), n = a === "biasadd", o = !n, u = r === "prelu", l = a === "fusedbatchnorm", p6 = i("numArgs", s, e, t);
  if (n) {
    if (u && p6 !== 2)
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
    if (!u && n && p6 !== 1)
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
  }
  if (l)
    throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  const m = i("strides", s, e, t), c = be(s, e, t), d = i("dataFormat", s, e, t).toUpperCase(), h6 = i("dilations", s, e, t);
  let [b6, f] = i("args", s, e, t);
  o && (f = b6, b6 = void 0);
  const y6 = i("leakyreluAlpha", s, e, t);
  return {
    stride: m,
    pad: c,
    dataFormat: d,
    dilations: h6,
    biasArg: b6,
    preluArg: f,
    activationFunc: r,
    leakyreluAlpha: y6
  };
}
const Ag = (s, e, t, a = A) => {
  switch (s.op) {
    case "Conv1D": {
      const r = i("stride", s, e, t), n = i("pad", s, e, t), o = i("dataFormat", s, e, t).toUpperCase(), u = i("dilation", s, e, t);
      return [a.conv1d(i("x", s, e, t), i("filter", s, e, t), r, n, o, u)];
    }
    case "Conv2D": {
      const r = i("strides", s, e, t), n = be(s, e, t), o = i("dataFormat", s, e, t).toUpperCase(), u = i("dilations", s, e, t);
      return [a.conv2d(i("x", s, e, t), i("filter", s, e, t), [r[1], r[2]], n, o, [u[1], u[2]])];
    }
    case "_FusedConv2D": {
      const { stride: r, pad: n, dataFormat: o, dilations: u, biasArg: l, preluArg: p6, activationFunc: m, leakyreluAlpha: c } = Rt(s, e, t);
      return [a.fused.conv2d({
        x: i("x", s, e, t),
        filter: i("filter", s, e, t),
        strides: [r[1], r[2]],
        pad: n,
        dataFormat: o,
        dilations: [u[1], u[2]],
        bias: l,
        activation: m,
        preluActivationWeights: p6,
        leakyreluAlpha: c
      })];
    }
    case "FusedDepthwiseConv2dNative": {
      const { stride: r, pad: n, dataFormat: o, dilations: u, biasArg: l, preluArg: p6, activationFunc: m, leakyreluAlpha: c } = Rt(s, e, t);
      return [a.fused.depthwiseConv2d({
        x: i("x", s, e, t),
        filter: i("filter", s, e, t),
        strides: [r[1], r[2]],
        pad: n,
        dataFormat: o,
        dilations: [u[1], u[2]],
        bias: l,
        activation: m,
        preluActivationWeights: p6,
        leakyreluAlpha: c
      })];
    }
    case "Conv2DBackpropInput":
    case "Conv2dTranspose": {
      const r = i("outputShape", s, e, t), n = i("strides", s, e, t), o = be(s, e, t);
      return [a.conv2dTranspose(i("x", s, e, t), i("filter", s, e, t), r, [n[1], n[2]], o)];
    }
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d": {
      const r = i("strides", s, e, t), n = be(s, e, t), o = i("dilations", s, e, t), u = i("dataFormat", s, e, t).toUpperCase();
      return [a.depthwiseConv2d(i("input", s, e, t), i("filter", s, e, t), [r[1], r[2]], n, u, [o[1], o[2]])];
    }
    case "Conv3D": {
      const r = i("strides", s, e, t), n = i("pad", s, e, t), o = i("dataFormat", s, e, t).toUpperCase(), u = i("dilations", s, e, t);
      return [a.conv3d(i("x", s, e, t), i("filter", s, e, t), [r[1], r[2], r[3]], n, o, [u[1], u[2], u[3]])];
    }
    case "AvgPool": {
      const r = i("strides", s, e, t), n = i("pad", s, e, t), o = i("kernelSize", s, e, t);
      return [a.avgPool(i("x", s, e, t), [o[1], o[2]], [r[1], r[2]], n)];
    }
    case "MaxPool": {
      const r = i("strides", s, e, t), n = i("pad", s, e, t), o = i("kernelSize", s, e, t);
      return [a.maxPool(i("x", s, e, t), [o[1], o[2]], [r[1], r[2]], n)];
    }
    case "MaxPoolWithArgmax": {
      const r = i("strides", s, e, t), n = i("pad", s, e, t), o = i("kernelSize", s, e, t), u = i("includeBatchInIndex", s, e, t), { result: l, indexes: p6 } = a.maxPoolWithArgmax(i("x", s, e, t), [o[1], o[2]], [r[1], r[2]], n, u);
      return [l, p6];
    }
    case "AvgPool3D": {
      const r = i("strides", s, e, t), n = i("pad", s, e, t), o = i("kernelSize", s, e, t);
      return [a.avgPool3d(i("x", s, e, t), [o[1], o[2], o[3]], [r[1], r[2], r[3]], n)];
    }
    case "MaxPool3D": {
      const r = i("strides", s, e, t), n = i("pad", s, e, t), o = i("kernelSize", s, e, t);
      return [a.maxPool3d(i("x", s, e, t), [o[1], o[2], o[3]], [r[1], r[2], r[3]], n)];
    }
    case "Dilation2D": {
      const r = i("strides", s, e, t), n = i("pad", s, e, t), o = i("dilations", s, e, t), u = r[1], l = r[2], p6 = o[1], m = o[2];
      return [a.dilation2d(
        i("x", s, e, t),
        i("filter", s, e, t),
        [u, l],
        n,
        [p6, m],
        "NHWC"
        /* dataFormat */
      )];
    }
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Eg = (s, e, t, a = A) => {
  switch (s.op) {
    case "Fill": {
      const r = i("shape", s, e, t), n = i("dtype", s, e, t), o = i("value", s, e, t);
      return [a.fill(r, o, n)];
    }
    case "LinSpace": {
      const r = i("start", s, e, t), n = i("stop", s, e, t), o = i("num", s, e, t);
      return [a.linspace(r, n, o)];
    }
    case "Multinomial": {
      const r = i("logits", s, e, t), n = i("numSamples", s, e, t), o = i("seed", s, e, t);
      return [a.multinomial(r, n, o)];
    }
    case "OneHot": {
      const r = i("indices", s, e, t), n = i("depth", s, e, t), o = i("onValue", s, e, t), u = i("offValue", s, e, t), l = i("dtype", s, e, t);
      return [a.oneHot(r, n, o, u, l)];
    }
    case "Ones":
      return [a.ones(i("shape", s, e, t), i("dtype", s, e, t))];
    case "OnesLike":
      return [a.onesLike(i("x", s, e, t))];
    case "RandomStandardNormal":
      return [a.randomStandardNormal(i("shape", s, e, t), i("dtype", s, e, t), i("seed", s, e, t))];
    case "RandomUniform":
      return [a.randomUniform(
        // tslint:disable-next-line:no-any
        i("shape", s, e, t),
        i("minval", s, e, t),
        i("maxval", s, e, t),
        i("dtype", s, e, t)
      )];
    case "Range": {
      const r = i("start", s, e, t), n = i("stop", s, e, t), o = i("step", s, e, t);
      return [a.range(r, n, o, i("dtype", s, e, t))];
    }
    case "TruncatedNormal": {
      const r = i("shape", s, e, t), n = i("mean", s, e, t), o = i("stdDev", s, e, t), u = i("seed", s, e, t);
      return [a.truncatedNormal(r, n, o, i("dtype", s, e, t), u)];
    }
    case "Zeros":
      return [a.zeros(i("shape", s, e, t), i("dtype", s, e, t))];
    case "ZerosLike":
      return [a.zerosLike(i("x", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ze(s, e, t) {
  const a = i("boxes", s, e, t), r = i("scores", s, e, t), n = i("maxOutputSize", s, e, t), o = i("iouThreshold", s, e, t), u = i("scoreThreshold", s, e, t), l = i("softNmsSigma", s, e, t);
  return {
    boxes: a,
    scores: r,
    maxOutputSize: n,
    iouThreshold: o,
    scoreThreshold: u,
    softNmsSigma: l
  };
}
const kg = async (s, e, t, a, r = A) => {
  switch (s.op) {
    case "NonMaxSuppressionV5": {
      const { boxes: n, scores: o, maxOutputSize: u, iouThreshold: l, scoreThreshold: p6, softNmsSigma: m } = ze(s, e, t), c = await r.image.nonMaxSuppressionWithScoreAsync(n, o, u, l, p6, m);
      return [c.selectedIndices, c.selectedScores];
    }
    case "NonMaxSuppressionV4": {
      const { boxes: n, scores: o, maxOutputSize: u, iouThreshold: l, scoreThreshold: p6 } = ze(s, e, t), m = i("padToMaxOutputSize", s, e, t), c = await r.image.nonMaxSuppressionPaddedAsync(n, o, u, l, p6, m);
      return [c.selectedIndices, c.validOutputs];
    }
    case "NonMaxSuppressionV3":
    case "NonMaxSuppressionV2": {
      const { boxes: n, scores: o, maxOutputSize: u, iouThreshold: l, scoreThreshold: p6 } = ze(s, e, t);
      return [await r.image.nonMaxSuppressionAsync(n, o, u, l, p6)];
    }
    case "Where": {
      const n = r.cast(i("condition", s, e, t), "bool"), o = [await r.whereAsync(n)];
      return n.dispose(), o;
    }
    case "ListDiff":
      return r.setdiff1dAsync(i("x", s, e, t), i("y", s, e, t));
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Ig = (s, e, t, a = A) => {
  switch (s.op) {
    case "LowerBound": {
      const r = i("sortedSequence", s, e, t), n = i("values", s, e, t);
      return [a.lowerBound(r, n)];
    }
    case "TopKV2": {
      const r = i("x", s, e, t), n = i("k", s, e, t), o = i("sorted", s, e, t), u = a.topk(r, n, o);
      return [u.values, u.indices];
    }
    case "UpperBound": {
      const r = i("sortedSequence", s, e, t), n = i("values", s, e, t);
      return [a.upperBound(r, n)];
    }
    case "Unique": {
      const r = i("x", s, e, t), n = a.unique(r);
      return [n.values, n.indices];
    }
    case "UniqueV2": {
      const r = i("x", s, e, t), n = i("axis", s, e, t), o = a.unique(r, n);
      return [o.values, o.indices];
    }
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Dg = (s, e, t, a = A) => {
  switch (s.op) {
    case "Const":
      return e[s.name];
    case "PlaceholderWithDefault":
      const r = i("default", s, e, t);
      return [k6(s.name, e, t) || r];
    case "Placeholder":
      return [k6(s.name, e, t)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars": {
      const m = i("x", s, e, t);
      return [H(m)];
    }
    case "IdentityN":
      return i("x", s, e, t).map((m) => H(m));
    case "Snapshot":
      const n = i("x", s, e, t);
      return [H(n)];
    case "Shape":
      return [a.tensor1d(i("x", s, e, t).shape, "int32")];
    case "ShapeN":
      return i("x", s, e, t).map((m) => a.tensor1d(m.shape));
    case "Size":
      return [a.scalar(i("x", s, e, t).size, "int32")];
    case "Rank":
      return [a.scalar(i("x", s, e, t).rank, "int32")];
    case "NoOp":
      return [a.scalar(1)];
    case "Print":
      const o = i("x", s, e, t), u = i("data", s, e, t), l = i("message", s, e, t), p6 = i("summarize", s, e, t);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(l);
      for (let m = 0; m < u.length; m++)
        console.log(Array.prototype.slice.call(u[m].dataSync()).slice(0, p6));
      return [o];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class $g {
  /**
   * Constructor of HashTable. Creates a hash table.
   *
   * @param keyDType `dtype` of the table keys.
   * @param valueDType `dtype` of the table values.
   */
  constructor(e, t) {
    this.keyDType = e, this.valueDType = t, this.handle = gt$1(0), this.tensorMap = /* @__PURE__ */ new Map(), cn$1(this.handle);
  }
  get id() {
    return this.handle.id;
  }
  /**
   * Dispose the tensors and handle and clear the hashtable.
   */
  clearAndClose() {
    this.tensorMap.forEach((e) => e.dispose()), this.tensorMap.clear(), this.handle.dispose();
  }
  /**
   * The number of items in the hash table.
   */
  size() {
    return this.tensorMap.size;
  }
  /**
   * The number of items in the hash table as a rank-0 tensor.
   */
  tensorSize() {
    return gt$1(this.size(), "int32");
  }
  /**
   * Replaces the contents of the table with the specified keys and values.
   * @param keys Keys to store in the hashtable.
   * @param values Values to store in the hashtable.
   */
  async import(e, t) {
    this.checkKeyAndValueTensor(e, t);
    const a = await e.data();
    return this.tensorMap.forEach((r) => r.dispose()), this.tensorMap.clear(), D(() => {
      const r = To(t), n = a.length, o = r.length;
      v(n === o, () => `The number of elements doesn't match, keys has ${n} elements, the values has ${o} elements.`);
      for (let u = 0; u < n; u++) {
        const l = a[u], p6 = r[u];
        cn$1(p6), this.tensorMap.set(l, p6);
      }
      return this.handle;
    });
  }
  /**
   * Looks up keys in a hash table, outputs the corresponding values.
   *
   * Performs batch lookups, for every element in the key tensor, `find`
   * stacks the corresponding value into the return tensor.
   *
   * If an element is not present in the table, the given `defaultValue` is
   * used.
   *
   * @param keys Keys to look up. Must have the same type as the keys of the
   *     table.
   * @param defaultValue The scalar `defaultValue` is the value output for keys
   *     not present in the table. It must also be of the same type as the
   *     table values.
   */
  async find(e, t) {
    this.checkKeyAndValueTensor(e, t);
    const a = await e.data();
    return D(() => {
      const r = [];
      for (let n = 0; n < a.length; n++) {
        const o = a[n], u = this.findWithDefault(o, t);
        r.push(u);
      }
      return os(r);
    });
  }
  // tslint:disable-next-line: no-any
  findWithDefault(e, t) {
    const a = this.tensorMap.get(e);
    return a ?? t;
  }
  checkKeyAndValueTensor(e, t) {
    if (e.dtype !== this.keyDType)
      throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);
    if (t.dtype !== this.valueDType)
      throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Cg = async (s, e, t, a) => {
  switch (s.op) {
    case "HashTable":
    case "HashTableV2": {
      const r = a.getHashTableHandleByName(s.name);
      if (r != null)
        return [r];
      {
        const n = i("keyDType", s, e, t), o = i("valueDType", s, e, t), u = new $g(n, o);
        return a.addHashTable(s.name, u), [u.handle];
      }
    }
    case "InitializeTable":
    case "InitializeTableV2":
    case "LookupTableImport":
    case "LookupTableImportV2": {
      const r = i("tableHandle", s, e, t, a), n = i("keys", s, e, t), o = i("values", s, e, t);
      return [await a.getHashTableById(r.id).import(n, o)];
    }
    case "LookupTableFind":
    case "LookupTableFindV2": {
      const r = i("tableHandle", s, e, t, a), n = i("keys", s, e, t), o = i("defaultValue", s, e, t);
      return [await a.getHashTableById(r.id).find(n, o)];
    }
    case "LookupTableSize":
    case "LookupTableSizeV2": {
      const r = i("tableHandle", s, e, t, a);
      return [a.getHashTableById(r.id).tensorSize()];
    }
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const zg = (s, e, t, a = A) => {
  switch (s.op) {
    case "ResizeBilinear": {
      const r = i("images", s, e, t), n = i("size", s, e, t), o = i("alignCorners", s, e, t), u = i("halfPixelCenters", s, e, t);
      return [a.image.resizeBilinear(r, [n[0], n[1]], o, u)];
    }
    case "ResizeNearestNeighbor": {
      const r = i("images", s, e, t), n = i("size", s, e, t), o = i("alignCorners", s, e, t), u = i("halfPixelCenters", s, e, t);
      return [a.image.resizeNearestNeighbor(r, [n[0], n[1]], o, u)];
    }
    case "CropAndResize": {
      const r = i("image", s, e, t), n = i("boxes", s, e, t), o = i("boxInd", s, e, t), u = i("cropSize", s, e, t), l = i("method", s, e, t), p6 = i("extrapolationValue", s, e, t);
      return [a.image.cropAndResize(r, n, o, u, l, p6)];
    }
    case "ImageProjectiveTransformV3": {
      const r = i("images", s, e, t), n = i("transforms", s, e, t), o = i("outputShape", s, e, t), u = i("fillValue", s, e, t), l = i("interpolation", s, e, t), p6 = i("fillMode", s, e, t);
      return [a.image.transform(r, n, l.toLowerCase(), p6.toLowerCase(), u, o)];
    }
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const xg = (s, e, t, a = A) => {
  switch (s.op) {
    case "Equal":
      return [a.equal(i("a", s, e, t), i("b", s, e, t))];
    case "NotEqual":
      return [a.notEqual(i("a", s, e, t), i("b", s, e, t))];
    case "Greater":
      return [a.greater(i("a", s, e, t), i("b", s, e, t))];
    case "GreaterEqual":
      return [a.greaterEqual(i("a", s, e, t), i("b", s, e, t))];
    case "Less":
      return [a.less(i("a", s, e, t), i("b", s, e, t))];
    case "LessEqual":
      return [a.lessEqual(i("a", s, e, t), i("b", s, e, t))];
    case "LogicalAnd":
      return [a.logicalAnd(i("a", s, e, t), i("b", s, e, t))];
    case "LogicalNot":
      return [a.logicalNot(i("a", s, e, t))];
    case "LogicalOr":
      return [a.logicalOr(i("a", s, e, t), i("b", s, e, t))];
    case "Select":
    case "SelectV2":
      return [a.where(i("condition", s, e, t), i("a", s, e, t), i("b", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Lg = (s, e, t, a = A) => {
  switch (s.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [a.matMul(i("a", s, e, t), i("b", s, e, t), i("transposeA", s, e, t), i("transposeB", s, e, t))];
    case "Einsum":
      return [a.einsum(i("equation", s, e, t), ...i("tensors", s, e, t))];
    case "Transpose":
      return [a.transpose(i("x", s, e, t), i("perm", s, e, t))];
    case "_FusedMatMul":
      const [r, n] = i("fusedOps", s, e, t), o = r === "biasadd", u = n === "prelu", l = i("numArgs", s, e, t), p6 = i("leakyreluAlpha", s, e, t);
      if (o) {
        if (u && l !== 2)
          throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!u && l !== 1)
          throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
      }
      const [m, c] = i("args", s, e, t);
      return [a.fused.matMul({
        a: i("a", s, e, t),
        b: i("b", s, e, t),
        transposeA: i("transposeA", s, e, t),
        transposeB: i("transposeB", s, e, t),
        bias: m,
        activation: n,
        preluActivationWeights: c,
        leakyreluAlpha: p6
      })];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Vg = (s, e, t, a = A) => {
  switch (s.op) {
    case "EuclideanNorm":
      return [a.euclideanNorm(i("x", s, e, t), i("axis", s, e, t), i("keepDims", s, e, t))];
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
      return [a.batchNorm(i("x", s, e, t), i("mean", s, e, t), i("variance", s, e, t), i("offset", s, e, t), i("scale", s, e, t), i("epsilon", s, e, t))];
    case "FusedBatchNormV3":
      return [a.batchNorm(i("x", s, e, t), i("mean", s, e, t), i("variance", s, e, t), i("offset", s, e, t), i("scale", s, e, t), i("epsilon", s, e, t))];
    case "LRN":
      return [a.localResponseNormalization(i("x", s, e, t), i("radius", s, e, t), i("bias", s, e, t), i("alpha", s, e, t), i("beta", s, e, t))];
    case "Softmax":
      return [a.softmax(i("x", s, e, t))];
    case "LogSoftmax":
      return [a.logSoftmax(i("x", s, e, t))];
    case "SparseToDense":
      return [a.sparseToDense(i("sparseIndices", s, e, t), i("outputShape", s, e, t), i("sparseValues", s, e, t), i("defaultValue", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Fg = (s, e, t, a = A) => {
  switch (s.op) {
    case "RaggedGather": {
      const { outputNestedSplits: r, outputDenseValues: n } = a.raggedGather(i("paramsNestedSplits", s, e, t), i("paramsDenseValues", s, e, t), i("indices", s, e, t), i("outputRaggedRank", s, e, t));
      return r.concat(n);
    }
    case "RaggedRange": {
      const { rtNestedSplits: r, rtDenseValues: n } = a.raggedRange(i("starts", s, e, t), i("limits", s, e, t), i("splits", s, e, t));
      return [r, n];
    }
    case "RaggedTensorToTensor":
      return [a.raggedTensorToTensor(i("shape", s, e, t), i("values", s, e, t), i("defaultValue", s, e, t), i("rowPartitionTensors", s, e, t), i("rowPartitionTypes", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Pg = (s, e, t, a = A) => {
  switch (s.op) {
    case "Max": {
      const u = i("axis", s, e, t), l = i("keepDims", s, e, t);
      return [a.max(i("x", s, e, t), u, l)];
    }
    case "Mean": {
      const u = i("axis", s, e, t), l = i("keepDims", s, e, t);
      return [a.mean(i("x", s, e, t), u, l)];
    }
    case "Min": {
      const u = i("axis", s, e, t), l = i("keepDims", s, e, t);
      return [a.min(i("x", s, e, t), u, l)];
    }
    case "Sum": {
      const u = i("axis", s, e, t), l = i("keepDims", s, e, t);
      return [a.sum(i("x", s, e, t), u, l)];
    }
    case "All": {
      const u = i("axis", s, e, t), l = i("keepDims", s, e, t);
      return [a.all(i("x", s, e, t), u, l)];
    }
    case "Any": {
      const u = i("axis", s, e, t), l = i("keepDims", s, e, t);
      return [a.any(i("x", s, e, t), u, l)];
    }
    case "ArgMax": {
      const u = i("axis", s, e, t);
      return [a.argMax(i("x", s, e, t), u)];
    }
    case "ArgMin": {
      const u = i("axis", s, e, t);
      return [a.argMin(i("x", s, e, t), u)];
    }
    case "Prod": {
      const u = i("axis", s, e, t), l = i("keepDims", s, e, t);
      return [a.prod(i("x", s, e, t), u, l)];
    }
    case "Cumprod": {
      const u = i("axis", s, e, t), l = i("exclusive", s, e, t), p6 = i("reverse", s, e, t);
      return [a.cumprod(i("x", s, e, t), u, l, p6)];
    }
    case "Cumsum": {
      const u = i("axis", s, e, t), l = i("exclusive", s, e, t), p6 = i("reverse", s, e, t);
      return [a.cumsum(i("x", s, e, t), u, l, p6)];
    }
    case "Bincount":
      const r = i("x", s, e, t), n = i("weights", s, e, t), o = i("size", s, e, t);
      return [a.bincount(r, n, o)];
    case "DenseBincount": {
      const u = i("x", s, e, t), l = i("weights", s, e, t), p6 = i("size", s, e, t), m = i("binaryOutput", s, e, t);
      return [a.denseBincount(u, l, p6, m)];
    }
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Rg = (s, e, t, a = A) => {
  switch (s.op) {
    case "ConcatV2":
    case "Concat": {
      const r = i("n", s, e, t), n = i("axis", s, e, t);
      let o = i("tensors", s, e, t);
      return o = o.slice(0, r), [a.concat(o, n)];
    }
    case "Gather": {
      const r = i("x", s, e, t), n = i("indices", s, e, t);
      return [a.gather(r, a.cast(n, "int32"), 0)];
    }
    case "GatherV2": {
      const r = i("axis", s, e, t), n = i("batchDims", s, e, t), o = i("x", s, e, t), u = i("indices", s, e, t);
      return [a.gather(o, a.cast(u, "int32"), r, n)];
    }
    case "Reverse": {
      const r = i("dims", s, e, t), n = [];
      for (let u = 0; u < r.length; u++)
        r[u] && n.push(u);
      const o = i("x", s, e, t);
      return [a.reverse(o, n)];
    }
    case "ReverseV2": {
      const r = i("axis", s, e, t), n = i("x", s, e, t);
      return [a.reverse(n, r)];
    }
    case "Slice": {
      const r = i("begin", s, e, t), n = i("size", s, e, t);
      return [a.slice(i("x", s, e, t), r, n)];
    }
    case "StridedSlice": {
      const r = i("begin", s, e, t), n = i("end", s, e, t), o = i("strides", s, e, t), u = i("beginMask", s, e, t), l = i("endMask", s, e, t), p6 = i("ellipsisMask", s, e, t), m = i("newAxisMask", s, e, t), c = i("shrinkAxisMask", s, e, t), d = i("x", s, e, t);
      return [a.stridedSlice(d, r, n, o, u, l, p6, m, c)];
    }
    case "Pack":
      return D(() => {
        const r = i("axis", s, e, t), n = i("tensors", s, e, t), o = n[0].shape, u = a.squeeze(n[0]).shape, l = n.map((p6) => {
          const m = Rt$1(p6.shape, o);
          if (!m && !Rt$1(a.squeeze(p6).shape, u))
            throw new Error("the input tensors shape does not match");
          return m ? p6 : a.reshape(p6, o);
        });
        return [a.stack(l, r)];
      });
    case "Unpack": {
      const r = i("axis", s, e, t), n = i("tensor", s, e, t);
      return a.unstack(n, r);
    }
    case "Tile": {
      const r = i("reps", s, e, t);
      return [a.tile(i("x", s, e, t), r)];
    }
    case "Split":
    case "SplitV": {
      const r = i("axis", s, e, t), n = i("numOrSizeSplits", s, e, t), o = i("x", s, e, t);
      return a.split(o, n, r);
    }
    case "ScatterNd": {
      const r = i("indices", s, e, t), n = i("values", s, e, t), o = i("shape", s, e, t);
      return [a.scatterND(r, n, o)];
    }
    case "GatherNd": {
      const r = i("x", s, e, t), n = i("indices", s, e, t);
      return [a.gatherND(r, n)];
    }
    case "SparseToDense": {
      const r = i("sparseIndices", s, e, t), n = i("outputShape", s, e, t), o = i("sparseValues", s, e, t), u = i("defaultValue", s, e, t);
      return [a.sparseToDense(r, o, n, o.dtype === u.dtype ? u : a.cast(u, o.dtype))];
    }
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const jg = (s, e, t, a = A) => {
  switch (s.op) {
    case "SparseFillEmptyRows": {
      const { outputIndices: r, outputValues: n, emptyRowIndicator: o, reverseIndexMap: u } = a.sparse.sparseFillEmptyRows(i("indices", s, e, t), i("values", s, e, t), i("denseShape", s, e, t), i("defaultValue", s, e, t));
      return [
        r,
        n,
        o,
        u
      ];
    }
    case "SparseReshape": {
      const { outputIndices: r, outputShape: n } = a.sparse.sparseReshape(i("inputIndices", s, e, t), i("inputShape", s, e, t), i("newShape", s, e, t));
      return [r, n];
    }
    case "SparseSegmentMean":
      return [a.sparse.sparseSegmentMean(i("data", s, e, t), i("indices", s, e, t), i("segmentIds", s, e, t))];
    case "SparseSegmentSum":
      return [a.sparse.sparseSegmentSum(i("data", s, e, t), i("indices", s, e, t), i("segmentIds", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Bg = (s, e, t, a = A) => {
  switch (s.op) {
    case "FFT":
      return [a.fft(i("x", s, e, t))];
    case "IFFT":
      return [a.ifft(i("x", s, e, t))];
    case "RFFT":
      return [a.rfft(i("x", s, e, t))];
    case "IRFFT":
      return [a.irfft(i("x", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Hg = (s, e, t, a = A) => {
  switch (s.op) {
    case "StringNGrams": {
      const { nGrams: r, nGramsSplits: n } = a.string.stringNGrams(i("data", s, e, t), i("dataSplits", s, e, t), i("separator", s, e, t), i("nGramWidths", s, e, t), i("leftPad", s, e, t), i("rightPad", s, e, t), i("padWidth", s, e, t), i("preserveShortSequences", s, e, t));
      return [r, n];
    }
    case "StringSplit": {
      const { indices: r, values: n, shape: o } = a.string.stringSplit(i("input", s, e, t), i("delimiter", s, e, t), i("skipEmpty", s, e, t));
      return [r, n, o];
    }
    case "StringToHashBucketFast":
      return [a.string.stringToHashBucketFast(i("input", s, e, t), i("numBuckets", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Wg = (s, e, t, a = A) => {
  switch (s.op) {
    case "Cast":
      return [a.cast(i("x", s, e, t), i("dtype", s, e, t))];
    case "ExpandDims": {
      const r = i("axis", s, e, t);
      return [a.expandDims(i("x", s, e, t), r)];
    }
    case "Squeeze": {
      const r = i("axis", s, e, t);
      return [a.squeeze(i("x", s, e, t), r)];
    }
    case "Reshape":
      return [a.reshape(i("x", s, e, t), i("shape", s, e, t))];
    case "MirrorPad":
      return [a.mirrorPad(i("x", s, e, t), i("padding", s, e, t), i("mode", s, e, t))];
    case "PadV2":
    case "Pad":
      return [a.pad(i("x", s, e, t), i("padding", s, e, t), i("constantValue", s, e, t))];
    case "SpaceToBatchND": {
      const r = i("blockShape", s, e, t), n = i("paddings", s, e, t);
      return [a.spaceToBatchND(i("x", s, e, t), r, n)];
    }
    case "BatchToSpaceND": {
      const r = i("blockShape", s, e, t), n = i("crops", s, e, t);
      return [a.batchToSpaceND(i("x", s, e, t), r, n)];
    }
    case "DepthToSpace": {
      const r = i("blockSize", s, e, t), n = i("dataFormat", s, e, t).toUpperCase();
      return [a.depthToSpace(i("x", s, e, t), r, n)];
    }
    case "BroadcastTo":
      return [a.broadcastTo(i("x", s, e, t), i("shape", s, e, t))];
    case "BroadcastArgs":
      return [a.broadcastArgs(i("s0", s, e, t), i("s1", s, e, t))];
    default:
      throw TypeError(`Node type ${s.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function jt(s, e, t, a, r = D) {
  const n = ((o, u, l) => {
    switch (o.category) {
      case "arithmetic":
        return r(() => bg2(o, u, l));
      case "basic_math":
        return r(() => Ng(o, u, l));
      case "control":
        return _g(o, u, l);
      case "convolution":
        return r(() => Ag(o, u, l));
      case "creation":
        return r(() => Eg(o, u, l));
      case "dynamic":
        return kg(o, u, l);
      case "evaluation":
        return r(() => Ig(o, u, l));
      case "image":
        return r(() => zg(o, u, l));
      case "graph":
        return r(() => Dg(o, u, l));
      case "logical":
        return r(() => xg(o, u, l));
      case "matrices":
        return r(() => Lg(o, u, l));
      case "normalization":
        return r(() => Vg(o, u, l));
      case "ragged":
        return r(() => Fg(o, u, l));
      case "reduction":
        return r(() => Pg(o, u, l));
      case "slice_join":
        return r(() => Rg(o, u, l));
      case "sparse":
        return r(() => jg(o, u, l));
      case "spectral":
        return r(() => Bg(o, u, l));
      case "string":
        return r(() => Hg(o, u, l));
      case "transformation":
        return r(() => Wg(o, u, l));
      case "hash_table":
        return Cg(o, u, l, a);
      case "custom":
        const p6 = Jn(o.op);
        if (p6 && p6.customExecutor)
          return p6.customExecutor(new gg(o, u, l));
        throw TypeError(`Custom op ${o.op} is not registered.`);
      default:
        throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
    }
  })(s, e, t);
  return ui$1(n) ? n.then((o) => [].concat(o)) : [].concat(n);
}
class Bt {
  constructor(e = {}, t = {}, a = {}, r = {}) {
    this.weightMap = e, this.tensorArrayMap = t, this.tensorListMap = a, this.functionMap = r, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }
  newFrame(e, t) {
    return { id: e, frameName: t, iterationId: 0 };
  }
  /**
   * Set the current context
   * @param contexts: ExecutionContextInfo[] the current path of execution
   * frames
   */
  set currentContext(e) {
    this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());
  }
  get currentContext() {
    return this.contexts;
  }
  /**
   * Returns the current context in string format.
   */
  get currentContextId() {
    return this._currentContextIds[0];
  }
  /**
   * Returns the current context and all parent contexts in string format.
   * This allow access to the nodes in the current and parent frames.
   */
  get currentContextIds() {
    return this._currentContextIds;
  }
  generateCurrentContextIds() {
    const e = [];
    for (let t = 0; t < this.contexts.length - 1; t++) {
      const a = this.contexts.slice(0, this.contexts.length - t);
      e.push(this.contextIdforContexts(a));
    }
    e.push(""), this._currentContextIds = e;
  }
  contextIdforContexts(e) {
    return e ? e.map((t) => t.id === 0 && t.iterationId === 0 ? "" : `${t.frameName}-${t.iterationId}`).join("/") : "";
  }
  /**
   * Enter a new frame, a new context is pushed on the current context list.
   * @param frameId new frame id
   */
  enterFrame(e) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }
  /**
   * Exit the current frame, the last context is removed from the current
   * context list.
   */
  exitFrame() {
    if (this.contexts && this.contexts.length > 1)
      this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
    else
      throw new Error("Cannot exit frame, the context is empty");
  }
  /**
   * Enter the next iteration of a loop, the iteration id of last context is
   * increased.
   */
  nextIteration() {
    if (this.contexts && this.contexts.length > 0) {
      this.contexts = this.contexts.slice(), this.lastId++;
      const e = Object.assign({}, this.contexts[this.contexts.length - 1]);
      e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    } else
      throw new Error("Cannot increase frame iteration, the context is empty");
  }
  getWeight(e) {
    return this.weightMap[e];
  }
  addTensorArray(e) {
    this.tensorArrayMap[e.id] = e;
  }
  getTensorArray(e) {
    return this.tensorArrayMap[e];
  }
  addTensorList(e) {
    this.tensorListMap[e.id] = e;
  }
  getTensorList(e) {
    return this.tensorListMap[e];
  }
  dispose(e) {
    for (const t in this.tensorArrayMap)
      this.tensorArrayMap[t].clearAndClose(e);
    for (const t in this.tensorListMap)
      this.tensorListMap[t].clearAndClose(e);
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function Ht(s, e, t, a) {
  const r = /* @__PURE__ */ new Set(), n = [];
  let o = null, u = null;
  const l = /* @__PURE__ */ new Set(), p6 = Object.keys(s).map((d) => $(d)[0]);
  let m = [];
  a != null && (m = a.map((d) => $(d.name)[0]));
  const c = [...e];
  for (; c.length > 0; ) {
    const d = c.pop();
    if ((Zn(d) || Jg(d) || Qg(d)) && o == null && (o = d, u = o.children.map((h6) => h6.name).filter((h6) => r.has(h6))), r.add(d.name), t[d.name] == null && p6.indexOf(d.name) === -1 && m.indexOf(d.name) === -1) {
      if (d.inputs.length === 0) {
        n.push(d.name);
        continue;
      }
      d.inputs.forEach((h6) => {
        l.has(h6.name) || (l.add(h6.name), c.push(h6));
      });
    }
  }
  return { inputs: s, outputs: e, usedNodes: r, missingInputs: n, dynamicNode: o, syncInputs: u };
}
function qg(s, e, t) {
  const { usedNodes: a, inputs: r } = t, n = [], o = Object.keys(r).map((m) => $(m)[0]).map((m) => s.nodes[m]), u = s.initNodes;
  o.forEach((m) => {
    a.has(m.name) && n.push(m);
  }), s.weights.forEach((m) => {
    a.has(m.name) && n.push(m);
  }), u != null && u.forEach((m) => {
    a.has(m.name) && n.push(m);
  });
  const l = /* @__PURE__ */ new Set(), p6 = [];
  for (; n.length > 0; ) {
    const m = n.pop();
    l.add(m.name), e[m.name] || p6.push(m), m.children.forEach((c) => {
      !l.has(c.name) && a.has(c.name) && c.inputs.every((d) => l.has(d.name)) && n.push(c);
    });
  }
  return p6;
}
const Ug = [
  "Switch",
  "Merge",
  "Enter",
  "Exit",
  "NextIteration",
  "StatelessIf",
  "StatelessWhile",
  "if",
  "While"
], Gg = [
  "NonMaxSuppressionV2",
  "NonMaxSuppressionV3",
  "NonMaxSuppressionV5",
  "Where"
], Kg = [
  "HashTable",
  "HashTableV2",
  "LookupTableImport",
  "LookupTableImportV2",
  "LookupTableFind",
  "LookupTableFindV2",
  "LookupTableSize",
  "LookupTableSizeV2"
];
function Zn(s) {
  return Ug.indexOf(s.op) >= 0;
}
function Jg(s) {
  return Gg.indexOf(s.op) >= 0;
}
function Qg(s) {
  return Kg.indexOf(s.op) >= 0;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Ee {
  /**
   *
   * @param graph Graph the model or function graph to be executed.
   * @param parent When building function exector you need to set the parent
   * executor. Since the weights and function executor maps are set at parant
   * level, that function executor can access the function maps and weight maps
   * through the parent.
   */
  constructor(e, t) {
    this.graph = e, this.parent = t, this.compiledMap = /* @__PURE__ */ new Map(), this._weightMap = {}, this.SEPERATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this.keepIntermediateTensors = false, this._outputs = e.outputs, this._inputs = e.inputs, this._initNodes = e.initNodes, this._signature = e.signature, this._functions = e.functions, e.functions != null && Object.keys(e.functions).forEach((a) => {
      this._functionExecutorMap[a] = new Ee(e.functions[a], this);
    });
  }
  get weightIds() {
    return this.parent ? this.parent.weightIds : this._weightIds;
  }
  get functionExecutorMap() {
    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
  }
  get weightMap() {
    return this.parent ? this.parent.weightMap : this._weightMap;
  }
  set weightMap(e) {
    const t = Object.keys(e).map((a) => e[a].map((r) => r.id));
    this._weightIds = [].concat(...t), this._weightMap = e;
  }
  /**
   * Set `ResourceManager` shared by executors of a model.
   * @param resourceManager: `ResourceManager` of the `GraphModel`.
   */
  set resourceManager(e) {
    this._resourceManager = e;
  }
  get inputs() {
    return this._inputs.map((e) => ({
      name: e.name,
      shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
      dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
    }));
  }
  get outputs() {
    return this._outputs.map((e) => ({
      name: e.name,
      shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
      dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
    }));
  }
  get inputNodes() {
    return this._inputs.map((e) => e.signatureKey || e.name);
  }
  get outputNodes() {
    return this._outputs.map((e) => {
      const t = e.signatureKey || e.name;
      return e.defaultOutput ? `${t}:${e.defaultOutput}` : t;
    });
  }
  get functions() {
    return Object.keys(this._functions).reduce((e, t) => (e[t] = this._functions[t].signature, e), {});
  }
  getCompilationKey(e, t) {
    const a = e.map((n) => n.name).sort(), r = t.map((n) => n.name).sort();
    return a.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR);
  }
  /**
   * Compiles the inference graph and returns the minimal set of nodes that are
   * required for execution, in the correct execution order.
   */
  compile(e, t) {
    const a = Ht(e, t, this.weightMap, this._initNodes), { missingInputs: r, dynamicNode: n, syncInputs: o } = a;
    if (n != null)
      throw new Error(`This execution contains the node '${n.name}', which has the dynamic op '${n.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);
    if (r.length > 0) {
      const u = t.map((p6) => p6.name), l = Object.keys(e);
      throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`);
    }
    return qg(this.graph, this.weightMap, a);
  }
  cloneAndKeepTensor(e) {
    if (e == null)
      return null;
    const t = e.clone();
    return cn$1(t), t;
  }
  cloneTensorList(e) {
    return e ? e.map((a) => this.cloneAndKeepTensor(a)) : null;
  }
  cloneTensorMap(e) {
    return Object.fromEntries(Object.entries(e).map(([t, a]) => [t, this.cloneTensorList(a)]));
  }
  /**
   * Executes the inference for given input tensors.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs Optional. output node name from the Tensorflow model, if
   * no outputs are specified, the default outputs of the model would be used.
   * You can inspect intermediate nodes of the model by adding them to the
   * outputs array.
   */
  execute(e, t) {
    this.disposeIntermediateTensors(), e = this.mapInputs(e);
    const a = Object.keys(e).sort();
    this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t);
    const r = a.map((c) => this.graph.nodes[$(c)[0]]), n = t.map((c) => $(c)[0]);
    let o = n.map((c) => this.graph.nodes[c]);
    o.length === 0 && (o = this._outputs);
    const u = this.getCompilationKey(r, o);
    let l = this.compiledMap.get(u);
    l == null && (l = this.compile(e, o), this.compiledMap.set(u, l));
    try {
      this.keepIntermediateTensors = F().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (c) {
      this.keepIntermediateTensors = false, console.warn(c.message);
    }
    const p6 = {}, m = {};
    return D(() => {
      const c = new Bt(this.weightMap, p6, m, this.functionExecutorMap), d = Object.assign({}, this.weightMap);
      this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap)), Object.keys(e).forEach((f) => {
        const [y6, T6] = $(f), _6 = [];
        _6[T6] = e[f], d[y6] = _6, this.keepIntermediateTensors && (this.clonedTensorsMap[y6] = this.cloneTensorList(_6));
      });
      const h6 = this.getFrozenTensorIds(d), b6 = {};
      for (let f = 0; f < l.length; f++) {
        const y6 = l[f];
        if (!d[y6.name]) {
          const T6 = jt(y6, d, c, this._resourceManager);
          if (ui$1(T6))
            throw new Error(`The execution of the op '${y6.op}' returned a promise. Please use model.executeAsync() instead.`);
          d[y6.name] = T6, this.keepIntermediateTensors && (this.clonedTensorsMap[y6.name] = this.cloneTensorList(T6)), this.checkTensorForDisposal(y6.name, y6, d, c, h6, n, b6);
        }
      }
      return this.parent == null && c.dispose(h6), t.map((f) => k6(f, d, c));
    });
  }
  getFrozenTensorIds(e) {
    const t = [].concat.apply([], Object.keys(e).map((a) => e[a]).map((a) => a.map((r) => r.id)));
    return new Set(t);
  }
  checkTensorForDisposal(e, t, a, r, n, o, u) {
    t.category === "control" || o.indexOf(e) !== -1 || (a[e].forEach((l) => {
      l != null && (u[l.id] = (u[l.id] || 0) + t.children.length);
    }), t.inputs.forEach((l) => {
      if (l.category !== "control") {
        const p6 = $y2(l.name, a, r);
        p6 != null && p6.forEach((m) => {
          if (m && !m.kept && !n.has(m.id)) {
            const c = u[m.id];
            c === 1 ? (m.dispose(), delete u[m.id]) : c != null && u[m.id]--;
          }
        });
      }
    }));
  }
  /**
   * Executes the inference for given input tensors in Async fashion.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs output node name from the Tensorflow model, if no outputs
   * are specified, the default outputs of the model would be used. You can
   * inspect intermediate nodes of the model by adding them to the outputs
   * array.
   */
  async executeAsync(e, t) {
    return this._executeAsync(e, t);
  }
  disposeIntermediateTensors() {
    this.clonedTensorsMap && (Object.values(this.clonedTensorsMap).forEach((e) => {
      for (const t of e)
        t && !t.isDisposed && t.dispose();
    }), this.clonedTensorsMap = null);
  }
  getIntermediateTensors() {
    return this.clonedTensorsMap;
  }
  /**
   * Executes the inference for given input tensors in Async fashion.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs Optional. output node name from the Tensorflow model,
   * if no outputs are specified, the default outputs of the model would be
   * used. You can inspect intermediate nodes of the model by adding them to
   * the outputs array.
   * @param isFunctionExecution Optional. Flag for executing a function.
   * @param tensorArrayMap Optional, global TensorArray map by id. Used for
   * function execution.
   * @param tensorArrayMap Optinal global TensorList map by id. Used for
   * function execution.
   */
  async _executeAsync(e, t, a = false, r = {}, n = {}) {
    this.disposeIntermediateTensors(), a || (e = this.mapInputs(e), this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t));
    try {
      this.keepIntermediateTensors = F().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (d) {
      this.keepIntermediateTensors = false, console.warn(d.message);
    }
    const o = new Bt(this.weightMap, r, n, this.functionExecutorMap);
    this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap));
    const u = await this.executeWithControlFlow(e, o, t, a), l = t.map((d) => k6(d, u, o)), p6 = l.map((d) => d.id), m = Object.keys(e).map((d) => e[d].id), c = /* @__PURE__ */ new Set([...p6, ...m, ...this.weightIds]);
    return Object.values(u).forEach((d) => {
      d.forEach((h6) => {
        h6 && !h6.isDisposed && !c.has(h6.id) && h6.dispose();
      });
    }), this.parent == null && o.dispose(c), l;
  }
  async executeFunctionAsync(e, t, a) {
    const r = e.reduce((n, o, u) => (n[this.inputs[u].name] = o, n), {});
    return this._executeAsync(r, this.outputNodes, true, t, a);
  }
  /**
   * When there are control flow nodes in the graph, the graph execution use
   * ExecutionContext to keep track of the frames and loop iterators.
   * @param inputs placeholder tensors for the graph.
   * @param context the execution context object for current execution.
   * @param outputNames Optional. output node name from the Tensorflow model,
   * if no outputs are specified, the default outputs of the model would be
   * used. You can inspect intermediate nodes of the model by adding them to
   * the outputs array.
   * @param isFunctionExecution Flag for executing a function.
   */
  async executeWithControlFlow(e, t, a, r) {
    const n = Object.keys(e), o = n.map((w6) => this.graph.nodes[$(w6)[0]]), u = a.map((w6) => $(w6)[0]);
    let l = u.map((w6) => this.graph.nodes[w6]);
    l.length === 0 && (l = this._outputs);
    const { usedNodes: p6, missingInputs: m, dynamicNode: c, syncInputs: d } = Ht(e, l, this.weightMap, this._initNodes), h6 = [
      ...o,
      ...this.graph.weights,
      ...this._initNodes || []
    ].map((w6) => ({ node: w6, contexts: t.currentContext })), b6 = Object.assign({}, this.weightMap);
    Object.keys(e).forEach((w6) => {
      const [I, E6] = $(w6), D6 = [];
      D6[E6] = e[w6], b6[I] = D6;
    });
    const f = {}, y6 = this.getFrozenTensorIds(b6), T6 = {};
    for (; h6.length > 0; ) {
      const w6 = this.processStack(o, h6, t, b6, T6, y6, u, f, p6);
      await Promise.all(w6);
    }
    c == null && !r && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
    const _6 = l.filter((w6) => !Zn(w6) && !k6(w6.name, b6, t)).map((w6) => w6.name);
    if (_6.length > 0) {
      let w6 = "";
      throw c != null && (w6 = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`), new Error(`Cannot compute the outputs [${_6}] from the provided inputs [${n}]. Consider providing the following inputs: [${m}]. ${w6}`);
    }
    return b6;
  }
  processStack(e, t, a, r, n, o, u, l, p6) {
    const m = [];
    for (; t.length > 0; ) {
      const c = t.pop();
      a.currentContext = c.contexts;
      let d = "";
      if (c.node.op === "Enter" && i("isConstant", c.node, r, a) && ([d] = B(c.node.name, a)), r[c.node.name] == null) {
        const h6 = jt(c.node, r, a, this._resourceManager);
        d || ([d] = B(c.node.name, a));
        const b6 = a.currentContext;
        ui$1(h6) ? m.push(h6.then((f) => (r[d] = f, this.keepIntermediateTensors && (this.clonedTensorsMap[d] = this.cloneTensorList(f)), a.currentContext = b6, this.checkTensorForDisposal(d, c.node, r, a, o, u, l), this.processChildNodes(c.node, t, a, r, n, p6), f))) : (r[d] = h6, this.keepIntermediateTensors && (this.clonedTensorsMap[d] = this.cloneTensorList(h6)), this.checkTensorForDisposal(d, c.node, r, a, o, u, l), this.processChildNodes(c.node, t, a, r, n, p6));
      } else
        this.processChildNodes(c.node, t, a, r, n, p6);
    }
    return m;
  }
  processChildNodes(e, t, a, r, n, o) {
    e.children.forEach((u) => {
      const [l] = B(u.name, a);
      n[l] || !o.has(u.name) || (u.op === "Merge" ? u.inputNames.some((p6) => !!k6(p6, r, a)) && (n[l] = true, t.push({ contexts: a.currentContext, node: u })) : u.inputNames.every((p6) => !!k6(p6, r, a)) && (n[l] = true, t.push({ contexts: a.currentContext, node: u })));
    });
  }
  /**
   * Releases the memory used by the weight tensors.
   */
  dispose() {
    Object.keys(this.weightMap).forEach((e) => this.weightMap[e].forEach((t) => t.dispose()));
  }
  checkInputShapeAndType(e) {
    Object.keys(e).forEach((t) => {
      const a = e[t], [r] = $(t), n = this.graph.nodes[r];
      if (n.attrParams.shape && n.attrParams.shape.value) {
        const o = n.attrParams.shape.value, u = o.length === a.shape.length && a.shape.every((l, p6) => o[p6] === -1 || o[p6] === l);
        v(u, () => `The shape of dict['${n.name}'] provided in model.execute(dict) must be [${o}], but was [${a.shape}]`);
      }
      n.attrParams.dtype && n.attrParams.dtype.value && v(a.dtype === n.attrParams.dtype.value, () => `The dtype of dict['${n.name}'] provided in model.execute(dict) must be ${n.attrParams.dtype.value}, but was ${a.dtype}`);
    });
  }
  mapInputs(e) {
    var t, a;
    const r = {};
    for (const n in e) {
      const o = (a = (t = this._signature) === null || t === void 0 ? void 0 : t.inputs) === null || a === void 0 ? void 0 : a[n];
      o != null ? r[o.name] = e[n] : r[n] = e[n];
    }
    return r;
  }
  checkInputs(e) {
    const t = Object.keys(e).filter((a) => {
      const [r] = $(a);
      return this.graph.nodes[r] == null;
    });
    if (t.length > 0)
      throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`);
  }
  mapOutputs(e) {
    return e.map((t) => {
      var a, r;
      const n = (r = (a = this._signature) === null || a === void 0 ? void 0 : a.outputs) === null || r === void 0 ? void 0 : r[t];
      return n != null ? n.name : t;
    }, {});
  }
  checkOutputs(e) {
    e.forEach((t) => {
      const [a] = $(t);
      if (!this.graph.nodes[a])
        throw new Error(`The output '${t}' is not found in the graph`);
    });
  }
}
class Xg {
  constructor(e = {}, t = {}) {
    this.hashTableNameToHandle = e, this.hashTableMap = t;
  }
  /**
   * Register a `HashTable` in the resource manager.
   *
   * The `HashTable` can be retrieved by `resourceManager.getHashTableById`,
   * where id is the table handle tensor's id.
   *
   * @param name Op node name that creates the `HashTable`.
   * @param hashTable The `HashTable` to be added to resource manager.
   */
  addHashTable(e, t) {
    this.hashTableNameToHandle[e] = t.handle, this.hashTableMap[t.id] = t;
  }
  /**
   * Get the table handle by node name.
   * @param name Op node name that creates the `HashTable`. This name is also
   *     used in the inputs list of lookup and import `HashTable` ops.
   */
  getHashTableHandleByName(e) {
    return this.hashTableNameToHandle[e];
  }
  /**
   * Get the actual `HashTable` by its handle tensor's id.
   * @param id The id of the handle tensor.
   */
  getHashTableById(e) {
    return this.hashTableMap[e];
  }
  /**
   * Dispose `ResourceManager`, including its hashTables and tensors in them.
   */
  dispose() {
    for (const e in this.hashTableMap)
      this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
    for (const e in this.hashTableNameToHandle)
      this.hashTableNameToHandle[e].dispose(), delete this.hashTableNameToHandle[e];
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Zg = "?tfjs-format=file", Yg = "model.json";
class Ot {
  /**
   * @param modelUrl url for the model, or an `io.IOHandler`.
   * @param weightManifestUrl url for the weight file generated by
   * scripts/convert.py script.
   * @param requestOption options for Request, which allows to send credentials
   * and custom headers.
   * @param onProgress Optional, progress callback function, fired periodically
   * before the load is completed.
   */
  constructor(e, t = {}, a = bt) {
    this.modelUrl = e, this.loadOptions = t, this.version = "n/a", this.io = a, t == null && (this.loadOptions = {}), this.resourceManager = new Xg();
  }
  // Returns the version information for the tensorflow model GraphDef.
  get modelVersion() {
    return this.version;
  }
  get inputNodes() {
    return this.executor.inputNodes;
  }
  get outputNodes() {
    return this.executor.outputNodes;
  }
  get inputs() {
    return this.executor.inputs;
  }
  get outputs() {
    return this.executor.outputs;
  }
  get weights() {
    return this.executor.weightMap;
  }
  get metadata() {
    return this.artifacts.userDefinedMetadata;
  }
  get modelSignature() {
    return this.signature;
  }
  get modelStructuredOutputKeys() {
    return this.structuredOutputKeys;
  }
  findIOHandler() {
    const e = this.modelUrl;
    if (e.load != null)
      this.handler = e;
    else if (this.loadOptions.requestInit != null)
      this.handler = this.io.browserHTTPRequest(e, this.loadOptions);
    else {
      const t = this.io.getLoadHandlers(e, this.loadOptions);
      if (t.length === 0)
        t.push(this.io.browserHTTPRequest(e, this.loadOptions));
      else if (t.length > 1)
        throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);
      this.handler = t[0];
    }
  }
  /**
   * Loads the model and weight files, construct the in memory weight map and
   * compile the inference graph.
   */
  load() {
    if (this.findIOHandler(), this.handler.load == null)
      throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
    const e = this.handler.load();
    return ui$1(e) ? e.then((t) => this.loadSync(t)) : this.loadSync(e);
  }
  /**
   * Synchronously construct the in memory weight map and
   * compile the inference graph.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  loadSync(e) {
    this.artifacts = e;
    const t = this.artifacts.modelTopology;
    let a = this.artifacts.signature;
    if (this.artifacts.userDefinedMetadata != null) {
      const n = this.artifacts.userDefinedMetadata;
      n.signature != null && (a = n.signature), n.structuredOutputKeys != null && (this.structuredOutputKeys = n.structuredOutputKeys);
    }
    this.signature = a, this.version = `${t.versions.producer}.${t.versions.minConsumer}`;
    const r = this.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
    if (this.executor = new Ee(Vt.Instance.transformGraph(t, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(r), this.executor.resourceManager = this.resourceManager, e.modelInitializer != null && e.modelInitializer.node != null) {
      const n = Vt.Instance.transformGraph(e.modelInitializer);
      this.initializer = new Ee(n), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializerSignature = e.initializerSignature;
    }
    return true;
  }
  /**
   * Save the configuration and/or weights of the GraphModel.
   *
   * An `IOHandler` is an object that has a `save` method of the proper
   * signature defined. The `save` method manages the storing or
   * transmission of serialized data ("artifacts") that represent the
   * model's topology and weights onto or via a specific medium, such as
   * file downloads, local storage, IndexedDB in the web browser and HTTP
   * requests to a server. TensorFlow.js provides `IOHandler`
   * implementations for a number of frequently used saving mediums, such as
   * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
   * for more details.
   *
   * This method also allows you to refer to certain types of `IOHandler`s
   * as URL-like string shortcuts, such as 'localstorage://' and
   * 'indexeddb://'.
   *
   * Example 1: Save `model`'s topology and weights to browser [local
   * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
   * then load it back.
   *
   * ```js
   * const modelUrl =
   *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
   * const model = await tf.loadGraphModel(modelUrl);
   * const zeros = tf.zeros([1, 224, 224, 3]);
   * model.predict(zeros).print();
   *
   * const saveResults = await model.save('localstorage://my-model-1');
   *
   * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
   * console.log('Prediction from loaded model:');
   * model.predict(zeros).print();
   * ```
   *
   * @param handlerOrURL An instance of `IOHandler` or a URL-like,
   * scheme-based string shortcut for `IOHandler`.
   * @param config Options for saving the model.
   * @returns A `Promise` of `SaveResult`, which summarizes the result of
   * the saving, such as byte sizes of the saved artifacts for the model's
   *   topology and weight values.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  async save(e, t) {
    if (typeof e == "string") {
      const a = this.io.getSaveHandlers(e);
      if (a.length === 0)
        throw new Error(`Cannot find any save handlers for URL '${e}'`);
      if (a.length > 1)
        throw new Error(`Found more than one (${a.length}) save handlers for URL '${e}'`);
      e = a[0];
    }
    if (e.save == null)
      throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    return e.save(this.artifacts);
  }
  addStructuredOutputNames(e) {
    if (this.structuredOutputKeys) {
      const t = e instanceof Lt$1 ? [e] : e, a = {};
      return t.forEach((r, n) => a[this.structuredOutputKeys[n]] = r), a;
    }
    return e;
  }
  /**
   * Execute the inference for the input tensors.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
   * inputs params should be in either `tf.Tensor`[] if the input order is
   * fixed, or otherwise NamedTensorMap format.
   *
   * For model with multiple inputs, we recommend you use NamedTensorMap as the
   * input type, if you use `tf.Tensor`[], the order of the array needs to
   * follow the
   * order of inputNodes array. @see {@link GraphModel.inputNodes}
   *
   * You can also feed any intermediate nodes using the NamedTensorMap as the
   * input type. For example, given the graph
   *    InputNode => Intermediate => OutputNode,
   * you can execute the subgraph Intermediate => OutputNode by calling
   *    model.execute('IntermediateNode' : tf.tensor(...));
   *
   * This is useful for models that uses tf.dynamic_rnn, where the intermediate
   * state needs to be fed manually.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   * Currently the batch size option is ignored for graph model.
   *
   * @returns Inference result tensors. If the model is converted and it
   * originally had structured_outputs in tensorflow, then a NamedTensorMap
   * will be returned matching the structured_outputs. If no structured_outputs
   * are present, the output will be single `tf.Tensor` if the model has single
   * output node, otherwise Tensor[].
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predict(e, t) {
    const a = this.execute(e, this.outputNodes);
    return this.addStructuredOutputNames(a);
  }
  /**
   * Execute the inference for the input tensors in async fashion, use this
   * method when your model contains control flow ops.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
   * inputs params should be in either `tf.Tensor`[] if the input order is
   * fixed, or otherwise NamedTensorMap format.
   *
   * For model with multiple inputs, we recommend you use NamedTensorMap as the
   * input type, if you use `tf.Tensor`[], the order of the array needs to
   * follow the
   * order of inputNodes array. @see {@link GraphModel.inputNodes}
   *
   * You can also feed any intermediate nodes using the NamedTensorMap as the
   * input type. For example, given the graph
   *    InputNode => Intermediate => OutputNode,
   * you can execute the subgraph Intermediate => OutputNode by calling
   *    model.execute('IntermediateNode' : tf.tensor(...));
   *
   * This is useful for models that uses tf.dynamic_rnn, where the intermediate
   * state needs to be fed manually.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   * Currently the batch size option is ignored for graph model.
   *
   * @returns A Promise of inference result tensors. If the model is converted
   * and it originally had structured_outputs in tensorflow, then a
   * NamedTensorMap will be returned matching the structured_outputs. If no
   * structured_outputs are present, the output will be single `tf.Tensor` if
   * the model has single output node, otherwise Tensor[].
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async predictAsync(e, t) {
    const a = await this.executeAsync(e, this.outputNodes);
    return this.addStructuredOutputNames(a);
  }
  normalizeInputs(e) {
    var t;
    if (!(e instanceof Lt$1) && !Array.isArray(e)) {
      const n = (t = this.signature) === null || t === void 0 ? void 0 : t.inputs;
      if (n != null)
        for (const o in n) {
          const u = n[o];
          u.resourceId != null && (e[o] = this.resourceIdToCapturedInput[u.resourceId]);
        }
      return e;
    }
    e = Array.isArray(e) ? e : [e];
    const a = Object.keys(this.resourceIdToCapturedInput).length;
    if (e.length + a !== this.inputNodes.length)
      throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - a} non-resource placeholders, while there are ${e.length} input tensors provided.`);
    let r = 0;
    return this.inputNodes.reduce((n, o) => {
      var u, l, p6;
      const m = (p6 = (l = (u = this.signature) === null || u === void 0 ? void 0 : u.inputs) === null || l === void 0 ? void 0 : l[o]) === null || p6 === void 0 ? void 0 : p6.resourceId;
      return m != null ? n[o] = this.resourceIdToCapturedInput[m] : n[o] = e[r++], n;
    }, {});
  }
  normalizeOutputs(e) {
    return e = e || this.outputNodes, Array.isArray(e) ? e : [e];
  }
  executeInitializerGraph() {
    return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.execute({}, []) : this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
  }
  async executeInitializerGraphAsync() {
    return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.executeAsync({}, []) : this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
  }
  setResourceIdToCapturedInput(e) {
    if (this.resourceIdToCapturedInput = {}, this.initializerSignature) {
      const t = this.initializerSignature.outputs, a = Object.keys(t);
      for (let r = 0; r < a.length; r++) {
        const n = a[r], o = t[n];
        this.resourceIdToCapturedInput[o.resourceId] = e[r];
      }
    }
  }
  /**
   * Executes inference for the model for given input tensors.
   * @param inputs tensor, tensor array or tensor map of the inputs for the
   * model, keyed by the input node names.
   * @param outputs output node name from the TensorFlow model, if no
   * outputs are specified, the default outputs of the model would be used.
   * You can inspect intermediate nodes of the model by adding them to the
   * outputs array.
   *
   * @returns A single tensor if provided with a single output or no outputs
   * are provided and there is only one default output, otherwise return a
   * tensor array. The order of the tensor array is the same as the outputs
   * if provided, otherwise the order of outputNodes attribute of the model.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  execute(e, t) {
    this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(this.executeInitializerGraph()), e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
    const a = this.executor.execute(e, t);
    return a.length > 1 ? a : a[0];
  }
  /**
   * Executes inference for the model for given input tensors in async
   * fashion, use this method when your model contains control flow ops.
   * @param inputs tensor, tensor array or tensor map of the inputs for the
   * model, keyed by the input node names.
   * @param outputs output node name from the TensorFlow model, if no outputs
   * are specified, the default outputs of the model would be used. You can
   * inspect intermediate nodes of the model by adding them to the outputs
   * array.
   *
   * @returns A Promise of single tensor if provided with a single output or
   * no outputs are provided and there is only one default output, otherwise
   * return a tensor map.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async executeAsync(e, t) {
    this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()), e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
    const a = await this.executor.executeAsync(e, t);
    return a.length > 1 ? a : a[0];
  }
  /**
   * Get intermediate tensors for model debugging mode (flag
   * KEEP_INTERMEDIATE_TENSORS is true).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  getIntermediateTensors() {
    return this.executor.getIntermediateTensors();
  }
  /**
   * Dispose intermediate tensors for model debugging mode (flag
   * KEEP_INTERMEDIATE_TENSORS is true).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  disposeIntermediateTensors() {
    this.executor.disposeIntermediateTensors();
  }
  convertTensorMapToTensorsMap(e) {
    return Object.keys(e).reduce((t, a) => (t[a] = [e[a]], t), {});
  }
  /**
   * Releases the memory used by the weight tensors and resourceManager.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  dispose() {
    this.executor.dispose(), this.initializer && (this.initializer.dispose(), this.resourceIdToCapturedInput && yt$1(this.resourceIdToCapturedInput)), this.resourceManager.dispose();
  }
}
async function Mg2(s, e = {}, t = bt) {
  if (s == null)
    throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
  e == null && (e = {}), e.fromTFHub && typeof s == "string" && (s = tb(s));
  const a = new Ot(s, e, t);
  return await a.load(), a;
}
function eb(s) {
  if (s == null)
    throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");
  let e;
  if (s instanceof Array) {
    const [a, r] = s;
    if (!a)
      throw new Error("modelJSON must be the first element of the array");
    if (!r || !(r instanceof ArrayBuffer))
      throw new Error("An ArrayBuffer of weights must be the second element of the array");
    if (!("modelTopology" in a))
      throw new Error("Model JSON is missing 'modelTopology'");
    if (!("weightsManifest" in a))
      throw new Error("Model JSON is missing 'weightsManifest'");
    const n = NC(a.weightsManifest), o = kC(a, n, r);
    e = _e(o);
  } else if ("load" in s)
    e = s;
  else if ("modelTopology" in s && "weightSpecs" in s && "weightData" in s)
    e = _e(s);
  else
    throw new Error("Unknown model format");
  const t = new Ot(e);
  return t.load(), t;
}
function tb(s) {
  return s.endsWith("/") || (s = s + "/"), `${s}${Yg}${Zg}`;
}
/** @license See the LICENSE file. */
const Yn2 = "4.2.0";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class Mn extends Tf$1 {
  /**
   * Create a `TextLineDataset`.
   *
   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.
   */
  constructor(e) {
    super(), this.input = e;
  }
  async iterator() {
    return (await this.input.iterator()).decodeUTF8().split(`
`).map((r) => (r.endsWith("\r") && (r = r.slice(0, -1)), r));
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
const ye = '"', ne = Symbol("out"), Wt = Symbol("field"), ge = Symbol("quote"), xe = Symbol("quoteafterquote"), qt = Symbol("quoteinquote");
class ei2 extends Tf$1 {
  /**
   * Create a `CSVDataset`.
   *
   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.
   * @param csvConfig (Optional) A CSVConfig object that contains configurations
   *     of reading and decoding from CSV file(s).
   *
   *     hasHeader: (Optional) A boolean value that indicates whether the first
   *     row of provided CSV file is a header line with column names, and should
   *     not be included in the data. Defaults to `true`.
   *
   *     columnNames: (Optional) A list of strings that corresponds to
   *     the CSV column names, in order. If provided, it ignores the column
   *     names inferred from the header row. If not provided, infers the column
   *     names from the first row of the records. If hasHeader is false and
   *     columnNames is not provided, this method throws an error.
   *
   *     columnConfigs: (Optional) A dictionary whose key is column names, value
   *     is an object stating if this column is required, column's data type,
   *     default value, and if this column is label. If provided, keys must
   *     correspond to names provided in columnNames or inferred from the file
   *     header lines. If isLabel is true any column, returns an array of two
   *     items: the first item is a dict of features key/value pairs, the second
   *     item is a dict of labels key/value pairs. If no feature is marked as
   *     label, returns a dict of features only.
   *
   *     configuredColumnsOnly (Optional) If true, only columns provided in
   *     columnConfigs will be parsed and provided during iteration.
   *
   *     delimiter (Optional) The string used to parse each line of the input
   *     file. Defaults to `,`.
   */
  constructor(e, t) {
    super(), this.input = e, this.hasHeader = true, this.fullColumnNames = null, this.columnNamesValidated = false, this.columnConfigs = null, this.configuredColumnsOnly = false, this.delimiter = ",", this.delimWhitespace = false, this.base = new Mn(e), t || (t = {}), this.hasHeader = t.hasHeader !== false, this.fullColumnNames = t.columnNames, this.columnConfigs = t.columnConfigs, this.configuredColumnsOnly = t.configuredColumnsOnly, t.delimWhitespace ? (v(t.delimiter == null, () => "Delimiter should not be provided when delimWhitespace is true."), this.delimWhitespace = true, this.delimiter = " ") : this.delimiter = t.delimiter ? t.delimiter : ",";
  }
  /**
   * Returns column names of the csv dataset. If `configuredColumnsOnly` is
   * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is
   * false and `columnNames` is provided, `columnNames`. If
   * `configuredColumnsOnly` is false and `columnNames` is not provided, return
   * all column names parsed from the csv file. For example usage please go to
   * `tf.data.csv`.
   *
   * @doc {heading: 'Data', subheading: 'Classes'}
   */
  async columnNames() {
    return this.columnNamesValidated || await this.setColumnNames(), this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames;
  }
  /* 1) If `columnNames` is provided as string[], use this string[] as output
   * keys in corresponding order. The length must match the number of inferred
   * columns if `hasHeader` is true .
   * 2) If `columnNames` is not provided, parse header line as `columnNames` if
   * hasHeader is true. If `hasHeader` is false, throw an error.
   * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must
   * exist in parsed `columnNames`.
   */
  async setColumnNames() {
    const e = await this.maybeReadHeaderLine();
    if (!this.fullColumnNames && !e)
      throw new Error("Column names must be provided if there is no header line.");
    this.fullColumnNames && e && v(e.length === this.fullColumnNames.length, () => "The length of provided columnNames (" + this.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + e.length.toString() + ")."), this.fullColumnNames || (this.fullColumnNames = e);
    const t = this.fullColumnNames.reduce((r, n) => (r[n] = r[n] + 1 || 1, r), {}), a = Object.keys(t).filter((r) => t[r] > 1);
    if (v(a.length === 0, () => "Duplicate column names found: " + a.toString()), this.columnConfigs) {
      for (const r of Object.keys(this.columnConfigs))
        if (this.fullColumnNames.indexOf(r) === -1)
          throw new Error('The key "' + r + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
    }
    this.columnNamesValidated = true;
  }
  async maybeReadHeaderLine() {
    if (this.hasHeader) {
      const t = await (await this.base.iterator()).next();
      if (t.done)
        throw new Error("No data was found for CSV parsing.");
      const a = t.value;
      return this.parseRow(a, false);
    } else
      return null;
  }
  async iterator() {
    this.columnNamesValidated || await this.setColumnNames();
    let e = await this.base.iterator();
    return this.hasHeader && (e = e.skip(1)), e.map((t) => this.makeDataElement(t));
  }
  makeDataElement(e) {
    const t = this.parseRow(e), a = {}, r = {};
    for (let n = 0; n < this.fullColumnNames.length; n++) {
      const o = this.fullColumnNames[n], u = this.columnConfigs ? this.columnConfigs[o] : null;
      if (!(this.configuredColumnsOnly && !u)) {
        const l = t[n];
        let p6 = null;
        if (l === "")
          if (u && u.default !== void 0)
            p6 = u.default;
          else {
            if (u && (u.required || u.isLabel))
              throw new Error(`Required column ${o} is empty in this line: ${e}`);
            p6 = void 0;
          }
        else {
          const m = Number(l);
          if (isNaN(m))
            u && u.dtype === "bool" ? p6 = this.getBoolean(l) : p6 = l;
          else if (!u || !u.dtype)
            p6 = m;
          else
            switch (u.dtype) {
              case "float32":
                p6 = m;
                break;
              case "int32":
                p6 = Math.floor(m);
                break;
              case "bool":
                p6 = this.getBoolean(l);
                break;
              default:
                p6 = m;
            }
        }
        u && u.isLabel ? r[o] = p6 : a[o] = p6;
      }
    }
    return Object.keys(r).length === 0 ? a : { xs: a, ys: r };
  }
  getBoolean(e) {
    return e === "1" || e.toLowerCase() === "true" ? 1 : 0;
  }
  // adapted from https://beta.observablehq.com/@mbostock/streaming-csv
  parseRow(e, t = true) {
    const a = [];
    let r = 0;
    const n = e.length;
    let o = ne;
    for (let u = 0; u < n; u++)
      switch (o) {
        case ne:
          switch (e.charAt(u)) {
            case ye:
              r = u + 1, o = ge;
              break;
            case this.delimiter:
              if (r = u + 1, this.delimiter === " " && this.delimWhitespace)
                break;
              a.push(""), o = ne;
              break;
            default:
              o = Wt, r = u;
              break;
          }
          break;
        case Wt:
          switch (e.charAt(u)) {
            case this.delimiter:
              a.push(e.substring(r, u)), o = ne, r = u + 1;
              break;
          }
          break;
        case ge:
          switch (e.charAt(u)) {
            case ye:
              o = xe;
              break;
          }
          break;
        case xe:
          switch (e.charAt(u)) {
            case this.delimiter:
              a.push(e.substring(r, u - 1)), o = ne, r = u + 1;
              break;
            case ye:
              o = ge;
              break;
            default:
              o = qt;
              break;
          }
          break;
        case qt:
          switch (e.charAt(u)) {
            case ye:
              o = ge;
              break;
          }
          break;
      }
    if (o === xe ? a.push(e.substring(r, n - 1)) : a.push(e.substring(r)), t && a.length !== this.fullColumnNames.length)
      throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${a}`);
    return a;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class _t extends Ke$1 {
  constructor(e) {
    super(), this.microphoneConfig = e, this.isClosed = false, this.fftSize = e.fftSize || 1024;
    const t = Math.log2(this.fftSize);
    if (this.fftSize < 0 || t < 4 || t > 14 || !Number.isInteger(t))
      throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);
    if (this.numFrames = e.numFramesPerSpectrogram || 43, this.sampleRateHz = e.sampleRateHz, this.columnTruncateLength = e.columnTruncateLength || this.fftSize, this.audioTrackConstraints = e.audioTrackConstraints, this.smoothingTimeConstant = e.smoothingTimeConstant || 0, this.includeSpectrogram = e.includeSpectrogram !== false, this.includeWaveform = e.includeWaveform === true, !this.includeSpectrogram && !this.includeWaveform)
      throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
  }
  summary() {
    return "microphone";
  }
  // Construct a MicrophoneIterator and start the audio stream.
  static async create(e = {}) {
    if (!F().get("IS_BROWSER"))
      throw new Error("microphone API is only supported in browser environment.");
    const t = new _t(e);
    return await t.start(), t;
  }
  // Start the audio stream and FFT.
  async start() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,
        video: false
      });
    } catch (a) {
      throw new Error(`Error thrown while initializing video stream: ${a.message}`);
    }
    if (!this.stream)
      throw new Error("Could not obtain audio from microphone.");
    const e = (
      // tslint:disable-next-line:no-any
      window.AudioContext || window.webkitAudioContext
    );
    if (this.audioContext = new e(), !this.sampleRateHz)
      this.sampleRateHz = this.audioContext.sampleRate;
    else if (this.audioContext.sampleRate !== this.sampleRateHz)
      throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);
    const t = this.audioContext.createMediaStreamSource(this.stream);
    this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = this.fftSize * 2, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, t.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize);
  }
  async next() {
    if (this.isClosed)
      return { value: null, done: true };
    let e, t;
    const a = await this.getAudioData();
    if (this.includeSpectrogram) {
      const r = this.flattenQueue(a.freqDataQueue);
      e = this.getTensorFromAudioDataArray(r, [this.numFrames, this.columnTruncateLength, 1]);
    }
    if (this.includeWaveform) {
      const r = this.flattenQueue(a.timeDataQueue);
      t = this.getTensorFromAudioDataArray(r, [this.numFrames * this.fftSize, 1]);
    }
    return {
      value: { spectrogram: e, waveform: t },
      done: false
    };
  }
  // Capture one result from the audio stream, and extract the value from
  // iterator.next() result.
  async capture() {
    return (await this.next()).value;
  }
  async getAudioData() {
    const e = [], t = [];
    let a = 0;
    return new Promise((r) => {
      const n = setInterval(() => {
        this.includeSpectrogram && (this.analyser.getFloatFrequencyData(this.freqData), this.freqData[0] === -1 / 0 && r({ freqDataQueue: e, timeDataQueue: t }), e.push(this.freqData.slice(0, this.columnTruncateLength))), this.includeWaveform && (this.analyser.getFloatTimeDomainData(this.timeData), t.push(this.timeData.slice())), ++a === this.numFrames && (clearInterval(n), r({ freqDataQueue: e, timeDataQueue: t }));
      }, this.fftSize / this.sampleRateHz * 1e3);
    });
  }
  // Stop the audio stream and pause the iterator.
  stop() {
    this.isClosed || (this.isClosed = true, this.analyser.disconnect(), this.audioContext.close(), this.stream != null && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop());
  }
  // Override toArray() function to prevent collecting.
  toArray() {
    throw new Error("Can not convert infinite audio stream to array.");
  }
  // Return audio sampling rate in Hz
  getSampleRate() {
    return this.sampleRateHz;
  }
  flattenQueue(e) {
    const t = e[0].length, a = new Float32Array(e.length * t);
    return e.forEach((r, n) => a.set(r, n * t)), a;
  }
  getTensorFromAudioDataArray(e, t) {
    const a = new Float32Array(O(t));
    return a.set(e, a.length - e.length), Re$1(a, t);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class At extends Ke$1 {
  constructor(e, t) {
    if (super(), this.webcamVideoElement = e, this.webcamConfig = t, this.isClosed = true, this.resize = false, this.needToResize())
      if (this.resize = true, this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth], this.cropBoxInd = Je$1([0], "int32"), this.webcamConfig.centerCrop) {
        const a = this.webcamConfig.resizeWidth * 1 / this.webcamVideoElement.width, r = this.webcamConfig.resizeHeight * 1 / this.webcamVideoElement.height, n = (1 - a) / 2, o = (1 - r) / 2, u = n + a, l = r + o;
        this.cropBox = qa([o, n, l, u], [1, 4]);
      } else
        this.cropBox = qa([0, 0, 1, 1], [1, 4]);
  }
  summary() {
    return "webcam";
  }
  // Construct a WebcamIterator and start it's video stream.
  static async create(e, t = {}) {
    if (!F().get("IS_BROWSER"))
      throw new Error("tf.data.webcam is only supported in browser environment.");
    if (!e) {
      if (e = document.createElement("video"), !t.resizeWidth || !t.resizeHeight)
        throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
      e.width = t.resizeWidth, e.height = t.resizeHeight;
    }
    const a = new At(e, t);
    return await a.start(), a;
  }
  // Async function to start video stream.
  async start() {
    this.webcamConfig.facingMode && v(this.webcamConfig.facingMode === "user" || this.webcamConfig.facingMode === "environment", () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        video: {
          deviceId: this.webcamConfig.deviceId,
          facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
          width: this.webcamVideoElement.width,
          height: this.webcamVideoElement.height
        }
      });
    } catch (e) {
      throw e.message = `Error thrown while initializing video stream: ${e.message}`, e;
    }
    if (!this.stream)
      throw new Error("Could not obtain video from webcam.");
    try {
      this.webcamVideoElement.srcObject = this.stream;
    } catch (e) {
      console.log(e), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
    }
    return this.webcamVideoElement.play(), this.isClosed = false, new Promise((e) => {
      this.webcamVideoElement.onloadedmetadata = () => {
        e();
      };
    });
  }
  async next() {
    if (this.isClosed)
      return { value: null, done: true };
    let e;
    try {
      e = b0(this.webcamVideoElement);
    } catch (t) {
      throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`);
    }
    if (this.resize)
      try {
        return { value: this.cropAndResizeFrame(e), done: false };
      } catch (t) {
        throw new Error(`Error thrown cropping the video: ${t.message}`);
      } finally {
        e.dispose();
      }
    else
      return { value: e, done: false };
  }
  needToResize() {
    return !!(this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight));
  }
  // Cropping and resizing each frame based on config
  cropAndResizeFrame(e) {
    return D(() => {
      const t = Ue$1(et(e, "float32"), 0);
      let a;
      a = uo.cropAndResize(t, this.cropBox, this.cropBoxInd, this.cropSize, "bilinear");
      const r = a.shape;
      return W(a, r.slice(1));
    });
  }
  // Capture one frame from the video stream, and extract the value from
  // iterator.next() result.
  async capture() {
    return (await this.next()).value;
  }
  // Stop the video stream and pause webcam iterator.
  stop() {
    this.stream.getTracks().forEach((t) => t.stop());
    try {
      this.webcamVideoElement.srcObject = null;
    } catch (t) {
      console.log(t), this.webcamVideoElement.src = null;
    }
    this.isClosed = true;
  }
  // Override toArray() function to prevent collecting.
  toArray() {
    throw new Error("Can not convert infinite video stream to array.");
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class ti {
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class si extends Ke$1 {
  /**
   * Splits a string stream on a given separator.
   *
   * It is assumed that the incoming chunk boundaries have no semantic meaning,
   * so conceptually the incoming stream is treated simply as the concatenation
   * of its elements.
   *
   * The outgoing stream provides chunks corresponding to the results of the
   * standard string split() operation (even if such a chunk spanned incoming
   * chunks).  The separators are not included.
   *
   * A typical usage is to split a text file (represented as a stream with
   * arbitrary chunk boundaries) into lines.
   *
   * @param upstream A readable stream of strings that can be treated as
   *   concatenated.
   * @param separator A character to split on.
   */
  split(e) {
    return new sb(this, e);
  }
}
class sb extends si {
  constructor(e, t) {
    super(), this.upstream = e, this.impl = new ab(e, t);
  }
  summary() {
    return this.impl.summary();
  }
  async next() {
    return this.impl.next();
  }
}
class ab extends SL {
  constructor(e, t) {
    super(), this.upstream = e, this.separator = t, this.carryover = "";
  }
  summary() {
    return `${this.upstream.summary()} -> Split('${this.separator}')`;
  }
  async pump() {
    const e = await this.upstream.next();
    if (e.done)
      return this.carryover === "" ? false : (this.outputQueue.push(this.carryover), this.carryover = "", true);
    const t = e.value.split(this.separator);
    t[0] = this.carryover + t[0];
    for (const a of t.slice(0, -1))
      this.outputQueue.push(a);
    return this.carryover = t[t.length - 1], true;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class rb extends Ke$1 {
  /**
   * Decode a stream of UTF8-encoded byte arrays to a stream of strings.
   *
   * The byte arrays producetd from the ByteChunkIterator on which this is
   * called will be interpreted as concatenated.  No assumptions are made about
   * the boundaries of the incoming chunks, so a multi-byte UTF8 encoding of a
   * character may span the boundary between chunks.  This naturally happens,
   * for instance, when reading fixed-size byte arrays from a file.
   */
  decodeUTF8() {
    return new nb(this);
  }
}
class nb extends si {
  constructor(e) {
    super(), this.upstream = e, this.impl = new ib(e);
  }
  summary() {
    return this.impl.summary();
  }
  async next() {
    return this.impl.next();
  }
}
class ib extends SL {
  constructor(e) {
    if (super(), this.upstream = e, F().get("IS_BROWSER"))
      this.decoder = new TextDecoder("utf-8");
    else {
      const { StringDecoder: t } = require("string_decoder");
      this.decoder = new t("utf8");
    }
  }
  summary() {
    return `${this.upstream.summary()} -> Utf8`;
  }
  async pump() {
    const e = await this.upstream.next();
    let t;
    if (e.done)
      return false;
    t = e.value;
    let a;
    return F().get("IS_BROWSER") ? a = this.decoder.decode(t, { stream: true }) : a = this.decoder.write(dist.Buffer.from(t.buffer)), this.outputQueue.push(a), true;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class ai extends rb {
  constructor(e, t = {}) {
    super(), this.file = e, this.options = t, v(e instanceof Uint8Array || (F().get("IS_BROWSER") ? e instanceof File || e instanceof Blob : false), () => "FileChunkIterator only supports File, Blob and Uint8Array right now."), this.offset = t.offset || 0, this.chunkSize = t.chunkSize || 1024 * 1024;
  }
  summary() {
    return `FileChunks ${this.file}`;
  }
  async next() {
    return this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size) ? { value: null, done: true } : { value: await new Promise((t, a) => {
      const r = this.offset + this.chunkSize;
      if (this.file instanceof Uint8Array)
        t(new Uint8Array(this.file.slice(this.offset, r)));
      else {
        const n = new FileReader();
        n.onload = (u) => {
          let l = n.result;
          if (l instanceof ArrayBuffer && (l = new Uint8Array(l)), !(l instanceof Uint8Array))
            return a(new TypeError("FileReader returned unknown type."));
          t(l);
        }, n.onabort = (u) => a(new Error("Aborted")), n.onerror = (u) => a(new Error(u.type));
        const o = this.file.slice(this.offset, r);
        n.readAsArrayBuffer(o);
      }
      this.offset = r;
    }), done: false };
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
async function ob(s, e = {}, t) {
  let a, r;
  typeof s == "string" ? a = s : (a = s.url, r = ub(s));
  const n = await (t || nC)(a, r);
  if (n.ok) {
    const o = new Uint8Array(await n.arrayBuffer());
    return new ai(o, e);
  } else
    throw new Error(n.statusText);
}
const ub = (s) => ({
  method: s.method,
  headers: s.headers,
  body: s.body,
  mode: s.mode,
  credentials: s.credentials,
  cache: s.cache,
  redirect: s.redirect,
  referrer: s.referrer,
  integrity: s.integrity
});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function ri(s) {
  return typeof s == "string" && s.slice(0, 7) === "file://";
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class ni extends ti {
  /**
   * Create a `FileDataSource`.
   *
   * @param input Local file path, or `File`/`Blob`/`Uint8Array` object to
   *     read. Local file only works in node environment.
   * @param options Options passed to the underlying `FileChunkIterator`s,
   *   such as {chunksize: 1024}.
   */
  constructor(e, t = {}) {
    super(), this.input = e, this.options = t;
  }
  async iterator() {
    if (ri(this.input) && F().get("IS_NODE")) {
      const e = require("fs");
      this.input = e.readFileSync(this.input.slice(7));
    }
    return new ai(this.input, this.options);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
class ii extends ti {
  /**
   * Create a `URLDataSource`.
   *
   * @param url A source URL string, or a `Request` object.
   * @param options Options passed to the underlying `FileChunkIterator`s,
   *   such as {chunksize: 1024}.
   */
  constructor(e, t = {}) {
    super(), this.url = e, this.fileOptions = t;
  }
  // TODO(soergel): provide appropriate caching options.  Currently this
  // will download the URL anew for each call to iterator().  Since we have
  // to treat the downloaded file as a blob/buffer anyway, we may as well retain
  // it-- but that raises GC issues.  Also we may want a persistent disk cache.
  async iterator() {
    return ri(this.url) ? new ni(this.url, this.fileOptions).iterator() : ob(this.url, this.fileOptions);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
function lb(s, e = {}) {
  return new ei2(new ii(s), e);
}
function pb(s) {
  const e = hL(s);
  return bn$1(async () => e);
}
function mb(s) {
  return bn$1(async () => {
    const e = await s();
    return hL(() => e.next());
  });
}
async function cb(s, e) {
  return At.create(s, e);
}
async function db(s) {
  return _t.create(s);
}
/** @license See the LICENSE file. */
const oi2 = "4.2.0";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const hb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CSVDataset: ei2,
  Dataset: Tf$1,
  FileDataSource: ni,
  TextLineDataset: Mn,
  URLDataSource: ii,
  array: EY,
  csv: lb,
  func: pb,
  generator: mb,
  microphone: db,
  version_data: oi2,
  webcam: cb,
  zip: LY
}, Symbol.toStringTag, { value: "Module" }));
/** @license See the LICENSE file. */
const fb = "4.2.0";
/** @license See the LICENSE file. */
const yb = "4.2.0";
/** @license See the LICENSE file. */
const gb = "4.2.0";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const bb = {
  "tfjs-core": jn2,
  "tfjs-backend-cpu": fb,
  "tfjs-backend-webgl": yb,
  "tfjs-data": oi2,
  "tfjs-layers": Gx,
  "tfjs-converter": Yn2,
  tfjs: gb
}, Nb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs: Vl,
  Acos: di,
  Acosh: hi,
  AdadeltaOptimizer: a0,
  AdagradOptimizer: l0,
  AdamOptimizer: c0,
  AdamaxOptimizer: u0,
  Add: br,
  AddN: Bd$1,
  All: Hd$1,
  Any: _d$1,
  ArgMax: zl,
  ArgMin: Xl,
  Asin: pi,
  Asinh: fi,
  Atan: mi,
  Atan2: bi,
  Atanh: gi,
  AvgPool: Pl,
  AvgPool3D: Al,
  AvgPool3DGrad: Yd$1,
  AvgPoolGrad: Ud$1,
  BatchMatMul: Ol,
  BatchToSpaceND: Kl,
  Bincount: Qd$1,
  BroadcastArgs: Kg$1,
  BroadcastTo: BI,
  Callback: Gn2,
  CallbackList: jG,
  Cast: xi,
  Ceil: yi,
  ClipByValue: wi,
  Complex: Jd$1,
  ComplexAbs: Zl,
  Concat: Bl,
  Conv2D: Hl,
  Conv2DBackpropFilter: jd$1,
  Conv2DBackpropInput: _l,
  Conv3D: Ul,
  Conv3DBackpropFilterV2: qd$1,
  Conv3DBackpropInputV2: th$1,
  Cos: Ii,
  Cosh: Ci,
  CropAndResize: nh$1,
  Cumprod: eh$1,
  Cumsum: Yl,
  CustomCallback: eE,
  DataStorage: Mg$1,
  DenseBincount: sh$1,
  DepthToSpace: oh$1,
  DepthwiseConv2dNative: Ql,
  DepthwiseConv2dNativeBackpropFilter: rh$1,
  DepthwiseConv2dNativeBackpropInput: ih$1,
  Diag: Zg$1,
  Dilation2D: Jl,
  Dilation2DBackpropFilter: nd,
  Dilation2DBackpropInput: ed,
  get ENV() {
    return Ag$1;
  },
  EarlyStopping: Kn,
  Einsum: Bg$1,
  Elu: Si,
  EluGrad: ah$1,
  Environment: XI,
  Equal: jl,
  Erf: ki,
  Exp: Ti,
  ExpandDims: ql,
  Expm1: Ni,
  FFT: lh$1,
  Fill: ch$1,
  FlipLeftRight: uh$1,
  Floor: Ri,
  FloorDiv: $i,
  FromPixels: sd,
  FusedBatchNorm: tc,
  FusedConv2D: rl,
  FusedDepthwiseConv2D: nb$1,
  GatherNd: Hg$1,
  GatherV2: ec,
  GraphModel: Ot,
  Greater: nc,
  GreaterEqual: Gi,
  History: tE,
  IFFT: dh$1,
  Identity: Ei,
  Imag: hh$1,
  InputSpec: de,
  IsFinite: Li,
  IsInf: Mi,
  IsNan: Wi,
  KernelBackend: Xd$1,
  LRN: cc,
  LRNGrad: ph$1,
  LayerVariable: zG,
  LayersModel: tr,
  LeakyRelu: sc,
  Less: oc,
  LessEqual: rc,
  LinSpace: _g$1,
  Log: Di,
  Log1p: Fi,
  LogSoftmax: HI,
  LogicalAnd: ic,
  LogicalNot: ac,
  LogicalOr: lc,
  LogicalXor: $4,
  LowerBound: G4,
  Max: uc,
  MaxPool: dc,
  MaxPool3D: hc,
  MaxPool3DGrad: mh$1,
  MaxPoolGrad: fh$1,
  MaxPoolWithArgmax: Ug$1,
  Maximum: Vi,
  Mean: pc,
  Min: fc,
  Minimum: zi,
  MirrorPad: mc,
  Mod: Xi,
  MomentumOptimizer: d0,
  Multinomial: Yg$1,
  Multiply: Pi,
  Neg: gc,
  NonMaxSuppressionV3: gh$1,
  NonMaxSuppressionV4: bh$1,
  NonMaxSuppressionV5: xh$1,
  NotEqual: bc,
  OP_SCOPE_SUFFIX: yC,
  OneHot: yc,
  OnesLike: xc,
  Optimizer: Ys,
  OptimizerConstructors: oR,
  Pack: wc,
  PadV2: Ic,
  Pool: E4,
  Pow: Ai,
  Prelu: Cc,
  Prod: vc,
  RMSPropOptimizer: h0,
  RNN: Qs,
  RaggedGather: Qg$1,
  RaggedRange: Jg$1,
  RaggedTensorToTensor: jg$1,
  Range: yh$1,
  get Rank() {
    return tm;
  },
  Real: wh$1,
  RealDiv: vi,
  Reciprocal: Oi,
  get Reduction() {
    return Ae$1;
  },
  Relu: Ki,
  Relu6: Zi,
  Reshape: Sc,
  ResizeBilinear: Tc,
  ResizeBilinearGrad: Ch$1,
  ResizeNearestNeighbor: kc,
  ResizeNearestNeighborGrad: Ih$1,
  Reverse: Nc,
  RotateWithOffset: Dh$1,
  Round: Bi,
  Rsqrt: Hi,
  SGDOptimizer: Gp,
  ScatterNd: qg$1,
  SearchSorted: tb$1,
  Select: Rc,
  Selu: _i,
  Sequential: oi$1,
  Sigmoid: Ji,
  Sign: Qi,
  Sin: Ui,
  Sinh: Yi,
  Slice: $c,
  Softmax: Mc,
  Softplus: ji,
  SpaceToBatchND: Ec,
  SparseFillEmptyRows: vh$1,
  SparseReshape: Sh$1,
  SparseSegmentMean: kh$1,
  SparseSegmentSum: Th$1,
  SparseToDense: eb$1,
  SplitV: Lc,
  Sqrt: qi,
  Square: Nh$1,
  SquaredDifference: ta,
  Step: ra,
  StridedSlice: Rh$1,
  StringNGrams: $h$1,
  StringSplit: Gh$1,
  StringToHashBucketFast: Eh$1,
  Sub: ea,
  Sum: Gc,
  SymbolicTensor: jn$1,
  Tan: na,
  Tanh: sa,
  Tensor: Lt$1,
  TensorBuffer: $e,
  Tile: oa,
  TopK: Lh$1,
  Transform: Mh$1,
  Transpose: Jo,
  Unique: Wh$1,
  Unpack: Wc,
  UnsortedSegmentSum: Dc,
  UpperBound: L4,
  Variable: al,
  ZerosLike: Fc,
  _FusedMatMul: ol,
  abs: fe$1,
  acos: o2,
  acosh: i2,
  add: U,
  addN: Yr,
  all: Nb$1,
  any: bd$1,
  argMax: Qr,
  argMin: d2,
  asin: p2,
  asinh: m2,
  atan: b2,
  atan2: y2,
  atanh: I2,
  avgPool: Bh$1,
  avgPool3d: $2,
  backend: $s,
  backend_util: cR,
  basicLSTMCell: Mr,
  batchNorm: zc,
  batchNorm2d: X2,
  batchNorm3d: A2,
  batchNorm4d: K2,
  batchToSpaceND: _h$1,
  bincount: B2,
  booleanMaskAsync: Cn2,
  broadcastArgs: en,
  broadcastTo: Br,
  broadcast_util: iY,
  browser: yY,
  buffer: vt$1,
  callbacks: ky2,
  cast: et,
  ceil: U2,
  clipByValue: pn$1,
  clone: po,
  complex: bo,
  concat: Ge$1,
  concat1d: J2,
  concat2d: q2,
  concat3d: ev,
  concat4d: sv,
  constraints: Oh,
  conv1d: Rb,
  conv2d: Co,
  conv2dTranspose: $b,
  conv3d: cv,
  conv3dTranspose: hv,
  copyRegisteredKernels: D4,
  cos: Yh$1,
  cosh: Eb,
  cosineWindow: n0,
  cumprod: yd$1,
  cumsum: Lb,
  customGrad: So,
  data: hb,
  denseBincount: rm,
  deprecationWarn: Y4,
  depthToSpace: yv,
  depthwiseConv2d: Qh$1,
  deregisterOp: Dy2,
  device_util: z4,
  diag: tn,
  dilation2d: Cv,
  disableDeprecationWarnings: U4,
  dispose: yt$1,
  disposeVariables: Q4,
  div: ut,
  divNoNan: Nv,
  dot: $v,
  dropout: oT,
  einsum: sn,
  elu: Xc,
  enableDebugMode: _4,
  enableProdMode: H4,
  enclosingPowerOfTwo: rT,
  engine: Xt,
  env: F,
  equal: kn$1,
  erf: Lv,
  euclideanNorm: Av,
  exp: Tn$1,
  expandDims: Ue$1,
  expm1: Bv,
  eye: Db,
  fft: xp,
  fill: ua,
  findBackend: sY,
  findBackendFactory: oY,
  floor: Ac,
  floorDiv: Tb$1,
  fused: Pn,
  gather: jh$1,
  gatherND: Vn,
  gather_util: wY,
  getBackend: eY,
  getGradient: Hf$1,
  getKernel: od,
  getKernelsForBackend: rd,
  grad: aY,
  grads: lY,
  greater: sn$1,
  greaterEqual: Do,
  ifft: pl,
  imag: qh$1,
  image: uo,
  inTopKAsync: Fn,
  initializers: jh,
  input: Bn,
  io: bt,
  irfft: Qb,
  isFinite: tS,
  isInf: nS,
  isNaN: oS,
  keep: cn$1,
  kernel_impls: Nh,
  layers: ny,
  leakyRelu: tp,
  less: Fb,
  lessEqual: yr,
  linalg: zN,
  linspace: an2,
  loadGraphModel: Mg2,
  loadGraphModelSync: eb,
  loadLayersModel: vY,
  localResponseNormalization: cS,
  log: Nn$1,
  log1p: ep,
  logSigmoid: gS,
  logSoftmax: Vb,
  logSumExp: zb,
  logicalAnd: ss,
  logicalNot: np,
  logicalOr: Xb,
  logicalXor: SS,
  losses: mY,
  lowerBound: rn,
  matMul: Gt,
  math: bh,
  max: Xn$1,
  maxPool: sp,
  maxPool3d: NS,
  maxPoolWithArgmax: nn,
  maximum: _s,
  mean: se,
  memory: cl,
  meshgrid: on,
  metrics: Ty2,
  min: ul,
  minimum: Kc,
  mirrorPad: LS,
  mod: WS,
  model: Bh,
  models: Sy2,
  moments: op,
  movingAverage: zn,
  mul: G,
  multiRNNCell: un,
  multinomial: ln,
  neg: jt$1,
  nextFrame: _c,
  norm: Pc,
  notEqual: qr,
  oneHot: Pb,
  ones: Us,
  onesLike: Rn$1,
  op: L,
  outerProduct: pn,
  pad: rp,
  pad1d: mn,
  pad2d: cn,
  pad3d: dn,
  pad4d: hn,
  pool: ZS,
  pow: ir,
  prelu: ap,
  print: QC,
  prod: _S,
  profile: J4,
  raggedGather: fn,
  raggedRange: yn,
  raggedTensorToTensor: gn,
  rand: bn,
  randomGamma: Tn,
  randomNormal: hk,
  randomStandardNormal: Sn,
  randomUniform: Zc,
  range: ti$1,
  ready: tY,
  real: dl,
  reciprocal: gk,
  registerBackend: kb,
  registerCallbackConstructor: Wh,
  registerGradient: UI,
  registerKernel: en$1,
  registerOp: Iy2,
  regularizers: Ay2,
  relu: ws,
  relu6: Ob,
  removeBackend: nY,
  reshape: W,
  reverse: ko,
  reverse1d: vn,
  reverse2d: On,
  reverse3d: _n,
  reverse4d: An,
  rfft: yp,
  round: Kb,
  rsqrt: Zb,
  scalar: gt$1,
  scatterND: xn2,
  scatter_util: hY,
  searchSorted: De,
  selu: Bb,
  separableConv2d: Hb,
  sequential: Hh,
  serialization: xY,
  setBackend: q4,
  setPlatform: rY,
  setdiff1dAsync: En,
  sigmoid: xr,
  sign: kk,
  signal: fY,
  sin: _b,
  sinh: Ub,
  slice: Dt,
  slice1d: mp,
  slice2d: Yb,
  slice3d: gp,
  slice4d: hl,
  slice_util: sR,
  softmax: bp,
  softplus: da,
  spaceToBatchND: ip,
  sparse: gY,
  sparseToDense: Ln,
  spectral: pY,
  split: un$1,
  sqrt: De$1,
  square: At$1,
  squaredDifference: Jb,
  squeeze: ha,
  stack: os,
  step: pa,
  stridedSlice: Kk,
  string: bY,
  sub: lt,
  sum: at,
  sumOutType: zh$1,
  tan: Bk,
  tanh: Hh$1,
  tensor: Re$1,
  tensor1d: Je$1,
  tensor2d: qa,
  tensor3d: Hk,
  tensor4d: kn,
  tensor5d: In,
  tensor6d: Dn,
  tensor_util: V4,
  test_util: Bd,
  tidy: D,
  tile: Vn$1,
  time: j4,
  topk: Uk,
  train: Ko,
  transpose: kt,
  truncatedNormal: jb,
  unique: Jk,
  unregisterGradient: W4,
  unregisterKernel: M4,
  unsortedSegmentSum: qb,
  unstack: To,
  upcastType: je$1,
  upperBound: $n,
  util: F4,
  valueAndGrad: cY,
  valueAndGrads: uY,
  variable: tT,
  variableGrads: hS,
  version: bb,
  version_converter: Yn2,
  version_core: jn2,
  version_layers: Gx,
  where: Oe,
  whereAsync: gt,
  zeros: ge$1,
  zerosLike: Tt$1
}, Symbol.toStringTag, { value: "Module" })), ui = new Matrix4();
ui.compose(new Vector3(), new Quaternion(), new Vector3(1e-3, 1e-3, 1e-3));
const wb = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
class Tb {
  constructor({
    container: e,
    imageTargetSrc: t,
    maxTrack: a,
    uiLoading: r = "yes",
    uiScanning: n = "yes",
    uiError: o = "yes",
    filterMinCF: u = null,
    filterBeta: l = null,
    warmupTolerance: p6 = null,
    missTolerance: m = null,
    userDeviceId: c = null,
    environmentDeviceId: d = null
  }) {
    this.container = e, this.imageTargetSrc = t, this.maxTrack = a, this.filterMinCF = u, this.filterBeta = l, this.warmupTolerance = p6, this.missTolerance = m, this.ui = new k$1({ uiLoading: r, uiScanning: n, uiError: o }), this.userDeviceId = c, this.environmentDeviceId = d, this.shouldFaceUser = false, this.scene = new Scene(), this.cssScene = new Scene(), this.renderer = new WebGLRenderer({ antialias: true, alpha: true }), this.cssRenderer = new CSS3DRenderer({ antialias: true }), this.renderer.outputEncoding = sRGBEncoding, this.renderer.setPixelRatio(window.devicePixelRatio), this.camera = new PerspectiveCamera(), this.anchors = [], this.renderer.domElement.style.position = "absolute", this.cssRenderer.domElement.style.position = "absolute", this.container.appendChild(this.renderer.domElement), this.container.appendChild(this.cssRenderer.domElement), window.addEventListener("resize", this.resize.bind(this));
  }
  async start() {
    this.ui.showLoading(), await this._startVideo(), await this._startAR();
  }
  stop() {
    this.controller.stopProcessVideo(), this.video.srcObject.getTracks().forEach(function(t) {
      t.stop();
    }), this.video.remove();
  }
  switchCamera() {
    this.shouldFaceUser = !this.shouldFaceUser, this.stop(), this.start();
  }
  addAnchor(e) {
    const t = new Group();
    t.visible = false, t.matrixAutoUpdate = false;
    const a = { group: t, targetIndex: e, onTargetFound: null, onTargetLost: null, onTargetUpdate: null, css: false, visible: false };
    return this.anchors.push(a), this.scene.add(t), a;
  }
  addCSSAnchor(e) {
    const t = new Group();
    t.visible = false, t.matrixAutoUpdate = false;
    const a = { group: t, targetIndex: e, onTargetFound: null, onTargetLost: null, onTargetUpdate: null, css: true, visible: false };
    return this.anchors.push(a), this.cssScene.add(t), a;
  }
  _startVideo() {
    return new Promise((e, t) => {
      if (this.video = document.createElement("video"), this.video.setAttribute("autoplay", ""), this.video.setAttribute("muted", ""), this.video.setAttribute("playsinline", ""), this.video.style.position = "absolute", this.video.style.top = "0px", this.video.style.left = "0px", this.video.style.zIndex = "-2", this.container.appendChild(this.video), !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        this.ui.showCompatibility(), t();
        return;
      }
      const a = {
        audio: false,
        video: {}
      };
      this.shouldFaceUser ? this.userDeviceId ? a.video.deviceId = { exact: this.userDeviceId } : a.video.facingMode = "user" : this.environmentDeviceId ? a.video.deviceId = { exact: this.environmentDeviceId } : a.video.facingMode = "environment", navigator.mediaDevices.getUserMedia(a).then((r) => {
        this.video.addEventListener("loadedmetadata", () => {
          this.video.setAttribute("width", this.video.videoWidth), this.video.setAttribute("height", this.video.videoHeight), e();
        }), this.video.srcObject = r;
      }).catch((r) => {
        console.log("getUserMedia error", r), t();
      });
    });
  }
  _startAR() {
    return new Promise(async (e, t) => {
      const a = this.video;
      this.container, this.controller = new MY({
        inputWidth: a.videoWidth,
        inputHeight: a.videoHeight,
        filterMinCF: this.filterMinCF,
        filterBeta: this.filterBeta,
        warmupTolerance: this.warmupTolerance,
        missTolerance: this.missTolerance,
        maxTrack: this.maxTrack,
        onUpdate: (n) => {
          if (n.type === "updateMatrix") {
            const { targetIndex: o, worldMatrix: u } = n;
            for (let p6 = 0; p6 < this.anchors.length; p6++)
              if (this.anchors[p6].targetIndex === o) {
                if (this.anchors[p6].css ? this.anchors[p6].group.children.forEach((m) => {
                  m.element.style.visibility = u === null ? "hidden" : "visible";
                }) : this.anchors[p6].group.visible = u !== null, u !== null) {
                  let m = new Matrix4();
                  m.elements = [...u], m.multiply(this.postMatrixs[o]), this.anchors[p6].css && m.multiply(ui), this.anchors[p6].group.matrix = m;
                } else
                  this.anchors[p6].group.matrix = wb;
                this.anchors[p6].visible && u === null && (this.anchors[p6].visible = false, this.anchors[p6].onTargetLost && this.anchors[p6].onTargetLost()), !this.anchors[p6].visible && u !== null && (this.anchors[p6].visible = true, this.anchors[p6].onTargetFound && this.anchors[p6].onTargetFound()), this.anchors[p6].onTargetUpdate && this.anchors[p6].onTargetUpdate();
              }
            this.anchors.reduce((p6, m) => p6 || m.visible, false) ? this.ui.hideScanning() : this.ui.showScanning();
          }
        }
      }), this.resize();
      const { dimensions: r } = await this.controller.addImageTargets(this.imageTargetSrc);
      this.postMatrixs = [];
      for (let n = 0; n < r.length; n++) {
        const o = new Vector3(), u = new Quaternion(), l = new Vector3(), [p6, m] = r[n];
        o.x = p6 / 2, o.y = p6 / 2 + (m - p6) / 2, l.x = p6, l.y = p6, l.z = p6;
        const c = new Matrix4();
        c.compose(o, u, l), this.postMatrixs.push(c);
      }
      await this.controller.dummyRun(this.video), this.ui.hideLoading(), this.ui.showScanning(), this.controller.processVideo(this.video), e();
    });
  }
  resize() {
    const { renderer: e, cssRenderer: t, camera: a, container: r, video: n } = this;
    if (!n)
      return;
    this.video.setAttribute("width", this.video.videoWidth), this.video.setAttribute("height", this.video.videoHeight);
    let o, u;
    const l = n.videoWidth / n.videoHeight, p6 = r.clientWidth / r.clientHeight;
    l > p6 ? (u = r.clientHeight, o = u * l) : (o = r.clientWidth, u = o / l);
    const m = this.controller.getProjectionMatrix(), c = this.controller.inputWidth / this.controller.inputHeight;
    let d;
    c > p6 ? d = this.video.width / this.controller.inputWidth : d = this.video.height / this.controller.inputHeight;
    let h6, b6;
    c > p6 ? (h6 = r.clientHeight, h6 *= d) : (b6 = r.clientWidth, h6 = b6 / this.controller.inputWidth * this.controller.inputHeight, h6 *= d);
    let f = r.clientHeight / h6;
    const y6 = 2 * Math.atan(1 / m[5] * f) * 180 / Math.PI, T6 = m[14] / (m[10] - 1), _6 = m[14] / (m[10] + 1);
    m[5] / m[0], a.fov = y6, a.near = T6, a.far = _6, a.aspect = r.clientWidth / r.clientHeight, a.updateProjectionMatrix(), n.style.top = -(u - r.clientHeight) / 2 + "px", n.style.left = -(o - r.clientWidth) / 2 + "px", n.style.width = o + "px", n.style.height = u + "px";
    const w6 = e.domElement, I = t.domElement;
    w6.style.position = "absolute", w6.style.left = 0, w6.style.top = 0, w6.style.width = r.clientWidth + "px", w6.style.height = r.clientHeight + "px", I.style.position = "absolute", I.style.left = 0, I.style.top = 0, I.style.width = r.clientWidth + "px", I.style.height = r.clientHeight + "px", e.setSize(r.clientWidth, r.clientHeight), t.setSize(r.clientWidth, r.clientHeight);
  }
}
window.MINDAR || (window.MINDAR = {});
window.MINDAR.IMAGE || (window.MINDAR.IMAGE = {});
window.MINDAR.IMAGE.MindARThree = Tb;
window.MINDAR.IMAGE.tf = Nb;
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i6 = 0; i6 < position.count; i6++) {
          indices.push(i6);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i6 = 1; i6 <= numberOfTriangles; i6++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i6));
        newIndices.push(index.getX(i6 + 1));
      }
    } else {
      for (let i6 = 0; i6 < numberOfTriangles; i6++) {
        if (i6 % 2 === 0) {
          newIndices.push(index.getX(i6));
          newIndices.push(index.getX(i6 + 1));
          newIndices.push(index.getX(i6 + 2));
        } else {
          newIndices.push(index.getX(i6 + 2));
          newIndices.push(index.getX(i6 + 1));
          newIndices.push(index.getX(i6));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
class GLTFLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i6 = 0; i6 < this.pluginCallbacks.length; i6++) {
      const plugin = this.pluginCallbacks[i6](parser);
      if (!plugin.name)
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i6 = 0; i6 < json.extensionsUsed.length; ++i6) {
        const extensionName = json.extensionsUsed[i6];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve2, reject) {
      scope.parse(data, path, resolve2, reject);
    });
  }
}
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light")
      return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsSheenExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      const colorFactor = extension.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
}
class GLTFMaterialsIorExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsAnisotropyExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFTextureBasisUExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
}
class GLTFTextureWebPExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve2) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve2(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}
class GLTFTextureAVIFExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve2) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve2(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}
class GLTFMeshoptCompression {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer2 = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder2 = this.parser.options.meshoptDecoder;
      if (!decoder2 || !decoder2.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer2.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength2 = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength2);
        if (decoder2.decodeGltfBufferAsync) {
          return decoder2.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder2.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder2.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
}
class GLTFMeshGpuInstancing {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m = new Matrix4();
        const p6 = new Vector3();
        const q = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i6 = 0; i6 < count; i6++) {
          if (attributes.TRANSLATION) {
            p6.fromBufferAttribute(attributes.TRANSLATION, i6);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i6);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i6);
          }
          instancedMesh.setMatrixAt(i6, m.compose(p6, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF";
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve2) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve2(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform2) {
    if ((transform2.texCoord === void 0 || transform2.texCoord === texture.channel) && transform2.offset === void 0 && transform2.rotation === void 0 && transform2.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform2.texCoord !== void 0) {
      texture.channel = transform2.texCoord;
    }
    if (transform2.offset !== void 0) {
      texture.offset.fromArray(transform2.offset);
    }
    if (transform2.rotation !== void 0) {
      texture.rotation = transform2.rotation;
    }
    if (transform2.scale !== void 0) {
      texture.repeat.fromArray(transform2.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i6 = 0; i6 !== valueSize; i6++) {
      result[i6] = values[offset + i6];
    }
    return result;
  }
  interpolate_(i12, t02, t, t12) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td2 = t12 - t02;
    const p6 = (t - t02) / td2;
    const pp2 = p6 * p6;
    const ppp = pp2 * p6;
    const offset1 = i12 * stride3;
    const offset0 = offset1 - stride3;
    const s22 = -2 * ppp + 3 * pp2;
    const s32 = ppp - pp2;
    const s02 = 1 - s22;
    const s12 = s32 - pp2 + p6;
    for (let i6 = 0; i6 !== stride; i6++) {
      const p02 = values[offset0 + i6 + stride];
      const m02 = values[offset0 + i6 + stride2] * td2;
      const p12 = values[offset1 + i6 + stride];
      const m12 = values[offset1 + i6] * td2;
      result[i6] = s02 * p02 + s12 * m02 + s22 * p12 + s32 * m12;
    }
    return result;
  }
}
const _q = new Quaternion();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(i12, t02, t, t12) {
    const result = super.interpolate_(i12, t02, t, t12);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
}
const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
const WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
const WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
const WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
const WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
const ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
const PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
const INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
const ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets2, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i6 = 0, il2 = targets2.length; i6 < il2; i6++) {
    const target = targets2[i6];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (target.COLOR_0 !== void 0)
      hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i6 = 0, il2 = targets2.length; i6 < il2; i6++) {
    const target = targets2[i6];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor)
      geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i6 = 0, il2 = meshDef.weights.length; i6 < il2; i6++) {
      mesh.morphTargetInfluences[i6] = meshDef.weights[i6];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i6 = 0, il2 = targetNames.length; i6 < il2; i6++) {
        mesh.morphTargetDictionary[targetNames[i6]] = i6;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i6 = 0, il2 = primitiveDef.targets.length; i6 < il2; i6++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i6]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i6 = 0, il2 = keys.length; i6 < il2; i6++) {
    attributesKey += keys[i6] + ":" + attributes[keys[i6]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0)
    return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
    return "image/webp";
  return "image/png";
}
const _identityMatrix = new Matrix4();
class GLTFParser {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
      isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i6 = 0, il2 = joints.length; i6 < il2; i6++) {
        nodeDefs[joints[i6]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    const ref2 = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i6, child] of original.children.entries()) {
        updateMappings(child, clone.children[i6]);
      }
    };
    updateMappings(object, ref2);
    ref2.name += "_instance_" + cache.uses[index]++;
    return ref2;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i6 = 0; i6 < extensions.length; i6++) {
      const result = func(extensions[i6]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i6 = 0; i6 < extensions.length; i6++) {
      const result = func(extensions[i6]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def2, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve2, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve2, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer2) {
      const byteLength2 = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer2.slice(byteOffset, byteOffset + byteLength2);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib2 = parser.cache.get(ibCacheKey);
        if (!ib2) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib2 = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib2);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib2, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i6 = 0, il2 = sparseIndices.length; i6 < il2; i6++) {
          const index = sparseIndices[i6];
          bufferAttribute.setX(index, sparseValues[i6 * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i6 * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i6 * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i6 * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve2, reject) {
        let onLoad = resolve2;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve2(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL.revokeObjectURL(sourceURI);
      }
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture)
        return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform2 = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform2) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform2);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name)
        material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i6 = 0, il2 = primitives.length; i6 < il2; i6++) {
      const primitive = primitives[i6];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i6 = 0, il2 = primitives.length; i6 < il2; i6++) {
      const material = primitives[i6].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i6].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i6 = 0, il2 = geometries.length; i6 < il2; i6++) {
        const geometry = geometries[i6];
        const primitive = primitives[i6];
        let mesh;
        const material = materials[i6];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i6 = 0, il2 = meshes.length; i6 < il2; i6++) {
        parser.associations.set(meshes[i6], {
          meshes: meshIndex,
          primitives: i6
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions)
          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions)
        addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i6 = 0, il2 = meshes.length; i6 < il2; i6++) {
        group.add(meshes[i6]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i6 = 0, il2 = skinDef.joints.length; i6 < il2; i6++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i6]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i6 = 0, il2 = jointNodes.length; i6 < il2; i6++) {
        const jointNode = jointNodes[i6];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i6 * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i6]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i6 = 0, il2 = animationDef.channels.length; i6 < il2; i6++) {
      const channel = animationDef.channels[i6];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0)
        continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets2 = dependencies[4];
      const tracks = [];
      for (let i6 = 0, il2 = nodes.length; i6 < il2; i6++) {
        const node = nodes[i6];
        const inputAccessor = inputAccessors[i6];
        const outputAccessor = outputAccessors[i6];
        const sampler = samplers[i6];
        const target = targets2[i6];
        if (node === void 0)
          continue;
        if (node.updateMatrix) {
          node.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k7 = 0; k7 < createdTracks.length; k7++) {
            tracks.push(createdTracks[k7]);
          }
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh)
            return;
          for (let i6 = 0, il2 = nodeDef.weights.length; i6 < il2; i6++) {
            o.morphTargetInfluences[i6] = nodeDef.weights[i6];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i6 = 0, il2 = childrenDef.length; i6 < il2; i6++) {
      childPending.push(parser.getDependency("node", childrenDef[i6]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh)
            return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i6 = 0, il2 = children.length; i6 < il2; i6++) {
        node.add(children[i6]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i6 = 0, il2 = objects.length; i6 < il2; i6++) {
          node.add(objects[i6]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i6 = 0, il2 = nodeIds.length; i6 < il2; i6++) {
      pending.push(parser.getDependency("node", nodeIds[i6]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i6 = 0, il2 = nodes.length; i6 < il2; i6++) {
        scene.add(nodes[i6]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node.name ? node.name : node.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.position:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j = 0, jl2 = targetNames.length; j < jl2; j++) {
      const track2 = new TypedKeyframeTrack(
        targetNames[j] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track2);
      }
      tracks.push(track2);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j = 0, jl2 = outputArray.length; j < jl2; j++) {
        scaled[j] = outputArray[j] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track2) {
    track2.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max[0], max[1], max[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets2 = primitiveDef.targets;
  if (targets2 !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i6 = 0, il2 = targets2.length; i6 < il2; i6++) {
      const target = targets2[i6];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
const targets = "/targets.mind";
const photar = "/photar.mind";
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "ARView",
  setup(__props) {
    const startRef = ref(null);
    const stopRef = ref(null);
    const containerRef = ref(null);
    const containerRef2 = ref(null);
    const styleRef = ref({ height: "800px" });
    const styleRef2 = ref({ height: "300px" });
    onMounted(() => {
      const container = containerRef.value;
      const container2 = containerRef2.value;
      const stopBtn = stopRef.value;
      const startBtn = startRef.value;
      stopBtn.style.zIndex = "5";
      startBtn.style.zIndex = "5";
      const mindarThree = new Tb({
        container,
        imageTargetSrc: targets,
        uiLoading: "no",
        uiScanning: "no",
        uiError: "no"
      });
      new Tb({
        container2,
        imageTargetSrc: photar,
        uiLoading: "no",
        uiScanning: "no",
        uiError: "no"
      });
      console.log(photar);
      const { renderer: renderer2, scene, camera } = mindarThree;
      const anchor = mindarThree.addAnchor(0);
      const loader = new GLTFLoader();
      loader.load("/scene.gltf ", function(gltf) {
        const model = gltf.scene;
        model.traverse(function(node) {
          if (node.isMesh) {
            const materials = Array.isArray(node.material) ? node.material : [node.material];
            materials.forEach(function(material) {
              material.transparent = true;
              material.opacity = 0.5;
            });
          }
        });
        model.position.set(-0.5, 0, 0.25);
        model.scale.set(0.01, 0.01, 0.01);
        model.rotation.set(Math.PI * 0.5, 0, 0);
        anchor.group.add(model);
      });
      const ambientLight = new AmbientLight(16777215, 0.75);
      anchor.group.add(ambientLight);
      const resizeRenderer = () => {
        container.style.width = window.innerWidth.toString();
        container.style.height = (window.innerHeight + 200).toString();
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer2.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      };
      window.addEventListener("resize", resizeRenderer);
      watchEffect(() => {
        resizeRenderer();
      });
      const start = async () => {
        await mindarThree.start();
        renderer2.setAnimationLoop(() => {
          renderer2.render(scene, camera);
        });
      };
      startBtn.addEventListener("click", () => {
        start();
      });
      stopBtn.addEventListener("click", () => {
        mindarThree.stop();
        mindarThree.renderer.setAnimationLoop(null);
      });
    });
    return (_ctx, _cache2) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("button", {
          ref_key: "stopRef",
          ref: stopRef
        }, "Stop", 512),
        createBaseVNode("button", {
          ref_key: "startRef",
          ref: startRef
        }, "Start", 512),
        createBaseVNode("div", {
          style: normalizeStyle(styleRef.value),
          ref_key: "containerRef",
          ref: containerRef
        }, null, 4),
        createBaseVNode("div", {
          style: normalizeStyle(styleRef2.value),
          ref_key: "containerRef2",
          ref: containerRef2
        }, null, 4)
      ], 64);
    };
  }
});
const _hoisted_1 = { style: { color: "red" } };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "ButtonComp",
  props: {
    label: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    return (_ctx, _cache2) => {
      return openBlock(), createElementBlock("button", _hoisted_1, toDisplayString(__props.label || "No props passed yet"), 1);
    };
  }
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const label = ref("Hello From Parent");
    return (_ctx, _cache2) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_sfc_main$2),
        createVNode(_sfc_main$1, { label: label.value }, null, 8, ["label"])
      ], 64);
    };
  }
});
createApp(_sfc_main).mount("#app");
